= Référence API extension WeeChat
:author: Sébastien Helleu
:email: flashcode@flashtux.org
:lang: fr
:toc-title: Table des matières

Ce manuel documente le client de messagerie instantanée WeeChat, il fait
partie de WeeChat.

La dernière version de ce document peut être téléchargée sur
https://weechat.org/doc/[cette page ^↗^^].

[[introduction]]
== Introduction

WeeChat (Wee Enhanced Environment for Chat) est un client de discussion libre,
rapide et léger, conçu pour différents systèmes d'exploitation.

Ce manuel documente l'API WeeChat des extensions, utilisée par les extensions
en C pour interagir avec le cœur de WeeChat.

[[plugins_in_weechat]]
== Extensions dans WeeChat

Une extension est un programme C qui peut appeler des fonctions WeeChat
définies dans une interface.

Ce programme C n'a pas besoin des sources WeeChat pour être compilé et peut
être dynamiquement chargé dans WeeChat avec la commande `/plugin`.

Cette extension doit être une bibliothèque dynamique, pour un chargement
dynamique par le système d'exploitation.
Sous GNU/Linux, le fichier a une extension ".so" et ".dll" sous Windows.

L'extension doit inclure le fichier "weechat-plugin.h" (disponible dans le code
source WeeChat).
Ce fichier définit les structures et types utilisés pour communiquer avec
WeeChat.

Pour appeler les fonctions de WeeChat dans le format affiché dans <<plugin_api>>,
le pointeur global suivant doit être déclaré et initialisé dans la fonction
<<_weechat_plugin_init,weechat_plugin_init>> :

[source,c]
----
struct t_weechat_plugin *weechat_plugin;
----

[[macros]]
=== Macros

L'extension doit utiliser des macros (pour définir quelques variables) :

WEECHAT_PLUGIN_NAME("name")::
    nom de l'extension

WEECHAT_PLUGIN_DESCRIPTION("description")::
    description courte de l'extension

WEECHAT_PLUGIN_AUTHOR("author")::
    nom de l'auteur

WEECHAT_PLUGIN_VERSION("1.0")::
    version de l'extension

WEECHAT_PLUGIN_LICENSE("GPL3")::
    licence de l'extension

WEECHAT_PLUGIN_PRIORITY(1000)::
    priorité de l'extension (facultatif, voir ci-dessous)

[[main_functions]]
=== Fonctions principales

L'extension doit utiliser deux fonctions :

* weechat_plugin_init
* weechat_plugin_end

==== weechat_plugin_init

Cette fonction est appelée quand l'extension est chargée par WeeChat.

Prototype :

[source,c]
----
int weechat_plugin_init (struct t_weechat_plugin *plugin,
                         int argc, char *argv[]);
----

Paramètres :

* _plugin_ : pointeur vers la structure d'extension WeeChat, utilisé pour
  initialiser le pointeur global `+weechat_plugin+`
* _argc_ : nombre de paramètres pour l'extension
* _argv_ : paramètres pour l'extension (voir ci-dessous)

Valeur de retour :

* _WEECHAT_RC_OK_ si ok (l'extension sera chargée)
* _WEECHAT_RC_ERROR_ si erreur (l'extension ne sera PAS chargée)

[[plugin_arguments]]
===== Paramètres de l'extension

Lorsque l'extension est chargée par WeeChat, elle reçoit la liste des
paramètres dans `argv` et le nombre de paramètres dans `argc`.

Les paramètres peuvent être :

* les paramètres de ligne de commande lors du lancement du binaire WeeChat,
* les paramètres donnés à la commande `/plugin load xxx`, lorsque l'extension
  est chargée manuellement par l'utilisateur.

Lorsque les paramètres proviennent de la ligne de commande, seulement ces
paramètres sont envoyés à l'extension :

*-a*, *--no-connect*::
    Supprimer la connexion automatique aux serveurs lors du démarrage.

*-s*, *--no-script*::
    Supprimer le chargement automatique des scripts au démarrage.

*extension:option*::
    Option pour une extension : seulement les options liées à l'extension sont
    envoyées, par exemple seulement les options démarrant par `irc:` sont
    envoyées à l'extension "irc".

[[plugin_priority]]
===== Priorité de l'extension

Lorsque les extensions sont automatiquement chargées (par exemple au
démarrage), WeeChat charge d'abord toutes les extensions, puis appelle les
fonctions _init_, en utilisant la priorité définie dans chaque extension.
Une grande priorité signifie que la fonction _init_ est appelée en premier.

La priorité par défaut est 1000 (avec une telle priorité, l'extension est
chargée après toutes les extensions par défaut).

Les extensions par défaut de WeeChat sont initialisées dans cet ordre :

include::{autogendir}/autogen_api_plugins_priority.fr.adoc[tag=plugins_priority]

==== weechat_plugin_end

Cette fonction est appelée quand l'extension est déchargée par WeeChat.

Prototype :

[source,c]
----
int weechat_plugin_end (struct t_weechat_plugin *plugin);
----

Paramètres :

* _plugin_ : pointeur vers la structure d'extension WeeChat

Valeur de retour :

* _WEECHAT_RC_OK_ si ok
* _WEECHAT_RC_ERROR_ si erreur

[[compile_plugin]]
=== Compilation de l'extension

La compilation ne nécessite pas les sources de WeeChat, seul le fichier
_weechat-plugin.h_ est requis.

Pour compiler l'extension qui n'a qu'un fichier "toto.c" (sous GNU/Linux) :

----
$ gcc -fPIC -Wall -c toto.c
$ gcc -shared -fPIC -o toto.so toto.o
----

[[load_plugin]]
=== Chargement de l'extension

Copiez le fichier _toto.so_ dans le répertoire système des extensions (par
exemple _/usr/local/lib/weechat/plugins_) ou dans le répertoire utilisateur des
extensions (par exemple _/home/user/.local/share/weechat/plugins_).

Sous WeeChat :

----
/plugin load toto
----

[[plugin_example]]
=== Exemple d'extension

Exemple complet d'extension, qui ajoute une commande `/double` : affiche deux
fois les paramètres sur le tampon courant, ou exécute deux fois une commande
(ok ce n'est pas très utile, mais c'est juste un exemple !) :

[source,c]
----
#include <stdlib.h>

#include "weechat-plugin.h"

WEECHAT_PLUGIN_NAME("double");
WEECHAT_PLUGIN_DESCRIPTION("Extension de test pour WeeChat");
WEECHAT_PLUGIN_AUTHOR("Sébastien Helleu <flashcode@flashtux.org>");
WEECHAT_PLUGIN_VERSION("0.1");
WEECHAT_PLUGIN_LICENSE("GPL3");

struct t_weechat_plugin *weechat_plugin = NULL;


/* fonction de rappel pour la commande "/double" */

int
commande_double_cb (const void *pointer, void *data,
                    struct t_gui_buffer *buffer,
                    int argc, char **argv, char **argv_eol)
{
    /* pour que le compilateur C soit content */
    (void) pointer;
    (void) data;
    (void) buffer;
    (void) argv;

    if (argc > 1)
    {
        weechat_command (NULL, argv_eol[1]);
        weechat_command (NULL, argv_eol[1]);
    }

    return WEECHAT_RC_OK;
}

int
weechat_plugin_init (struct t_weechat_plugin *plugin,
                     int argc, char *argv[])
{
    weechat_plugin = plugin;

    weechat_hook_command ("double",
                          "Affiche deux fois un message "
                          "ou exécute deux fois une commande",
                          "message | commande",
                          "message : message à afficher deux fois\n"
                          "commande : commande à exécuter deux fois",
                          NULL,
                          &commande_double_cb, NULL, NULL);

    return WEECHAT_RC_OK;
}

int
weechat_plugin_end (struct t_weechat_plugin *plugin)
{
    /* pour que le compilateur C soit content */
    (void) plugin;

    return WEECHAT_RC_OK;
}
----

[[plugin_api]]
== API extension

Les chapitres ci-dessous décrivent les fonctions de l'API, classées par
catégorie.

Pour chaque fonction, on donne :

* une description de la fonction,
* le prototype en C,
* le détail des paramètres,
* la valeur de retour,
* un exemple en C,
* un exemple en script Python (la syntaxe pour les autres langages de script est
  similaire).

[[registering]]
=== Enregistrement

Functions pour enregistrer un script : utilisées seulement par l'API script,
pas l'API C.

==== register

Enregistrer le script.

Pour plus d'informations, voir le
link:weechat_scripting.fr.html#register_function[Guide pour scripts WeeChat ^↗^^].

Script (Python) :

[source,python]
----
# prototype
def register(name: str, author: str, version: str, license: str, description: str, shutdown_function: str, charset: str) -> int: ...
----

[NOTE]
Cette fonction n'est pas disponible dans l'API C.

[[plugins]]
=== Extensions

Fonctions pour obtenir des informations sur les extensions.

==== plugin_get_name

Retourner le nom d'une extension.

Prototype :

[source,c]
----
const char *weechat_plugin_get_name (struct t_weechat_plugin *plugin);
----

Paramètres :

* _plugin_ : pointeur vers la structure d'extension WeeChat (peut être NULL)

Valeur de retour :

* nom de l'extension, "core" pour le cœur de WeeChat (si le pointeur vers
  l'extension est NULL)

Exemple en C :

[source,c]
----
const char *name = weechat_plugin_get_name (plugin);
----

Script (Python) :

[source,python]
----
# prototype
def plugin_get_name(plugin: str) -> str: ...

# exemple
plugin = weechat.buffer_get_pointer(weechat.current_buffer(), "plugin")
name = weechat.plugin_get_name(plugin)
----

[[strings]]
=== Chaînes de caractères

Plusieurs fonctions sur les chaînes de caractères sont déjà disponibles via
les fonctions standard du C, mais il est recommandé d'utiliser celles de l'API
car elles sont ok avec UTF-8 et la locale.

==== charset_set

Définir le nouveau jeu de caractères (le jeu de caractères par défaut est
_UTF-8_, donc si votre extension utilise _UTF-8_, vous n'avez pas besoin
d'appeler cette fonction).

Prototype :

[source,c]
----
void weechat_charset_set (const char *charset);
----

Paramètres :

* _charset_ : nouveau jeu de caractères à utiliser

Exemple en C :

[source,c]
----
weechat_charset_set ("iso-8859-1");
----

Script (Python) :

[source,python]
----
# prototype
def charset_set(charset: str) -> int: ...

# exemple
weechat.charset_set("iso-8859-1")
----

==== iconv_to_internal

Convertir une chaîne vers le jeu de caractères interne (UTF-8).

Prototype :

[source,c]
----
char *weechat_iconv_to_internal (const char *charset, const char *string);
----

Paramètres :

* _charset_ : jeu de caractères à convertir
* _string_ : chaîne à convertir

Valeur de retour :

* chaîne convertie (doit être supprimée par un appel à "free" après utilisation)

Exemple en C :

[source,c]
----
char *str = weechat_iconv_to_internal ("iso-8859-1", "chaîne iso : é à");
/* ... */
free (str);
----

Script (Python) :

[source,python]
----
# prototype
def iconv_to_internal(charset: str, string: str) -> str: ...

# exemple
str = weechat.iconv_to_internal("iso-8859-1", "chaîne iso : é à")
----

==== iconv_from_internal

Convertir une chaîne du jeu de caractères interne (UTF-8) vers un autre.

Prototype :

[source,c]
----
char *weechat_iconv_from_internal (const char *charset, const char *string);
----

Paramètres :

* _charset_ : jeu de caractères cible
* _string_ : chaîne à convertir

Valeur de retour :

* chaîne convertie (doit être supprimée par un appel à "free" après utilisation)

Exemple en C :

[source,c]
----
char *str = weechat_iconv_from_internal ("iso-8859-1", "chaîne utf-8 : é à");
/* ... */
free (str);
----

Script (Python) :

[source,python]
----
# prototype
def iconv_from_internal(charset: str, string: str) -> str: ...

# exemple
str = weechat.iconv_from_internal("iso-8859-1", "chaîne utf-8 : é à")
----

==== gettext

Retourner la chaîne traduite (dépend de la langue locale).

Prototype :

[source,c]
----
const char *weechat_gettext (const char *string);
----

Paramètres :

* _string_ : chaîne à traduire

Valeur de retour :

* chaîne traduite ou _string_ s'il n'y a pas de traduction disponible dans la langue locale

Exemple en C :

[source,c]
----
char *str = weechat_gettext ("hello");
----

Script (Python) :

[source,python]
----
# prototype
def gettext(string: str) -> str: ...

# exemple
str = weechat.gettext("hello")
----

==== ngettext

Retourner la chaîne traduite, en utilisant le singulier ou le pluriel, selon
le paramètre _count_.

Prototype :

[source,c]
----
const char *weechat_ngettext (const char *string, const char *plural,
                              int count);
----

Paramètres :

* _string_ : chaîne à traduire, au singulier
* _plural_ : chaîne à traduire, au pluriel
* _count_ : utilisé pour choisir entre le singulier et le pluriel (le choix est
  fonction de la langue utilisée)

Valeur de retour :

* chaîne traduite ou _string_ / _plural_ s'il n'y a pas de traduction disponible
  dans la langue locale

Exemple en C :

[source,c]
----
char *str = weechat_ngettext ("file", "files", num_files);
----

Script (Python) :

[source,python]
----
# prototype
def ngettext(string: str, plural: str, count: int) -> str: ...

# exemple
num_files = 2
str = weechat.ngettext("file", "files", num_files)
----

==== asprintf

_WeeChat ≥ 4.3.0._

Formater un message dans une chaîne allouée par la fonction.

[NOTE]
Cette fonction est définie pour les systèmes où la fonction GNU `asprintf()`
n'est pas disponible. +
Le comportement est quasiment le même à l'exception de `*result` qui est mis à
NULL en cas d'erreur.

Prototype :

[source,c]
----
int weechat_asprintf (char **result, const char *fmt, ...);
----

Paramètres :

* _result_ : pointeur vers un pointeur de chaîne
* _fmt_ : chaîne de formatage

Valeur de retour :

* nombre d'octets écrits dans `*result` (en excluant le caractère nul de fin),
  une valeur négative en cas d'erreur.

Exemple en C :

[source,c]
----
char *str;

if (weechat_asprintf (&str, "%s, %d", "test", 42) >= 0)
{
    /* *str == "test, 42" */
    /* ... */
    free (str);
}
else
{
    /* erreur : *str == NULL */
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== strndup

Retourner la chaîne dupliquée, avec un nombre maximum d'octets.

Prototype :

[source,c]
----
char *weechat_strndup (const char *string, int bytes);
----

Paramètres :

* _string_ : chaîne à dupliquer
* _bytes_ : nombre maximum d'octets à dupliquer

Valeur de retour :

* chaîne dupliquée (doit être supprimée par un appel à "free" après utilisation)

Exemple en C :

[source,c]
----
char *str = weechat_strndup ("abcdef", 3);  /* résultat : "abc" */
/* ... */
free (str);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_cut

_WeeChat ≥ 3.3._

Couper une chaîne après un nombre donné de caractères, ajouter un suffixe
facultatif après la chaîne si elle est coupée.

Prototype :

[source,c]
----
char *weechat_string_cut (const char *string, int length, int count_suffix, int screen, const char *cut_suffix);
----

Paramètres :

* _string_ : chaîne à couper
* _length_ : nombre maximum de caractères
* _count_suffix_ : si 1, la longueur du suffixe est comptée dans la longueur maximale
* _screen_ : si 1, le découpage est basé sur la largeur des caractères affichés
* _cut_suffix_ : le suffixe ajouté à la fin de la chaîne si elle est découpée

Valeur de retour :

* chaîne coupée (doit être supprimée par un appel à "free" après utilisation)

Exemple en C :

[source,c]
----
char *str = weechat_string_cut ("ceci est un test", 5, 1, 1, "…");  /* résultat : "ceci…" */
/* ... */
free (str);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_tolower

_Mis à jour dans la 3.8._

Retourner une chaîne avec les lettres majuscules converties en minuscules.

[NOTE]
Le comportement a changé dans la version 3.8 : désormais toutes les lettres en
majuscules sont correctement converties en minuscules (par appel à la fonction
`towlower`), en plus de l'intervalle de `A` à `Z`. +
De plus, une chaîne nouvellement allouée est retournée et doit être libérée après
utilisation.

Prototype :

[source,c]
----
char *weechat_string_tolower (const char *string);
----

Paramètres :

* _string_ : chaîne à convertir

Valeur de retour :

* chaîne avec les lettres en minuscules (doit être supprimée par un appel à "free"
  après utilisation)

Exemple en C :

[source,c]
----
char *str = weechat_string_tolower ("ABCD_É");  /* résultat : "abcd_é" */
/* ... */
free (str);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_toupper

_Mis à jour dans la 3.8._

Retourner une chaîne avec les lettres minuscules converties en majuscules.

[NOTE]
Le comportement a changé dans la version 3.8 : désormais toutes les lettres en
minuscules sont correctement converties en majuscules (par appel à la fonction
`towupper`), en plus de l'intervalle de `a` à `z`. +
De plus, une chaîne nouvellement allouée est retournée et doit être libérée après
utilisation.

Prototype :

[source,c]
----
char *weechat_string_toupper (const char *string);
----

Paramètres :

* _string_ : chaîne à convertir

Valeur de retour :

* chaîne avec les lettres en majuscules (doit être supprimée par un appel à "free"
  après utilisation)

Exemple en C :

[source,c]
----
char *str = weechat_string_toupper ("abcd_é");  /* résultat : "ABCD_É" */
/* ... */
free (str);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_charcmp

_Mis à jour dans la 1.0, 3.8._

Comparer deux caractères.

Prototype :

[source,c]
----
int weechat_string_charcmp (const char *string1, const char *string2);
----

Paramètres :

* _string1_ : première chaîne pour la comparaison
* _string2_ : seconde chaîne pour la comparaison

Valeur de retour :

* résultat de la soustraction du premier caractère UTF-8 dans
  _string2_ du premier caractère UTF-8 dans _string1_ :
** < 0 si char1 < char2
** 0 si char1 == char2
** > 0 si char1 > char2

Exemple en C :

[source,c]
----
int diff = weechat_string_charcmp ("aaa", "ccc");  /* == -2 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_charcasecmp

_Mis à jour dans la 1.0, 3.8._

Comparer deux caractères en ignorant la casse.

[NOTE]
Le comportement a changé dans la version 3.8 : désormais toutes les lettres en
majuscules sont correctement converties en minuscules (par appel à la fonction
`towlower`), en plus de l'intervalle de `A` à `Z`.

Prototype :

[source,c]
----
int weechat_string_charcasecmp (const char *string1, const char *string2);
----

Paramètres :

* _string1_ : première chaîne pour la comparaison
* _string2_ : seconde chaîne pour la comparaison

Valeur de retour :

* résultat de la soustraction du premier caractère UTF-8 dans
  _string2_ (converti en minuscule) du premier caractère UTF-8 dans _string1_
  (converti en minuscule) :
** < 0 si char1 < char2
** 0 si char1 == char2
** > 0 si char1 > char2

Exemple en C :

[source,c]
----
int diff = weechat_string_charcasecmp ("aaa", "CCC");  /* == -2 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== strcmp

_WeeChat ≥ 3.8._

Comparer deux chaînes.

Prototype :

[source,c]
----
int weechat_strcmp (const char *string1, const char *string2);
----

Paramètres :

* _string1_ : première chaîne à comparer
* _string2_ : seconde chaîne à comparer

Valeur de retour :

* résultat de la soustraction du dernier caractère UTF-8 comparé
  dans _string2_ du dernier caractère UTF-8 comparé dans _string1_ :
** < 0 si string1 < string2
** 0 si string1 == string2
** > 0 si string1 > string2

Exemple en C :

[source,c]
----
int diff = weechat_strcmp ("aaa", "ccc");  /* == -2 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== strncmp

_WeeChat ≥ 3.8._

Comparer deux chaînes, pour _max_ caractères.

Prototype :

[source,c]
----
int weechat_strncmp (const char *string1, const char *string2, int max);
----

Paramètres :

* _string1_ : première chaîne à comparer
* _string2_ : seconde chaîne à comparer
* _max_ : nombre maximum de caractères à comparer

Valeur de retour :

* résultat de la soustraction du dernier caractère UTF-8 comparé
  dans _string2_ du dernier caractère UTF-8 comparé dans _string1_ :
** < 0 si string1 < string2
** 0 si string1 == string2
** > 0 si string1 > string2

Exemple en C :

[source,c]
----
int diff = weechat_strncmp ("aabb", "aacc", 2);  /* == 0 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== strcasecmp

_Mis à jour dans la 1.0, 3.8._

Comparer deux chaînes indépendemment de la casse.

[NOTE]
Le comportement a changé dans la version 3.8 : désormais toutes les lettres en
majuscules sont correctement converties en minuscules (par appel à la fonction
`towlower`), en plus de l'intervalle de `A` à `Z`.

Prototype :

[source,c]
----
int weechat_strcasecmp (const char *string1, const char *string2);
----

Paramètres :

* _string1_ : première chaîne à comparer
* _string2_ : seconde chaîne à comparer

Valeur de retour :

* résultat de la soustraction du dernier caractère UTF-8 comparé
  dans _string2_ (converti en minuscule) du dernier caractère UTF-8 comparé dans
  _string1_ (converti en minuscule) :
** < 0 si string1 < string2
** 0 si string1 == string2
** > 0 si string1 > string2

Exemple en C :

[source,c]
----
int diff;
diff = weechat_strcasecmp ("aaa", "CCC");    /* == -2 */
diff = weechat_strcasecmp ("noël", "NOËL");  /* == 0  */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== strcasecmp_range

_WeeChat ≥ 0.3.7, mis à jour dans la 1.0, 3.8._

Comparer deux chaînes indépendemment de la locale et de la casse, avec un
intervalle pour comparer la casse.

Prototype :

[source,c]
----
int weechat_strcasecmp_range (const char *string1, const char *string2, int range);
----

Paramètres :

* _string1_ : première chaîne à comparer
* _string2_ : seconde chaîne à comparer
* _range_ : nombre de caractères pour la comparaison de casse, par exemple :
** 26 : `+A-Z+` deviennent en minuscules `a-z`
** 29 : `+A-Z [ \ ]+` deviennent minuscules `+a-z { | }+`
** 30 : `+A-Z [ \ ] ^+` deviennent minuscules `+a-z { | } ~+`

[NOTE]
Les valeurs 29 et 30 sont utilisés par quelques protocoles comme IRC.

Valeur de retour :

* résultat de la soustraction du dernier caractère UTF-8 comparé
  dans _string2_ (converti en minuscule) du dernier caractère UTF-8 comparé dans
  _string1_ (converti en minuscule) :
** < 0 si string1 < string2
** 0 si string1 == string2
** > 0 si string1 > string2

Exemple en C :

[source,c]
----
int diff = weechat_strcasecmp_range ("nick{away}", "NICK[away]", 29);  /* == 0 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== strncasecmp

_Mis à jour dans la 1.0, 3.8._

Comparer deux chaînes indépendemment de la casse, pour _max_ caractères.

[NOTE]
Le comportement a changé dans la version 3.8 : désormais toutes les lettres en
majuscules sont correctement converties en minuscules (par appel à la fonction
`towlower`), en plus de l'intervalle de `A` à `Z`.

Prototype :

[source,c]
----
int weechat_strncasecmp (const char *string1, const char *string2, int max);
----

Paramètres :

* _string1_ : première chaîne à comparer
* _string2_ : seconde chaîne à comparer
* _max_ : nombre maximum de caractères à comparer

Valeur de retour :

* résultat de la soustraction du dernier caractère UTF-8 comparé
  dans _string2_ (converti en minuscule) du dernier caractère UTF-8 comparé dans
  _string1_ (converti en minuscule) :
** < 0 si string1 < string2
** 0 si string1 == string2
** > 0 si string1 > string2

Exemple en C :

[source,c]
----
int diff = weechat_strncasecmp ("aabb", "AACC", 2);  /* == 0 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== strncasecmp_range

_WeeChat ≥ 0.3.7, mis à jour dans la 1.0, 3.8._

Comparer deux chaînes indépendemment de la locale et de la casse, pour _max_
caractères, avec un intervalle pour comparer la casse.

Prototype :

[source,c]
----
int weechat_strncasecmp_range (const char *string1, const char *string2, int max, int range);
----

Paramètres :

* _string1_ : première chaîne à comparer
* _string2_ : seconde chaîne à comparer
* _max_ : nombre maximum de caractères à comparer
* _range_ : nombre de caractères pour la comparaison de casse, par exemple :
** 26 : `+A-Z+` deviennent en minuscules `+a-z+`
** 29 : `+A-Z [ \ ]+` deviennent minuscules `+a-z { | }+`
** 30 : `+A-Z [ \ ] ^+` deviennent minuscules `+a-z { | } ~+`

[NOTE]
Les valeurs 29 et 30 sont utilisés par quelques protocoles comme IRC.

Valeur de retour :

* résultat de la soustraction du dernier caractère UTF-8 comparé
  dans _string2_ (converti en minuscule) du dernier caractère UTF-8 comparé dans
  _string1_ (converti en minuscule) :
** < 0 si string1 < string2
** 0 si string1 == string2
** > 0 si string1 > string2

Exemple en C :

[source,c]
----
int diff = weechat_strncasecmp_range ("nick{away}", "NICK[away]", 6, 29);  /* == 0 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== strcmp_ignore_chars

_Mis à jour dans la 1.0, 3.8._

Comparer deux chaînes en ignorant des caractères.

Prototype :

[source,c]
----
int weechat_strcmp_ignore_chars (const char *string1, const char *string2,
                                 const char *chars_ignored,
                                 int case_sensitive);
----

Paramètres :

* _string1_ : première chaîne à comparer
* _string2_ : seconde chaîne à comparer
* _chars_ignored_ : chaîne avec les caractères à ignorer
* _case_sensitive_ : 1 pour une comparaison tenant compte de la casse, sinon 0

[NOTE]
Le comportement a changé dans la version 3.8 lorsque _case_sensitive_ est
positionné à 0 : désormais toutes les lettres en majuscules sont correctement
converties en minuscules (par appel à la fonction `towlower`), en plus de
l'intervalle de `A` à `Z`.

Valeur de retour :

* résultat de la soustraction du dernier caractère UTF-8 comparé
  dans _string2_ (converti en minuscule si _case_sensitive_ est positionné à 0)
  du dernier caractère UTF-8 comparé dans _string1_ (converti en minuscule si
  _case_sensitive_ est positionné à 0) :
** < 0 si string1 < string2
** 0 si string1 == string2
** > 0 si string1 > string2

Exemple en C :

[source,c]
----
int diff = weechat_strcmp_ignore_chars ("a-b", "--a-e", "-", 1);  /* == -3 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== strcasestr

_Mis à jour dans la 1.3, 3.8._

Rechercher une chaîne indépendemment de la casse.

[NOTE]
Le comportement a changé dans la version 3.8 : désormais toutes les lettres en
majuscules sont correctement converties en minuscules (par appel à la fonction
`towlower`), en plus de l'intervalle de `A` à `Z`.

Prototype :

[source,c]
----
const char *weechat_strcasestr (const char *string, const char *search);
----

Paramètres :

* _string_ : chaîne
* _search_ : chaîne à rechercher dans _string_

Valeur de retour :

* pointeur vers la chaîne trouvée, ou NULL si non trouvée
  (_WeeChat ≥ 1.3_ : le pointeur retourné est un _const char *_ au lieu d'un
  _char *_)

Exemple en C :

[source,c]
----
const char *pos = weechat_strcasestr ("aBcDeF", "de");  /* résultat : pointeur vers "DeF" */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== strlen_screen

_WeeChat ≥ 0.4.2, mis à jour dans la 3.8._

Retourner le nombre de caractères nécessaires pour afficher la chaîne UTF-8
sur l'écran.

Les codes couleur de WeeChat sont sautés et ne comptent pas dans le résultat
(ceci est la seule différence avec la fonction <<_utf8_strlen_screen,utf8_strlen_screen>>).

Prototype :

[source,c]
----
int weechat_strlen_screen (const char *string);
----

Paramètres :

* _string_ : chaîne

Valeur de retour :

* nombre de caractères nécessaires pour afficher la chaîne UTF-8 sur l'écran

Exemple en C :

[source,c]
----
int length_on_screen = weechat_strlen_screen ("é");  /* == 1 */
----

Script (Python) :

[source,python]
----
# prototype
def strlen_screen(string: str) -> int: ...

# exemple
length = weechat.strlen_screen("é")  # 1
----

==== string_match

_Mis à jour dans la 1.0, 3.8._

Vérifier si une chaîne correspond à un masque.

Prototype :

[source,c]
----
int weechat_string_match (const char *string, const char *mask,
                          int case_sensitive);
----

Paramètres :

* _string_ : chaîne
* _mask_ : masque avec des caractères joker (`+*+`), chaque joker correspond à 0
  ou plusieurs caractères dans la chaîne
* _case_sensitive_ : 1 pour une comparaison tenant compte de la casse, sinon 0

[NOTE]
Depuis la version 1.0, les caractères joker sont autorisés à l'intérieur du
masque (pas seulement au début et à la fin du masque).

[NOTE]
Le comportement a changé dans la version 3.8 lorsque _case_sensitive_ est
positionné à 0 : désormais toutes les lettres en majuscules sont correctement
converties en minuscules (par appel à la fonction `towlower`), en plus de
l'intervalle de `A` à `Z`.

Valeur de retour :

* 1 si la chaîne correspond au masque, sinon 0

Exemple en C :

[source,c]
----
int match1 = weechat_string_match ("abcdef", "abc*", 0);   /* == 1 */
int match2 = weechat_string_match ("abcdef", "*dd*", 0);   /* == 0 */
int match3 = weechat_string_match ("abcdef", "*def", 0);   /* == 1 */
int match4 = weechat_string_match ("abcdef", "*de*", 0);   /* == 1 */
int match5 = weechat_string_match ("abcdef", "*b*d*", 0);  /* == 1 */
----

Script (Python) :

[source,python]
----
# prototype
def string_match(string: str, mask: str, case_sensitive: int) -> int: ...

# exemples
match1 = weechat.string_match("abcdef", "abc*", 0)   # == 1
match2 = weechat.string_match("abcdef", "*dd*", 0)   # == 0
match3 = weechat.string_match("abcdef", "*def", 0)   # == 1
match4 = weechat.string_match("abcdef", "*de*", 0)   # == 1
match5 = weechat.string_match("abcdef", "*b*d*", 0)  # == 1
----

==== string_match_list

_WeeChat ≥ 2.5, mis à jour dans la 3.8._

Vérifier si une chaîne correspond à une liste de masques. Des masques négatifs
sont autorisés avec le format "!mot". Un masque négatif a une priorité plus
haute qu'un masque standard.

Prototype :

[source,c]
----
int weechat_string_match_list (const char *string, const char **masks,
                               int case_sensitive);
----

Paramètres :

* _string_ : chaîne
* _masks_ : liste de masques avec un NULL après le dernier masque de la liste ;
  chaque masque est comparé à la chaîne avec la fonction
  <<_string_match,string_match>>
* _case_sensitive_ : 1 pour une comparaison tenant compte de la casse, sinon 0

[NOTE]
Le comportement a changé dans la version 3.8 lorsque _case_sensitive_ est
positionné à 0 : désormais toutes les lettres en majuscules sont correctement
converties en minuscules (par appel à la fonction `towlower`), en plus de
l'intervalle de `A` à `Z`.

Valeur de retour :

* 1 si la chaîne correspond à la liste de masques (au moins un masque correspond
  et aucun masque négatif ne correspond), sinon 0

Exemple en C :

[source,c]
----
const char *masks[3] = { "*", "!abc*", NULL };
int match1 = weechat_string_match_list ("abc", masks, 0);     /* == 0 */
int match2 = weechat_string_match_list ("abcdef", masks, 0);  /* == 0 */
int match3 = weechat_string_match_list ("def", masks, 0);     /* == 1 */
----

Script (Python) :

[source,python]
----
# prototype
def string_match_list(string: str, masks: str, case_sensitive: int) -> int: ...

# exemples
match1 = weechat.string_match("abc", "*,!abc*", 0)     # == 0
match2 = weechat.string_match("abcdef", "*,!abc*", 0)  # == 0
match3 = weechat.string_match("def", "*,!abc*", 0)     # == 1
----

==== string_expand_home

_WeeChat ≥ 0.3.3._

Remplacer le `+~+` en début de chaîne par le répertoire "home". Si la chaîne ne
débute pas par `+~+`, alors une chaîne identique est retournée.

Prototype :

[source,c]
----
char *weechat_string_expand_home (const char *path);
----

Paramètres :

* _path_ : chemin

Valeur de retour :

* chemin avec le `+~+` en début remplacé par le répertoire "home" (doit être
  supprimé par un appel à "free" après utilisation)

Exemple en C :

[source,c]
----
char *str = weechat_string_expand_home ("~/fichier.txt");
/* résultat : "/home/user/fichier.txt" */
/* ... */
free (str);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_eval_path_home

_WeeChat ≥ 1.3, mis à jour dans la 3.2._

Évaluer un chemin en 3 étapes :

. remplacer le `%h` du début par un répertoire WeeChat ("data" par défaut),
. remplacer le `+~+` du début par le répertoire maison de l'utilisateur (appel à
  <<_string_expand_home,string_expand_home>>),
. évaluer les variables (voir <<_string_eval_expression,string_eval_expression>>).

Prototype :

[source,c]
----
char *weechat_string_eval_path_home (const char *path,
                                     struct t_hashtable *pointers,
                                     struct t_hashtable *extra_vars,
                                     struct t_hashtable *options);
----

Paramètres :

* _path_ : chemin
* _pointers_ : table de hachage pour l'appel à la fonction
  <<_string_eval_expression,string_eval_expression>>
* _extra_vars_ : table de hachage pour l'appel à la fonction
  <<_string_eval_expression,string_eval_expression>>
* _options_ : table de hachage pour l'appel à la fonction
  <<_string_eval_expression,string_eval_expression>>, avec une clé supplémentaire
  supportée :
** _directory_: répertoire WeeChat à utiliser pour remplacer `%h`, un parmi
   ceux-ci :
*** _config_
*** _data_ (par défaut)
*** _cache_
*** _runtime_

Valeur de retour :

* chemin évalué (doit être supprimé par un appel à "free" après utilisation)

Exemple en C :

[source,c]
----
char *str = weechat_string_eval_path_home ("${weechat_config_dir}/test.conf", NULL, NULL, NULL);
/* résultat : "/home/user/.config/weechat/test.conf" */
/* ... */
free (str);
----

Script (Python) :

[source,python]
----
# prototype
def string_eval_path_home(path: str, pointers: Dict[str, str], extra_vars: Dict[str, str], options: Dict[str, str]) -> str: ...

# exemple
path = weechat.string_eval_path_home("${weechat_config_dir}/test.conf", {}, {}, {})
# path == "/home/user/.config/weechat/test.conf"
----

==== string_remove_quotes

Supprimer les apostrophes/guillemets au début et à la fin d'une chaîne (les
espaces avant la première apostrophe ou après la dernière sont ignorés).

Prototype :

[source,c]
----
char *weechat_string_remove_quotes (const char *string, const char *quotes);
----

Paramètres :

* _string_ : chaîne
* _quotes_ : chaîne avec la liste des apostrophes/guillemets à supprimer

Valeur de retour :

* chaîne sans les apostrophes/guillemets au début et à la fin (doit être
  supprimée par un appel à "free" après utilisation)

Exemple en C :

[source,c]
----
char *str = weechat_string_remove_quotes (string, " 'aujourd'hui' ", "'");
/* résultat : "aujourd'hui" */
/* ... */
free (str);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_strip

Supprimer des caractères au début et/ou à la fin d'une chaîne.

Prototype :

[source,c]
----
char *weechat_string_strip (const char *string, int left, int right,
                            const char *chars);
----

Paramètres :

* _string_ : chaîne
* _left_ : supprime les caractères en début de chaîne si différent de 0
* _right_ : supprime les caractères en fin de chaîne si différent de 0
* _chars_ : chaîne avec les caractères à supprimer

Valeur de retour :

* chaîne avec les caractères supprimés (doit être supprimée par un appel à
  "free" après utilisation)

Exemple en C :

[source,c]
----
char *str = weechat_string_strip (".abc -", 0, 1, "- .");  /* résultat : ".abc" */
/* ... */
free (str);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_convert_escaped_chars

_WeeChat ≥ 1.0._

Convertir les caractères échappés par leur valeur :

* `+\"+` : double guillemet droit
* `+\\+` : barre oblique inversée
* `+\a+` : alerte (BEL)
* `+\b+` : retour arrière
* `+\e+` : échappement
* `+\f+` : saut de page
* `+\n+` : nouvelle ligne
* `+\r+` : retour chariot
* `+\t+` : tabulation horizontale
* `+\v+` : tabulation verticale
* `+\0ooo+` : caractère sous forme de valeur octale (`ooo` a 0 à 3 chiffres)
* `+\xhh+` : caractère sous forme de valeur hexadécimale (`hh` a 1 à 2 chiffres)
* `+\uhhhh+` : caractère unicode sous forme de valeur hexadécimale
  (`hhhh` a 1 à 4 chiffres)
* `+\Uhhhhhhhh+` : caractère unicode sous forme de valeur hexadécimale
  (`hhhhhhhh` a 1 à 8 chiffres)

Prototype :

[source,c]
----
char *weechat_string_convert_escaped_chars (const char *string);
----

Paramètres :

* _string_ : chaîne

Valeur de retour :

* chaîne avec les caractères échappés remplacés par leur valeur (doit être
  supprimée par un appel à "free" après utilisation)

Exemple en C :

[source,c]
----
char *str = weechat_string_convert_escaped_chars ("snowman : \\u2603");
/* str == "snowman : ☃" */
/* ... */
free (str);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_mask_to_regex

Retourner une expression régulière ("regex"), construite avec un masque où le
seul caractère spécial est `+*+`. Tous les autres caractères spéciaux
d'expression régulière sont échappés.

Prototype :

[source,c]
----
char *weechat_string_mask_to_regex (const char *mask);
----

Paramètres :

* _mask_ : masque

Valeur de retour :

* expression régulière, sous forme de chaîne (doit être supprimée par un appel à
  "free" après utilisation)

Exemple en C :

[source,c]
----
char *str_regex = weechat_string_mask_to_regex ("test*mask");
/* résultat : "test.*mask" */
/* ... */
free (str_regex);
----

Script (Python) :

[source,python]
----
# prototype
def string_mask_to_regex(mask: str) -> str: ...

# exemple
regex = weechat.string_mask_to_regex("test*mask")  # "test.*mask"
----

==== string_regex_flags

_WeeChat ≥ 0.3.7._

Retourner un pointeur dans la chaîne après les "flags" et le masque avec les
"flags" pour compiler l'expression régulière.

Prototype :

[source,c]
----
const char *weechat_string_regex_flags (const char *regex, int default_flags, int *flags)
----

Paramètres :

* _regex_ : expression régulière POSIX étendue
* _default_flags_ : combinaison des valeurs suivantes (voir `man regcomp`) :
** REG_EXTENDED
** REG_ICASE
** REG_NEWLINE
** REG_NOSUB
* _flags_ : la valeur du pointeur est alimentée avec les "flags" utilisés dans
  l'expression régulière ("flags" par défaut + "flags" définis dans l'expression
  régulière)

Les "flags" doivent être au début de l'expression régulière. Le format est :
"(?eins-eins)chaîne".

Les "flags" autorisés sont :

* _e_ : expression régulière POSIX étendue (_REG_EXTENDED_)
* _i_ : insensible à la casse (_REG_ICASE_)
* _n_ : les opérateurs qui cherchent n'importe quel caractère ne trouvent pas
  les nouvelles lignes (_REG_NEWLINE_)
* _s_ : le support d'adressage des sous-chaînes de correspondance n'est pas
  requis (_REG_NOSUB_)

Valeur de retour :

* pointeur dans la _regex_, après les "flags"

Exemple en C :

[source,c]
----
const char *regex = "(?i)test";
int flags;
const char *ptr_regex = weechat_string_regex_flags (regex, REG_EXTENDED, &flags);
/* ptr_regex == "test", flags == REG_EXTENDED | REG_ICASE */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_regcomp

_WeeChat ≥ 0.3.7._

Compiler une expression régulière avec des "flags" optionnels en début de chaîne
(pour le format des "flags", voir <<_string_regex_flags,string_regex_flags>>).

Prototype :

[source,c]
----
int weechat_string_regcomp (void *preg, const char *regex, int default_flags)
----

Paramètres :

* _preg_ : pointeur vers la structure _regex_t_
* _regex_ : expression régulière POSIX étendue
* _default_flags_ : combinaison des valeurs suivantes (voir `man regcomp`) :
** REG_EXTENDED
** REG_ICASE
** REG_NEWLINE
** REG_NOSUB

Valeur de retour :

* même code retour que la fonction `regcomp` (0 si ok, autre valeur pour une
  erreur, voir `man regcomp`)

[NOTE]
L'expression régulière _preg_ doit être nettoyée par un appel à "regfree" après
utilisation, si la fonction a retourné 0 (OK).

Exemple en C :

[source,c]
----
regex_t my_regex;
if (weechat_string_regcomp (&my_regex, "(?i)test", REG_EXTENDED) == 0)
{
    /* OK */
    /* ... */
    regfree (&my_regex);
}
else
{
    /* erreur */
    /* ... */
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_has_highlight

Vérifier si une chaîne a un ou plusieurs "highlights", en utilisant une liste
de mots "highlight".

Prototype :

[source,c]
----
int weechat_string_has_highlight (const char *string,
                                  const char highlight_words);
----

Paramètres :

* _string_ : chaîne
* _highlight_words_ : liste de mots "highlight", séparés par des virgules

Valeur de retour :

* 1 si la chaîne a un ou plusieurs "highlights", sinon 0

Exemple en C :

[source,c]
----
int hl = weechat_string_has_highlight ("my test string", "test,word2");  /* == 1 */
----

Script (Python) :

[source,python]
----
# prototype
def string_has_highlight(string: str, highlight_words: str) -> int: ...

# exemple
highlight = weechat.string_has_highlight("my test string", "test,word2")  # 1
----

==== string_has_highlight_regex

_WeeChat ≥ 0.3.4._

Vérifier si une chaîne a un ou plusieurs "highlights", en utilisant une
expression régulière POSIX étendue. +
Pour au moins une correspondance dans la chaîne, elle doit être entourée de
délimiteurs (caractères différents de : alphanumérique, `+-+`, `+_+` et `+|+`).

Prototype :

[source,c]
----
int weechat_string_has_highlight_regex (const char *string, const char *regex);
----

Paramètres :

* _string_ : chaîne
* _regex_ : expression régulière POSIX étendue

Valeur de retour :

* 1 si la chaîne a un ou plusieurs "highlights", sinon 0

Exemple en C :

[source,c]
----
int hl = weechat_string_has_highlight_regex ("my test string", "test|word2");  /* == 1 */
----

Script (Python) :

[source,python]
----
# prototype
def string_has_highlight_regex(string: str, regex: str) -> int: ...

# exemple
highlight = weechat.string_has_highlight_regex("my test string", "test|word2")  # 1
----

==== string_replace

Remplacer toutes les occurrences d'une chaîne par une autre chaîne.

Prototype :

[source,c]
----
char *weechat_string_replace (const char *string, const char *search,
                              const char *replace);
----

Paramètres :

* _string_ : chaîne
* _search_ : chaîne à remplacer
* _replace_ : remplacement pour la chaîne _search_

Valeur de retour :

* chaîne avec _search_ remplacée par _replace_ (doit être supprimée par un appel
  à "free" après utilisation)

Exemple en C :

[source,c]
----
char *str = weechat_string_replace ("test, test", "s", "x");  /* résultat : "text" */
/* ... */
free (str);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_replace_regex

_WeeChat ≥ 1.0._

Remplacer du texte dans une chaîne en utilisant une expression régulière, du
texte de remplacement et une fonction de rappel optionnelle.

Prototype :

[source,c]
----
char *weechat_string_replace_regex (const char *string, void *regex,
                                    const char *replace, const char reference_char,
                                    char *(*callback)(void *data, const char *text),
                                    void *callback_data);
----

Paramètres :

* _string_ : chaîne
* _regex_ : pointeur vers une expression régulière (structure _regex_t_)
  compilée avec la fonction WeeChat <<_string_regcomp,string_regcomp>> ou regcomp
  (voir `man regcomp`)
* _replace_ : texte de remplacement, où les références suivantes sont
  autorisées :
** `+$0+` à `+$99+` : correspondance 0 à 99 dans l'expression régulière (0 est la
   correspondance entière, 1 à 99 sont les groupes capturés entre parenthèses)
** `+$++` : la dernière correspondance (avec le numéro le plus élevé)
** `+$.*N+` : correspondance `+N+` (peut être `+++` ou de `+0+` à `+99+`), avec
   tous les caractères remplacés par `+*+` (le caractère `+*+` peut être n'importe quel
   caractère entre l'espace (32) et `+~+` (126))
* _reference_char_ : le caractère utilisé pour les références aux
  correspondances (en général `+$+`)
* _callback_ : une fonction de rappel optionnelle appelé pour chaque référence
  dans _replace_ (sauf pour les correspondances remplacées par un caractère) ;
  la fonction de rappel doit retourner :
** une chaîne nouvellement allouée : elle est utilisée en texte de remplacement
   (elle est libérée après utilisation)
** NULL : le texte reçu dans la fonction de rappel est utilisé comme texte de
   remplacement (sans changement)
* _callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée

Valeur de retour :

* chaîne avec le texte remplacé, NULL en cas de problème (doit être supprimée
  par un appel à "free" après utilisation)

Exemple en C :

[source,c]
----
regex_t my_regex;
char *string;
if (weechat_string_regcomp (&my_regex, "([0-9]{4})-([0-9]{2})-([0-9]{2})",
                            REG_EXTENDED) == 0)
{
    string = weechat_string_replace_regex ("date : 2014-02-14", &my_regex,
                                           "$3/$2/$1", '$', NULL, NULL);
    /* string == "date : 14/02/2014" */
    if (string)
        free (string);
    regfree (&my_regex);
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_translate_chars

_WeeChat ≥ 3.8._

Traduire des caractères dans une chaîne.

Prototype :

[source,c]
----
char *string_translate_chars (const char *string, const char *chars1, const char *chars2);
----

Paramètres :

* _string_ : chaîne
* _chars1_ : chaîne avec des caractères à traduire
* _chars2_ : chaîne avec les caractères de remplacement ; elle doit contenir
  le même nombre de caractères UTF-8 que _chars1_

Valeur de retour :

* chaîne avec les caractères traduits, NULL en cas de problème (doit être
  supprimée par un appel à "free" après utilisation)

Exemples en C :

[source,c]
----
/* "test" => "tEst" */
char *str = weechat_string_translate_chars ("test", "abcdef", "ABCDEF");

/* "clean the boat" => "CleAn the BoAt" */
char *str = weechat_string_translate_chars ("clean the boat", "abc", "ABC");
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_split

_Mis à jour dans la 2.5, 2.6._

Découper une chaîne à l'aide de délimiteur(s).

Prototype :

[source,c]
----
char **weechat_string_split (const char *string, const char *separators,
                             const char *strip_items, int flags,
                             int num_items_max, int *num_items);
----

Paramètres :

* _string_ : chaîne à découper
* _separators_ : délimiteurs utilisés pour le découpage
* _strip_items_ : caractères à supprimer des chaînes retournées (gauche/droite) ;
  optionnel, peut être NULL
* _flags_ : combinaison de valeurs pour changer le comportement par défaut ;
  si la valeur est 0, le comportement par défaut est utilisé (pas de suppression
  des séparateurs en début/fin de chaîne, plusieurs séparateurs consécutifs
  sont utilisés tels quels donc des chaînes vides peuvent être retournées) ;
  les "flags" suivants sont acceptés :
** WEECHAT_STRING_SPLIT_STRIP_LEFT : supprimer les séparateurs sur la gauche
   (début de la chaîne)
** WEECHAT_STRING_SPLIT_STRIP_RIGHT : supprimer les séparateurs sur la droite
   (fin de la chaîne)
** WEECHAT_STRING_SPLIT_COLLAPSE_SEPS : regrouper plusieurs séparateurs
   consécutifs en un seul
** WEECHAT_STRING_SPLIT_KEEP_EOL : garder la fin de la ligne pour chaque valeur
* _num_items_max_ : nombre maximum de chaînes à créer (0 = pas de limite)
* _num_items_ : pointeur vers un entier qui contiendra le nombre de chaînes
  créées

[NOTE]
Avec WeeChat ≤ 2.4, le paramètre _flags_ s'appelait _keep_eol_ et prenait
d'autres valeurs, qui doivent être converties comme ceci ;
[width="100%",cols="1,10",options="header"]
|===
| keep_eol | flags
| 0        | WEECHAT_STRING_SPLIT_STRIP_LEFT \| WEECHAT_STRING_SPLIT_STRIP_RIGHT \| WEECHAT_STRING_SPLIT_COLLAPSE_SEPS
| 1        | WEECHAT_STRING_SPLIT_STRIP_LEFT \| WEECHAT_STRING_SPLIT_STRIP_RIGHT \| WEECHAT_STRING_SPLIT_COLLAPSE_SEPS \| WEECHAT_STRING_SPLIT_KEEP_EOL
| 2        | WEECHAT_STRING_SPLIT_STRIP_LEFT \| WEECHAT_STRING_SPLIT_COLLAPSE_SEPS \| WEECHAT_STRING_SPLIT_KEEP_EOL
|===

Valeur de retour :

* tableau de chaînes, NULL en cas de problème (doit être supprimé par un appel à
  <<_string_free_split,string_free_split>> après utilisation)

Exemples en C :

[source,c]
----
char **argv;
int argc;

argv = weechat_string_split ("abc de  fghi ", " ", NULL, 0, 0, &argc);
/* résultat :  argv[0] == "abc"
               argv[1] == "de"
               argv[2] == ""
               argv[3] == "fghi"
               argv[4] == ""
               argv[5] == NULL
               argc == 5
*/
weechat_string_free_split (argv);

argv = weechat_string_split ("abc de  fghi ", " ", NULL,
                             WEECHAT_STRING_SPLIT_STRIP_LEFT
                             | WEECHAT_STRING_SPLIT_STRIP_RIGHT
                             | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS,
                             0, &argc);
/* résultat :  argv[0] == "abc"
               argv[1] == "de"
               argv[2] == "fghi"
               argv[3] == NULL
               argc == 3
*/
weechat_string_free_split (argv);

argv = weechat_string_split ("abc de  fghi ", " ", NULL,
                             WEECHAT_STRING_SPLIT_STRIP_LEFT
                             | WEECHAT_STRING_SPLIT_STRIP_RIGHT
                             | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS
                             | WEECHAT_STRING_SPLIT_KEEP_EOL,
                             0, &argc);
/* résultat : argv[0] == "abc de  fghi"
              argv[1] == "de  fghi"
              argv[2] == "fghi"
              argv[3] == NULL
              argc == 3
*/
weechat_string_free_split (argv);

argv = weechat_string_split ("abc de  fghi ", " ", NULL,
                             WEECHAT_STRING_SPLIT_STRIP_LEFT
                             | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS
                             | WEECHAT_STRING_SPLIT_KEEP_EOL,
                             0, &argc);
/* résultat : argv[0] == "abc de  fghi "
              argv[1] == "de  fghi "
              argv[2] == "fghi "
              argv[3] == NULL
              argc == 3
*/
weechat_string_free_split (argv);

argv = weechat_string_split (" abc, de,, fghi ", ",", " ",
                             WEECHAT_STRING_SPLIT_STRIP_LEFT
                             | WEECHAT_STRING_SPLIT_STRIP_RIGHT
                             | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS,
                             0, &argc);
/* résultat : argv[0] == "abc"
              argv[1] == "de"
              argv[2] == "fghi"
              argv[3] == NULL
              argc == 3
*/
weechat_string_free_split (argv);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_split_shell

_WeeChat ≥ 1.0._

Découper une chaîne comme le shell le fait pour une commande avec ses
paramètres.

Cette fonction est une conversion en C de la classe Python "shlex" (fichier :
Lib/shlex.py dans le dépôt Python), voir
https://docs.python.org/3/library/shlex.html[cette page ^↗^^].

Prototype :

[source,c]
----
char **weechat_string_split_shell (const char *string, int *num_items);
----

Paramètres :

* _string_ : chaîne à découper
* _num_items_ : pointeur vers un entier qui contiendra le nombre de chaînes
  créées

Valeur de retour :

* tableau de chaînes, NULL en cas de problème (doit être supprimé par un appel à
  <<_string_free_split,string_free_split>> après utilisation)

Exemple en C :

[source,c]
----
char **argv;
int argc;
argv = weechat_string_split_shell ("test 'first arg'  \"second arg\"", &argc);
/* résultat : argv[0] == "test"
              argv[1] == "first arg"
              argv[2] == "second arg"
              argv[3] == NULL
              argc == 3
*/
weechat_string_free_split (argv);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_free_split

Supprimer une chaîne découpée.

Prototype :

[source,c]
----
void weechat_string_free_split (char **split_string);
----

Paramètres :

* _split_string_ : chaîne découpée par <<_string_split,string_split>>

Exemple en C :

[source,c]
----
char *argv;
int argc;
argv = weechat_string_split (string, " ", 0, 0, &argc);
/* ... */
weechat_string_free_split (argv);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_rebuild_split_string

_Mis à jour dans la 3.7._

Reconstruire une chaîne à partir d'une chaîne découpée, d'un séparateur facultatif
et d'un index de première/dernière chaîne à utiliser.

Prototype :

[source,c]
----
char *weechat_string_rebuild_split_string (char **split_string,
                                           const char *separator,
                                           int index_start, int index_end);
----

Paramètres :

* _split_string_ : chaîne découpée par la fonction <<_string_split,string_split>>
* _separator_ : chaîne utilisée pour séparer les différentes chaînes (peut être
  NULL ou une chaîne vide)
* _index_start_ : index de la première chaîne à utiliser (≥ 0)
* _index_end_ : index de la dernière chaîne à utiliser (doit être ≥ _index_start_ ;
  la valeur spéciale -1 peut être utilisée pour utiliser toutes les chaînes
  jusqu'à ce que NULL soit trouvé)

Valeur de retour :

* chaîne reconstruite avec la chaîne découpée (doit être supprimée par un appel à
  "free" après utilisation)

Exemple en C :

[source,c]
----
char **argv;
int argc;
argv = weechat_string_split ("abc def ghi", " ", 0, 0, &argc);
char *str = weechat_string_rebuild_split_string (argv, ";", 0, -1);
/* str == "abc;def;ghi" */
/* ... */
free (str);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_split_command

Découper une liste de commandes séparées par _separator_ (qui peut être échappé
par `+\+` dans la chaîne).

Prototype :

[source,c]
----
char **weechat_string_split_command (const char *command, char separator);
----

Paramètres :

* _command_ : commande à découper
* _separator_ : séparateur

Valeur de retour :

* tableau de chaînes, NULL en cas de problème (doit être supprimé par un appel à
  <<_free_split_command,free_split_command>> après utilisation)

Exemple en C :

[source,c]
----
char **argv = weechat_string_split_command ("/commande1 arg;/commande2", ';');
/* résultat : argv[0] == "/commande1 arg"
              argv[1] == "/commande2"
              argv[2] == NULL
*/
weechat_free_split_command (argv);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_free_split_command

Supprimer une commande découpée.

Prototype :

[source,c]
----
void weechat_string_free_split_command (char **split_command);
----

Paramètres :

* _split_command_ : commande découpée par
  <<_string_split_command,string_split_command>>

Exemple en C :

[source,c]
----
char **argv = weechat_string_split_command ("/commande1 arg;/commande2", ';');
/* ... */
weechat_free_split_command (argv);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_format_size

Construire une chaîne avec une taille de fichier formatée et une unité traduite
dans la langue locale.

Prototype :

[source,c]
----
char *weechat_string_format_size (unsigned long long size);
----

Paramètres :

* _size_ : taille (en octets)

Valeur de retour :

* chaîne formatée (doit être supprimée par un appel à "free" après utilisation)

Exemples en C :

[source,c]
----
/* exemples avec la langue française */

char *str = weechat_string_format_size (0);  /* str == "0 octet" */
/* ... */
free (str);

char *str = weechat_string_format_size (1);  /* str == "1 octet" */
/* ... */
free (str);

char *str = weechat_string_format_size (200);  /* str == "200 octets" */
/* ... */
free (str);

char *str = weechat_string_format_size (15200);  /* str == "15.2 Ko" */
/* ... */
free (str);

char *str = weechat_string_format_size (2097152);  /* str == "2.10 Mo" */
/* ... */
free (str);
----

Script (Python), _WeeChat ≥ 2.2_ :

[source,python]
----
# prototype
def string_format_size(size: int) -> str: ...

# exemple
str = weechat.string_format_size(15200)  # == "15.2 Ko"
----

==== string_parse_size

_WeeChat ≥ 3.7._

Analyser une chaîne avec une taille et une unité optionnelle et retourner
la taille en octets.

Prototype :

[source,c]
----
unsigned long long weechat_string_parse_size (const char *size);
----

Paramètres :

* _size_ : la taille sous forme de chaîne : nombre entier positif suivi par des
  espaces optionnels et une unité optionnelle (en minuscules ou majuscules),
  qui est une des suivantes :
** _b_ : octets
** _k_ : kilo-octets (1k = 1000 octets)
** _m_ : méga-octets (1m = 1000k = 1 000 000 octets)
** _g_ : giga-octets (1g = 1000m = 1 000 000 000 octets)
** _t_ : tera-octets (1t = 1000g = 1 000 000 000 000 octets)

Valeur de retour :

* taille en octets, 0 si erreur

Exemple en C :

[source,c]
----
unsigned long long size = weechat_parse_size ("1.34m");  /* size == 1340000 */
----

Script (Python) :

[source,python]
----
# prototype
def string_parse_size(size: str) -> int: ...

# exemple
size = weechat.string_parse_size("1.34m")  # 1340000
----

==== string_color_code_size

_WeeChat ≥ 3.0._

Retourner la taille (en octets) du code couleur WeeChat au début de la chaîne.

Prototype :

[source,c]
----
int weechat_string_color_code_size (const char *string);
----

Paramètres :

* _string_ : chaîne

Valeur de retour :

* taille (en octets) du code couleur WeeChat au début de la chaîne ;
  si la chaîne est NULL, vide ou ne commence pas avec un code couleur, 0 est retourné ;
  si la chaîne commence par plusieurs codes couleur, seule la taille du premier est retournée

Exemples en C :

[source,c]
----
int size;

size = weechat_string_color_code_size ("test");  /* size == 0 */
size = weechat_string_color_code_size (weechat_color ("bold"));  /* size == 2 */
size = weechat_string_color_code_size (weechat_color ("yellow,red"));  /* size == 7 */
----

Script (Python) :

[source,python]
----
# prototype
def string_color_code_size(string: str) -> int: ...

# exemples
size = weechat.string_color_code_size("test")  # size == 0
size = weechat.string_color_code_size(weechat.color("bold"))  # size == 2
size = weechat.string_color_code_size(weechat.color("yellow,red"))  # size == 7
----

==== string_remove_color

_Mis à jour dans la 4.3.0._

Supprimer les couleurs WeeChat dans une chaîne.

Prototype :

[source,c]
----
char *weechat_string_remove_color (const char *string, const char *replacement);
----

Paramètres :

* _string_ : chaîne
* _replacement_ : si non NULL et non vide, les couleurs WeeChat sont remplacées
  par cette chaîne, sinon les codes couleurs WeeChat et les caractères suivants
  (rattachés à la couleur) sont supprimés de la chaîne

Valeur de retour :

* chaîne sans couleur (doit être supprimée par un appel à "free" après
  utilisation)

Exemples en C :

[source,c]
----
/* supprime les codes couleur */
char *str = weechat_string_remove_color (ma_chaine1, NULL);
/* ... */
free (str);

/* remplace les codes couleur par "?" */
char *str = weechat_string_remove_color (ma_chaine2, "[color]");
/* ... */
free (str);
----

Script (Python) :

[source,python]
----
# prototype
def string_remove_color(string: str, replacement: str) -> str: ...

# exemple
str = weechat.string_remove_color(ma_chaine, "[color]")
----

==== string_base_encode

_WeeChat ≥ 2.4, mis à jour dans la 4.3.0._

Encoder une chaîne en base 16, 32 ou 64.

Prototype :

[source,c]
----
int weechat_string_base_encode (const char *base, const char *from, int length, char *to);
----

Paramètres :

* _base_ : "16", "32", "64" ou "64url"
* _from_ : chaîne à encoder
* _length_ : longueur de chaîne à encoder (par exemple `strlen(from)`)
* _to_ : pointeur vers la chaîne pour stocker le résultat (doit être
  suffisamment long, le résultat est plus long que la chaîne initiale)

Valeur de retour :

* longueur de la chaîne stockée dans _*to_ (ne compte pas le `\0` final),
  -1 en cas d'erreur

Exemple en C :

[source,c]
----
char *string = "abcdefgh", result[128];
int length;
length = weechat_string_base_encode ("16", string, strlen (string), result);
/* length == 16, result == "6162636465666768" */
length = weechat_string_base_encode ("32", string, strlen (string), result);
/* length == 16, result == "MFRGGZDFMZTWQ===" */
length = weechat_string_base_encode ("64", string, strlen (string), result);
/* length == 12, result == "YWJjZGVmZ2g=" */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_base_decode

_WeeChat ≥ 2.4, mis à jour dans la 4.3.0._

Décoder une chaîne encodée en base 16, 32 ou 64.

Prototype :

[source,c]
----
int weechat_string_base_decode (const char *base, const char *from, char *to);
----

Paramètres :

* _base_ : "16", "32", "64" ou "64url"
* _from_ : chaîne à décoder
* _to_ : pointeur vers la chaîne pour stocker le résultat (doit être
  suffisamment long, le résultat est plus court que la chaîne initiale)

Valeur de retour :

* longueur de la chaîne stockée dans _*to_ (ne compte pas le `\0` final),
  -1 en cas d'erreur

Exemple en C :

[source,c]
----
char result[128];
int length;
length = weechat_string_base_decode ("16", "6162636465666768", result);
/* length == 8, result == "abcdefgh" */
length = weechat_string_base_decode ("32", "MFRGGZDFMZTWQ===", result);
/* length == 8, result == "abcdefgh" */
length = weechat_string_base_decode ("64", "YWJjZGVmZ2g=", result);
/* length == 8, result == "abcdefgh" */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_hex_dump

_WeeChat ≥ 1.4._

Afficher les données sous forme d'octets en hexadécimal et ascii.

Prototype :

[source,c]
----
char *string_hex_dump (const char *data, int data_size, int bytes_per_line,
                       const char *prefix, const char *suffix);
----

Paramètres :

* _data_ : les données à afficher
* _data_size_ : nombre d'octets à afficher dans _data_
* _bytes_per_line_ : nombre d'octets à afficher sur chaque ligne
* _prefix_ : le préfixe à afficher au début de chaque ligne
  (optionnel, peut être NULL)
* _suffix_ : le suffixe à afficher à la fin de chaque ligne
  (optionnel, peut être NULL)

Valeur de retour :

* chaîne avec les données (doit être supprimée par un appel à "free" après
  utilisation)

Exemple en C :

[source,c]
----
char *string = "abc def-ghi";
char *dump = weechat_string_hex_dump (string, strlen (string), 8, " >> ", NULL);
/* dump == " >> 61 62 63 20 64 65 66 2D   a b c   d e f - \n"
           " >> 67 68 69                  g h i           "  */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_is_command_char

_WeeChat ≥ 0.3.2._

Vérifier si le premier caractère de la chaîne est un caractère de commande (le
caractère par défaut de commande est `+/+`).

Prototype :

[source,c]
----
int weechat_string_is_command_char (const char *string);
----

Paramètres :

* _string_ : chaîne

Valeur de retour :

* 1 si le premier caractère de la chaîne est un caractère de commande, sinon 0

Exemples en C :

[source,c]
----
int command_char1 = weechat_string_is_command_char ("/test");  /* == 1 */
int command_char2 = weechat_string_is_command_char ("test");   /* == 0 */
----

Script (Python) :

[source,python]
----
# prototype
def string_is_command_char(string: str) -> int: ...

# exemples
command_char1 = weechat.string_is_command_char("/test")  # == 1
command_char2 = weechat.string_is_command_char("test")   # == 0
----

==== string_input_for_buffer

_WeeChat ≥ 0.3.2._

Retourner un pointeur vers le texte envoyé vers le tampon (pointeur à
l'intérieur du paramètre "string"), ou NULL si c'est une commande.

Prototype :

[source,c]
----
const char *weechat_string_input_for_buffer (const char *string);
----

Paramètres :

* _string_ : chaîne

Valeur de retour :

* pointeur vers "string", ou NULL

Exemples en C :

[source,c]
----
const char *str1 = weechat_string_input_for_buffer ("test");    /* "test"  */
const char *str2 = weechat_string_input_for_buffer ("/test");   /* NULL    */
const char *str3 = weechat_string_input_for_buffer ("//test");  /* "/test" */
----

Script (Python) :

[source,python]
----
# prototype
def string_input_for_buffer(string: str) -> str: ...

# exemples
str1 = weechat.string_input_for_buffer("test")    # "test"
str2 = weechat.string_input_for_buffer("/test")   # ""
str3 = weechat.string_input_for_buffer("//test")  # "/test"
----

==== string_eval_expression

_WeeChat ≥ 0.4.0, mis à jour dans la 0.4.2, 0.4.3, 1.0, 1.1, 1.2, 1.3, 1.6, 1.8,
2.0, 2.2, 2.3, 2.7, 2.9, 3.1, 3.2, 3.3, 3.4, 3.6, 3.8, 4.0.0, 4.2.0, 4.3.0._

Évaluer l'expression et retourner le résultat sous forme de chaîne.
Les variables spéciales avec le format `+${variable}+` sont étendues (voir le
tableau ci-dessous).

[NOTE]
Depuis la version 1.0, les variables imbriquées sont supportées, par exemple :
`+${color:${variable}}+`.

Prototype :

[source,c]
----
char *weechat_string_eval_expression (const char *expr,
                                      struct t_hashtable *pointers,
                                      struct t_hashtable *extra_vars,
                                      struct t_hashtable *options);
----

Paramètres :

* _expr_ : l'expression à évaluer (voir les <<eval_conditions,conditions>> et
  <<eval_variables,variables>>)
* _pointers_ : table de hachage avec les pointeurs (les clés doivent être des
  chaînes, les valeurs doivent être des pointeurs) ; les pointeurs "window" et
  "buffer" sont automatiquement ajoutés s'ils ne sont pas dans la table de
  hachage (avec le pointeur vers fenêtre/tampon courants) (peut être NULL) :
** _regex_ : pointeur vers une expression régulière (structure _regex_t_)
   compilée avec la fonction WeeChat
   <<_string_regcomp,string_regcomp>> ou regcomp (voir `man regcomp`) ;
   cette option est similaire à _regex_ dans la table de
   hachage _options_ (ci-dessous), mais est utilisée pour de meilleures
   performances
* _extra_vars_ : variables additionnelles qui seront étendues (peut être NULL)
* _options_ : table de hachage avec des options (les clés et valeurs doivent
  être des chaînes) (peut être NULL) :
** _type_ : le comportement par défaut est de juste remplacer les valeurs dans
   l'expression, d'autres types peuvent être choisis :
*** _condition_ : l'expression est évaluée comme une condition : les opérateurs
    et parenthèses sont utilisés, le résultat est un booléen ("0" ou "1")
** _prefix_ : préfixe avant les variables à remplacer (par défaut : `+${+`)
** _suffix_ : suffixe après les variables à remplacer (par défaut : `+}+`)
** _extra_ : le comportement par défaut est juste de remplacer les variables
   additionnelles (_extra_vars_), un autre comportement peut être sélectionné :
*** _eval_ : les variables additionnelles (_extra_vars_) sont évaluées
    elles-mêmes avant remplacement _(WeeChat ≥ 1.6)_
** _regex_ : une expression regulière pour remplacer du texte dans _expr_ (qui
   n'est alors pas évalué)
** _regex_replace_ : le texte de remplacement à utiliser avec _regex_, pour
   remplacer du texte dans _expr_ (_regex_replace_ est évalué sur chaque
   correspondance de _regex_ sur _expr_, jusqu'à ce que plus aucune
   correspondance ne soit trouvée)
** _debug_ : niveau de debug (chaîne avec un nombre entier ≥ 1), si activé,
   une clé "debug_output" est ajoutée dans la table de hachage _options_ :
*** _1_ : activer le debug
*** _2_ : activer le debug plus verbeux

Valeur de retour :

* expression évaluée (doit être supprimée après un appel à "free" après
  utilisation), ou NULL si problème (expression invalide ou pas assez de
  mémoire)

Exemples en C :

[source,c]
----
/* conditions */
struct t_hashtable *options1 = weechat_hashtable_new (8,
                                                      WEECHAT_HASHTABLE_STRING,
                                                      WEECHAT_HASHTABLE_STRING,
                                                      NULL,
                                                      NULL);
weechat_hashtable_set (options1, "type", "condition");
char *str1 = weechat_string_eval_expression ("${window.win_width} > 100", NULL, NULL, options1);  /* "1" */
char *str2 = weechat_string_eval_expression ("abc =~ def", NULL, NULL, options1);                 /* "0" */

/* expression simple */
char *str3 = weechat_string_eval_expression ("${buffer.full_name}", NULL, NULL, NULL);  /* "core.weechat" */

/* remplacement avec regex */
struct t_hashtable *options2 = weechat_hashtable_new (8,
                                                      WEECHAT_HASHTABLE_STRING,
                                                      WEECHAT_HASHTABLE_STRING,
                                                      NULL,
                                                      NULL);
/* ajout de crochets autour des URLs */
weechat_hashtable_set (options2, "regex", "[a-zA-Z0-9_]+://[^ ]+");
weechat_hashtable_set (options2, "regex_replace", "[ ${re:0} ]");
char *str4 = weechat_string_eval_expression ("test : https://weechat.org", NULL, NULL, NULL);  /* "test : [ https://weechat.org ]" */

/* masquage des mots de passe */
weechat_hashtable_set (options2, "regex", "(password=)([^ ]+)");
weechat_hashtable_set (options2, "regex_replace", "${re:1}${hide:*,${re:2}}");
char *str5 = weechat_string_eval_expression ("password=abc password=def", NULL, NULL, NULL);  /* "password=*** password=***" */
----

Script (Python) :

[source,python]
----
# prototype
def string_eval_expression(expr: str, pointers: Dict[str, str], extra_vars: Dict[str, str], options: Dict[str, str]) -> str: ...

# exemples

# conditions
str1 = weechat.string_eval_expression("${window.win_width} > 100", {}, {}, {"type": "condition"})  # "1"
str2 = weechat.string_eval_expression("abc =~ def", {}, {}, {"type": "condition"})                 # "0"

# expression simple
str3 = weechat.string_eval_expression("${buffer.full_name}", {}, {}, {}) # "core.weechat"

# remplacement avec regex : ajout de crochets autour des URLs
options = {
    "regex": "[a-zA-Z0-9_]+://[^ ]+",
    "regex_replace": "[ ${re:0} ]",
}
str4 = weechat.string_eval_expression("test : https://weechat.org", {}, {}, options)  # "test : [ https://weechat.org ]"

# replace with regex : masquage des mots de passe
options = {
    "regex": "(password=)([^ ]+)",
    "regex_replace": "${re:1}${hide:*,${re:2}}",
}
str5 = weechat.string_eval_expression("password=abc password=def", {}, {}, options)  # "password=*** password=***"
----

[[eval_conditions]]
===== Conditions

Liste des opérateurs logiques qui peuvent être utilisés dans les conditions
(par ordre de priorité, du premier utilisé au dernier) :

[width="100%",cols="2,1,5,5",options="header"]
|===
| Opérateur | WeeChat mini | Description | Exemples

| `+&&+` |
| "Et" logique
| >> `+25 && 77+` +
  == `+1+` +
  +
  >> `+25 && 0+` +
  == `+0+`

| `+\|\|+` |
| "Ou" logique
| >> `+25 \|\| 0+` +
  == `+1+` +
  +
  >> `+0 \|\| 0+` +
  ==   `+0+`
|===

Liste des opérateurs de comparaison qui peuvent être utilisés dans les conditions
(par ordre de priorité, du premier utilisé au dernier) :

[width="100%",cols="2,1,5,5",options="header"]
|===
| Opérateur | WeeChat mini | Description | Exemples

| `+=~+` |
| Correspond à l'expression régulière POSIX étendue (des "flags" facultatifs sont autorisés, voir la fonction <<_string_regcomp,string_regcomp>>)
| >> `+abc def =~ ab.*ef+` +
  == `+1+` +
  +
  >> `+abc def =~ y.*z+` +
  == `+0+`

| `+!~+` |
| Ne correspond PAS à l'expression régulière POSIX étendue (des "flags" facultatifs sont autorisés, voir la fonction <<_string_regcomp,string_regcomp>>)
| >> `+abc def !~ ab.*ef+` +
  == `+0+` +
  +
  >> `+abc def !~ y.*z+` +
  == `+1+`

| `+==*+` | 2.9
| Correspond au masque où le caractère joker "*" est autorisé, sensible à la casse (voir la fonction <<_string_match,string_match>>)
| >> `+abc def ==* a*f+` +
  == `+1+` +
  +
  >> `+abc def ==* y*z+` +
  == `+0+`

| `+!!*+` | 2.9
| Ne correspond PAS au masque où le caractère joker "*" est autorisé, sensible à la casse (voir la fonction <<_string_match,string_match>>)
| >> `+abc def !!* a*f+` +
  == `+0+` +
  +
  >> `+abc def !!* y*z+` +
  == `+1+`

| `+=*+` | 1.8
| Correspond au masque où le caractère joker "*" est autorisé, insensible à la casse (voir la fonction <<_string_match,string_match>>)
| >> `+abc def =* A*F+` +
  == `+1+` +
  +
  >> `+abc def =* Y*Z+` +
  == `+0+`

| `+!*+` | 1.8
| Ne correspond PAS au masque où le caractère joker "*" est autorisé, insensible à la casse (voir la fonction <<_string_match,string_match>>)
| >> `+abc def !* A*F+` +
  == `+0+` +
  +
  >> `+abc def !* Y*Z+` +
  == `+1+`

| `+==-+` | 2.9
| Est inclus, sensible à la casse
| >> `+abc def ==- bc+` +
  == `+1+` +
  +
  >> `+abc def ==- xyz+` +
  == `+0+`

| `+!!-+` | 2.9
| N'est PAS inclus, sensible à la casse
| >> `+abc def !!- bc+` +
  == `+0+` +
  +
  >> `+abc def !!- xyz+` +
  == `+1+`

| `+=-+` | 2.9
| Est inclus, insensible à la casse
| >> `+abc def =- BC+` +
  == `+1+` +
  +
  >> `+abc def =- XYZ+` +
  == `+0+`

| `+!-+` | 2.9
| N'est PAS inclus, insensible à la casse
| >> `+abc def !- BC+` +
  == `+0+` +
  +
  >> `+abc def !- XYZ+` +
  == `+1+`

| `+==+` |
| Égal
| >> `+test == test+` +
  == `+1+` +
  +
  >> `+test == string+` +
  == `+0+`

| `+!=+` |
| Non égal
| >> `+test != test+` +
  == `+0+` +
  +
  >> `+test != string+` +
  == `+1+`

| `+<=+` |
| Plus petit ou égal
| >> `+abc <= defghi+` +
  == `+1+` +
  +
  >> `+abc <= abc+` +
  == `+1+` +
  +
  >> `+defghi <= abc+` +
  == `+0+` +
  +
  >> `+15 <= 2+` +
  == `+0+`

| `+<+` |
| Plus petit
| >> `+abc < defghi+` +
  == `+1+` +
  +
  >> `+abc < abc+` +
  == `+0+` +
  +
  >> `+defghi < abc+` +
  == `+0+` +
  +
  >> `+15 < 2+` +
  == `+0+`

| `+>=+` |
| Plus grand ou égal
| >> `+defghi >= abc+` +
  == `+1+` +
  +
  >> `+abc >= abc+` +
  == `+1+` +
  +
  >> `+abc >= defghi+` +
  == `+0+` +
  +
  >> `+15 >= 2+` +
  == `+1+`

| `+>+` |
| Plus grand
| >> `+defghi > abc+` +
  == `+1+` +
  +
  >> `+abc > abc+` +
  == `+0+` +
  +
  >> `+abc > defghi+` +
  == `+0+` +
  +
  >> `+15 > 2+` +
  == `+1+`
|===

La comparaison est faite en utilisant des nombres à virgule si les deux expressions
sont des nombres valides, avec l'un de ces formats :

* entier (exemples : 5, -7)
* nombre à virgule (exemples : 5.2, -7.5, 2.83e-2) _(WeeChat ≥ 2.0)_
* nombre hexadécimal (exemples : 0xA3, -0xA3) _(WeeChat ≥ 2.0)_

Pour forcer une comparaison de chaînes, vous pouvez ajouter des guillemets autour
de chaque expression, par exemple :

* `50 > 100` retourne 0 (comparaison de nombres)
* `"50" > "100"` retourne 1 (comparaison de chaînes)

[[eval_variables]]
===== Variables

Liste des variables étendues dans l'expression (par ordre de priorité, de la
première étendue à la dernière) :

[width="100%",cols="2,1,5,5",options="header"]
|===
| Format | WeeChat mini | Description | Exemples

| `+${raw_hl:xxx}+` | 4.2.0
| Chaîne brute (non évaluée), avec mise en évidence de la syntaxe (en utilisant
  des couleurs).
| >> `+${raw_hl:${cut:1,,${rev:hello}}}+` +
  == `+${cut:1,,${rev:hello}}+` (avec des couleurs)

| `+${raw:xxx}+` | 3.1
| Chaîne brute (non évaluée).
| >> `+${raw:${info:version}}+` +
  == `+${info:version}+`

| `+${hl:xxx}+` | 4.2.0
| Chaîne avec mise en évidence de la syntaxe (en utilisant des couleurs).
| >> `+${hl:${fichier.section.option}}+` +
  == `+test ${variable}+` (avec des couleurs)

| `+${nom}+` | 3.4
| Variable définie par l'utilisateur (avec `+${define:nom,valeur}+`).
| >> `+${nom}+` +
  == `+valeur+`

| `+${nom}+` |
| Variable `nom` de la table de hachage _extra_vars_.
| >> `+${nom}+` +
  == `+valeur+`

| `+${weechat_xxx_dir}+` | 3.2
| Un répertoire WeeChat : `+${weechat_config_dir}+`, `+${weechat_data_dir}+`,
  `+${weechat_state_dir}+`, `+${weechat_cache_dir}+` ou `+${weechat_runtime_dir}+`.
| >> `+${weechat_config_dir}+` +
  == `+/home/user/.config/weechat+` +
  +
  >> `+${weechat_data_dir}+` +
  == `+/home/user/.local/share/weechat+` +
  +
  >> `+${weechat_state_dir}+` +
  == `+/home/user/.local/state/weechat+` +
  +
  >> `+${weechat_cache_dir}+` +
  == `+/home/user/.cache/weechat+` +
  +
  >> `+${weechat_runtime_dir}+` +
  == `+/run/user/1000/weechat+`

| `+${eval:xxx}+` | 1.3
| Chaîne à évaluer.
| >> `+${eval:${date:${weechat.look.buffer_time_format}}}+` +
  == `+19:02:45+` ^(1)^ +
  +
  ^(1)^ Avec des couleurs s'il y a des codes couleur dans l'option
  weechat.look.buffer_time_format

| `+${eval_cond:xxx}+` | 3.1
| Chaîne à évaluer comme condition.
| >> `+${eval_cond:${window.win_width} > 100}+` +
  == `+1+`

| `+${esc:xxx}+` +
  `+${\xxx}+` | 1.0
| Chaîne avec caractères échappés.
| >> `+${esc:préfixe\tmessage}+` +
  == `+préfixe<TAB>message+` +
  +
  >> `+${\ua9}+` +
  == `+©+`

| `+${chars:range}+` | 3.8
| Chaîne avec un intervalle de caractères, où `range` est parmi : +
  - `digit` (`0123456789`) +
  - `xdigit` (`0123456789abcdefABCDEF`) +
  - `lower` (toutes les lettres en minuscules) +
  - `upper` (toutes les lettres en majuscules) +
  - `alpha` (toutes les lettres) +
  - `alnum` (toutes les lettres et chiffres) +
  - un intervalle de caractères avec le format `c1-c2` (le code de `c1` doit
    être inférieur ou égal à celui de `c2`)
| >> `+${chars:digit}+` +
  == `+0123456789+` +
  +
  >> `+${chars:xdigit}+` +
  == `+0123456789abcdefABCDEF+` +
  +
  >> `+${chars:lower}+` +
  == `+abcdefghijklmnopqrstuvwxyz+` +
  +
  >> `+${chars:J-V}+` +
  == `+JKLMNOPQRSTUV+` +
  +
  >> `+${chars:←-↓}+` +
  == `+←↑→↓+`

| `+${lower:string}+` | 3.6
| Chaîne convertie en minuscules.
| >> `+${lower:TEST}+` +
  == `+test+`

| `+${upper:string}+` | 3.6
| Chaîne convertie en majuscules.
| >> `+${upper:test}+` +
  == `+TEST+`

| `+${hide:x,chaîne}+` | 1.1
| Chaîne avec les caractères masqués (tous les caractères dans `chaîne`
  remplacés par `x`).
| >> `+${hide:*,mot_de_passe}+` +
  == `+************+`

| `+${cut:max,suffixe,chaîne}+` +
  `+${cut:+max,suffixe,chaîne}+` | 1.8
| Chaîne avec `max` caractères, et un `suffixe` facultatif si la chaîne est coupée. +
  Avec le format `+max`, le suffixe est compté dans la longueur maximale.
| >> `+${cut:4,…,ceci est un test}+` +
  == `+ceci…+` +
  +
  >> `+${cut:+4,…,ceci est un test}+` +
  == `+c…+` +
  +
  >> `+${cut:2,>>,こんにちは世界}+` +
  == `+こん>>+`

| `+${cutscr:max,suffixe,chaîne}+` +
  `+${cutscr:+max,suffixe,chaîne}+` | 1.8
| Chaîne avec `max` caractères affichés à l'écran, et un `suffixe` facultatif si la chaîne est coupée. +
  Avec le format `+max`, le suffixe est compté dans la longueur maximale.
| >> `+${cutscr:4,…,ceci est un test}+` +
  == `+ceci…+` +
  +
  >> `+${cutscr:+4,…,ceci est un test}+` +
  == `+cec…+` +
  +
  >> `+${cutscr:2,>>,こんにちは世界}+` +
  == `+こ>>+`

| `+${rev:xxx}+` | 2.2
| Chaîne inversée (les codes couleurs sont inversés, donc la chaîne ne devrait
  pas contenir de codes couleurs).
| >> `+${rev:Bonjour, le monde !}+` +
  == `+! ednom el ,ruojnoB+` +
  +
  >> `+${rev:Bonjour, ${color:red}le monde !}+` +
  == `+! ednom el30F ,ruojnoB+` ^(1)^ +
  +
  ^(1)^ Pas de couleur, le code couleur est inversé

| `+${revscr:xxx}+` | 2.7
| Chaîne inversée pour l'écran : les codes couleurs ne sont pas inversés.
| >> `+${revscr:Bonjour, le monde !}+` +
  == `+! ednom el ,ruojnoB+` +
  +
  >> `+${revscr:Bonjour, ${color:red}le monde !}+` +
  == `+! ednom el ,ruojnoB+` ^(1)^ +
  +
  ^(1)^ (`pass:[ ,ruojnoB]` en rouge

| `+${repeat:nombre,chaîne}+` | 2.3
| Chaîne répétée.
| >> `+${repeat:5,-}+` +
  == `+-----+`

| `+${length:xxx}+` | 2.7
| Longueur de la chaîne (nombre de caractères UTF-8), les codes couleurs sont
  ignorés.
| >> `+${length:test}+` +
  == `+4+` +
  +
  >> `+${length:こんにちは世界}+` +
  == `+7+`

| `+${lengthscr:xxx}+` | 2.7
| Longueur de la chaîne affichée à l'écran, les codes couleurs sont ignorés.
| >> `+${lengthscr:test}+` +
  == `+4+` +
  +
  >> `+${lengthscr:こんにちは世界}+` +
  == `+14+`

| `+${split:number,seps,flags,xxx}+` | 3.3
| Chaîne découpée, et retour, selon `number` : +
  - `count` : nombre d'éléments après le découpage +
  - `random` : un élément au hasard +
  - entier ≥ 1 : l'élément par son index (1 = premier élément) +
  - entier ≤ -1 : l'élément par son index en partant de la fin (-1 = dernier élément, -2 = avant-dernier élément, etc.), +
  `seps` est une liste de caractères qui sont utilisés comme séparateurs (si vide, une virgule est utilisé), +
  `flags` est une liste de drapeaux séparés par `+`: +
  - `strip_left` : supprimer les séparateurs sur la gauche (début de chaîne) +
  - `strip_right` : supprimer les séparateurs sur la droite (fin de chaîne) +
  - `collapse_seps` : regrouper de multiples séparateurs consécutifs en un seul +
  - `keep_eol` : garder jusqu'à la fin de la ligne pour chaque valeur +
  - `strip_items=xyz` : supprimer les caractères `x`, `y` et `z` au début/fin des éléments +
  - `max_items=N` : retourner au plus N éléments
| >> `+${split:1,,,abc,def,ghi}+` +
  == `+abc+` +
  +
  >> `+${split:-1,,,abc,def,ghi}+` +
  == `+ghi+` +
  +
  >> `+${split:count,,,abc,def,ghi}+` +
  == `+3+` +
  +
  >> `+${split:random,,,abc,def,ghi}+` +
  == `+def+` +
  +
  >> `+${split:3,,collapse_seps,abc,,,def,,,ghi}+` +
  == `+ghi+` +
  +
  >> `+${split:3,,strip_items=-_,_-abc-_,_-def-_,_-ghi-_}+` +
  == `+ghi+` +
  +
  >> `+${split:2, ,,this is a test}+` +
  == `+is+` +
  +
  >> `+${split:2, ,strip_left+strip_right, this is a test }+` +
  == `+is+` +
  +
  >> `+${split:2, ,keep_eol,this is a test}+` +
  == `+is a test+`

| `+${split_shell:number,xxx}+` | 3.3
| Paramètres shells découpés, et retour, selon `number` : +
  - `count` : le nombre de paramètres après découpage +
  - `random` : un paramètre au hasard +
  - entier ≥ 1 : le paramètre par son index (1 = premier paramètre) +
  - entier ≤ -1 : le paramètre par son index en partant de la fin (-1 = dernier paramètre, -2 = avant-dernier paramètre, etc.)
| >> `+${split_shell:1,"first arg" arg2}+` +
  == `+first arg+` +
  +
  >> `+${split_shell:-1,"first arg" arg2}+` +
  == `+arg2+` +
  +
  >> `+${split_shell:count,"first arg" arg2}+` +
  == `+2+` +
  +
  >> `+${split_shell:random,"first arg" arg2}+` +
  == `+arg2+`

| `+${re:xxx}+` | 1.1
| Données sur l'expression régulière : +
  `0` = toute la chaîne correspondante, +
  `1` à `99` = groupe capturé, +
  `+++` = dernier groupe capturé, +
  `#` = index du dernier groupe capturé _(WeeChat ≥ 1.8)_ +
  `repl_index` = index du remplacement en cours (démarre à 1) _(WeeChat ≥ 3.3)_.
| >> `+${re:0}+` +
  == `+test1 test2+` +
  +
  >> `+${re:1}+` +
  == `+test1+` +
  +
  >> `+${re:2}+` +
  == `+test2+` +
  +
  >> `pass:[${re:+}]` +
  == `+test2+` +
  +
  >> `+${re:#}+` +
  == `+2+` +
  +
  >> `+${re:repl_index}+` +
  == `+1+`

| `+${color:nom}+` | 0.4.2
| Code couleur WeeChat (le nom de couleur a des attributs facultatifs),
  voir la fonction <<_color,color>> pour les formats supportés.
| >> `+${color:red}texte rouge+` +
  == `+texte rouge+` ^(1)^ +
  +
  >> `+${color:*214}texte orange gras+` +
  == `+texte orange gras+` ^(2)^ +
  +
  ^(1)^ En rouge +
  ^(2)^ En orange gras

| `+${modifier:name,data,string}+` | 2.7
| Résultat d'un modificateur, voir la fonction
  <<_hook_modifier_exec,hook_modifier_exec>>.
| >> `+${modifier:eval_path_home,,~}+` +
  == `+/home/user+` +
  +
  >> `+${modifier:eval_path_home,directory=config,%h/irc.conf}+` +
  == `+/home/user/.config/weechat/irc.conf+`

| `+${info:nom}+` +
  `+${info:nom,paramètres}+` | 0.4.3
| Info de WeeChat ou d'une extension, voir la fonction <<_info_get,info_get>>.
| >> `+${info:version}+` +
  == `+1.0+` +
  +
  >> `+${info:nick_color_name,foo}+` +
  == `+lightblue+`

| `+${base_encode:base,xxx}+` | 2.9
| Chaîne encodée en base 16, 32 ou 64.
| >> `+${base_encode:16,test string}+` +
  == `+7465737420737472696E67+` +
  +
  >> `+${base_encode:32,test string}+` +
  == `+ORSXG5BAON2HE2LOM4======+` +
  +
  >> `+${base_encode:64,test string}+` +
  == `+dGVzdCBzdHJpbmc=+`

| `+${base_decode:base,xxx}+` | 2.9
| Chaîne décodée depuis base 16, 32 ou 64.
| >> `+${base_decode:16,7465737420737472696E67}+` +
  == `+test string+` +
  +
  >> `+${base_decode:32,ORSXG5BAON2HE2LOM4======}+` +
  == `+test string+` +
  +
  >> `+${base_decode:64,dGVzdCBzdHJpbmc=}+` +
  == `+test string+`

| `+${date}+` +
  `+${date:xxx}+` | 1.3
| La date/heure courante, avec un format personnalisé (voir la fonction
  <<_util_strftimeval,util_strftimeval>>), le format par défaut est `%F %T`.
| >> `+${date}+` +
  == `+2015-06-30 19:02:45+` +
  +
  >> `+${date:%H:%M:%S}+` +
  == `+19:02:45+` +
  +
  >> `+${date:%!.%.3}+` +
  == `+1435683765.482+`

| `+${env:NOM}+` | 1.2
| Valeur de la variable d'environnement `NOM`.
| >> `+${env:HOME}+` +
  == `+/home/user+`

| `+${if:condition}+` +
  `+${if:condition?vrai}+`
  `+${if:condition?vrai:faux}+` | 1.8
| Opérateur ternaire avec une condition, une valeur si la condition est vraie
  (optionnelle) et une autre valeur si la condition est fausse (optionnelle).
  Si les valeurs ne sont pas données, "1" ou "0" est retourné, selon le résultat
  de la condition.
| >> `+${if:${info:term_width}>80?grand:petit}+` +
  == `+grand+`

| `+${calc:xxx}+` | 2.7
| Résultat de l'expression, où les parenthèses et les opérateurs suivants sont
  supportés : +
  `+++` : addition +
  `+-+` : soustraction +
  `+*+` : multiplication +
  `+/+` : division +
  `+//+` : résultat de la division sans la partie décimale +
  `+%+` : reste de la division +
  `+**+`: puissance.
| >> `+${calc:5+2*3}+` +
  == `+11+` +
  +
  >> `+${calc:(5+2)*3}+` +
  == `+21+` +
  +
  >> `+${calc:10/4}+` +
  == `+2.5+` +
  +
  >> `+${calc:10//4}+` +
  == `+2+` +
  +
  >> `+${calc:9.2%3}+` +
  == `+0.2+` +
  +
  >> `+${calc:2**16}+` +
  == `+65536+`

| `+${random:min,max}+` | 3.3
| Nombre entier aléatoire dans l'intervalle de `min` à `max` (inclus).
| >> `+${random:0,10}+` +
  == `+3+`

| `+${translate:xxx}+` | 3.2
| Chaîne traduite (dépend de la langue utilisée par WeeChat pour afficher les
  messages).
| >> `+${translate:Plugin}+` +
  == `+Extension+` ^(1)^ +
  +
  ^(1)^ Exemple en Français

| `+${define:nom,valeur}+` | 3.4
| Définir une variable `nom` à `valeur`, qui peut être utilisée dans la même
  expression évaluée avec `+${nom}+`.
| >> `+${define:len,${calc:5+3}}${len}x${len}+` +
  == `+8x8+`

| `+${sec.data.nom}+` |
| Valeur de la donnée sécurisée `nom`.
| >> `+${sec.data.libera_pass}+` +
  == `+mon_mot_de_passe+`

| `+${fichier.section.option}+` |
| Valeur de l'option.
| >> `+${weechat.look.buffer_time_format}+` +
  == `+%H:%M:%S+`

| `+${nom}+` |
| Valeur de la variable locale `nom` dans le tampon.
| >> `+${nick}+` +
  == `+FlashCode+`

| `+${pointeur}+` |
| Variable `pointeur` de la table de hachage _pointers_.
| >> `+${buffer}+` +
  == `+0x1234abcd+`

| `+${hdata.var1.var2...}+` +
  `+${hdata[list].var1.var2...}+` |
| Valeur d'un hdata (les pointeurs `window` et `buffer` sont définis par défaut
  avec la fenêtre et tampon courants), `list` peut être le nom d'une liste
  (exemple : "gui_buffers"), un pointeur (exemple : "0x1234abcd") ou un nom
  de pointeur (exemple : "mon_pointeur"). +
  Lorsque `var1` est une table de hachage, les méthodes `keys()`, `values()`,
  `keys_sorted()`, `keys_values()` et `keys_values_sorted()` peuvent être appelées.
| >> `+${buffer[gui_buffers].full_name}+` +
  == `+core.weechat+` +
  +
  >> `+${buffer[mon_pointeur_buffer].full_name}+` +
  == `+core.weechat+` +
  +
  >> `+${window.buffer.number}+` +
  == `+1+` +
  +
  >> `+${buffer.local_variables.keys_values()}+` +
  == `+plugin:core,name:weechat+` +
  +
  >> `+${buffer.local_variables.plugin}+` +
  == `+core+`
|===

==== string_dyn_alloc

_WeeChat ≥ 1.8._

Allouer une chaîne dynamique, avec une longueur variable. +
De manière interne, une structure est allouée avec le pointeur vers la chaîne,
la taille allouée et la longueur courante de la chaîne.

Seul le pointeur de pointeur de chaîne (_**string_) est utilisé dans toutes les fonctions
_pass:[string_dyn_*]_.

Prototype :

[source,c]
----
char **weechat_string_dyn_alloc (int size_alloc);
----

Paramètres :

* _size_alloc_ : la taille initialement allouée (doit être supérieure à zéro)

Valeur de retour :

* pointeur vers la chaîne dynamique

Exemple en C :

[source,c]
----
char **string = weechat_string_dyn_alloc (256);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_dyn_copy

_WeeChat ≥ 1.8._

Copier une chaîne dans une chaîne dynamique.

Le pointeur _*string_ peut changer si la chaîne est réallouée (s'il n'y a pas
assez de place pour copier la chaîne).

Prototype :

[source,c]
----
int weechat_string_dyn_copy (char **string, const char *new_string);
----

Paramètres :

* _string_ : pointeur vers la chaîne dynamique
* _new_string_ : la chaîne à copier

Valeur de retour :

* 1 si OK, 0 si erreur

Exemple en C :

[source,c]
----
char **string = weechat_string_dyn_alloc (256);
if (weechat_string_dyn_copy (string, "test"))
{
    /* OK */
}
else
{
    /* erreur */
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_dyn_concat

_WeeChat ≥ 1.8, mis à jour en 3.0._

Concaténer une chaîne dans une chaîne dynamique.

Le pointeur _*string_ peut changer si la chaîne est réallouée (s'il n'y a pas
assez de place pour concaténer la chaîne).

Prototype :

[source,c]
----
int weechat_string_dyn_concat (char **string, const char *add, int bytes);
----

Paramètres :

* _string_ : pointeur vers la chaîne dynamique
* _add_ : la chaîne à ajouter
* _bytes_ : nombre maximum d'octets de _add_ à concaténer, doit être inférieur
  ou égal à la longueur de _add_ (-1 = automatique : concaténer la totalité de
  la chaîne _add_) _(WeeChat ≥ 3.0)_

Valeur de retour :

* 1 si OK, 0 si erreur

Exemple en C :

[source,c]
----
char **string = weechat_string_dyn_alloc (256);
if (weechat_string_dyn_copy (string, "test"))
{
    if (weechat_string_dyn_concat (string, "abc", -1))
    {
        /* ... */
    }
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_dyn_free

_WeeChat ≥ 1.8._

Libérer une chaîne dynamique.

Prototype :

[source,c]
----
char *weechat_string_dyn_free (char **string, int free_string);
----

Paramètres :

* _string_ : pointeur vers la chaîne dynamique
* _free_string_ : libérer la chaîne elle-même ; si 0, le contenu de _*string_
  reste valide après l'appel à cette fonction

Valeur de retour :

* pointeur vers la chaîne si _free_string_ vaut 0, sinon NULL

Exemple en C :

[source,c]
----
char **string = weechat_string_dyn_alloc (256);
if (weechat_string_dyn_concat (string, "test"))
{
    /* OK */
}
else
{
    /* erreur */
}
/* ... */
weechat_string_dyn_free (string, 1);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== string_concat

_WeeChat ≥ 4.2.0._

Concaténer plusieurs chaînes de caractères en utilisant un séparateur.

Prototype :

[source,c]
----
const char *weechat_string_concat (const char *separator, ...);
----

Paramètres :

* _separator_ : la chaîne de séparation qui est insérée entre les chaînes
  concaténées (peut être NULL ou une chaîne vide)

[NOTE]
Le dernier paramètre *DOIT* toujours être NULL. +
Une macro nommée `WEECHAT_STR_CONCAT` peut être utilisée, où la valeur finale
NULL n'est pas nécessaire (l'utilisation de cette macro est recommandée).

Valeur de retour :

* chaîne concaténée

Exemple en C :

[source,c]
----
const char *result = weechat_string_concat (" / ", "abc", "def", "ghi", NULL);  /* result == "abc / def / ghi" */

/* with macro */
const char *result = WEECHAT_STR_CONCAT(" / ", "abc", "def", "ghi");  /* result == "abc / def / ghi" */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

[[utf-8]]
=== UTF-8

Fonctions pour les chaînes UTF-8.

==== utf8_has_8bits

Vérifier si une chaîne a des caractères 8-bits.

Prototype :

[source,c]
----
int weechat_utf8_has_8bits (const char *string);
----

Paramètres :

* _string_ : chaîne

Valeur de retour :

* 1 si la chaîne a des caractères 8-bits, 0 s'il y a seulement des caractères
  7-bits

Exemple en C :

[source,c]
----
if (weechat_utf8_has_8bits (string))
{
    /* ... */
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== utf8_is_valid

_Mis à jour dans la 1.4._

Vérifier si une chaîne est valide UTF-8.

Prototype :

[source,c]
----
int weechat_utf8_is_valid (const char *string, int length, char **error);
----

Paramètres :

* _string_ : chaîne
* _length_ : nombre maximum de caractères UTF-8 à vérifier ; si ≤ 0, la chaîne
  complète est vérifiée _(WeeChat ≥ 1.4)_
* _error_ : si non NULL, _*error_ est alimenté avec le pointeur vers le premier
  caractère non valide dans la chaîne, s'il y en a

Valeur de retour :

* 1 si la chaîne UTF-8 est valide, sinon 0

Exemple en C :

[source,c]
----
char *error;
if (weechat_utf8_is_valid (string, -1, &error))
{
    /* ... */
}
else
{
    /* "error" pointe vers le premier caractère invalide */
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== utf8_normalize

Normaliser une chaîne UTF-8 : supprimer tous les caractères non valides UTF-8
en les remplaçant par un caractère.

Prototype :

[source,c]
----
void weechat_utf8_normalize (char *string, char replacement);
----

Paramètres :

* _string_ : chaîne
* _replacement_ : caractère de remplacement pour les caractères non valides

Exemple en C :

[source,c]
----
weechat_utf8_normalize (string, '?');
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== utf8_prev_char

_Mis à jour dans la 1.3._

Retourner un pointeur vers le caractère UTF-8 précédent dans une chaîne.

Prototype :

[source,c]
----
const char *weechat_utf8_prev_char (const char *string_start,
                                    const char *string);
----

Paramètres :

* _string_start_ : début de la chaîne (la fonction ne retournera pas un
  caractère situé avant ce pointeur)
* _string_ : pointeur vers la chaîne (doit être ≥ _string_start_)

Valeur de retour :

* pointeur vers le caractère UTF-8 précédent, NULL si non trouvé (début de
  chaîne atteint)
  (_WeeChat ≥ 1.3_ : le pointeur retourné est un _const char *_ au lieu d'un
  _char *_)

Exemple en C :

[source,c]
----
const char *prev_char = weechat_utf8_prev_char (string, ptr_in_string);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== utf8_next_char

_Mis à jour dans la 1.3._

Retourner un pointeur vers le caractère UTF-8 suivant dans une chaîne.

Prototype :

[source,c]
----
const char *weechat_utf8_next_char (const char *string);
----

Paramètres :

* _string_ : chaîne

Valeur de retour :

* pointeur vers le caractère UTF-8 suivant, NULL si non trouvé (fin de la
  chaîne atteinte)
  (_WeeChat ≥ 1.3_ : le pointeur retourné est un _const char *_ au lieu d'un
  _char *_)

Exemple en C :

[source,c]
----
const char *next_char = weechat_utf8_next_char (string);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== utf8_char_int

Retourner un caractère UTF-8 sous forme d'entier.

Prototype :

[source,c]
----
int weechat_utf8_char_int (const char *string);
----

Paramètres :

* _string_ : chaîne

Valeur de retour :

* caractère UTF-8 sous forme d'entier

Exemple en C :

[source,c]
----
int char_int = weechat_utf8_char_int ("être");  /* "ê" comme entier */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== utf8_char_size

Retourner la taille d'un caractère UTF-8 (en octets).

Prototype :

[source,c]
----
int weechat_utf8_char_size (const char *string);
----

Paramètres :

* _string_ : chaîne

Valeur de retour :

* taille du caractère UTF-8 (en octets)

Exemple en C :

[source,c]
----
int char_size = weechat_utf8_char_size ("être");  /* == 2 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== utf8_strlen

Retourner la taille d'une chaîne UTF-8 (en nombre de caractères UTF-8).

Prototype :

[source,c]
----
int weechat_utf8_strlen (const char *string);
----

Paramètres :

* _string_ : chaîne

Valeur de retour :

* longueur de la chaîne UTF-8 (nombre de caractères UTF-8)

Exemple en C :

[source,c]
----
int length = weechat_utf8_strlen ("chêne");  /* == 5 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== utf8_strnlen

Retourner la taille d'une chaîne UTF-8 (en nombre de caractères UTF-8), pour au
maximum _bytes_ octets dans la chaîne.

Prototype :

[source,c]
----
int weechat_utf8_strnlen (const char *string, int bytes);
----

Paramètres :

* _string_ : chaîne
* _bytes_ : nombre maximum d'octets

Valeur de retour :

* longueur de la chaîne UTF-8 (nombre de caractères UTF-8)

Exemple en C :

[source,c]
----
int length = weechat_utf8_strnlen ("chêne", 4);  /* == 3 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== utf8_strlen_screen

Retourner le nombre de caractères nécessaires pour afficher la chaîne UTF-8
sur l'écran.

Prototype :

[source,c]
----
int weechat_utf8_strlen_screen (const char *string);
----

Paramètres :

* _string_ : chaîne

Valeur de retour :

* nombre de caractères nécessaires pour afficher la chaîne UTF-8 sur l'écran

Exemple en C :

[source,c]
----
int length_on_screen = weechat_utf8_strlen_screen ("é");  /* == 1 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== utf8_char_size_screen

_Mis à jour dans la 3.8._

Retourner le nombre de caractères nécessaires pour afficher le caractère UTF-8
sur l'écran.

Prototype :

[source,c]
----
int weechat_utf8_char_size_screen (const char *string);
----

Paramètres :

* _string_ : chaîne

Valeur de retour :

* nombre de caractères nécessaires pour afficher le caractère UTF-8 sur l'écran :
** -1 : caractère non affichable
** ≥ 0 : caractère affichable

Le résultat est la valeur de retour de la fonction `wcwidth` (voir `man wcwidth`),
avec une exception pour les caractères suivants, qui ont un comportement
spécifique dans WeeChat :

* U+0009 (Tabulation) : valeur de l'option
    link:weechat_user.fr.html#option_weechat.look.tab_width[weechat.look.tab_width ^↗^^]
* U+0001 (1) to U+001F (31), sauf U+0009 (Tabulation) : 1
* U+00AD (173, trait d'union conditionnel) : -1
* U+200B (8203, espace sans chasse) : -1

Exemple en C :

[source,c]
----
int length_on_screen = weechat_utf8_char_size_screen ("é");  /* == 1 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== utf8_add_offset

_Mis à jour dans la 1.3._

Avancer de N caractères dans une chaîne UTF-8.

Prototype :

[source,c]
----
const char *weechat_utf8_add_offset (const char *string, int offset);
----

Paramètres :

* _string_ : chaîne
* _offset_ : nombre de caractères

Valeur de retour :

* pointeur vers la chaîne, N caractères après (NULL s'il est impossible
  d'atteindre cette position dans la chaîne)
  (_WeeChat ≥ 1.3_ : le pointeur retourné est un _const char *_ au lieu d'un
  _char *_)

Exemple en C :

[source,c]
----
const char *str = "chêne";
const char *str2 = weechat_utf8_add_offset (str, 3);  /* pointe vers "ne" */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== utf8_real_pos

Retourner la position réelle dans une chaîne UTF-8.

Prototype :

[source,c]
----
int weechat_utf8_real_pos (const char *string, int pos);
----

Paramètres :

* _string_ : chaîne
* _pos_ : position (en nombre de caractères)

Valeur de retour :

* position réelle (en octets)

Exemple en C :

[source,c]
----
int pos = weechat_utf8_real_pos ("chêne", 3);  /* == 4 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== utf8_pos

Retourner la position dans une chaîne UTF-8.

Prototype :

[source,c]
----
int weechat_utf8_pos (const char *string, int real_pos);
----

Paramètres :

* _string_ : chaîne
* _real_pos_ : position (en octets)

Valeur de retour :

* position (en nombre de caractères)

Exemple en C :

[source,c]
----
int pos = weechat_utf8_pos ("chêne", 4);  /* == 3 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== utf8_strndup

Retourner une chaîne dupliquée, avec au plus _length_ caractères.

Prototype :

[source,c]
----
char *weechat_utf8_strndup (const char *string, int length);
----

Paramètres :

* _string_ : chaîne
* _length_ : nombre maximum de caractères à dupliquer

Valeur de retour :

* chaîne dupliquée (doit être supprimée avec un appel à "free" après
  utilisation)

Exemple en C :

[source,c]
----
char *string = weechat_utf8_strndup ("chêne", 3);  /* retourne "chê" */
/* ... */
free (str);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== utf8_strncpy

_WeeChat ≥ 3.8._

Copier au plus _length_ caractères dans une autre chaîne et ajouter l'octet
nul à la fin.

Prototype :

[source,c]
----
void weechat_utf8_strncpy (char *dest, const char *string, int length);
----

Paramètres :

* _dest_ : chaîne de destination (doit être suffisamment grande)
* _string_ : chaîne
* _length_ : nombre maximum de caractères à copier

Exemple en C :

[source,c]
----
char dest[256];

weechat_utf8_strncpy (dest, "chêne", 3);  /* copie "chê" dans dest */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

[[crypto]]
=== Cryptographie

Fonctions de cryptographie.

==== crypto_hash

_WeeChat ≥ 2.8._

Calculer le hachage des données.

Prototype :

[source,c]
----
int weechat_crypto_hash (const void *data, int data_size, const char *hash_algo,
                         void *hash, int *hash_size);
----

Paramètres :

* _data_ : les données à hacher
* _data_size_ : nombre d'octets à hacher dans _data_
* _hash_algo_ : l'algorithme de hachage, voir le tableau ci-dessous
* _hash_ : pointeur vers la variable de hachage, qui est utilisée pour stocker
  le résultat du hachage (le tampon doit être suffisamment grand, selon
  l'algorithme, voir le tableau ci-dessous)
* _hash_size_ : pointeur vers une variable utiliser pour stocker la longueur
  du résultat du hachage (en octets) (peut être NULL)

[[crypto_hash_algorithms]]
Algorithmes de hachage supportés :

[width="100%",cols="2,2,3,6",options="header"]
|===
| Valeur          | Algorithme  | Taille du haché      | Notes
| `+crc32+`       | CRC32       | 4 octets (32 bits)   | Pas un algorithme de hachage au sens cryptographique.
| `+md5+`         | MD5         | 16 octets (128 bits) | *Faible*, non recommandé pour un usage cryptographique.
| `+sha1+`        | SHA-1       | 20 octets (160 bits) | *Faible*, non recommandé pour un usage cryptographique.
| `+sha224+`      | SHA-224     | 28 octets (224 bits) |
| `+sha256+`      | SHA-256     | 32 octets (256 bits) |
| `+sha384+`      | SHA-384     | 48 octets (384 bits) |
| `+sha512+`      | SHA-512     | 64 octets (512 bits) |
| `+sha512-224+`  | SHA-512/224 | 28 octets (224 bits) | Algorithme disponible avec libgcrypt ≥ 1.9.4.
| `+sha512-256+`  | SHA-512/256 | 32 octets (256 bits) | Algorithme disponible avec libgcrypt ≥ 1.9.4.
| `+sha3-224+`    | SHA3-224    | 28 octets (224 bits) | Algorithme disponible avec libgcrypt ≥ 1.7.0.
| `+sha3-256+`    | SHA3-256    | 32 octets (256 bits) | Algorithme disponible avec libgcrypt ≥ 1.7.0.
| `+sha3-384+`    | SHA3-384    | 48 octets (384 bits) | Algorithme disponible avec libgcrypt ≥ 1.7.0.
| `+sha3-512+`    | SHA3-512    | 64 octets (512 bits) | Algorithme disponible avec libgcrypt ≥ 1.7.0.
| `+blake2b-160+` | BLAKE2B-160 | 20 octets (160 bits) | Algorithme disponible avec libgcrypt ≥ 1.8.0.
| `+blake2b-256+` | BLAKE2B-256 | 32 octets (256 bits) | Algorithme disponible avec libgcrypt ≥ 1.8.0.
| `+blake2b-384+` | BLAKE2B-384 | 48 octets (384 bits) | Algorithme disponible avec libgcrypt ≥ 1.8.0.
| `+blake2b-512+` | BLAKE2B-512 | 64 octets (512 bits) | Algorithme disponible avec libgcrypt ≥ 1.8.0.
| `+blake2s-128+` | BLAKE2S-128 | 16 octets (128 bits) | Algorithme disponible avec libgcrypt ≥ 1.8.0.
| `+blake2s-160+` | BLAKE2S-160 | 20 octets (160 bits) | Algorithme disponible avec libgcrypt ≥ 1.8.0.
| `+blake2s-224+` | BLAKE2S-224 | 28 octets (224 bits) | Algorithme disponible avec libgcrypt ≥ 1.8.0.
| `+blake2s-256+` | BLAKE2S-256 | 32 octets (256 bits) | Algorithme disponible avec libgcrypt ≥ 1.8.0.
|===

Valeur de retour :

* 1 si OK, 0 si erreur

Exemple en C :

[source,c]
----
const char *data = "abcdefghijklmnopqrstuvwxyz";
char hash[256 / 8];
int rc, hash_size;
rc = weechat_crypto_hash (data, strlen (data), "sha256", hash, &hash_size);
/* rc == 1, hash_size == 32 et hash est un tampon avec :
   71 c4 80 df 93 d6 ae 2f 1e fa d1 44 7c 66 c9 52 5e 31 62 18 cf 51 fc 8d 9e d8 32 f2 da f1 8b 73 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== crypto_hash_file

_WeeChat ≥ 3.7._

Calculer le hachage d'un fichier.

Prototype :

[source,c]
----
int weechat_crypto_hash_file (const char *filename, const char *hash_algo,
                              void *hash, int *hash_size);
----

Paramètres :

* _filename_ : chemin et nom du fichier
* _hash_algo_ : l'algorithme de hachage, voir le tableau de la fonction
  <<crypto_hash_algorithms,crypto_hash>>
* _hash_ : pointeur vers la variable de hachage, qui est utilisée pour stocker
  le résultat du hachage (le tampon doit être suffisamment grand, selon
  l'algorithme, voir le tableau de la fonction
  <<crypto_hash_algorithms,crypto_hash>>)
* _hash_size_ : pointeur vers une variable utiliser pour stocker la longueur
  du résultat du hachage (en octets) (peut être NULL)

Valeur de retour :

* 1 si OK, 0 si erreur

Exemple en C :

[source,c]
----
char hash[256 / 8];
int rc, hash_size;
rc = weechat_crypto_hash_file ("/chemin/vers/fichier", "sha256", hash, &hash_size);
/* rc == 1, hash_size == 32 et hash est un tampon avec :
   71 c4 80 df 93 d6 ae 2f 1e fa d1 44 7c 66 c9 52 5e 31 62 18 cf 51 fc 8d 9e d8 32 f2 da f1 8b 73 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== crypto_hash_pbkdf2

_WeeChat ≥ 2.8._

Calculer le hachage PBKDF2 (PKCS#5 Passphrase Based Key Derivation Function number 2)
des données.

Prototype :

[source,c]
----
int weechat_crypto_hash_pbkdf2 (const void *data, int data_size,
                                const char *hash_algo,
                                const void *salt, int salt_size,
                                int iterations,
                                void *hash, int *hash_size);
----

Paramètres :

* _data_ : les données à hacher
* _data_size_ : nombre d'octets à hacher dans _data_
* _hash_algo_ : algorithme de hachage utilisé dans la fonction de dérivation
  de clé, voir le tableau dans la fonction <<crypto_hash_algorithms,crypto_hash>>
* _salt_ : le sel
* _salt_size_ : nombre d'octets dans _salt_
* _iterations_ : nombre d'itérations
* _hash_ : pointeur vers la variable de hachage, qui est utilisée pour stocker
  le résultat du hachage (le tampon doit être suffisamment grand, selon
  l'algorithme, voir le tableau dans la fonction <<crypto_hash_algorithms,crypto_hash>>)
* _hash_size_ : pointeur vers une variable utiliser pour stocker la longueur
  du résultat du hachage (en octets) (peut être NULL)

Valeur de retour :

* 1 si OK, 0 si erreur

Exemple en C :

[source,c]
----
const char *data = "abcdefghijklmnopqrstuvwxyz";
const char *salt = "12345678901234567890123456789012";  /* 32 octets */
char hash[256 / 8];
int rc, hash_size;
rc = weechat_crypto_hash_pbkdf2 (data, strlen (data), "sha256", salt, strlen (salt), 100000,
                                 hash, &hash_size);
/* rc == 1, hash_size == 32 et hash est un tampon avec :
   99 b3 5e 42 53 d1 a7 a8 49 c1 dc 2c e2 53 c2 b6 6d a1 8b dc 6e 78 a7 06 e0 ef 34 db 0a 7a a2 bb */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== crypto_hmac

_WeeChat ≥ 3.2._

Calculer le code d'authentification d'une empreinte cryptographique de message
avec clé (HMAC).

Prototype :

[source,c]
----
int weechat_crypto_hmac (const void *key, int key_size, const void *message, int message_size,
                         int hash_algo, void *hash, int *hash_size);
----

Paramètres :

* _key_ : la clé
* _key_size_ : nombre d'octets dans _key_
* _message_ : le message
* _message_size_ : nombre d'octets dans _message_
* _hash_algo_ : l'algorithme de hachage, voir le tableau dans la fonction
  <<crypto_hash_algorithms,crypto_hash>>
* _hash_ : pointeur vers la variable de hachage, qui est utilisée pour stocker
  le résultat du hachage (le tampon doit être suffisamment grand, selon
  l'algorithme, voir le tableau dans la fonction
  <<crypto_hash_algorithms,crypto_hash>>)
* _hash_size_ : pointeur vers une variable utiliser pour stocker la longueur
  du résultat du hachage (en octets) (peut être NULL)

Valeur de retour :

* 1 si OK, 0 si erreur

Exemple en C :

[source,c]
----
const char *key = "the key";
const char *message = "the message";
char hash[256 / 8];
int rc, hash_size;
rc = weechat_crypto_hmac (key, strlen (key), message, strlen (message), "sha256", hash, &hash_size);
/* rc == 1, hash_size == 32 et hash est un tampon avec :
   47 36 67 02 fc bc b1 97 a4 25 e6 7a b9 52 92 bd 15 9a 66 91 9c fb 94 b0 b4 9a 39 cb c0 24 2d 7b */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

[[directories]]
=== Répertoires

Fonctions liées aux répertoires.

==== mkdir_home

_Mis à jour dans la 3.2._

Créer un répertoire dans le répertoire de WeeChat.

Prototype :

[source,c]
----
int weechat_mkdir_home (char *directory, int mode);
----

Paramètres :

* _directory_ : nom du répertoire à créer ; il peut commencer par une de ces
  chaînes pour forcer un répertoire spécifique de WeeChat (WeeChat ≥ 3.2) :
** `${weechat_config_dir}`
** `${weechat_data_dir}` (par défaut)
** `${weechat_state_dir}`
** `${weechat_cache_dir}`
** `${weechat_runtime_dir}`
* _mode_ : mode pour le répertoire

Valeur de retour :

* 1 si le répertoire est créé, 0 en cas d'erreur

Exemple en C :

[source,c]
----
if (!weechat_mkdir_home ("${weechat_cache_dir}/temp", 0755))
{
    /* erreur */
}
----

Script (Python) :

[source,python]
----
# prototype
def mkdir_home(directory: str, mode: int) -> int: ...

# exemple
weechat.mkdir_home("${weechat_cache_dir}/temp", 0755)
----

==== mkdir

Créer un répertoire.

Prototype :

[source,c]
----
int weechat_mkdir (char *directory, int mode);
----

Paramètres :

* _directory_ : nom du répertoire à créer
* _mode_ : mode pour le répertoire

Valeur de retour :

* 1 si le répertoire est créé, 0 en cas d'erreur

Exemple en C :

[source,c]
----
if (!weechat_mkdir ("/tmp/mydir", 0755))
{
    /* erreur */
}
----

Script (Python) :

[source,python]
----
# prototype
def mkdir(directory: str, mode: int) -> int: ...

# exemple
weechat.mkdir("/tmp/mydir", 0755)
----

==== mkdir_parents

Créer un répertoire et ses parents si besoin.

Prototype :

[source,c]
----
int weechat_mkdir_parents (char *directory, int mode);
----

Paramètres :

* _directory_ : nom du répertoire à créer
* _mode_ : mode pour le répertoire

Valeur de retour :

* 1 si le répertoire est créé, 0 en cas d'erreur

Exemple en C :

[source,c]
----
if (!weechat_mkdir_parents ("/tmp/my/dir", 0755))
{
    /* erreur */
}
----

Script (Python) :

[source,python]
----
# prototype
def mkdir_parents(directory: str, mode: int) -> int: ...

# exemple
weechat.mkdir_parents("/tmp/my/dir", 0755)
----

==== exec_on_files

_Mis à jour dans la 1.5, 2.0._

Balayer les fichiers dans un répertoire et exécuter une fonction de rappel
pour chaque fichier.

Prototype :

[source,c]
----
void weechat_exec_on_files (const char *directory,
                            int recurse_subdirs,
                            int hidden_files,
                            void (*callback)(void *data,
                                             const char *filename),
                            void *callback_data);
----

Paramètres :

* _directory_ : répertoire où chercher les fichiers
* _recurse_subdirs_ : 1 pour entrer dans les sous-répertoires _(WeeChat ≥ 2.0)_
* _hidden_files_ : 1 pour inclure les fichiers cachés, sinon 0
* _callback_ : fonction appelée pour chaque fichier trouvé, paramètres :
** _void *data_ : pointeur
** _const char *filename_ : nom de fichier trouvé
* _callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat

Exemple en C :

[source,c]
----
void callback (void *data, const char *filename)
{
    /* ... */
}
...
weechat_exec_on_files ("/tmp", 0, 0, &callback, NULL);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== file_get_content

_WeeChat ≥ 0.3.1._

Lire le contenu d'un fichier texte dans une chaîne de caractères.

Prototype :

[source,c]
----
char *weechat_file_get_content (const char *filename);
----

Paramètres :

* _filename_ : chemin et nom du fichier

Valeur de retour :

* contenu du fichier sous forme de chaîne (doit être supprimé par un appel à
  "free" après utilisation)

Exemple en C :

[source,c]
----
char *contenu;

contenu = weechat_file_get_content ("/tmp/test.txt");
/* ... */
free (contenu);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== file_copy

_WeeChat ≥ 3.3._

Copier un fichier vers une autre destination.

Prototype :

[source,c]
----
int weechat_file_copy (const char *from, const char *to);
----

Paramètres :

* _from_ : fichier source
* _to_ : fichier cible

Valeur de retour :

* 1 si OK, 0 si erreur

Exemple en C :

[source,c]
----
if (weechat_file_copy ("/tmp/test.txt", "/path/to/test2.txt"))
{
    /* OK */
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== file_compress

_WeeChat ≥ 3.7._

Compresser un fichier avec gzip ou zstd.

Prototype :

[source,c]
----
int weechat_file_compress (const char *from, const char *to,
                           const char *compressor, int compression_level);
----

Paramètres :

* _from_ : fichier source
* _to_ : fichier cible
* _compressor_ : le compresseur à utiliser, un parmi :
** _gzip_ : compression gzip
** _zstd_ : compression zstandard (disponible seulement si zstd a été activé
   lors de la compilation de WeeChat)
* _compression_level_ : niveau de compression, entre 1 (rapide, peu de
  compression) à 100 (lent, meilleure compression)

Valeur de retour :

* 1 si OK, 0 si erreur

Exemple en C :

[source,c]
----
if (weechat_file_compress ("/tmp/test.txt", "/tmp/test.txt.zst", "zstd", 50))
{
    /* OK */
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

[[util]]
=== Util

Quelques fonctions utiles.

==== util_timeval_cmp

Comparer deux structures "timeval".

Prototype :

[source,c]
----
int weechat_util_timeval_cmp (struct timeval *tv1, struct timeval *tv2);
----

Paramètres :

* _tv1_ : première structure "timeval"
* _tv2_ : seconde structure "timeval"

Valeur de retour :

* -1 si tv1 < tv2
* zéro si tv1 == tv2
* +1 si tv1 > tv2

Exemple en C :

[source,c]
----
if (weechat_util_timeval_cmp (&tv1, &tv2) > 0)
{
    /* tv1 > tv2 */
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== util_timeval_diff

_Mis à jour dans la 1.1._

Retourner la différence (en microsecondes) entre deux structures "timeval".

Prototype :

[source,c]
----
long long weechat_util_timeval_diff (struct timeval *tv1, struct timeval *tv2);
----

Paramètres :

* _tv1_ : première structure "timeval"
* _tv2_ : seconde structure "timeval"

Valeur de retour :

* différence en microsecondes

[NOTE]
Avec WeeChat ≤ 1.0, la valeur retournée était en millisecondes.

Exemple en C :

[source,c]
----
long long diff = weechat_util_timeval_diff (&tv1, &tv2);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== util_timeval_add

_Mis à jour dans la 1.1._

Ajouter un intervalle (en microsecondes) à une structure "timeval".

Prototype :

[source,c]
----
void weechat_util_timeval_add (struct timeval *tv, long long interval);
----

Paramètres :

* _tv_ : structure "timeval"
* _interval_ : intervalle (en microsecondes)

[NOTE]
Avec WeeChat ≤ 1.0, l'intervalle était exprimé en millisecondes.

Exemple en C :

[source,c]
----
weechat_util_timeval_add (&tv, 2000000);  /* ajouter 2 secondes */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== util_get_time_string

_WeeChat ≥ 0.3.2, mise à jour dans la 1.3._

Retourner la date/heure sous forme de chaîne construite avec "strftime" et le
format défini dans l'option _weechat.look.time_format_.

Prototype :

[source,c]
----
const char *weechat_util_get_time_string (const time_t *date);
----

Paramètres :

* _date_ : pointeur vers la date

Valeur de retour :

* pointeur vers une chaîne contenant la date/heure

Exemple en C :

[source,c]
----
time_t date = time (NULL);
weechat_printf (NULL, "date : %s",
                weechat_util_get_time_string (&date));
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== util_strftimeval

_WeeChat ≥ 4.2.0, mis à jour dans la 4.3.0._

Formatter la date et l'heure comme la fonction `strftime` de la bibliothèque C,
en utilisant un `struct timeval` en entrée et en supportant des caractères de
conversion supplémentaires.

Prototype :

[source,c]
----
int weechat_util_strftimeval (char *string, int max, const char *format, struct timeval *tv);
----

Paramètres :

* _string_ : tampon où stocker la chaîne formatée
* _max_ : taille de la chaîne
* _format_ : format, le même que celui de la fonction _strftime_, avec des
  caractères de conversion supplémentaires :
** `%.N` où `N` est entre 1 and 6: microsecondes remplies avec des zéros sur
   N chiffres (par exemple `%.3` pour les millisecondes)
** `%f` : alias de `%.6`
** `%!` : horodatage sous forme d'entier, en secondes (valeur de tv->tv_sec)

Valeur de retour :

* nombre d'octets placés dans _string_ (valeur retournée par la fonction _strftime_).

Exemple en C :

[source,c]
----
char time[256];
struct timeval tv;
gettimeofday (&tv, NULL);
weechat_util_strftimeval (time, sizeof (time), "%FT%T.%f", &tv);
/* résultat : 2023-12-26T18:10:04.460509 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== util_parse_time

_WeeChat ≥ 4.2.0._

Analyser la date/heure avec le support des microsecondes.

Prototype :

[source,c]
----
int util_parse_time (const char *datetime, struct timeval *tv);
----

Paramètres :

* _date_ : date/heure
* _tv_: date/heure analysée (structure "timeval")

Valeur de retour :

* 1 si OK, 0 si erreur

Exemple en C :

[source,c]
----
struct timeval tv;
weechat_util_parse_time ("2023-12-25T10:29:09.456789Z", &tv);  /* == 1 */
/* result: tv.tv_sec == 1703500149, tv.tv_usec = 456789 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== util_version_number

_WeeChat ≥ 0.3.9._

Convertir une chaîne avec la version WeeChat en nombre.

Prototype :

[source,c]
----
int weechat_util_version_number (const char *version);
----

Paramètres :

* _version_ : version WeeChat sous forme de chaîne (exemple : "0.3.9" ou
  "0.3.9-dev")

Exemple en C :

[source,c]
----
version_number = weechat_util_version_number ("0.3.8");      /* == 0x00030800 */
version_number = weechat_util_version_number ("0.3.9-dev");  /* == 0x00030900 */
version_number = weechat_util_version_number ("0.3.9-rc1");  /* == 0x00030900 */
version_number = weechat_util_version_number ("0.3.9");      /* == 0x00030900 */
version_number = weechat_util_version_number ("1.0");        /* == 0x01000000 */
version_number = weechat_util_version_number ("4.0.0");      /* == 0x04000000 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

[[sorted_lists]]
=== Listes triées

Fonctions pour les listes triées.

==== list_new

Créer une nouvelle liste.

Prototype :

[source,c]
----
struct t_weelist *weechat_list_new ();
----

Valeur de retour :

* pointeur vers la nouvelle liste

Exemple en C :

[source,c]
----
struct t_weelist *list = weechat_list_new ();
----

Script (Python) :

[source,python]
----
# prototype
def list_new() -> str: ...

# exemple
list = weechat.list_new()
----

==== list_add

Ajouter un élément dans une liste.

Prototype :

[source,c]
----
struct t_weelist_item *weechat_list_add (struct t_weelist *weelist,
                                         const char *data,
                                         const char *where,
                                         void *user_data);
----

Paramètres :

* _weelist_ : pointeur vers la liste
* _data_ : donnée à insérer dans la liste
* _where_ : position dans la liste :
** _WEECHAT_LIST_POS_SORT_ : ajout dans la liste, en gardant la liste triée
** _WEECHAT_LIST_POS_BEGINNING_ : ajout en début de liste
** _WEECHAT_LIST_POS_END_ : ajout en fin de liste
* _user_data_ : un pointeur quelconque

Valeur de retour :

* pointeur vers le nouvel élément

Exemple en C :

[source,c]
----
struct t_weelist_item *my_item =
    weechat_list_add (list, "ma donnée", WEECHAT_LIST_POS_SORT, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def list_add(list: str, data: str, where: str, user_data: str) -> str: ...

# exemple
item = weechat.list_add(list, "ma donnée", weechat.WEECHAT_LIST_POS_SORT, "")
----

==== list_search

Rechercher un élément dans une liste.

Prototype :

[source,c]
----
struct t_weelist_item *weechat_list_search (struct t_weelist *weelist,
                                            const char *data);
----

Paramètres :

* _weelist_ : pointeur vers la liste
* _data_ : donnée à chercher dans la liste

Valeur de retour :

* pointeur vers l'élément trouvé, NULL si aucun élément n'a été trouvé

Exemple en C :

[source,c]
----
struct t_weelist_item *item = weechat_list_search (list, "ma donnée");
----

Script (Python) :

[source,python]
----
# prototype
def list_search(list: str, data: str) -> str: ...

# exemple
item = weechat.list_search(list, "ma donnée")
----

==== list_search_pos

_WeeChat ≥ 0.3.4._

Rechercher la position d'un élément dans une liste.

Prototype :

[source,c]
----
int weechat_list_search_pos (struct t_weelist *weelist,
                             const char *data);
----

Paramètres :

* _weelist_ : pointeur vers la liste
* _data_ : donnée à chercher dans la liste

Valeur de retour :

* position de l'élément trouvé, -1 si aucun élément n'a été trouvé

Exemple en C :

[source,c]
----
int pos_item = weechat_list_search_pos (list, "ma donnée");
----

Script (Python) :

[source,python]
----
# prototype
def list_search_pos(list: str, data: str) -> int: ...

# exemple
pos_item = weechat.list_search_pos(list, "ma donnée")
----

==== list_casesearch

Rechercher un élément dans la liste, sans tenir compte de la casse.

Prototype :

[source,c]
----
struct t_weelist_item *weechat_list_casesearch (struct t_weelist *weelist,
                                                const char *data);
----

Paramètres :

* _weelist_ : pointeur vers la liste
* _data_ : données à chercher dans la liste

Valeur de retour :

* pointeur vers l'élément trouvé, NULL si aucun élément n'a été trouvé

Exemple en C :

[source,c]
----
struct t_weelist_item *item = weechat_list_casesearch (list, "ma donnée");
----

Script (Python) :

[source,python]
----
# prototype
def list_casesearch(list: str, data: str) -> str: ...

# exemple
item = weechat.list_casesearch(list, "ma donnée")
----

==== list_casesearch_pos

_WeeChat ≥ 0.3.4._

Rechercher la position d'un élément dans la liste, sans tenir compte de la
casse.

Prototype :

[source,c]
----
int weechat_list_casesearch_pos (struct t_weelist *weelist,
                                 const char *data);
----

Paramètres :

* _weelist_ : pointeur vers la liste
* _data_ : données à chercher dans la liste

Valeur de retour :

* position l'élément trouvé, -1 si aucun élément n'a été trouvé

Exemple en C :

[source,c]
----
int pos_item = weechat_list_casesearch_pos (list, "ma donnée");
----

Script (Python) :

[source,python]
----
# prototype
def list_casesearch_pos(list: str, data: str) -> int: ...

# exemple
pos_item = weechat.list_casesearch_pos(list, "ma donnée")
----

==== list_get

Retourner un élément de la liste par sa position.

Prototype :

[source,c]
----
struct t_weelist_item *weechat_list_get (struct t_weelist *weelist,
                                         int position);
----

Paramètres :

* _weelist_ : pointeur vers la liste
* _position_ : position dans la liste (le premier élément est 0)

Valeur de retour :

* pointeur vers l'élément trouvé, NULL si aucun élément n'a été trouvé

Exemple en C :

[source,c]
----
struct t_weelist_item *item = weechat_list_get (list, 0);  /* premier élément */
----

Script (Python) :

[source,python]
----
# prototype
def list_get(list: str, position: int) -> str: ...

# exemple
item = weechat.list_get(list, 0)
----

==== list_set

Affecter une nouvelle valeur pour un élément.

Prototype :

[source,c]
----
void weechat_list_set (struct t_weelist_item *item, const char *value);
----

Paramètres :

* _item_ : pointeur vers l'élément
* _value_ : nouvelle valeur pour l'élément

Exemple en C :

[source,c]
----
weechat_list_set (item, "nouvelle donnée");
----

Script (Python) :

[source,python]
----
# prototype
def list_set(item: str, value: str) -> int: ...

# exemple
weechat.list_set(item, "nouvelle donnée")
----

==== list_next

Retourner l'élément suivant dans la liste.

Prototype :

[source,c]
----
struct t_weelist_item *weechat_list_next (struct t_weelist_item *item);
----

Paramètres :

* _item_ : pointeur vers l'élément

Valeur de retour :

* pointeur vers l'élément suivant, NULL si le pointeur était sur le dernier
  élément de la liste

Exemple en C :

[source,c]
----
struct t_weelist_item *next_item = weechat_list_next (item);
----

Script (Python) :

[source,python]
----
# prototype
def list_next(item: str) -> str: ...

# exemple
item = weechat.list_next(item)
----

==== list_prev

Retourner l'élément précédent dans la liste.

Prototype :

[source,c]
----
struct t_weelist_item *weechat_list_prev (struct t_weelist_item *item);
----

Paramètres :

* _item_ : pointeur vers l'élément

Valeur de retour :

* pointeur vers l'élément précédent, NULL si le pointeur était sur le premier
  élément de la liste

Exemple en C :

[source,c]
----
struct t_weelist_item *prev_item = weechat_list_prev (item);
----

Script (Python) :

[source,python]
----
# prototype
def list_prev(item: str) -> str: ...

# exemple
item = weechat.list_prev(item)
----

==== list_string

Retourner la valeur de l'élément sous forme de chaîne.

Prototype :

[source,c]
----
const char *weechat_list_string (struct t_weelist_item *item);
----

Paramètres :

* _item_ : pointeur vers l'élément

Valeur de retour :

* valeur de l'élément

Exemple en C :

[source,c]
----
weechat_printf (NULL, "valeur de l'élément : %s", weechat_list_string (item));
----

Script (Python) :

[source,python]
----
# prototype
def list_string(item: str) -> str: ...

# exemple
weechat.prnt("", "valeur de l'élément : %s" % weechat.list_string(item))
----

==== list_user_data

_WeeChat ≥ 2.6._

Retourner le pointeur vers les données utilisateur de l'élément.

Prototype :

[source,c]
----
void *weechat_list_user_data (struct t_weelist_item *item);
----

Paramètres :

* _item_ : pointeur vers l'élément

Valeur de retour :

* pointeur vers les données utilisateur de l'élément

Exemple en C :

[source,c]
----
weechat_printf (NULL, "données utilisateur de l'élément : %p", weechat_list_user_data (item));
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== list_size

Retourner la taille de la liste (nombre d'éléments).

Prototype :

[source,c]
----
char *weechat_list_size (struct t_weelist *weelist);
----

Paramètres :

* _weelist_ : pointeur vers la liste

Valeur de retour :

* taille de la liste (nombre d'éléments), 0 si la liste est vide

Exemple en C :

[source,c]
----
weechat_printf (NULL, "taille de la liste : %d", weechat_list_size (list));
----

Script (Python) :

[source,python]
----
# prototype
def list_size(list: str) -> int: ...

# exemple
weechat.prnt("", "taille de la liste : %d" % weechat.list_size(list))
----

==== list_remove

Supprimer un élément de la liste.

Prototype :

[source,c]
----
void weechat_list_remove (struct t_weelist *weelist,
                          struct t_weelist_item *item);
----

Paramètres :

* _weelist_ : pointeur vers la liste
* _item_ : pointeur vers l'élément

Exemple en C :

[source,c]
----
weechat_list_remove (list, item);
----

Script (Python) :

[source,python]
----
# prototype
def list_remove(list: str, item: str) -> int: ...

# exemple
weechat.list_remove(list, item)
----

==== list_remove_all

Supprimer tous les éléments de la liste.

Prototype :

[source,c]
----
void weechat_list_remove_all (struct t_weelist *weelist);
----

Paramètres :

* _weelist_ : pointeur vers la liste

Exemple en C :

[source,c]
----
weechat_list_remove_all (list);
----

Script (Python) :

[source,python]
----
# prototype
def list_remove_all(list: str) -> int: ...

# exemple
weechat.list_remove_all(list)
----

==== list_free

Supprimer une liste.

Prototype :

[source,c]
----
void weechat_list_free (struct t_weelist *weelist);
----

Paramètres :

* _weelist_ : pointeur vers la liste

Exemple en C :

[source,c]
----
weechat_list_free (list);
----

Script (Python) :

[source,python]
----
# prototype
def list_free(list: str) -> int: ...

# exemple
weechat.list_free(list)
----

[[array_lists]]
=== Listes avec tableau

Fonctions pour les listes avec tableau.

Une liste avec tableau est une liste de pointeurs avec une taille dynamique et un tri optionnel.

==== arraylist_new

_WeeChat ≥ 1.8._

Créer une nouvelle liste avec tableau.

Prototype :

[source,c]
----
struct t_arraylist *weechat_arraylist_new (int initial_size,
                                           int sorted,
                                           int allow_duplicates,
                                           int (*callback_cmp)(void *data,
                                                               struct t_arraylist *arraylist,
                                                               void *pointer1,
                                                               void *pointer2),
                                           void *callback_cmp_data,
                                           void (*callback_free)(void *data,
                                                                 struct t_arraylist *arraylist,
                                                                 void *pointer),
                                           void *callback_free_data);
----

Paramètres :

* _initial_size_ : taille initiale de la liste avec tableau (ce n'est pas le nombre d'éléments)
* _sorted_ : 1 pour trier la liste avec tableau, 0 pour ne pas trier
* _allow_duplicates_ : 1 pour autoriser les entrées dupliquées, 0 pour empêcher
  une même entrée d'être ajoutée à nouveau
* _callback_cmp_ : fonction appelée pour comparer deux éléments (optionnelle),
  paramètres et valeur de retour :
** _void *data_ : pointeur
** _struct t_arraylist *arraylist_ : pointeur vers la liste avec tableau
** _void *pointer1_ : pointeur vers le premier élément
** _void *pointer2_ : pointeur vers le second élément
** valeur de retour :
*** nombre négatif si le premier élément est inférieur au second élément
*** 0 si le premier élément est égal au second élément
*** nombre positif si le premier élément est supérieur au second élément
* _callback_cmp_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat
* _callback_free_ : fonction utilisée pour libérer les éléments (optionnelle),
  paramètres :
** _void *data_ : pointeur
** _struct t_arraylist *arraylist_ : pointeur vers la liste avec tableau
** _void *pointer_ : pointeur vers l'élément
* _callback_free_data_ : pointeur donné à la fonction de rappelle lorsqu'elle est
  appelée par WeeChat

Valeur de retour :

* pointeur vers la nouvelle liste avec tableau

Exemple en C :

[source,c]
----
int
cmp_cb (void *data, struct t_arraylist *arraylist,
        void *pointer1, void *pointer2)
{
    if (...)
        return -1;
    else if (...)
        return 1;
    else
        return 0;
}

struct t_arraylist *list = weechat_arraylist_new (32, 1, 1,
                                                  &cmp_cb, NULL, NULL, NULL);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== arraylist_size

_WeeChat ≥ 1.8._

Retourner la taille de la liste (nombre de pointeurs vers des éléments).

Prototype :

[source,c]
----
int weechat_list_size (struct t_arraylist *arraylist);
----

Paramètres :

* _arraylist_ : pointeur vers la liste avec tableau

Valeur de retour :

* taille de la liste avec tableau (nombre d'éléments), 0 si la liste avec tableau est vide

Exemple en C :

[source,c]
----
weechat_printf (NULL, "size of array list: %d", weechat_arraylist_size (arraylist));
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== arraylist_get

_WeeChat ≥ 1.8._

Retourner un pointeur avec un élément par sa position.

Prototype :

[source,c]
----
void *weechat_arraylist_get (struct t_arraylist *arraylist, int index);
----

Paramètres :

* _arraylist_ : pointeur vers la liste avec tableau
* _index_ : index dans la liste (le premier pointeur est 0)

Valeur de retour :

* pointeur trouvé, NULL si le pointeur n'est pas trouvé

Exemple en C :

[source,c]
----
void *pointer = weechat_arraylist_get (arraylist, 0);  /* premier élément */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== arraylist_search

_WeeChat ≥ 1.8._

Chercher un élément dans une liste avec tableau.

Prototype :

[source,c]
----
void *weechat_arraylist_search (struct t_arraylist *arraylist, void *pointer,
                                int *index, int *index_insert);
----

Paramètres :

* _arraylist_ : pointeur vers la liste avec tableau
* _pointer_ : pointeur vers l'élément à chercher dans la liste avec tableau
* _index_ : pointeur vers un entier qui sera défini avec l'index trouvé, ou -1 si non trouvé
  (optionnel)
* _index_insert_ : pointeur vers un entier qui sera défini avec l'index qui doit être utilisé
  pour insérer un élément dans la liste avec tableau (pour garder la liste avec tableau triée)
  (optionnel)

Valeur de retour :

* pointeur vers l'élément trouvé, NULL si l'élément n'est pas trouvé

Exemple en C :

[source,c]
----
int index, index_insert;
void *item = weechat_arraylist_search (arraylist, pointer, &index, &index_insert);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== arraylist_insert

_WeeChat ≥ 1.8._

Insérer un élément dans une liste avec tableau.

Prototype :

[source,c]
----
int weechat_arraylist_insert (struct t_arraylist *arraylist, int index, void *pointer);
----

Paramètres :

* _arraylist_ : pointeur vers la liste avec tableau
* _index_ : position de l'élément dans la liste avec tableau ou -1 pour ajouter
  l'élément à la fin (ce paramètre est utilisé seulement si la liste avec tableau
  n'est pas triée, il est ignoré si la liste avec tableau est triée)
* _pointeur_ : pointeur vers l'élément à insérer

Valeur de retour :

* index du nouvel élément (≥ 0), -1 si erreur.

Exemple en C :

[source,c]
----
int index = weechat_arraylist_insert (arraylist, -1, pointer);  /* insert at the end if not sorted */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== arraylist_add

_WeeChat ≥ 1.8._

Ajouter un élément dans une liste avec tableau.

Prototype :

[source,c]
----
int weechat_arraylist_add (struct t_arraylist *arraylist, void *pointer);
----

Paramètres :

* _arraylist_ : pointeur vers la liste avec tableau
* _pointer_ : pointeur vers l'élément à ajouter

Valeur de retour :

* index du nouvel élément (≥ 0), -1 si erreur.

Exemple en C :

[source,c]
----
int index = weechat_arraylist_add (arraylist, pointer);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== arraylist_remove

_WeeChat ≥ 1.8._

Supprimer un élément d'une liste avec tableau.

Prototype :

[source,c]
----
int weechat_arraylist_remove (struct t_arraylist *arraylist, int index);
----

Paramètres :

* _arraylist_ : pointeur vers la liste avec tableau
* _index_ : index de l'élément à supprimer

Valeur de retour :

* index de l'élément supprimé, -1 si erreur.

Exemple en C :

[source,c]
----
int index_removed = weechat_arraylist_remove (arraylist, index);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== arraylist_clear

_WeeChat ≥ 1.8._

Supprimer tous les éléments d'une liste avec tableau.

Prototype :

[source,c]
----
int weechat_arraylist_clear (struct t_arraylist *arraylist);
----

Paramètres :

* _arraylist_ : pointeur vers la liste avec tableau

Valeur de retour :

* 1 si OK, 0 si erreur

Exemple en C :

[source,c]
----
if (weechat_arraylist_clear (arraylist))
{
    /* OK */
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== arraylist_free

_WeeChat ≥ 1.8._

Supprimer une liste avec tableau.

Prototype :

[source,c]
----
void weechat_arraylist_free (struct t_arraylist *arraylist);
----

Paramètres :

* _arraylist_ : pointeur vers la liste avec tableau

Exemple en C :

[source,c]
----
weechat_arraylist_free (arraylist);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

[[hashtables]]
=== Tables de hachage

Fonctions pour les tables de hachage.

==== hashtable_new

_WeeChat ≥ 0.3.3._

Créer une nouvelle table de hachage.

Prototype :

[source,c]
----
struct t_hashtable *weechat_hashtable_new (int size,
                                           const char *type_keys,
                                           const char *type_values,
                                           unsigned long long (*callback_hash_key)(struct t_hashtable *hashtable,
                                                                                   const void *key),
                                           int (*callback_keycmp)(struct t_hashtable *hashtable,
                                                                  const void *key1,
                                                                  const void *key2));
----

Paramètres :

* _size_ : taille du tableau interne pour stocker les clés sous forme de
  hachage, une grande valeur utilise plus de mémoire mais présente une meilleure
  performance (cela n'est *pas* une limite sur le nombre d'entrées de la table
  de hachage)
* _type_keys_ : type pour les clés dans la table de hachage :
** _WEECHAT_HASHTABLE_INTEGER_
** _WEECHAT_HASHTABLE_STRING_
** _WEECHAT_HASHTABLE_POINTER_
** _WEECHAT_HASHTABLE_BUFFER_
** _WEECHAT_HASHTABLE_TIME_
* _type_values_ : type pour les valeurs dans la table de hachage :
** _WEECHAT_HASHTABLE_INTEGER_
** _WEECHAT_HASHTABLE_STRING_
** _WEECHAT_HASHTABLE_POINTER_
** _WEECHAT_HASHTABLE_BUFFER_
** _WEECHAT_HASHTABLE_TIME_
* _callback_hash_key_ : fonction appelée pour rendre le hachage d'une clé (la
  clé sous forme de nombre entier), peut être NULL si le type de clé n'est pas
  "buffer" (une fonction de hachage par défaut est utilisée), paramètres et
  valeur de retour :
** _struct t_hashtable *hashtable_ : pointeur vers la table de hachage
** _const void *key_ : clé
** valeur de retour : hachage de la clé
* _callback_keycmp_ : fonction appelée pour comparer deux clés, peut être NULL
  si le type de clé n'est pas "buffer" (une fonction de comparaison par défaut
  est utilisée), paramètres et valeur de retour :
** _struct t_hashtable *hashtable_ : pointeur vers la table de hachage
** _const void *key1_ : première clé
** _const void *key2_ : seconde clé
** valeur de retour :
*** nombre négatif si _key1_ est inférieur à _key2_
*** 0 si _key1_ est égal à _key2_
*** nombre positif si _key1_ est supérieur à _key2_

Valeur de retour :

* pointeur vers la nouvelle table de hachage, NULL en cas d'erreur

Exemple en C :

[source,c]
----
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== hashtable_set_with_size

_WeeChat ≥ 0.3.3, mis à jour dans la 0.4.2._

Ajouter ou mettre à jour une entrée dans une table de hachage avec une taille
pour la clé et la valeur.

Prototype :

[source,c]
----
struct t_hashtable_item *weechat_hashtable_set_with_size (struct t_hashtable *hashtable,
                                                          const void *key, int key_size,
                                                          const void *value, int value_size);
----

Paramètres :

* _hashtable_ : pointeur vers la table de hachage
* _key_ : pointeur vers la clé
* _key_size_ : taille de la clé (en octets), utilisée seulement si le type de
  clés dans la table de hachage est "buffer"
* _value_ : pointeur vers la valeur
* _value_size_ : taille de la valeur (en octets), utilisée seulement si le type
  de valeurs dans la table de hachage est "buffer"

Valeur de retour :

* pointeur vers l'item créé/mis à jour, NULL en cas d'erreur

Exemple en C :

[source,c]
----
weechat_hashtable_set_with_size (hashtable, "ma_cle", 0,
                                 my_buffer, sizeof (my_buffer_struct));
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== hashtable_set

_WeeChat ≥ 0.3.3, mis à jour dans la 0.4.2._

Ajouter ou mettre à jour une entrée dans la table de hachage.

Prototype :

[source,c]
----
struct t_hashtable_item *weechat_hashtable_set (struct t_hashtable *hashtable,
                                                const void *key, const void *value);
----

Paramètres :

* _hashtable_ : pointeur vers la table de hachage
* _key_ : pointeur vers la clé
* _value_ : pointeur vers la valeur

Valeur de retour :

* pointeur vers l'entrée créée/mise à jour, NULL en cas d'erreur

Exemple en C :

[source,c]
----
weechat_hashtable_set (hashtable, "ma_cle", "ma_valeur");
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== hashtable_get

_WeeChat ≥ 0.3.3._

Retourner la valeur associée à une clé dans une table de hachage.

Prototype :

[source,c]
----
void *weechat_hashtable_get (struct t_hashtable *hashtable, void *key);
----

Paramètres :

* _hashtable_ : pointeur vers la table de hachage
* _key_ : pointeur vers la clé

Valeur de retour :

* valeur pour la clé, NULL si la clé n'est pas trouvée

Exemple en C :

[source,c]
----
void *value = weechat_hashtable_get (hashtable, "ma_cle");
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== hashtable_has_key

_WeeChat ≥ 0.3.4._

Vérifier si une clé est présente dans la table de hachage.

Prototype :

[source,c]
----
int weechat_hashtable_has_key (struct t_hashtable *hashtable, void *key);
----

Paramètres :

* _hashtable_ : pointeur vers la table de hachage
* _key_ : pointeur vers la clé

Valeur de retour :

* 1 si la clé est dans la table de hachage, 0 si la clé n'est pas dans la table
  de hachage

Exemple en C :

[source,c]
----
if (weechat_hashtable_has_key (hashtable, "ma_cle"))
{
    /* la clé est dans la table de hachage */
    /* ... */
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== hashtable_map

_WeeChat ≥ 0.3.3._

Appeller une fonction pour chaque entrée d'une table de hachage, par ordre
d'insertion dans la table de hachage (de la plus ancienne à la plus récente).

Prototype :

[source,c]
----
void weechat_hashtable_map (struct t_hashtable *hashtable,
                            void (*callback_map)(void *data,
                                                 struct t_hashtable *hashtable,
                                                 const void *key,
                                                 const void *value),
                            void *callback_map_data);
----

Paramètres :

* _hashtable_ : pointeur vers la table de hachage
* _callback_map_ : fonction appelée pour chaque entrée de la table de hachage
* _callback_map_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée

Exemple en C :

[source,c]
----
void
map_cb (void *data, struct t_hashtable *hashtable,
        const void *key, const void *value)
{
    /* afficher la clé et la valeur (elles sont des chaînes ici) */
    weechat_printf (NULL, "clé : '%s', valeur : '%s'",
                    (const char *)key,
                    (const char *)value);
}
/* ... */
weechat_hashtable_map (hashtable, &map_cb, NULL);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== hashtable_map_string

_WeeChat ≥ 0.3.7._

Appeller une fonction pour chaque entrée d'une table de hachage, par ordre
d'insertion dans la table de hachage (de la plus ancienne à la plus récente),
en envoyant les clés et valeurs sous forme de chaînes.

Prototype :

[source,c]
----
void weechat_hashtable_map_string (struct t_hashtable *hashtable,
                                   void (*callback_map)(void *data,
                                                        struct t_hashtable *hashtable,
                                                        const char *key,
                                                        const char *value),
                                   void *callback_map_data);
----

Paramètres :

* _hashtable_ : pointeur vers la table de hachage
* _callback_map_ : fonction appelée pour chaque entrée de la table de hachage
* _callback_map_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée

[NOTE]
Les chaînes _key_ et _value_ envoyées à la fonction de rappel sont des chaînes
temporaires, elles sont supprimées après l'appel à cette fonction.

Exemple en C :

[source,c]
----
void
map_cb (void *data, struct t_hashtable *hashtable,
        const char *key, const char *value)
{
    /* afficher la clé et la valeur */
    weechat_printf (NULL, "clé : '%s', valeur : '%s'",
                    key, value);
}
/* ... */
weechat_hashtable_map_string (hashtable, &map_cb, NULL);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== hashtable_dup

_WeeChat ≥ 1.0._

Dupliquer une table de hachage.

Prototype :

[source,c]
----
struct t_hashtable *weechat_hashtable_dup (struct t_hashtable *hashtable);
----

Paramètres :

* _hashtable_ : pointeur vers la table de hachage

Valeur de retour :

* table de hachage dupliquée

Exemple en C :

[source,c]
----
struct t_hashtable *new_hashtable = weechat_hashtable_dup (hashtable);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== hashtable_get_integer

_WeeChat ≥ 0.3.3._

Retourner une valeur entière pour une propriété d'une table de hachage.

Prototype :

[source,c]
----
int weechat_hashtable_get_integer (struct t_hashtable *hashtable,
                                   void *property);
----

Paramètres :

* _hashtable_ : pointeur vers la table de hachage
* _property_ : nom de propriété :
** _size_ : taille du tableau interne "htable" dans la table de hachage
** _items_count_ : nombre d'éléments dans la table de hachage

Valeur de retour :

* valeur de la propriété sous forme d'entier

Exemple en C :

[source,c]
----
int items_count = weechat_hashtable_get_integer (hashtable, "items_count");
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== hashtable_get_string

_WeeChat ≥ 0.3.4._

Retourner une valeur pour une propriété d'une table de hachage sous forme de
chaîne.

Prototype :

[source,c]
----
const char *weechat_hashtable_get_string (struct t_hashtable *hashtable,
                                          const char *property);
----

Paramètres :

* _hashtable_ : pointeur vers la table de hachage
* _property_ : nom de la propriété :
** _type_keys_ : type pour les clés :
*** _integer_ : entier
*** _string_ : chaîne
*** _pointer_ : pointeur
*** _buffer_ : buffer
*** _time_ : heure
** _type_values_ : type pour les valeurs :
*** _integer_ : entier
*** _string_ : chaîne
*** _pointer_ : pointeur
*** _buffer_ : buffer
*** _time_ : heure
** _keys_ : chaîne avec la liste des clés (format : "clé1,clé2,clé3")
** _keys_sorted_ : chaîne avec la liste triée des clés (format :
   "clé1,clé2,clé3")
** _values_ : chaîne avec la liste des valeurs (format :
   "valeur1,valeur2,valeur3")
** _keys_values_ : chaîne avec la liste des clés et valeurs
   (format : "clé1:valeur1,clé2:valeur2,clé3:valeur3")
** _keys_values_sorted_ : chaîne avec la liste des clés et valeurs (triée sur
   les clés) (format : "clé1:valeur1,clé2:valeur2,clé3:valeur3")

Valeur de retour :

* valeur de la propriété sous forme de chaîne

Exemples en C :

[source,c]
----
weechat_printf (NULL, "les clés sont de type : %s",
                weechat_hashtable_get_string (hashtable, "type_keys"));
weechat_printf (NULL, "liste des clés : %s",
                weechat_hashtable_get_string (hashtable, "keys"));
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== hashtable_set_pointer

_WeeChat ≥ 0.3.4._

Affecter un pointeur à une propriété d'une table de hachage.

Prototype :

[source,c]
----
void weechat_hashtable_set_pointer (struct t_hashtable *hashtable,
                                    const char *property, void *pointer);
----

Paramètres :

* _hashtable_ : pointeur vers la table de hachage
* _property_ : nom de la propriété :
** _callback_free_key_ : définit la fonction de rappel pour supprimer les clés
   de la table de hachage _(WeeChat ≥ 0.4.2)_
** _callback_free_value_ : définit la fonction de rappel pour supprimer les
   valeurs de la table de hachage
* _pointer_ : nouvelle valeur de pointeur pour la propriété

Exemple en C :

[source,c]
----
void
my_free_value_cb (struct t_hashtable *hashtable, const void *key, void *value)
{
    /* ... */
}

void
my_free_key_cb (struct t_hashtable *hashtable, void *key)
{
    /* ... */
}

weechat_hashtable_set_pointer (hashtable, "callback_free_value", &my_free_value_cb);
weechat_hashtable_set_pointer (hashtable, "callback_free_key", &my_free_key_cb);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== hashtable_add_to_infolist

_WeeChat ≥ 0.3.3._

Ajouter les éléments d'une table de hachage dans un objet infolist, par ordre
d'insertion dans la table de hachage (de la plus ancienne à la plus récente).

Prototype :

[source,c]
----
int weechat_hashtable_add_to_infolist (struct t_hashtable *hashtable,
                                       struct t_infolist_item *infolist_item,
                                       const char *prefix);
----

Paramètres :

* _hashtable_ : pointeur vers la table de hachage
* _infolist_item_ : pointeur vers l'objet de l'infolist
* _prefix_ : chaîne utilisée comme préfixe pour les noms dans l'infolist

Valeur de retour :

* 1 si ok, 0 en cas d'erreur

Exemple en C :

[source,c]
----
weechat_hashtable_add_to_infolist (hashtable, infolist_item, "testhash");

/* si la table de hachage contient :
     "cle1" => "valeur 1"
     "cle2" => "valeur 2"
   alors les variables suivantes seront ajoutées dans l'objet de l'infolist :
     "testhash_name_00000"  = "cle1"
     "testhash_value_00000" = "valeur 1"
     "testhash_name_00001"  = "cle2"
     "testhash_value_00001" = "valeur 2"
*/
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== hashtable_add_from_infolist

_WeeChat ≥ 2.2._

Ajouter les éléments d'une infolist dans une table de hachage.

Prototype :

[source,c]
----
int weechat_hashtable_add_from_infolist (struct t_hashtable *hashtable,
                                         struct t_infolist *infolist,
                                         const char *prefix);
----

Paramètres :

* _hashtable_ : pointeur vers la table de hachage
* _infolist_ : pointeur vers l'infolist
* _prefix_ : chaîne utilisée comme préfixe pour les noms dans l'infolist

Valeur de retour :

* 1 si ok, 0 en cas d'erreur

Exemple en C :

[source,c]
----
weechat_hashtable_add_from_infolist (hashtable, infolist, "testhash");

/* si l'infolist contient :
     "testhash_name_00000"  = "cle1"
     "testhash_value_00000" = "valeur 1"
     "testhash_name_00001"  = "cle2"
     "testhash_value_00001" = "valeur 2"
   alors les variables suivantes seront ajoutées dans la table de hachage :
     "cle1" => "valeur 1"
     "cle2" => "valeur 2"
*/
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== hashtable_remove

_WeeChat ≥ 0.3.3._

Supprimer un élément d'une table de hachage.

Prototype :

[source,c]
----
void weechat_hashtable_remove (struct t_hashtable *hashtable, const void *key);
----

Paramètres :

* _hashtable_ : pointeur vers la table de hachage
* _key_ : pointeur vers la clé

Exemple en C :

[source,c]
----
weechat_hashtable_remove (hashtable, "ma_cle");
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== hashtable_remove_all

_WeeChat ≥ 0.3.3._

Supprimer tous les éléments d'une table de hachage.

Prototype :

[source,c]
----
void weechat_hashtable_remove_all (struct t_hashtable *hashtable);
----

Paramètres :

* _hashtable_ : pointeur vers la table de hachage

Exemple en C :

[source,c]
----
weechat_hashtable_remove_all (hashtable);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== hashtable_free

_WeeChat ≥ 0.3.3._

Supprimer une table de hachage.

Prototype :

[source,c]
----
void weechat_hashtable_free (struct t_hashtable *hashtable);
----

Paramètres :

* _hashtable_ : pointeur vers la table de hachage

Exemple en C :

[source,c]
----
weechat_hashtable_free (hashtable);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

[[configuration_files]]
=== Fichiers de configuration

Fonctions pour les fichiers de configuration.

==== config_new

_Mis à jour dans la 1.5, 4.0.0._

Créer un nouveau fichier de configuration.

Prototype :

[source,c]
----
struct t_config_file *weechat_config_new (const char *name,
                                          int (*callback_reload)(const void *pointer,
                                                                 void *data,
                                                                 struct t_config_file *config_file),
                                          const void *callback_reload_pointer,
                                          void *callback_reload_data);
----

Paramètres :

* _name_ : nom du nouveau fichier de configuration (sans chemin ou extension) ;
  une priorité est autorisée avant le nom, avec le format `nnn|nom` où `nnn` est
  un entier positif avec la priorité ; la priorité par défaut est 1000 ; les
  fichiers de configuration sont triés par priorité de la plus haute à la plus
  basse lorsque la commande `/reload` est exécutée
  (voir la priorité des fichiers de configuration ci-dessous)
* _callback_reload_ : fonction appelée quand le fichier de configuration est
  rechargé avec `/reload` (optionnel, peut être NULL, voir ci-dessous),
  paramètres et valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _struct t_config_file *config_file_ : pointeur vers le fichier de
   configuration
** valeur de retour :
*** _WEECHAT_CONFIG_READ_OK_
*** _WEECHAT_CONFIG_READ_MEMORY_ERROR_
*** _WEECHAT_CONFIG_READ_FILE_NOT_FOUND_
* _callback_reload_pointer_ : pointeur donné à la fonction de rappel de
  rechargement lorsqu'elle est appelée par WeeChat
* _callback_reload_data_ : pointeur donné à la fonction de rappel lorsqu'elle
  est appelée  par WeeChat; si non NULL, doit avoir été alloué par malloc (ou
  une fonction similaire) et est automatiquement libéré (par free) lorsque le
  fichier de configuration est libéré

Fonction de rechargement :

* La fonction de rappel doit appeler seulement la fonction
  <<_config_reload,config_reload>>, elle ne doit pas supprimer le fichier de
  configuration.
* Une fonction de rappel est nécessaire seulement si des choses sont faites
  avant ou après l'appel à la fonction <<_config_reload,config_reload>>. +
  Si aucune fonction de rappel n'est donnée, WeeChat appellera sa fonction
  interne de rechargement, donc le fichier de configuration sera rechargé dans
  tous les cas.

Valeur de retour :

* pointeur vers le nouveau fichier de configuration, NULL en cas d'erreur

[NOTE]
Le fichier n'est PAS créé sur le disque par cette fonction. Il sera créé par
l'appel à la fonction <<_config_write,config_write>>.
Vous ne devriez appeler cette fonction qu'après avoir créé les sections (avec
<<_config_new_section,config_new_section>>) et les options (avec
<<_config_new_option,config_new_option>>).

Priorité des fichiers de configuration par défaut :

include::{autogendir}/autogen_api_config_priority.fr.adoc[tag=config_priority]

Exemple en C :

[source,c]
----
int
my_config_reload_cb (const void *pointer, void *data,
                     struct t_config_file *config_file)
{
    /* ... */

    return WEECHAT_RC_OK;
}

struct t_config_file *config_file = weechat_config_new ("test",
                                                        &my_config_reload_cb,
                                                        NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def config_new(name: str, callback_reload: str, callback_reload_data: str) -> str: ...

# exemple
def my_config_reload_cb(data: str, config_file: str) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

config_file = weechat.config_new("test", "my_config_reload_cb", "")
----

==== config_set_version

_WeeChat ≥ 4.0.0._

Définir la version du fichier de configuration et une fonction de rappel pour
la mise à jour des sections/options à la volée lorsque la configuration est lue.

Prototype :

[source,c]
----
int config_file_set_version (struct t_config_file *config_file,
                             int version,
                             struct t_hashtable *(*callback_update)(const void *pointer,
                                                                    void *data,
                                                                    struct t_config_file *config_file,
                                                                    int version_read,
                                                                    struct t_hashtable *data_read),
                             const void *callback_update_pointer,
                             void *callback_update_data);
----

Paramètres :

* _config_file_ : pointeur vers le fichier de configuration
* _version_ : version, doit être ≥ 2
* _callback_update_ : fonction appelée lorsque le fichier de configuration est
  lu, pour chaque section et option, si la version lue est inférieure à la
  version attendue (optionnelle, peut être NULL, voir ci-dessous), paramètres
  et valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _struct t_config_file *config_file_ : pointeur vers le fichier de configuration
** _int version_read_ : version lue dans le fichier de configuration (1 par défaut)
** _struct t_hashtable *data_read_ : table de hachage avec les données lues du
   fichier de configuration (voir ci-dessous)
** valeur de retour :
*** soit le pointeur vers la table de hachage "data_read" (avec la
   table de hachage complétée), ou un pointeur vers une nouvelle table de
   hachage (créée par la fonction de rappel, avec clés et valeurs de type
   "string")
* _callback_update_pointer_: pointeur donné à la fonction de rappel lorsqu'elle
  est appelée par WeeChat
* _callback_update_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou une
  fonction similaire) et est automatiquement libéré (par free) lorsque le
  fichier de configuration est libéré

Fonction de rappel de mise à jour :

* La fonction de rappel reçoit une table de hachage avec les données lues du
  fichier de configuration :

[width="100%",cols="1m,2,8",options="header"]
|===
| Clé        | Disponibilité             | Valeur
| config     | Toujours définie          | Nom du fichier de configuration sans l'extension (par exemple : `weechat`)
| section    | Toujours définie          | Nom de la section lue
| option     | Pour une option seulement | Nom de l'option
| value      | Pour une option seulement | Valeur de l'option (si non NULL)
| value_null | Pour une option seulement | L'option a une valeur NULL (la valeur est toujours `1`)
|===

* La fonction de rappel peut mettre à jour la "section" pour une ligne avec une
  section et "option", "value" et "value_null" pour une ligne avec une option.
* Si "option" est changée en chaîne vide par la fonction de rappel, la ligne lue
  dans le fichier de configuration est ignorée.
* Le champ "value_null" peut être positionné pour forcer une valeur NULL dans
  l'option.

Valeur de retour :

* 1 si OK, 0 si erreur

Exemple en C :

[source,c]
----
struct t_hashtable *
my_config_update_cb (const void *pointer, void *data,
                     struct t_config_file *config_file,
                     int version_read,
                     struct t_hashtable *data_read)
{
    const char *ptr_section, *ptr_option;

    /* retourner maintenant si la version est déjà la dernière */
    if (version_read >= 2)
        return NULL;

    ptr_section = hashtable_get (data_read, "section");
    ptr_option = hashtable_get (data_read, "option");

    /* renommer la section "abc" en "def" */
    if (ptr_section && !ptr_option && (strcmp (ptr_section, "abc") == 0))
    {
        hashtable_set (data_read, "section", "def");
        return data_read;
    }

    /* limiter les autres changements à la section "test" */
    if (!ptr_section || !ptr_option || (strcmp (ptr_section, "test") != 0))
        return NULL;

    /* renommer l'option "test1" en "test2" */
    if (strcmp (ptr_option, "test1") == 0)
    {
        hashtable_set (data_read, "option", "test2");
        return data_read;
    }

    /* définir la valeur à "xxx" pour l'option "test" */
    if (strcmp (ptr_option, "test") == 0)
    {
        hashtable_set (data_read, "value", "xxx");
        return data_read;
    }

    /* définir la valeur à NULL pour l'option "test_null" */
    if (strcmp (ptr_option, "test_null") == 0)
    {
        hashtable_set (data_read, "value_null", "1");
        return data_read;
    }

    /* aucun changement */
    return NULL;
}

struct t_config_file *config_file = weechat_config_new ("test", NULL, NULL, NULL);
weechat_config_set_version (config_file, 2, &my_config_update_cb, NULL, NULL);
weechat_config_read (config_file);
----

Script (Python) :

[source,python]
----
# prototype
def config_set_version(config_file: str, version: int, callback_update: str, callback_update_data: str) -> int: ...

# exemple
def my_config_update_cb(data: str, config_file: str, version_read: int, data_read: Dict[str, str]) -> Dict[str, str]:
    # retourner maintenant si la version est déjà la dernière
    if version_read >= 2:
        return {}

    section = data_read.get("section")
    option = data_read.get("option")

    # renommer la section "abc" en "def"
    if section and not option and section == "abc":
        data_read["section"] = "def"
        return data_read

    # limiter les autres changements à la section "test"
    if not section or not option or section != "test":
        return {}

    # renommer l'option "test1" en "test2"
    if option == "test1":
        data_read["option"] = "test2"
        return data_read

    # définir la valeur à "xxx" pour l'option "test"
    if option == "test":
        data_read["value"] = "xxx"
        return data_read

    # définir la valeur à NULL pour l'option "test_null"
    if option == "test_null":
        data_read["value_null"] = "1"
        return data_read

    # aucun changement
    return {}

config_file = weechat.config_new("test", "", "")
weechat.config_set_version(config_file, 2, "my_config_update_cb", "")
weechat.config_read(config_file)
----

==== config_new_section

_Mis à jour dans la 1.5._

Créer une nouvelle section dans un fichier de configuration.

Prototype :

[source,c]
----
struct t_config_section *weechat_config_new_section (
    struct t_config_file *config_file,
    const char *name,
    int user_can_add_options,
    int user_can_delete_options,
    int (*callback_read)(const void *pointer,
                         void *data,
                         struct t_config_file *config_file,
                         struct t_config_section *section,
                         const char *option_name,
                         const char *value),
    const void *callback_read_pointer,
    void *callback_read_data,
    int (*callback_write)(const void *pointer,
                          void *data,
                          struct t_config_file *config_file,
                          const char *section_name),
    const void *callback_write_pointer,
    void *callback_write_data,
    int (*callback_write_default)(const void *pointer,
                                  void *data,
                                  struct t_config_file *config_file,
                                  const char *section_name),
    const void *callback_write_default_pointer,
    void *callback_write_default_data,
    int (*callback_create_option)(const void *pointer,
                                  void *data,
                                  struct t_config_file *config_file,
                                  struct t_config_section *section,
                                  const char *option_name,
                                  const char *value),
    const void *callback_create_option_pointer,
    void *callback_create_option_data,
    int (*callback_delete_option)(const void *pointer,
                                  void *data,
                                  struct t_config_file *config_file,
                                  struct t_config_section *section,
                                  struct t_config_option *option),
    const void *callback_delete_option_pointer,
    void *callback_delete_option_data);
----

Paramètres :

* _config_file_ : pointeur vers le fichier de configuration
* _name_ : nom de la section
* _user_can_add_options_ : 1 si l'utilisateur peut créer de nouvelles options
  dans la section, ou 0 si c'est interdit
* _user_can_delete_options_ : 1 si l'utilisateur peut supprimer des options
  dans la section, ou 0 si c'est interdit
* _callback_read_ : fonction appelée quand une option de la section est lue
  depuis le disque (devrait être NULL dans la plupart des cas, sauf si des
  options de la section nécessitent une fonction personnalisée), paramètres et
  valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _struct t_config_file *config_file_ : pointeur vers le fichier de
   configuration
** _struct t_config_section *section_ : pointeur vers la section
** _const char *option_name_ : nom de l'option
** _const char *value_ : valeur
** valeur de retour :
*** _WEECHAT_CONFIG_OPTION_SET_OK_CHANGED_
*** _WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE_
*** _WEECHAT_CONFIG_OPTION_SET_ERROR_
*** _WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND_
* _callback_read_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle
  est appelée par WeeChat
* _callback_read_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou une
  fonction similaire) et est automatiquement libéré (par free) lorsque la
  section est libérée
* _callback_write_ : fonction appelée lorsque la section est écrite dans le
  fichier (devrait être NULL dans la plupart des cas, sauf si la section
  nécessite d'être écrite par une fonction personnalisée), paramètres et valeur
  de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _struct t_config_file *config_file_ : pointeur vers le fichier de
   configuration
** _const char *section_name_ : nom de la section
** valeur de retour :
*** _WEECHAT_CONFIG_WRITE_OK_
*** _WEECHAT_CONFIG_WRITE_ERROR_
*** _WEECHAT_CONFIG_WRITE_MEMORY_ERROR_
* _callback_write_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle
  est appelée par WeeChat
* _callback_write_data_ : pointeur donné à la fonction de rappel lorsqu'elle
  est appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou
  une fonction similaire) et est automatiquement libéré (par free) lorsque la
  section est libérée
* _callback_write_default_ : fonction appelée lorsque les valeurs par défaut
  doivent être écrites dans le fichier, paramètres et valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _struct t_config_file *config_file_ : pointeur vers le fichier de
   configuration
** _const char *section_name_ : nom de la section
** valeur de retour :
*** _WEECHAT_CONFIG_WRITE_OK_
*** _WEECHAT_CONFIG_WRITE_ERROR_
*** _WEECHAT_CONFIG_WRITE_MEMORY_ERROR_
* _callback_write_default_pointer_ : pointeur donné à la fonction de rappel
  lorsqu'elle est appelé par WeeChat
* _callback_write_default_data_ : pointeur donné à la fonction de rappel
  lorsqu'elle est appelée par WeeChat; si non NULL, doit avoir été alloué par
  malloc (ou une fonction similaire) et est automatiquement libéré (par free)
  lorsque la section est libérée
* _callback_create_option_ : fonction appelée lorsqu'une nouvelle option est
  créée dans la section (NULL si la section n'autorise pas la création de
  nouvelles options), paramètres et valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _struct t_config_file *config_file_ : pointeur vers le fichier de
   configuration
** _struct t_config_section *section_ : pointeur vers la section
** _const char *option_name_ : nom de l'option
** _const char *value_ : valeur
* _callback_create_option_pointer_ : pointeur donné à la fonction de rappel
  lorsqu'elle est appelée par WeeChat
* _callback_create_option_data_ : pointeur donné à la fonction de rappel
  lorsqu'elle est appelée par WeeChat; si non NULL, doit avoir été alloué par
  malloc (ou une fonction similaire) et est automatiquement libéré (par free)
  lorsque la section est libérée
* _callback_delete_option_ : fonction appelée lorsqu'une option est supprimée
  de la section (NULL si la section n'autorise pas la suppression d'options),
  paramètres et valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _struct t_config_file *config_file_ : pointeur vers le fichier de
   configuration
** _struct t_config_section *section_ : pointeur vers la section
** _struct t_config_option *option_ : pointeur vers l'option
** valeur de retour :
*** _WEECHAT_CONFIG_OPTION_SET_OK_CHANGED_
*** _WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE_
*** _WEECHAT_CONFIG_OPTION_SET_ERROR_
*** _WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND_
* _callback_delete_option_pointer_ : pointeur donné à la fonction de rappel
  lorsqu'elle est appelée par WeeChat
* _callback_delete_option_data_ : pointeur donné à la fonction de rappel
  lorsqu'elle est appelée par WeeChat; si non NULL, doit avoir été alloué par
  malloc (ou une fonction similaire) et est automatiquement libéré (par free)
  lorsque la section est libérée

Valeur de retour :

* pointeur vers la nouvelle section du fichier de configuration, NULL en cas
  d'erreur

Exemple en C :

[source,c]
----
int
my_section_read_cb (const void *pointer, void *data,
                    struct t_config_file *config_file,
                    struct t_config_section *section,
                    const char *option_name,
                    const char *value)
{
    /* ... */

    return WEECHAT_CONFIG_OPTION_SET_OK_CHANGED;
    /* return WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE; */
    /* return WEECHAT_CONFIG_OPTION_SET_ERROR; */
    /* return WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND; */
}

int
my_section_write_cb (const void *pointer, void *data,
                     struct t_config_file *config_file,
                     const char *section_name)
{
    /* ... */

    return WEECHAT_CONFIG_WRITE_OK;
    /* return WEECHAT_CONFIG_WRITE_ERROR; */
    /* return WEECHAT_CONFIG_WRITE_MEMORY_ERROR; */
}

int
my_section_write_default_cb (const void *pointer, void *data,
                             struct t_config_file *config_file,
                             const char *section_name)
{
    /* ... */

    return WEECHAT_CONFIG_WRITE_OK;
    /* return WEECHAT_CONFIG_WRITE_ERROR; */
    /* return WEECHAT_CONFIG_WRITE_MEMORY_ERROR; */
}

int
my_section_create_option_cb (const void *pointer, void *data,
                             struct t_config_file *config_file,
                             struct t_config_section *section,
                             const char *option_name,
                             const char *value)
{
    /* ... */

    return WEECHAT_CONFIG_OPTION_SET_OK_CHANGED;
    /* return WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE; */
    /* return WEECHAT_CONFIG_OPTION_SET_ERROR; */
    /* return WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND; */
}

int
my_section_delete_option_cb (const void *pointer, void *data,
                             struct t_config_file *config_file,
                             struct t_config_section *section,
                             struct t_config_option *option)
{
    /* ... */

    return WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED;
    /* return WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET; */
    /* return WEECHAT_CONFIG_OPTION_UNSET_OK_RESET; */
    /* return WEECHAT_CONFIG_OPTION_UNSET_ERROR; */
}

/* section standard, l'utilisateur ne peut pas ajouter/supprimer des options */
struct t_config_section *new_section1 =
    weechat_config_new_section (config_file, "section1", 0, 0,
                                NULL, NULL, NULL,
                                NULL, NULL, NULL,
                                NULL, NULL, NULL,
                                NULL, NULL, NULL,
                                NULL, NULL, NULL);

/* section spéciale, l'utilisateur peut ajouter/supprimer des options, et les
   options nécessitent une fonction de rappel pour la lecture/écriture */
struct t_config_section *new_section2 =
    weechat_config_new_section (config_file, "section2", 1, 1,
                                &my_section_read_cb, NULL, NULL,
                                &my_section_write_cb, NULL, NULL,
                                &my_section_write_default_cb, NULL, NULL,
                                &my_section_create_option_cb, NULL, NULL,
                                &my_section_delete_option_cb, NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def config_new_section(config_file: str, name: str,
                       user_can_add_options: int, user_can_delete_options: int,
                       callback_read: str, callback_read_data: str,
                       callback_write: str, callback_write_data: str,
                       callback_write_default: str, callback_write_default_data: str,
                       callback_create_option: str, callback_create_option_data: str,
                       callback_delete_option: str, callback_delete_option_data: str) -> str: ...

# exemple
def my_section_read_cb(data: str, config_file: str, section: str, option_name: str, value: Union[str, None]) -> int:
    # ...
    return weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED
    # return weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE
    # return weechat.WEECHAT_CONFIG_OPTION_SET_ERROR
    # return weechat.WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND

def my_section_write_cb(data: str, config_file: str, section_name: str) -> int:
    # ...
    return weechat.WEECHAT_CONFIG_WRITE_OK
    # return weechat.WEECHAT_CONFIG_WRITE_ERROR
    # return weechat.WEECHAT_CONFIG_WRITE_MEMORY_ERROR

def my_section_write_default_cb(data: str, config_file: str, section_name: str) -> int:
    # ...
    return weechat.WEECHAT_CONFIG_WRITE_OK
    # return weechat.WEECHAT_CONFIG_WRITE_ERROR
    # return weechat.WEECHAT_CONFIG_WRITE_MEMORY_ERROR

def my_section_create_option_cb(data: str, config_file: str, section: str, option_name: str, value: Union[str, None]) -> int:
    # ...
    return weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED
    # return weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE
    # return weechat.WEECHAT_CONFIG_OPTION_SET_ERROR
    # return weechat.WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND

def my_section_delete_option_cb(data: str, config_file: str, section: str, option: str) -> int:
    # ...
    return weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED
    # return weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET
    # return weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_RESET
    # return weechat.WEECHAT_CONFIG_OPTION_UNSET_ERROR

section = weechat.config_new_section(config_file, "section1", 1, 1,
    "my_section_read_cb", "",
    "my_section_write_cb", "",
    "my_section_write_default_cb", "",
    "my_section_create_option_cb", "",
    "my_section_delete_option_cb", "")
----

==== config_search_section

Rechercher une section dans un fichier de configuration.

Prototype :

[source,c]
----
struct t_config_section *weechat_config_search_section (
    struct t_config_file *config_file,
    const char *section_name);
----

Paramètres :

* _config_file_ : pointeur vers le fichier de configuration
* _section_name_ : nom de la section à chercher

Valeur de retour :

* pointeur vers la section trouvée, ou NULL si la section n'a pas été trouvée

Exemple en C :

[source,c]
----
struct t_config_section *section = weechat_config_search_section (config_file,
                                                                  "section");
----

Script (Python) :

[source,python]
----
# prototype
def config_search_section(config_file: str, section_name: str) -> str: ...

# exemple
section = weechat.config_search_section(config_file, "section")
----

==== config_new_option

_Mis à jour dans la 1.5, 4.1.0._

Créer une nouvelle option dans une section d'un fichier de configuration.

Prototype :

[source,c]
----
struct t_config_option *weechat_config_new_option (
    struct t_config_file *config_file,
    struct t_config_section *section,
    const char *name,
    const char *type,
    const char *description,
    const char *string_values,
    int min,
    int max,
    const char *default_value,
    const char *value,
    int null_value_allowed,
    int (*callback_check_value)(const void *pointer,
                                void *data,
                                struct t_config_option *option,
                                const char *value),
    const void *callback_check_value_pointer,
    void *callback_check_value_data,
    void (*callback_change)(const void *pointer,
                            void *data,
                            struct t_config_option *option),
    const void *callback_change_pointer,
    void *callback_change_data,
    void (*callback_delete)(const void *pointer,
                            void *data,
                            struct t_config_option *option),
    const void *callback_delete_pointer,
    void *callback_delete_data);
----

Paramètres :

* _config_file_ : pointeur vers le fichier de configuration
* _section_ : pointeur vers la section
* _name_ : nom de l'option ; avec WeeChat ≥ 1.4, le nom peut inclure le nom
  d'une option parente (la valeur de l'option parente sera affichée dans la
  sortie de `/set` si cette option est "null"), la syntaxe est alors :
  "name << file.section.option"
* _type_ : type de l'option :
** _boolean_ : valeur booléenne (on/off)
** _integer_ : valeur entière
** _string_ : une chaîne de caractères
** _color_ : une couleur
** _enum_ : liste de valeurs sous forme de chaînes (stocké comme nombre entier
   en interne)
* _description_ : description de l'option
* _string_values_ : valeurs sous forme de chaîne (séparées par `+|+`) (optionnel,
  requis pour le type _enum_)
* _min_ : valeur minimum (pour le type _integer_)
* _max_ : valeur maximum (pour le type _integer_)
* _default_value_ : valeur par défaut de l'option (utilisée quand l'option est
  réinitialisée)
* _value_ : valeur de l'option
* _null_value_allowed_ : 1 si _null_ (valeur non définie) est autorisé pour
  l'option, sinon 0
* _callback_check_value_ : fonction appelée pour vérifier la nouvelle valeur
  de l'option (optionnel), paramètres et valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _struct t_config_option *option_ : pointeur vers l'option
** _const char *value_ : nouvelle valeur pour l'option
** valeur de retour :
*** 1 si la valeur est ok
*** 0 si la valeur est invalide
* _callback_check_value_pointer_ : pointeur donné à la fonction de rappel
  lorsqu'elle est appelée par WeeChat
* _callback_check_value_data_ : pointeur donné à la fonction de rappel
  lorsqu'elle est appelée par WeeChat; si non NULL, doit avoir été alloué par
  malloc (ou une fonction similaire) et est automatiquement libéré (par free)
  lorsque l'option est libérée
* _callback_change_ : fonction appelée lorsque la valeur de l'option a changé
  (optionnel), paramètres :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _struct t_config_option *option_ : pointeur vers l'option
* _callback_change_pointer_ : pointeur donné à la fonction de rappel
  lorsqu'elle est appelée par WeeChat
* _callback_change_data_ : pointeur donné à la fonction de rappel lorsqu'elle
  est appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou
  une fonction similaire) et est automatiquement libéré (par free) lorsque
  l'option est libérée
* _callback_delete_ : fonction appelée lorsque l'option est supprimée
  (optionnel), paramètres :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _struct t_config_option *option_ : pointeur vers l'option
* _callback_delete_pointer_ : pointeur donné à la fonction de rappel
  lorsqu'elle est appelée par WeeChat
* _callback_delete_data_ : pointeur donné à la fonction de rappel lorsqu'elle
  est appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou
  une fonction similaire) et est automatiquement libéré (par free) lorsque
  l'option est libérée

Valeur de retour :

* pointeur vers la nouvelle option de la section, NULL en cas d'erreur

Exemple en C :

[source,c]
----
/* booléen */
struct t_config_option *option1_bool =
    weechat_config_new_option (config_file, section, "option_bool", "boolean",
                               "Mon option, type booléen",
                               NULL,
                               0, 0,
                               "on",
                               "on",
                               0,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL);

/* entier */
struct t_config_option *option_int =
    weechat_config_new_option (config_file, section, "option_int", "integer",
                               "Mon option, type entier",
                               NULL,
                               0, 100,
                               "15",
                               "15",
                               0,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL);

/* chaîne */
struct t_config_option *option_str =
    weechat_config_new_option (config_file, section, "option_str", "string",
                               "Mon option, type chaîne",
                               NULL,
                               0, 0,
                               "test",
                               "test",
                               1,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL);

/* couleur */
struct t_config_option *option_col =
    weechat_config_new_option (config_file, section, "option_col", "color",
                               "Mon option, type couleur",
                               NULL,
                               0, 0,
                               "lightblue",
                               "lightblue",
                               0,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL);

/* énuméré */
struct t_config_option *option_enum =
    weechat_config_new_option (config_file, section, "option_enum", "enum",
                               "Mon option, type énuméré",
                               "top|bottom|left|right",
                               0, 0,
                               "bottom",
                               "bottom",
                               0,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def config_new_option(config_file: str, section: str, name: str, type: str, description: str,
                      string_values: str, min: int, max: int,
                      default_value: Union[str, None], value: Union[str, None], null_value_allowed: int,
                      callback_check_value: str, callback_check_value_data: str,
                      callback_change: str, callback_change_data: str,
                      callback_delete: str, callback_delete_data: str) -> str: ...

# exemple
def option_str_check_value_cb(data: str, option: str, value: str) -> int:
    # ...
    return 1
    # return 0

def option_str_change_cb(data: str, option: str) -> None:
    # ...

def option_str_delete_cb(data: str, option: str) -> None:
    # ...

option_bool = weechat.config_new_option(config_file, section, "option_bool", "boolean",
    "Mon option, type booléen",
    "", 0, 0, "on", "on", 0,
    "", "",
    "", "",
    "", "")

option_int = weechat.config_new_option(config_file, section, "option_int", "integer",
    "Mon option, type entier",
    "", 0, 100, "15", "15", 0,
    "", "",
    "", "",
    "", "")

option_str = weechat.config_new_option(config_file, section, "option_str", "string",
    "Mon option, type chaîne",
    "", 0, 0, "test", "test", 1,
    "option_str_check_value_cb", "",
    "option_str_change_cb", "",
    "option_str_delete_cb", "")

option_col = weechat.config_new_option(config_file, section, "option_col", "color",
    "Mon option, type couleur",
    "", 0, 0, "lightblue", "lightblue", 0,
    "", "",
    "", "",
    "", "")

option_enum = weechat.config_new_option(config_file, section, "option_enum", "enum",
    "Mon option, type énuméré",
    "top|bottom|left|right",
    0, 0, "bottom", "bottom", 0,
    "", "",
    "", "",
    "", "")
----

[NOTE]
En Ruby, les 3 fonctions de rappel + "data" (6 chaînes) doivent être données
dans un tableau de 6 chaînes de caractères (en raison d'une limitation de Ruby
à 15 paramètres par fonction), voir le
link:++weechat_scripting.fr.html#_ruby++[Guide pour scripts WeeChat ^↗^^]
pour plus d'infos _(corrigé dans la version 0.4.1)_.

==== config_search_option

Rechercher une option dans une section d'un fichier de configuration.

Prototype :

[source,c]
----
struct t_config_option *weechat_config_search_option (
    struct t_config_file *config_file,
    struct t_config_section *section,
    const char *option_name);
----

Paramètres :

* _config_file_ : pointeur vers le fichier de configuration
* _section_ : pointeur vers la section
* _name_ : nom de l'option à rechercher

Valeur de retour :

* pointeur vers l'option trouvée, NULL si l'option n'a pas été trouvée

Exemple en C :

[source,c]
----
struct t_config_option *option =
    weechat_config_search_option (config_file, section, "option");
----

Script (Python) :

[source,python]
----
# prototype
def config_search_option(config_file: str, section: str, option_name: str) -> str: ...

# exemple
option = weechat.config_search_option(config_file, section, "option")
----

==== config_search_section_option

Rechercher une section et une option dans un fichier de configuration ou une
section.

Prototype :

[source,c]
----
void weechat_config_search_section_option (struct t_config_file *config_file,
                                           struct t_config_section *section,
                                           const char *option_name,
                                           struct t_config_section **section_found,
                                           struct t_config_option **option_found);
----

Paramètres :

* _config_file_ : pointeur vers le fichier de configuration
* _section_ : pointeur vers la section
* _option_name_ : nom de l'option
* _section_ : pointeur vers un pointeur sur une section, sera alimenté avec le
  pointeur vers la section de l'option trouvée
* _option_ : pointeur vers un pointeur sur une option, sera alimenté avec le
  pointeur vers l'option trouvée

Exemple en C :

[source,c]
----
struct t_config_section *ptr_section;
struct t_config_option *ptr_option;

weechat_config_search_section_option (config_file,
                                      section,
                                      "option",
                                      &ptr_section,
                                      &ptr_option);
if (ptr_option)
{
    /* option trouvée */
}
else
{
    /* option non trouvée */
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== config_search_with_string

Retourner des infos sur fichier/section/option pour une option avec le nom
complet.

Prototype :

[source,c]
----
void weechat_config_search_with_string (const char *option_name,
                                        struct t_config_file **config_file,
                                        struct t_config_section **section,
                                        struct t_config_option **option,
                                        char **pos_option_name);
----

Paramètres :

* _option_name_ : nom complet de l'option (format : "fichier.section.option")
* _config_file_ : pointeur vers un pointeur sur un fichier de configuration,
  sera alimenté avec le pointeur vers le fichier de configuration de l'option
  trouvée
* _section_ : pointeur vers un pointeur sur une section, sera alimenté avec le
  pointeur vers la section de l'option trouvée
* _option_ : pointeur vers un pointeur sur une option, sera alimenté avec le
  pointeur vers l'option trouvée
* _pos_option_name_ : pointeur vers un pointeur sur une chaîne, sera alimenté
  avec le pointeur vers le nom de l'option trouvée

Exemple en C :

[source,c]
----
struct t_config_file *ptr_config_file;
struct t_config_section *ptr_section;
struct t_config_option *ptr_option;
char *option_name;

weechat_config_search_with_string ("fichier.section.option",
                                   &ptr_config_file,
                                   &ptr_section,
                                   &ptr_option,
                                   &option_name);
if (ptr_option)
{
    /* option trouvée */
}
else
{
    /* option non trouvée */
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== config_string_to_boolean

Vérifier si un texte est "vrai" ou "faux", au sens booléen.

Prototype :

[source,c]
----
int weechat_config_string_to_boolean (const char *text);
----

Paramètres :

* _text_ : texte à analyser

Valeur de retour :

* 1 si le texte est "vrai" ("on", "yes", "y", "true", "t", "1")
* 0 si le texte est "faux" ("off", "no", "n", "false", "f", "0")

Exemple en C :

[source,c]
----
if (weechat_config_string_to_boolean (option_value))
{
    /* la valeur est "vrai" */
}
else
{
    /* la valeur est "faux" */
}
----

Script (Python) :

[source,python]
----
# prototype
def config_string_to_boolean(text: str) -> int: ...

# exemple
if weechat.config_string_to_boolean(text):
    # ...
----

==== config_option_reset

Réinitialiser une option à sa valeur par défaut.

Prototype :

[source,c]
----
int weechat_config_option_reset (struct t_config_option *option,
                                 int run_callback);
----

Paramètres :

* _option_ : pointeur vers l'option
* _run_callback_ : 1 pour appeler la fonction de rappel si la valeur de
  l'option est changée, sinon 0

Valeur de retour :

* _WEECHAT_CONFIG_OPTION_SET_OK_CHANGED_ si la valeur de l'option a été
  réinitialisée
* _WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE_ si la valeur n'a pas changé
* _WEECHAT_CONFIG_OPTION_SET_ERROR_ en cas d'erreur

Exemple en C :

[source,c]
----
switch (weechat_config_option_reset (option, 1))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* .... */
        break;
}
----

Script (Python) :

[source,python]
----
# prototype
def config_option_reset(option: str, run_callback: int) -> int: ...

# exemple
rc = weechat.config_option_reset(option, 1)
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----

==== config_option_set

Affecter une nouvelle valeur pour une option.

Prototype :

[source,c]
----
int weechat_config_option_set (struct t_config_option *option,
                               const char *value, int run_callback);
----

Paramètres :

* _option_ : pointeur vers l'option
* _value_ : nouvelle valeur pour l'option, des valeurs spéciales sont possibles
  selon le type de l'option :
** _boolean_ :
*** `toggle` : basculer la valeur courante
** _integer_, _color_ ou _enum_ :
*** `++N` : ajouter `N` (un entier) à la valeur courante
*** `--N` : soustraire `N` (un entier) de la valeur courante
* _run_callback_ : 1 pour appeler la fonction de rappel si la valeur de
  l'option est changée, sinon 0

Valeur de retour :

* _WEECHAT_CONFIG_OPTION_SET_OK_CHANGED_ si la valeur de l'option a été changée
* _WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE_ si la valeur n'a pas changé
* _WEECHAT_CONFIG_OPTION_SET_ERROR_ en cas d'erreur

Exemple en C :

[source,c]
----
switch (weechat_config_option_set (option, "nouvelle_valeur", 1))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* .... */
        break;
}
----

Script (Python) :

[source,python]
----
# prototype
def config_option_set(option: str, value: str, run_callback: int) -> int: ...

# exemple
rc = weechat.config_option_set(option, "nouvelle_valeur", 1)
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----

==== config_option_set_null

Affecter "null" (valeur indéfinie) à une option.

Prototype :

[source,c]
----
int weechat_config_option_set_null (struct t_config_option *option,
                                    int run_callback);
----

Paramètres :

* _option_ : pointeur vers l'option
* _run_callback_ : 1 pour appeler la fonction de rappel si la valeur de
  l'option est changée (elle n'était pas "null"), sinon 0

[NOTE]
Vous pouvez affecter "null" à une option seulement si c'est autorisé pour
l'option (voir <<_config_new_option,config_new_option>>).

Valeur de retour :

* _WEECHAT_CONFIG_OPTION_SET_OK_CHANGED_ si la valeur de l'option a été changée
* _WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE_ si la valeur n'a pas changé
* _WEECHAT_CONFIG_OPTION_SET_ERROR_ en cas d'erreur

Exemple en C :

[source,c]
----
switch (weechat_config_option_set_null (option, 1))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* .... */
        break;
}
----

Script (Python) :

[source,python]
----
# prototype
def config_option_set_null(option: str, run_callback: int) -> int: ...

# exemple
rc = weechat.config_option_set_null(option, 1)
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----

==== config_option_unset

Réinitialiser ou supprimer une option.

Prototype :

[source,c]
----
int weechat_config_option_unset (struct t_config_option *option);
----

Paramètres :

* _option_ : pointeur vers l'option

Valeur de retour :

* _WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET_ si la valeur de l'option n'a pas
  été réinitialisée
* _WEECHAT_CONFIG_OPTION_UNSET_OK_RESET_ si la valeur de l'option a été
  réinitialisée
* _WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED_ si l'option a été supprimée
* _WEECHAT_CONFIG_OPTION_UNSET_ERROR_ en cas d'erreur

Exemple en C :

[source,c]
----
switch (weechat_config_option_unset (option))
{
    case WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_ERROR:
        /* .... */
        break;
}
----

Script (Python) :

[source,python]
----
# prototype
def config_option_unset(option: str) -> int: ...

# exemple
rc = weechat.config_option_unset(option)
if rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_ERROR:
    # ...
----

==== config_option_rename

Renommer une option.

Prototype :

[source,c]
----
void weechat_config_option_rename (struct t_config_option *option,
                                   const char *new_name);
----

Paramètres :

* _option_ : pointeur vers l'option
* _new_name_ : nouveau nom pour l'option

Exemple en C :

[source,c]
----
weechat_config_option_rename (option, "nouveau_nom");
----

Script (Python) :

[source,python]
----
# prototype
def config_option_rename(option: str, new_name: str) -> int: ...

# exemple
weechat.config_option_rename(option, "nouveau_nom")
----

==== config_option_get_string

_WeeChat ≥ 1.9._

Retourner la valeur d'une propriété de l'option sous forme de chaîne.

Prototype :

[source,c]
----
const char *weechat_config_option_get_string (struct t_config_option *option,
                                              const char *property);
----

Paramètres :

* _option_ : pointeur vers l'option
* _property_ : nom de la propriété :
** _config_name_ : nom du fichier
** _section_name_ : nom de la section
** _name_ : nom de l'option
** _parent_name_ : nom de l'option parente
** _type_ : type de l'option, un parmi ceux-ci :
*** _boolean_
*** _integer_
*** _string_
*** _color_
*** _enum_
** _description_ : description de l'option

Valeur de retour :

* valeur de la propriété, sous forme de chaîne

Exemple en C :

[source,c]
----
const char *type = weechat_config_option_get_string (option, "type");
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== config_option_get_pointer

Retourner un pointeur vers une propriété de l'option.

Prototype :

[source,c]
----
void *weechat_config_option_get_pointer (struct t_config_option *option,
                                         const char *property);
----

Paramètres :

* _option_ : pointeur vers l'option
* _property_ : nom de la propriété :
** _config_file_ : pointeur vers le fichier de configuration
   (_struct t_config_file *_)
** _section_ : pointeur vers la section (_struct t_config_section *_)
** _name_ : nom de l'option (_char *_)
** _parent_name_ : nom de l'option parente (_char *_) _(WeeChat ≥ 1.4)_
** _type_ : type de l'option (_int *_)
** _description_ : description de l'option (_char *_)
** _string_values_ : valeurs sous forme de chaîne (_char *_)
** _min_ : valeur minimum (_int *_)
** _max_ : valeur maximum (_int *_)
** _default_value_ : valeur par défaut (dépend du type)
** _value_ : valeur courante (dépend du type)
** _prev_option_ : pointeur vers l'option précédente
   (_struct t_config_option *_)
** _next_option_ : pointeur vers l'option suivante
   (_struct t_config_option *_)

Valeur de retour :

* pointeur vers la propriété demandée

Exemple en C :

[source,c]
----
char *description = weechat_config_option_get_pointer (option, "description");
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== config_option_is_null

Vérifier si une option est "null" (valeur non définie).

Prototype :

[source,c]
----
int weechat_config_option_is_null (struct t_config_option *option);
----

Paramètres :

* _option_ : pointeur vers l'option

Valeur de retour :

* 1 si la valeur de l'option est "null"
* 0 si la valeur de l'option n'est pas "null"

Exemple en C :

[source,c]
----
if (weechat_config_option_is_null (option))
{
    /* la valeur est "null" */
}
else
{
    /* la valeur n'est pas "null" */
}
----

Script (Python) :

[source,python]
----
# prototype
def config_option_is_null(option: str) -> int: ...

# exemple
if weechat.config_option_is_null(option):
    # ...
----

==== config_option_default_is_null

Vérifier si la valeur par défaut d'une option est "null" (valeur non définie).

Prototype :

[source,c]
----
int weechat_config_option_default_is_null (struct t_config_option *option);
----

Paramètres :

* _option_ : pointeur vers l'option

Valeur de retour :

* 1 si la valeur par défaut de l'option est "null"
* 0 si la valeur par défaut de l'option n'est pas "null"

Exemple en C :

[source,c]
----
if (weechat_config_option_default_is_null (option))
{
    /* la valeur par défaut est "null" */
}
else
{
    /* la valeur par défaut n'est pas "null" */
}
----

Script (Python) :

[source,python]
----
# prototype
def config_option_default_is_null(option: str) -> int: ...

# exemple
if weechat.config_option_default_is_null(option):
    # ...
----

==== config_boolean

Retourner la valeur booléenne de l'option.

Prototype :

[source,c]
----
int weechat_config_boolean (struct t_config_option *option);
----

Paramètres :

* _option_ : pointeur vers l'option

Valeur de retour, selon le type de l'option :

* _boolean_ : valeur booléenne de l'option (0 ou 1)
* _integer_ : 0
* _string_ : 0
* _color_ : 0
* _enum_ : 0

Exemple en C :

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
if (weechat_config_boolean (option))
{
    /* la valeur est "vrai" */
}
else
{
    /* la valeur est "faux" */
}
----

Script (Python) :

[source,python]
----
# prototype
def config_boolean(option: str) -> int: ...

# exemple
option = weechat.config_get("plugin.section.option")
if weechat.config_boolean(option):
    # ...
----

==== config_boolean_default

Retourner la valeur booléenne par défaut de l'option.

Prototype :

[source,c]
----
int weechat_config_boolean_default (struct t_config_option *option);
----

Paramètres :

* _option_ : pointeur vers l'option

Valeur de retour, selon le type de l'option :

* _boolean_ : valeur booléenne par défaut de l'option (0 ou 1)
* _integer_ : 0
* _string_ : 0
* _color_ : 0
* _enum_ : 0

Exemple en C :

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
if (weechat_config_boolean_default (option))
{
    /* la valeur est "vrai" */
}
else
{
    /* la valeur est "faux" */
}
----

Script (Python) :

[source,python]
----
# prototype
def config_boolean_default(option: str) -> int: ...

# exemple
option = weechat.config_get("plugin.section.option")
if weechat.config_boolean_default(option):
    # ...
----

==== config_boolean_inherited

_WeeChat ≥ 4.3.0._

Retourner la valeur booléenne héritée de l'option : la valeur si l'option n'est
pas NULL, ou la valeur de l'option parente (si l'option hérite d'une autre option). +
Si l'option parente n'est pas trouvée, retourner la valeur par défaut de l'option. +
Si la valeur parente est NULL, retourner la valeur par défaut de l'option parente.

Prototype :

[source,c]
----
int weechat_config_boolean_inherited (struct t_config_option *option);
----

Paramètres :

* _option_ : pointeur vers l'option

Valeur de retour : voir les fonctions <<_config_boolean,config_boolean>> et
<<_config_boolean_default,config_boolean_default>>.

Exemple en C :

[source,c]
----
struct t_config_option *option = weechat_config_get ("irc.server.libera.autoconnect");
int autoconnect = weechat_config_boolean_inherited (option);
----

Script (Python):

[source,python]
----
# prototype
def config_boolean_inherited(option: str) -> int: ...

# exemple
option = weechat.config_get("irc.server.libera.autoconnect")
autoconect = weechat.config_boolean_inherited(option)
----

==== config_integer

Retourner la valeur entière de l'option.

Prototype :

[source,c]
----
int weechat_config_integer (struct t_config_option *option);
----

Paramètres :

* _option_ : pointeur vers l'option

Valeur de retour, selon le type de l'option :

* _boolean_ : valeur booléenne de l'option (0 ou 1)
* _integer_ : valeur entière de l'option
* _string_ : 0
* _color_ : index de la couleur
* _enum_ : valeur entière de l'option (index de la valeur de l'énuméré)

Exemple en C :

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
int value = weechat_config_integer (option);
----

Script (Python) :

[source,python]
----
# prototype
def config_integer(option: str) -> int: ...

# exemple
option = weechat.config_get("plugin.section.option")
value = weechat.config_integer(option)
----

==== config_integer_default

Retourner la valeur entière par défaut de l'option.

Prototype :

[source,c]
----
int weechat_config_integer_default (struct t_config_option *option);
----

Paramètres :

* _option_ : pointeur vers l'option

Valeur de retour, selon le type de l'option :

* _boolean_ : valeur booléenne par défaut de l'option (0 ou 1)
* _integer_ : valeur entière par défaut de l'option
* _string_ : 0
* _color_ : index de la couleur par défaut
* _enum_ : valeur entière par défaut de l'option (index de la valeur de l'énuméré)

Exemple en C :

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
int value = weechat_config_integer_default (option);
----

Script (Python) :

[source,python]
----
# prototype
def config_integer_default(option: str) -> int: ...

# exemple
option = weechat.config_get("plugin.section.option")
value = weechat.config_integer_default(option)
----

==== config_integer_inherited

_WeeChat ≥ 4.3.0._

Return inherited integer value of option: value of option if not NULL,
or value of the parent option (if option inherits from another option). +
If the parent option is not found, return the default value of the option. +
If the parent value is NULL, return the default value of the parent option.

Prototype :

[source,c]
----
int weechat_config_integer_inherited (struct t_config_option *option);
----

Paramètres :

* _option_ : pointeur vers l'option

Valeur de retour : voir les fonctions <<_config_integer,config_integer>> et
<<_config_integer_default,config_integer_default>>.

Exemple en C :

[source,c]
----
struct t_config_option *option = weechat_config_get ("irc.server.libera.autojoin_delay");
int delay = weechat_config_integer_inherited (option);
----

Script (Python):

[source,python]
----
# prototype
def config_integer_inherited(option: str) -> int: ...

# exemple
option = weechat.config_get("irc.server.libera.autojoin_delay")
delay = weechat.config_integer_inherited(option)
----

==== config_string

Retourner la valeur de l'option, sous forme de chaîne.

Prototype :

[source,c]
----
const char *weechat_config_string (struct t_config_option *option);
----

Paramètres :

* _option_ : pointeur vers l'option

Valeur de retour, selon le type de l'option :

* _boolean_ : "on" si la valeur est vraie, sinon "off"
* _integer_ : NULL
* _string_ : valeur de l'option sous forme de chaîne
* _color_ : nom de la couleur
* _enum_ : valeur de l'option sous forme de chaîne

Exemple en C :

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
const char *value = weechat_config_string (option);
----

Script (Python) :

[source,python]
----
# prototype
def config_string(option: str) -> str: ...

# exemple
option = weechat.config_get("plugin.section.option")
value = weechat.config_string(option)
----

==== config_string_default

Retourner la valeur par défaut de l'option, sous forme de chaîne.

Prototype :

[source,c]
----
const char *weechat_config_string_default (struct t_config_option *option);
----

Paramètres :

* _option_ : pointeur vers l'option

Valeur de retour, selon le type de l'option :

* _boolean_ : "on" si la valeur par défaut est vraie, sinon "off"
* _integer_ : NULL
* _string_ : valeur par défaut de l'option sous forme de chaîne
* _color_ : nom de la couleur par défaut
* _enum_ : valeur par défaut de l'option sous forme de chaîne

Exemple en C :

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
const char *value = weechat_config_string_default (option);
----

Script (Python) :

[source,python]
----
# prototype
def config_string_default(option: str) -> str: ...

# exemple
option = weechat.config_get("plugin.section.option")
value = weechat.config_string_default(option)
----

==== config_string_inherited

_WeeChat ≥ 4.3.0._

Return inherited string value of option: value of option if not NULL,
or value of the parent option (if option inherits from another option). +
If the parent option is not found, return the default value of the option. +
If the parent value is NULL, return the default value of the parent option.

Prototype :

[source,c]
----
const char *weechat_config_string_inherited (struct t_config_option *option);
----

Paramètres :

* _option_ : pointeur vers l'option

Valeur de retour : voir les fonctions <<_config_string,config_string>> et
<<_config_string_default,config_string_default>>.

Exemple en C :

[source,c]
----
struct t_config_option *option = weechat_config_get ("irc.server.libera.msg_quit");
const char *msg_quit = weechat_config_string_inherited (option);
----

Script (Python):

[source,python]
----
# prototype
def config_string_inherited(option: str) -> str: ...

# exemple
option = weechat.config_get("irc.server.libera.msg_quit")
msg_quit = weechat.config_string_inherited(option)
----

==== config_color

Retourner la valeur de l'option, sous forme de couleur.

Prototype :

[source,c]
----
const char *weechat_config_color (struct t_config_option *option);
----

Paramètres :

* _option_ : pointeur vers l'option

Valeur de retour, selon le type de l'option :

* _boolean_ : NULL
* _integer_ : NULL
* _string_ : NULL
* _color_ : nom de la couleur
* _enum_ : NULL

Exemple en C :

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
const char *color = weechat_config_color (option);
----

Script (Python) :

[source,python]
----
# prototype
def config_color(option: str) -> str: ...

# exemple
option = weechat.config_get("plugin.section.option")
color = weechat.config_color(option)
----

==== config_color_default

Retourner la valeur par défaut de l'option, sous forme de couleur.

Prototype :

[source,c]
----
const char *weechat_config_color_default (struct t_config_option *option);
----

Paramètres :

* _option_ : pointeur vers l'option

Valeur de retour, selon le type de l'option :

* _boolean_ : NULL
* _integer_ : NULL
* _string_ : NULL
* _color_ : nom de la couleur par défaut
* _enum_ : NULL

Exemple en C :

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
const char *color = weechat_config_color_default (option);
----

Script (Python) :

[source,python]
----
# prototype
def config_color_default(option: str) -> str: ...

# exemple
option = weechat.config_get("plugin.section.option")
color = weechat.config_color_default(option)
----

==== config_color_inherited

_WeeChat ≥ 4.3.0._

Return inherited color value of option: value of option if not NULL,
or value of the parent option (if option inherits from another option). +
If the parent option is not found, return the default value of the option. +
If the parent value is NULL, return the default value of the parent option.

Prototype :

[source,c]
----
const char *weechat_config_color_inherited (struct t_config_option *option);
----

Paramètres :

* _option_ : pointeur vers l'option

Valeur de retour : voir les fonctions <<_config_color,config_color>> et
<<_config_color_default,config_color_default>>.

Exemple en C :

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
const char *color = weechat_config_color_inherited (option);
----

Script (Python):

[source,python]
----
# prototype
def config_color_inherited(option: str) -> str: ...

# exemple
option = weechat.config_get("plugin.section.option")
color = weechat.config_color_inherited(option)
----

==== config_enum

_WeeChat ≥ 4.1.0._

Retourner la valeur de l'option, sous forme d'entier.

Prototype :

[source,c]
----
int weechat_config_enum (struct t_config_option *option);
----

Paramètres :

* _option_ : pointeur vers l'option

Valeur de retour, selon le type de l'option :

* _boolean_ : valeur booléenne de l'option (0 ou 1)
* _integer_ : valeur entière de l'option
* _string_ : 0
* _color_ : index de la couleur
* _enum_ : valeur entière de l'option (index de la valeur de l'énuméré)

Exemple en C :

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
int value = weechat_config_enum (option);
----

Script (Python) :

[source,python]
----
# prototype
def config_enum(option: str) -> int: ...

# exemple
option = weechat.config_get("plugin.section.option")
value = weechat.config_enum(option)
----

==== config_enum_default

_WeeChat ≥ 4.1.0._

Retourner la valeur par défaut de l'option, sous forme d'entier.

Prototype :

[source,c]
----
int weechat_config_enum_default (struct t_config_option *option);
----

Paramètres :

* _option_ : pointeur vers l'option

Valeur de retour, selon le type de l'option :

* _boolean_ : valeur booléenne par défaut de l'option (0 ou 1)
* _integer_ : valeur entière par défaut de l'option
* _string_ : 0
* _color_ : index de la couleur par défaut
* _enum_ : valeur entière par défaut de l'option (index de la valeur de l'énuméré)

Exemple en C :

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
int value = weechat_config_enum_default (option);
----

Script (Python) :

[source,python]
----
# prototype
def config_enum_default(option: str) -> int: ...

# exemple
option = weechat.config_get("plugin.section.option")
value = weechat.config_enum_default(option)
----

==== config_enum_inherited

_WeeChat ≥ 4.3.0._

Return inherited enum value of option: value of option if not NULL,
or value of the parent option (if option inherits from another option). +
If the parent option is not found, return the default value of the option. +
If the parent value is NULL, return the default value of the parent option.

Prototype :

[source,c]
----
int weechat_config_enum_inherited (struct t_config_option *option);
----

Paramètres :

* _option_ : pointeur vers l'option

Valeur de retour : voir les fonctions <<_config_enum,config_enum>> et
<<_config_enum_default,config_enum_default>>.

Exemple en C :

[source,c]
----
struct t_config_option *option = weechat_config_get ("irc.server.libera.sasl_fail");
int sasl_fail = weechat_config_enum_inherited (option);
----

Script (Python):

[source,python]
----
# prototype
def config_enum_inherited(option: str) -> int: ...

# exemple
option = weechat.config_get("irc.server.libera.sasl_fail")
sasl_fail = weechat.config_enum_inherited(option)
----

==== config_write_option

Écrire une ligne dans le fichier de configuration avec l'option et sa valeur
(cette fonction doit être appelée uniquement dans une fonction de rappel
"write" ou "write_default" pour une section).

Prototype :

[source,c]
----
void weechat_config_write_option (struct t_config_file *config_file,
                                  struct t_config_option *option);
----

Paramètres :

* _config_file_ : pointeur vers le fichier de configuration
* _option_ : pointeur vers l'option

Exemple en C :

[source,c]
----
int
my_section_write_cb (const void *pointer, void *data,
                     struct t_config_file *config_file,
                     const char *section_name)
{
    weechat_config_write_line (config_file, "ma_section", NULL);

    weechat_config_write_option (config_file, option);

    return WEECHAT_RC_OK;
}
----

Script (Python) :

[source,python]
----
# prototype
def config_write_option(config_file: str, option: str) -> int: ...

# exemple
def my_section_write_cb(data: str, config_file: str, section_name: str) -> int:
    weechat.config_write_line(config_file, "ma_section", "")
    weechat.config_write_option(config_file, option)
    return weechat.WEECHAT_RC_OK
----

==== config_write_line

Écrire une ligne dans un fichier de configuration (cette fonction doit être
appelée uniquement dans une fonction de rappel "write" ou "write_default" pour
une section).

Prototype :

[source,c]
----
void weechat_config_write_line (struct t_config_file *config_file,
                                const char *option_name,
                                const char *value, ...);
----

Paramètres :

* _config_file_ : pointeur vers le fichier de configuration
* _option_name_ : nom de l'option
* _value_ : valeur (si NULL, alors la ligne est écrite avec le nom de la
  section, par exemple : "[section]")

Exemple en C :

[source,c]
----
int
my_section_write_cb (const void *pointer, void *data,
                     struct t_config_file *config_file,
                     const char *section_name)
{
    weechat_config_write_line (config_file, "ma_section", NULL);

    weechat_config_write_line (config_file, "option", "%s;%d",
                               "valeur", 123);

    return WEECHAT_RC_OK;
}
----

Script (Python) :

[source,python]
----
# prototype
def config_write_line(config_file: str, option_name: str, value: str) -> int: ...

# exemple
def my_section_write_cb(data: str, config_file: str, section_name: str) -> int:
    weechat.config_write_line(config_file, "ma_section", "")
    weechat.config_write_line(config_file, "option", "valeur")
    return weechat.WEECHAT_RC_OK
----

==== config_write

Écrire un fichier de configuration sur le disque.

Prototype :

[source,c]
----
int weechat_config_write (struct t_config_file *config_file);
----

Paramètres :

* _config_file_ : pointeur vers le fichier de configuration.

Valeur de retour :

* _WEECHAT_CONFIG_WRITE_OK_ si la configuration a été écrite
* _WEECHAT_CONFIG_WRITE_MEMORY_ERROR_ s'il n'y a pas eu suffisamment de mémoire
* _WEECHAT_CONFIG_WRITE_ERROR_ si une autre erreur s'est produite

Exemple en C :

[source,c]
----
switch (weechat_config_write (config_file))
{
    case WEECHAT_CONFIG_WRITE_OK:
        /* ... */
        break;
    case WEECHAT_CONFIG_WRITE_MEMORY_ERROR:
        /* ... */
        break;
    case WEECHAT_CONFIG_WRITE_ERROR:
        /* ... */
        break;
}
----

Script (Python) :

[source,python]
----
# prototype
def config_write(config_file: str) -> int: ...

# exemple
rc = weechat.config_write(config_file)
if rc == weechat.WEECHAT_CONFIG_WRITE_OK:
    # ...
elif rc == weechat.WEECHAT_CONFIG_WRITE_MEMORY_ERROR:
    # ...
elif rc == weechat.WEECHAT_CONFIG_WRITE_ERROR:
    # ...
----

==== config_read

Lire un fichier de configuration depuis le disque.

Prototype :

[source,c]
----
int weechat_config_read (struct t_config_file *config_file);
----

Paramètres :

* _config_file_ : pointeur vers le fichier de configuration

Valeur de retour :

* _WEECHAT_CONFIG_READ_OK_ si la configuration a été chargée
* _WEECHAT_CONFIG_READ_MEMORY_ERROR_ s'il n'y a pas eu suffisamment de mémoire
* _WEECHAT_CONFIG_READ_FILE_NOT_FOUND_ si le fichier n'a pas été trouvé

Exemple en C :

[source,c]
----
switch (weechat_config_read (config_file))
{
    case WEECHAT_CONFIG_READ_OK:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_MEMORY_ERROR:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
        /* ... */
        break;
}
----

Script (Python) :

[source,python]
----
# prototype
def config_read(config_file: str) -> int: ...

# exemple
rc = weechat.config_read(config_file)
if rc == weechat.WEECHAT_CONFIG_READ_OK:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_MEMORY_ERROR:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
    # ...
----

==== config_reload

Relire un fichier de configuration depuis le disque.

Prototype :

[source,c]
----
int weechat_config_reload (struct t_config_file *config_file);
----

Paramètres :

* _config_file_ : pointeur vers le fichier de configuration

Valeur de retour :

* _WEECHAT_CONFIG_READ_OK_ si la configuration a été rechargée
* _WEECHAT_CONFIG_READ_MEMORY_ERROR_ s'il n'y a pas eu suffisamment de mémoire
* _WEECHAT_CONFIG_READ_FILE_NOT_FOUND_ si le fichier n'a pas été trouvé

Exemple en C :

[source,c]
----
switch (weechat_config_reload (config_file))
{
    case WEECHAT_CONFIG_READ_OK:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_MEMORY_ERROR:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
        /* ... */
        break;
}
----

Script (Python) :

[source,python]
----
# prototype
def config_reload(config_file: str) -> int: ...

# exemple
rc = weechat.config_reload(config_file)
if rc == weechat.WEECHAT_CONFIG_READ_OK:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_MEMORY_ERROR:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
    # ...
----

==== config_option_free

Supprimer une option.

Prototype :

[source,c]
----
void weechat_config_option_free (struct t_config_option *option);
----

Paramètres :

* _option_ : pointeur vers l'option

Exemple en C :

[source,c]
----
weechat_config_option_free (option);
----

Script (Python) :

[source,python]
----
# prototype
def config_option_free(option: str) -> int: ...

# exemple
weechat.config_option_free(option)
----

==== config_section_free_options

Supprimer toutes les options dans une section.

Prototype :

[source,c]
----
void weechat_config_section_free_options (struct t_config_section *section);
----

Paramètres :

* _section_ : pointeur vers la section

Exemple en C :

[source,c]
----
weechat_config_section_free_options (section);
----

Script (Python) :

[source,python]
----
# prototype
def config_section_free_options(section: str) -> int: ...

# exemple
weechat.config_section_free_options(section)
----

==== config_section_free

Supprimer une section.

Prototype :

[source,c]
----
void weechat_config_section_free (struct t_config_section *section);
----

Paramètres :

* _section_ : pointeur vers la section

Exemple en C :

[source,c]
----
weechat_config_section_free (section);
----

Script (Python) :

[source,python]
----
# prototype
def config_section_free(section: str) -> int: ...

# exemple
weechat.config_section_free(section)
----

==== config_free

Supprimer un fichier de configuration.

Prototype :

[source,c]
----
void weechat_config_free (struct t_config_file *config_file);
----

Paramètres :

* _config_file_ : pointeur vers le fichier de configuration

Exemple en C :

[source,c]
----
weechat_config_free (config_file);
----

Script (Python) :

[source,python]
----
# prototype
def config_free(config_file: str) -> int: ...

# exemple
weechat.config_free(config_file)
----

==== config_get

Rechercher une option avec le nom complet.

Prototype :

[source,c]
----
struct t_config_option *weechat_config_get (const char *option_name);
----

Paramètres :

* _option_name_ : nom complet de l'option (format : "fichier.section.option")

Valeur de retour :

* pointeur vers l'option trouvée, NULL si l'option n'a pas été trouvée

Exemple en C :

[source,c]
----
struct t_config_option *option = weechat_config_get ("weechat.look.item_time_format");
----

Script (Python) :

[source,python]
----
# prototype
def config_get(option_name: str) -> str: ...

# exemple
option = weechat.config_get("weechat.look.item_time_format")
----

==== config_get_plugin

Rechercher une option dans le fichier de configuration des extensions
(plugins.conf).

Prototype :

[source,c]
----
const char *weechat_config_get_plugin (const char *option_name);
----

Paramètres :

* _option_name_ : nom de l'option, WeeChat ajoutera le préfixe
  "plugins.var.xxx." (où "xxx" est le nom de l'extension courante)

Valeur de retour :

* valeur de l'option trouvée, NULL si l'option n'a pas été trouvée

Exemple en C :

[source,c]
----
/* si l'extension courante est "test", alors on cherche la valeur de l'option
   "plugins.var.test.option" dans le fichier plugins.conf */
char *value = weechat_config_get_plugin ("option");
----

Script (Python) :

[source,python]
----
# prototype
def config_get_plugin(option_name: str) -> str: ...

# exemple
value = weechat.config_get_plugin("option")
----

==== config_is_set_plugin

Vérifier si une option existe dans le fichier de configuration des extensions
(plugins.conf).

Prototype :

[source,c]
----
int weechat_config_is_set_plugin (const char *option_name);
----

Paramètres :

* _option_name_ : nom de l'option, WeeChat ajoutera le préfixe
  "plugins.var.xxx." (où "xxx" est le nom de l'extension courante)

Valeur de retour :

* 1 si l'option est définie, 0 si l'option n'existe pas

Exemple en C :

[source,c]
----
if (weechat_config_is_set_plugin ("option"))
{
    /* l'option existe */
}
else
{
    /* l'option n'existe pas */
}
----

Script (Python) :

[source,python]
----
# prototype
def config_is_set_plugin(option_name: str) -> int: ...

# exemple
if weechat.config_is_set_plugin("option"):
    # l'option existe
    # ...
else:
    # l'option n'existe pas
    # ...
----

==== config_set_plugin

Affecter une nouvelle valeur pour une option dans le fichier de configuration
des extensions (plugins.conf).

Prototype :

[source,c]
----
int weechat_config_set_plugin (const char *option_name, const char *value);
----

Paramètres :

* _option_name_ : nom de l'option, WeeChat ajoutera le préfixe
  "plugins.var.xxx." (où "xxx" est le nom de l'extension courante)
* _value_ : nouvelle valeur pour l'option

Valeur de retour :

* _WEECHAT_CONFIG_OPTION_SET_OK_CHANGED_ si la valeur de l'option a été changée
* _WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE_ si la valeur n'a pas changé
* _WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND_ si l'option n'a pas été trouvée
* _WEECHAT_CONFIG_OPTION_SET_ERROR_ en cas d'erreur

Exemple en C :

[source,c]
----
switch (weechat_config_set_plugin ("option", "valeur_test"))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* ... */
        break;
}
----

Script (Python) :

[source,python]
----
# prototype
def config_set_plugin(option_name: str, value: str) -> int: ...

# exemple
rc = weechat.config_set_plugin("option", "valeur_test")
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----

==== config_set_desc_plugin

_WeeChat ≥ 0.3.5._

Affecter une description pour une option dans le fichier de configuration des
extensions (plugins.conf).

Prototype :

[source,c]
----
void weechat_config_set_desc_plugin (const char *option_name,
                                     const char *description);
----

Paramètres :

* _option_name_ : nom de l'option, WeeChat ajoutera le préfixe
  "plugins.desc.xxx." (où "xxx" est le nom de l'extension courante)
* _description_ : description pour l'option

[NOTE]
Ce n'est pas un problème si l'option (plugins.var.xxx.option_name) n'existe pas.
Une création future de cette option utilisera cette description.

Exemple en C :

[source,c]
----
weechat_config_set_desc_plugin ("option", "description de l'option");
----

Script (Python) :

[source,python]
----
# prototype
def config_set_desc_plugin(option_name: str, description: str) -> int: ...

# exemple
version = weechat.info_get("version_number", "") or 0
if int(version) >= 0x00030500:
    weechat.config_set_desc_plugin("option", "description de l'option")
----

==== config_unset_plugin

Supprimer une option du fichier de configuration des extensions (plugins.conf).

Prototype :

[source,c]
----
int weechat_config_unset_plugin (const char *option_name);
----

Paramètres :

* _option_name_ : nom de l'option, WeeChat ajoutera le préfixe
  "plugins.var.xxx." (où "xxx" est le nom de l'extension courante)

Valeur de retour :

* _WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET_ si la valeur de l'option n'a pas
  été réinitialisée
* _WEECHAT_CONFIG_OPTION_UNSET_OK_RESET_ si la valeur de l'option a été
  réinitialisée
* _WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED_ si l'option a été supprimée
* _WEECHAT_CONFIG_OPTION_UNSET_ERROR_ en cas d'erreur

Exemple en C :

[source,c]
----
switch (weechat_config_unset_plugin ("option"))
{
    case WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_ERROR:
        /* ... */
        break;
}
----

Script (Python) :

[source,python]
----
# prototype
def config_unset_plugin(option_name: str) -> int: ...

# exemple
rc = weechat.config_unset_plugin("option")
if rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_ERROR:
    # ...
----

[[key_bindings]]
=== Associations de touches

Fonctions pour les associations de touches.

==== key_bind

_WeeChat ≥ 0.3.6, mis à jour dans la 1.8._

Ajouter de nouvelles associations de touches.

[NOTE]
Contrairement à la commande `/key bind`, cette fonction ne changera jamais
une association de touche existante, seulement des nouvelles touches seront
créées. Pour supprimer une association de touche, utilisez <<_key_unbind,key_unbind>>.

Prototype :

[source,c]
----
int weechat_key_bind (const char *context, struct t_hashtable *keys);
----

:key_bind_quiet: __quiet

Paramètres :

* _context_ : contexte pour les touches :
** _default_ : contexte par défaut (actions courantes)
** _search_ : contexte de recherche (lors de la recherche de texte dans le
   tampon)
** _cursor_ : mouvement libre du curseur à l'écran
** _mouse_ : touches pour les évènements de souris
* _keys_ : table de hachage avec les associations de touches ; elle peut contenir
  les clés spéciales suivantes :
** _{key_bind_quiet}_: ne pas afficher les touches ajoutées dans le tampon _core_
   _(WeeChat ≥ 1.8)_

Valeur de retour :

* nombre d'associations de touches ajoutées

Exemple en C :

[source,c]
----
struct t_hashtable *keys = weechat_hashtable_new (8,
                                                  WEECHAT_HASHTABLE_STRING,
                                                  WEECHAT_HASHTABLE_STRING,
                                                  NULL,
                                                  NULL);
if (keys)
{
    weechat_hashtable_set (keys, "@chat(plugin.buffer):button1", "hsignal:test_mouse");
    weechat_hashtable_set (keys, "@chat(plugin.buffer):wheelup", "/mycommand up");
    weechat_hashtable_set (keys, "@chat(plugin.buffer):wheeldown", "/mycommand down");
    weechat_key_bind ("mouse", keys);
    weechat_hashtable_free (keys);
}
----

Script (Python) :

[source,python]
----
# prototype
def key_bind(context: str, keys: Dict[str, str]) -> int: ...

# exemple
keys = {"@chat(python.test):button1": "hsignal:test_mouse",
        "@chat(python.test):wheelup": "/mycommand up",
        "@chat(python.test):wheeldown": "/mycommand down"}
weechat.key_bind("mouse", keys)
----

==== key_unbind

_WeeChat ≥ 0.3.6, mis à jour dans la 2.0._

Supprimer une/des association(s) de touche(s).

[WARNING]
Lors de l'appel à cette fonction, assurez-vous que vous n'allez pas supprimer
une touche définie par l'utilisateur.

Prototype :

[source,c]
----
int weechat_key_unbind (const char *context, const char *key);
----

Paramètres :

* _context_ : contexte pour les touches (voir <<_key_bind,key_bind>>)
* _key_ : touche à supprimer ou la valeur spéciale "area:XXX" pour supprimer
  toutes les touches ayant _XXX_ comme première ou deuxième zone; si la touche
  commence par "quiet:", les touches supprimées ne sont pas affichées dans le
  tampon _core_ _(WeeChat ≥ 2.0)_.

Valeur de retour :

* nombre d'associations de touches supprimées

Exemples en C :

[source,c]
----
/* supprimer une seule touche */
weechat_key_unbind ("mouse", "@chat(plugin.buffer):button1");

/* supprimer toutes les touches avec la zone "chat(plugin.buffer)" */
weechat_key_unbind ("mouse", "area:chat(plugin.buffer)");
----

Script (Python) :

[source,python]
----
# prototype
def key_unbind(context: str, key: str) -> int: ...

# exemples

# supprimer une seule touche
weechat.key_unbind("mouse", "@chat(plugin.buffer):button1")

# supprimer toutes les touches avec la zone "chat(python.test)"
weechat.key_unbind("mouse", "area:chat(python.test)")
----

[[display]]
=== Affichage

Fonctions pour afficher du texte dans les tampons.

==== prefix

Retourner un préfixe.

Prototype :

[source,c]
----
const char *weechat_prefix (const char *prefix);
----

Paramètres :

* _prefix_ : nom du préfixe (voir le tableau ci-dessous)

Valeur de retour :

* valeur du préfixe (chaîne avec le préfixe et des codes couleur), chaîne vide
  si le préfixe n'a pas été trouvé

Liste des préfixes :

[width="100%",cols="^2m,^1,^3,5",options="header"]
|===
| Préfixe | Valeur   | Couleur                   | Description
| error   | `+=!=+`  | jaune ("yellow")          | Message d'erreur.
| network | `+--+`   | violet ("magenta")        | Message du réseau.
| action  | `+*+`    | blanc ("white")           | Action personnelle.
| join    | `+-->+`  | vert clair ("lightgreen") | Quelqu'un a rejoint la discussion.
| quit    | `+<--+`  | rouge clair ("lightred")  | Quelqu'un a quitté la discussion.
|===

[NOTE]
Les valeurs et couleurs peuvent être configurées avec la commande `/set`.

Exemple en C :

[source,c]
----
weechat_printf (NULL, "%sCeci est une erreur...", weechat_prefix ("error"));
----

Script (Python) :

[source,python]
----
# prototype
def prefix(prefix: str) -> str: ...

# exemple
weechat.prnt("", "%sCeci est une erreur..." % weechat.prefix("error"))
----

==== color

Retourner une chaîne avec un code couleur pour affichage.

Prototype :

[source,c]
----
const char *weechat_color (const char *color_name);
----

Paramètres :

* _color_name_ : nom de la couleur, parmi :
** le nom d'une option de couleur WeeChat (de weechat.color.xxx), par exemple
  _chat_delimiters_
** le nom d'une option (format : fichier.section.option), par exemple
   _irc.color.message_quit_ _(WeeChat ≥ 1.2)_
** une couleur avec des attributs/fond optionnels (voir ci-dessous)
** un attribut :
*** _blink_ : activer le clignotement
*** _-blink_ : désactiver le clignotement
*** _dim_ : activer le "dim" (demi-intensité)
*** _-dim_ : désactiver le "dim" (demi-intensité)
*** _bold_ : activer le gras
*** _-bold_ : désactiver le gras
*** _reverse_ : activer la vidéo inverse
*** _-reverse_ : désactiver la vidéo inverse
*** _italic_ : activer l'italique
*** _-italic_ : désactiver l'italique
*** _underline_ : activer le souligné
*** _-underline_ : désactiver le souligné
*** _emphasis_ : activer/désactiver la mise en valeur du texte (note : cela ne
    devrait être utilisé que dans les barres, car WeeChat utilise la mise en
    valeur du texte lors de la recherche de texte dans le tampon)
    _(WeeChat ≥ 0.4.2)_
** nom d'une couleur de barre :
*** _bar_fg_ : couleur de texte pour la barre
*** _bar_delim_ : couleur des délimiteurs pour la barre
*** _bar_bg_ : couleur de fond pour la barre
** réinitialisation :
*** _reset_ : réinitialiser la couleur et les attributs
*** _resetcolor_ : réinitialiser la couleur (garder les attributs)
    _(WeeChat ≥ 0.3.6)_

Le format de la couleur est : attributs (optionnel) + nom de couleur + ",fond"
(optionnel). Les attributs possibles sont :

* `+%+` : clignotement
* `+.+` : "dim" (demi-intensité)
* `+*+` : texte gras
* `+!+` : mode vidéo inverse
* `+/+` : italique
* `+_+` : texte souligné
* `+|+` : garder les attributs : ne pas réinitialiser
  gras/inverse/italique/souligné lors du changement de couleur
  _(WeeChat ≥ 0.3.6)_

Exemples :

* `+yellow+` : jaune
* `+_green+` : vert souligné
* `+*214+` : orange gras
* `+yellow,red+` : jaune sur rouge
* `+|cyan+` : cyan (et garder tout attribut définit précédemment)

Valeur de retour :

* chaîne avec le code couleur, ou une chaîne vide si la couleur n'a pas été
  trouvée

Exemple en C :

[source,c]
----
weechat_printf (NULL, "Couleur : %sbleu %scouleur par défaut %sjaune sur rouge",
                weechat_color ("blue"),
                weechat_color ("chat"),
                weechat_color ("yellow,red"));
----

Script (Python) :

[source,python]
----
# prototype
def color(color_name: str) -> str: ...

# exemple
weechat.prnt("", "Couleur : %sbleu %scouleur par défaut %sjaune sur rouge"
    % (weechat.color("blue"), weechat.color("chat"), weechat.color("yellow,red")))
----

==== printf

Afficher un message sur un tampon.

Prototype :

[source,c]
----
void weechat_printf (struct t_gui_buffer *buffer, const char *message, ...);
----

Cette fonction est un raccourci vers la fonction printf_datetime_tags. +
Ces deux appels donnent exactement le même résultat :

[source,c]
----
weechat_printf (buffer, "message");
weechat_printf_datetime_tags (buffer, 0, 0, NULL, "message");
----

Paramètres :

* _buffer_ : pointeur vers le tampon, si NULL, le message est affiché sur le
  tampon WeeChat
* _message_ : message à afficher

[NOTE]
La première tabulation dans le message ("\t") est utilisée pour séparer le
préfixe du message. +
Si votre message contient des tabulations et si vous ne voulez pas de préfixe,
utilisez un espace, une tabulation, puis le message : cela désactivera le
préfixe (l'espace avant la tabulation ne sera pas affiché).

[NOTE]
Avec deux tabulations ("\t") au début du message, l'heure ne sera pas affichée
et le message n'aura pas d'alignement. De plus, la date dans le message sera
positionnée à 0.

Exemple en C :

[source,c]
----
weechat_printf (NULL, "Bonjour sur le tampon WeeChat");
weechat_printf (buffer, "Bonjour sur ce tampon");
weechat_printf (buffer, "%sCeci est une erreur !", weechat_prefix ("error"));
weechat_printf (buffer, " \tMessage sans préfixe mais avec \t quelques \t tabulations");
weechat_printf (buffer, "\t\tMessage sans heure/alignement");
weechat_printf (buffer, "\t\t");  /* ligne vide (sans heure) */
----

Script (Python) :

[source,python]
----
# prototype
def prnt(buffer: str, message: str) -> int: ...

# exemple
weechat.prnt("", "Bonjour sur le tampon WeeChat")
weechat.prnt(buffer, "Bonjour sur ce tampon")
weechat.prnt(buffer, "%sCeci est une erreur !" % weechat.prefix("error"))
weechat.prnt(buffer, " \tMessage sans préfixe mais avec \t quelques \t tabulations")
weechat.prnt(buffer, "\t\tMessage sans heure/alignement")
weechat.prnt(buffer, "\t\t")  # ligne vide (sans heure)
----

[NOTE]
La fonction s'appelle "print" dans les scripts ("prnt" en Python).

==== printf_date_tags

Afficher un message sur un tampon, en utilisant une date et des étiquettes
personnalisées.

Prototype :

[source,c]
----
void weechat_printf_date_tags (struct t_gui_buffer *buffer, time_t date,
                               const char *tags, const char *message, ...);
----

Cette fonction est un raccourci vers la fonction printf_datetime_tags. +
Ces deux appels donnent exactement le même résultat :

[source,c]
----
weechat_printf_date_tags (buffer, 0, NULL, "message");
weechat_printf_datetime_tags (buffer, 0, 0, NULL, "message");
----

Paramètres :

* _buffer_ : pointeur vers le tampon, si NULL, le message est affiché sur le
  tampon WeeChat
* _date_ : date pour le message (0 signifie la date/heure courante)
* _tags_ : liste d'étiquettes séparées par des virgules (NULL signifie aucune
  étiquette)
* _message_ : message à afficher

Voir le link:weechat_user.fr.html#lines_tags[Guide utilisateur WeeChat / Étiquettes des lignes ^↗^^]
pour une liste des étiquettes couramment utilisées dans WeeChat.

Exemple en C :

[source,c]
----
weechat_printf_date_tags (NULL, time (NULL) - 120, "notify_message",
                          "Message il y a 2 minutes avec une étiquette 'notify_message'");
----

Script (Python) :

[source,python]
----
# prototype
def prnt_date_tags(buffer: str, date: int, tags: str, message: str) -> int: ...

# exemple
time = int(time.time())
weechat.prnt_date_tags("", time - 120, "notify_message",
    "Message il y a 2 minutes avec une étiquette 'notify_message'")
----

[NOTE]
La fonction s'appelle "print_date_tags" dans les scripts ("prnt_date_tags" en
Python).

==== printf_datetime_tags

_WeeChat ≥ 4.2.0._

Afficher un message sur un tampon, en utilisant une date/heure (avec microsecondes)
et des étiquettes personnalisées.

Prototype :

[source,c]
----
void weechat_printf_datetime_tags (struct t_gui_buffer *buffer, time_t date,
                                   int date_usec, const char *tags, const char *message, ...);
----

Paramètres :

* _buffer_ : pointeur vers le tampon, si NULL, le message est affiché sur le
  tampon WeeChat
* _date_ : date pour le message (0 signifie la date/heure courante)
* _date_usec_ : microsecondes de la date (entre 0 et 999999)
* _tags_ : liste d'étiquettes séparées par des virgules (NULL signifie aucune
  étiquette)
* _message_ : message à afficher

Voir le link:weechat_user.fr.html#lines_tags[Guide utilisateur WeeChat / Étiquettes des lignes ^↗^^]
pour une liste des étiquettes couramment utilisées dans WeeChat.

Exemple en C :

[source,c]
----
struct timeval tv_now;

gettimeofday (&tv_now, NULL);
weechat_printf_datetime_tags (NULL, tv_now.tv_sec - 120, tv_now.tv_usec,
                              "notify_message",
                              "Message il y a 2 minutes avec une étiquette 'notify_message'");
----

Script (Python) :

[source,python]
----
# prototype
def prnt_datetime_tags(buffer: str, date: int, date_usec: int, tags: str, message: str) -> int: ...

# exemple
now = time.time()
time_sec = int(now)
time_usec = int((now * 1000000) % 1000000)
weechat.prnt_datetime_tags("", time_sec - 120, time_usec, "notify_message",
                           "Message il y a 2 minutes avec une étiquette 'notify_message'")
----

[NOTE]
La fonction s'appelle "print_datetime_tags" dans les scripts ("prnt_datetime_tags"
en Python).

==== printf_y

Afficher un message sur une ligne d'un tampon avec contenu libre.

Prototype :

[source,c]
----
void weechat_printf_y (struct t_gui_buffer *buffer, int y, const char *message, ...);
----

Cette fonction est un raccourci vers la fonction printf_y_datetime_tags. +
Ces deux appels donnent exactement le même résultat :

[source,c]
----
weechat_printf_y (buffer, 0, "message");
weechat_printf_y_datetime_tags (buffer, 0, 0, 0, NULL, "message");
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _y_ : numéro de ligne (la première ligne est 0); une valeur négative affiche
  une ligne après la dernière ligne affichée : la valeur absolue de _y_ est le
  nombre de lignes après la dernière ligne (par exemple -1 est immédiatement
  après la dernière ligne, -2 est 2 lignes après la dernière ligne)
  _(WeeChat ≥ 1.0)_
* _message_ : message à afficher

Exemple en C :

[source,c]
----
weechat_printf_y (buffer, 2, "Mon message sur la 3ème ligne");
----

Script (Python) :

[source,python]
----
# prototype
def prnt_y(buffer: str, y: int, message: str) -> int: ...

# exemple
weechat.prnt_y("", 2, "Mon message sur la 3ème ligne")
----

[NOTE]
La fonction s'appelle "print_y" dans les scripts ("prnt_y" en Python).

==== printf_y_date_tags

_WeeChat ≥ 3.5._

Afficher un message sur une ligne d'un tampon avec contenu libre, en utilisant
une date et des étiquettes personnalisées.

Prototype :

[source,c]
----
void weechat_printf_y_date_tags (struct t_gui_buffer *buffer, int y, time_t date,
                                 const char *tags, const char *message, ...);
----

Cette fonction est un raccourci vers la fonction printf_y_datetime_tags. +
Ces deux appels donnent exactement le même résultat :

[source,c]
----
weechat_printf_y_date_tags (buffer, 0, 0, NULL, "message");
weechat_printf_y_datetime_tags (buffer, 0, 0, 0, NULL, "message");
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _y_ : numéro de ligne (la première ligne est 0); une valeur négative affiche
  une ligne après la dernière ligne affichée : la valeur absolue de _y_ est le
  nombre de lignes après la dernière ligne (par exemple -1 est immédiatement
  après la dernière ligne, -2 est 2 lignes après la dernière ligne)
* _date_ : date pour le message (0 signifie la date/heure courante)
* _tags_ : liste d'étiquettes séparées par des virgules (NULL signifie aucune
  étiquette)
* _message_ : message à afficher

Exemple en C :

[source,c]
----
weechat_printf_y_date_tags (buffer, 2, 0, "mon_etiquette", "Mon message sur la 3ème ligne avec une étiquette");
----

Script (Python) :

[source,python]
----
# prototype
def prnt_y_date_tags(buffer: str, y: int, date: int, tags: str, message: str) -> int: ...

# exemple
weechat.prnt_y_date_tags("", 2, 0, "mon_etiquette", "Mon message sur la 3ème ligne avec une étiquette")
----

[NOTE]
La fonction s'appelle "print_y_date_tags" dans les scripts ("prnt_y_date_tags"
en Python).

==== printf_y_datetime_tags

_WeeChat ≥ 4.2.0._

Afficher un message sur une ligne d'un tampon avec contenu libre, en utilisant
une date/heure (avec microsecondes) et des étiquettes personnalisées.

Prototype :

[source,c]
----
void weechat_printf_y_datetime_tags (struct t_gui_buffer *buffer, int y, time_t date,
                                     int date_usec, const char *tags, const char *message, ...);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _y_ : numéro de ligne (la première ligne est 0); une valeur négative affiche
  une ligne après la dernière ligne affichée : la valeur absolue de _y_ est le
  nombre de lignes après la dernière ligne (par exemple -1 est immédiatement
  après la dernière ligne, -2 est 2 lignes après la dernière ligne)
* _date_ : date pour le message (0 signifie la date/heure courante)
* _date_usec_ : microsecondes de la date (entre 0 et 999999)
* _tags_ : liste d'étiquettes séparées par des virgules (NULL signifie aucune
  étiquette)
* _message_ : message à afficher

Exemple en C :

[source,c]
----
weechat_printf_y_datetime_tags (buffer, 2, 0, 0, "mon_etiquette", "Mon message sur la 3ème ligne avec une étiquette");
----

Script (Python) :

[source,python]
----
# prototype
def prnt_y_datetime_tags(buffer: str, y: int, date: int, date_usec: int, tags: str, message: str) -> int: ...

# exemple
weechat.prnt_y_datetime_tags("", 2, 0, 0, "mon_etiquette", "Mon message sur la 3ème ligne avec une étiquette")
----

[NOTE]
La fonction s'appelle "print_y_datetime_tags" dans les scripts
("prnt_y_datetime_tags" en Python).

==== log_printf

Écrire un message dans le fichier de log WeeChat (weechat.log).

Prototype :

[source,c]
----
void weechat_log_printf (const char *message, ...);
----

Paramètres :

* _message_ : message à écrire

Exemple en C :

[source,c]
----
weechat_log_printf ("Mon message dans le fichier log");
----

Script (Python) :

[source,python]
----
# prototype
def log_print(message: str) -> int: ...

# exemple
weechat.log_print("Mon message dans le fichier log")
----

[NOTE]
La fonction s'appelle "log_print" dans les scripts.

[[hooks]]
=== Hooks

[[hook_priority]]
[float]
==== Priorité de hook

_WeeChat ≥ 0.3.4._

Pour certains "hooks", vous pouvez définir une priorité. Un "hook" avec une
priorité plus élevée sera au début de la liste des "hooks", et donc il sera
trouvé et exécuté avant les autres "hooks". Cela est pratique pour les
modificateurs, car l'ordre d'exécution est important.

Pour définir une priorité, vous devez utiliser cette syntaxe, pour un paramètre
où la priorité est autorisée : `nnn|nom` où `nnn` est un entier positif ou nul
avec la priorité et `nom` le nom pour le paramètre (la priorité n'apparaît pas
dans le nom, elle est automatiquement retirée de la chaîne). +
Une seule priorité par "hook" est autorisée.

La priorité par défaut est 1000.

Exemples en C :

[source,c]
----
/* accrocher un modificateur avec priorité = 2000 */
/* haute priorité : appelé avant les autres fonctions de rappel "modifier" */
weechat_hook_modifier ("2000|input_text_display", &modifier_cb, NULL, NULL);

/* accrocher deux signaux avec priorité = 3000 */
/* haute priorité : appelé avant les autres fonctions de rappel "signal" */
weechat_hook_signal ("3000|quit;upgrade", &signal_cb, NULL, NULL);

/* accrocher les lignes affichées dans les tampons formatés avec priorité = 500 */
/* basse priorité : appelé après les autres fonctions de rappel "line" */
weechat_hook_line ("500|formatted", "*", NULL, &line_cb, NULL, NULL);
----

Les types de "hooks" suivants autorisent une priorité :

* <<_hook_command,command>>
* <<_hook_completion,completion>>
* <<_hook_command_run,command_run>>
* <<_hook_line,line>>
* <<_hook_signal,signal>>
* <<_hook_hsignal,hsignal>>
* <<_hook_config,config>>
* <<_hook_modifier,modifier>>
* <<_hook_info,info>>
* <<_hook_info_hashtable,info_hashtable>>
* <<_hook_infolist,infolist>>
* <<_hook_hdata,hdata>>
* <<_hook_focus,focus>>

==== hook_command

_Mis à jour dans la 1.5, 1.7._

Accrocher une commande.

Prototype :

[source,c]
----
struct t_hook *weechat_hook_command (const char *command,
                                     const char *description,
                                     const char *args,
                                     const char *args_description,
                                     const char *completion,
                                     int (*callback)(const void *pointer,
                                                     void *data,
                                                     struct t_gui_buffer *buffer,
                                                     int argc,
                                                     char **argv,
                                                     char **argv_eol),
                                     const void *callback_pointer,
                                     void *callback_data);
----

Paramètres :

* _command_ : nom de la commande
  (une priorité est autorisée avant la commande, voir la note sur la <<hook_priority,priorité>>)
* _description_ : description de la commande (affiché avec `/help command`)
* _args_ : paramètres pour la commande (affichés avec `/help command`)
* _args_description_ : description des paramètres (affichée avec
  `/help command`)
* _completion_ : modèle pour la complétion de la commande (voir le format ci-dessous)
* _callback_ : fonction appelée lorsque la commande est utilisée, paramètres et
  valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _struct t_gui_buffer *buffer_ : tampon où la commande est exécutée
** _int argc_ : nombre de paramètres passés à la commande
** _char **argv_ : paramètres pour la commande
** _char **argv_eol_ : paramètres pour la commande (jusqu'à fin de ligne pour
   chaque paramètre)
** valeur de retour :
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat
* _callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou une
  fonction similaire) et est automatiquement libéré (par free) lorsque le
  "hook" est supprimé

Le modèle de complétion est une liste de complétions pour chaque paramètre,
séparés par des espaces. Plusieurs complétions sont possibles pour un paramètre,
séparées par `+|+`. Plusieurs modèles de complétions sont possibles pour une
même commande, séparés par `+||+`.

Le format de la complétion peut être :

* _%(nom)_ : la complétion _nom_
* _%(nom:paramètres)_ : la complétion _nom_ avec des _paramètres_ envoyés à la
  fonction de rappel _(WeeChat ≥ 1.7)_
* toute chaîne : elle est utilisée telle quelle dans la complétion

Par exemple le modèle `list || add %(filters_names) || del %(filters_names)|-all`
complètera avec les valeurs suivantes dans les paramètres de commande :

* premier paramètre : `list`, `add` et `del`
* second paramètre, cela dépend du premier paramètre :
** `list` : rien
** `add` : noms des filtres
** `del` : noms des filtres et `-all`

Les codes complétions par défaut sont :

include::{autogendir}/autogen_api_completions.fr.adoc[tag=completions]

Codes spéciaux :

* `+%%command+` : réutiliser le modèle de complétion de la commande _command_
* `+%-+` : arrêter la complétion
* `+%*+` : répéter la dernière complétion

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,c]
----
int
my_command_cb (const void *pointer, void *data, struct t_gui_buffer *buffer,
               int argc, char **argv, char **argv_eol)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* cet exemple s'inspire de la commande /filter */
struct t_hook *my_command_hook =
    weechat_hook_command ("monfiltre",
                          "description de monfiltre",
                          "[list] | [enable|disable|toggle [nom]] | "
                          "[add nom extension.tampon tags regex] | "
                          "[del nom|-all]",
                          "description des paramètres...",
                          "list"
                          " || enable %(filters_names)"
                          " || disable %(filters_names)"
                          " || toggle %(filters_names)"
                          " || add %(filters_names) %(buffers_plugins_names)|*"
                          " || del %(filters_names)|-all",
                          &my_command_cb, NULL, NULL);
----

Par exemple, si la commande appelée est `/command abc def ghi`, alors _argv_ et
_argv_eol_ ont les valeurs suivantes :

* _argv_ :
** _argv[0]_ == "/command"
** _argv[1]_ == "abc"
** _argv[2]_ == "def"
** _argv[3]_ == "ghi"
* _argv_eol_ :
** _argv_eol[0]_ == "/command abc def ghi"
** _argv_eol[1]_ == "abc def ghi"
** _argv_eol[2]_ == "def ghi"
** _argv_eol[3]_ == "ghi"

Pour les scripts, _args_ a la valeur "abc def ghi".

Script (Python) :

[source,python]
----
# prototype
def hook_command(command: str, description: str, args: str, args_description: str,
                 completion: str, callback: str, callback_data: str) -> str: ...

# exemple
def my_command_cb(data: str, buffer: str, args: str) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_command("monfiltre", "description de monfiltre",
    "[list] | [enable|disable|toggle [name]] | [add name plugin.buffer tags regex] | [del name|-all]",
    "description des paramètres...",
    "list"
    " || enable %(filters_names)"
    " || disable %(filters_names)"
    " || toggle %(filters_names)"
    " || add %(filters_names) %(buffers_plugins_names)|*"
    " || del %(filters_names)|-all",
    "my_command_cb", "")
----

==== hook_completion

_Mis à jour dans la 1.5, 1.7._

Accrocher une complétion.

Prototype :

[source,c]
----
struct t_hook *weechat_hook_completion (const char *completion_item,
                                        const char *description,
                                        int (*callback)(const void *pointer,
                                                        void *data,
                                                        const char *completion_item,
                                                        struct t_gui_buffer *buffer,
                                                        struct t_gui_completion *completion),
                                        const void *callback_pointer,
                                        void *callback_data);
----

Paramètres :

* _completion_item_ : nom de l'objet de complétion, après vous pouvez utiliser
  _%(nom)_ (ou _%(nom:paramètres)_ avec WeeChat ≥ 1.7) dans une commande
  (paramètre _completion_)
  (une priorité est autorisée avant le nom de l'objet de complétion,
  voir la note sur la <<hook_priority,priorité>>)
* _description_ : description de la complétion
* _callback_ : fonction appelée lorsque la complétion est utilisée
  (l'utilisateur est en train de compléter quelque chose qui fait appel à cette
  complétion), paramètres et valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _const char *completion_item_ : nom de la complétion (avec WeeChat ≥ 1.7 il
   peut inclure des paramètres, avec le format : _nom:paramètres_)
** _struct t_gui_buffer *buffer_ : tampon où la complétion est effectuée
** _struct t_gui_completion *completion_ : structure utilisée pour ajouter
   les mots pour la complétion (voir <<_completion_list_add,completion_list_add>>)
** valeur de retour :
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat
* _callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou une
  fonction similaire) et est automatiquement libéré (par free) lorsque le
  "hook" est supprimé

[NOTE]
Les noms de complétion sont globaux (partagés entre WeeChat et les extensions).
Il est donc recommandé de choisir un nom avec un préfixe unique, comme
"monextension_xxx" (où "xxx" est le nom de votre complétion).

[IMPORTANT]
La fonction de rappel doit seulement appeler des fonction de complétion comme
<<_completion_list_add,completion_list_add>> et ne doit *PAS* mettre à jour
la ligne de commande. +
Pour mettre à jour la ligne de commande quand kbd:[Tab] est pressé, vous pouvez
utiliser la fonction <<_hook_command_run,hook_command_run>>
avec la commande : `+/input complete_next+` (et vous devez retourner
_WEECHAT_RC_OK_EAT_ si votre fonction de rappel a mis à jour la ligne de
commande, de sorte que WeeChat n'exécute pas la complétion).

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,c]
----
int
my_completion_cb (const void *pointer, void *data, const char *completion_item,
                  struct t_gui_buffer *buffer,
                  struct t_gui_completion *completion)
{
    weechat_completion_list_add (completion, "mot1", 0, WEECHAT_LIST_POS_SORT);
    weechat_completion_list_add (completion, "test_mot2", 0, WEECHAT_LIST_POS_SORT);
    return WEECHAT_RC_OK;
}

struct t_hook *my_completion_hook = weechat_hook_completion ("extension_item",
                                                             "ma complétion !",
                                                             &my_completion_cb, NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def hook_completion(completion_item: str, description: str, callback: str, callback_data: str) -> str: ...

# exemple
def my_completion_cb(data: str, completion_item: str, buffer: str, completion: str) -> int:
    weechat.completion_list_add(completion, "mot1", 0, weechat.WEECHAT_LIST_POS_SORT)
    weechat.completion_list_add(completion, "test_mot2", 0, weechat.WEECHAT_LIST_POS_SORT)
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_completion("extension_item", "ma complétion !",
                               "my_completion_cb", "")
----

==== hook_completion_get_string

_WeeChat ≥ 0.3.4._

*Obsolète depuis WeeChat 2.9* (toujours là pour des raisons de compatibilité). +
Cette fonction a été remplacée par <<_completion_get_string,completion_get_string>>.

==== hook_completion_list_add

*Obsolète depuis WeeChat 2.9* (toujours là pour des raisons de compatibilité). +
Cette fonction a été remplacée par <<_completion_list_add,completion_list_add>>.

==== hook_command_run

_Mis à jour dans la 1.5._

Intercepter une commande lorsqu'elle est exécutée par WeeChat.

Prototype :

[source,c]
----
struct t_hook *weechat_hook_command_run (const char *command,
                                         int (*callback)(const void *pointer,
                                                         void *data,
                                                         struct t_gui_buffer *buffer,
                                                         const char *command),
                                         const void *callback_pointer,
                                         void *callback_data);
----

Paramètres :

* _command_ : commande à intercepter (le caractère joker `+*+` est autorisé)
  (une priorité est autorisée avant la commande, voir la note sur la <<hook_priority,priorité>>)
* _callback_ : fonction appelée lorsque la commande est exécutée, paramètres et
  valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _struct t_gui_buffer *buffer_ : tampon où la commande est exécutée
** _const char *command_ : la commande exécutée, avec ses paramètres
** valeur de retour :
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_OK_EAT_ : la commande ne sera pas exécutée par WeeChat après
    la fonction de rappel
*** _WEECHAT_RC_ERROR_
* _callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat
* _callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou une
  fonction similaire) et est automatiquement libéré (par free) lorsque le
  "hook" est supprimé

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,c]
----
int
my_command_run_cb (const void *pointer, void *data,
                   struct t_gui_buffer *buffer, const char *command)
{
    weechat_printf (NULL, "Je mange la complétion !");
    return WEECHAT_RC_OK_EAT;
}

struct t_hook *my_command_run_hook =
    weechat_hook_command_run ("/input complete*",
                              &my_command_run_cb, NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def hook_command_run(command: str, callback: str, callback_data: str) -> str: ...

# exemple
def my_command_run_cb(data: str, buffer: str, command: str) -> int:
    weechat.prnt("", "Je mange la complétion !")
    return weechat.WEECHAT_RC_OK_EAT

hook = weechat.hook_command_run("/input complete*", "my_command_run_cb", "")
----

==== hook_timer

_Mis à jour dans la 1.5._

Accrocher un minuteur (fonction appelée à intervalles réguliers).

Prototype :

[source,c]
----
struct t_hook *weechat_hook_timer (long interval,
                                   int align_second,
                                   int max_calls,
                                   int (*callback)(const void *pointer,
                                                   void *data,
                                                   int remaining_calls),
                                   const void *callback_pointer,
                                   void *callback_data);
----

Paramètres :

* _interval_ : intervalle entre deux appels (en millisecondes, donc 1000 = 1
  seconde)
* _align_second_ : alignement sur la seconde. Par exemple, si la date courante
  est 09:00, si l'intervalle est 60000 (60 secondes), et que align_second = 60,
  alors le minuteur sera appelé chaque minute quand la seconde sera 0
* _max_calls_ : nombre maximum d'appels au minuteur (si 0, le minuteur n'a pas
  de fin)
* _callback_ : fonction appelée quand le délai est atteint, paramètres et valeur
  de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _int remaining_calls_ : nombre d'appels restants (-1 si le minuteur n'a pas
   de fin)
** valeur de retour :
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat
* _callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou une
  fonction similaire) et est automatiquement libéré (par free) lorsque le
  "hook" est supprimé

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,c]
----
int
my_timer_cb (const void *pointer, void *data, int remaining_calls)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* minuteur appelé toutes les 20 secondes */
struct t_hook *my_timer_hook =
    weechat_hook_timer (20 * 1000, 0, 0, &my_timer_cb, NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def hook_timer(interval: int, align_second: int, max_calls: int, callback: str, callback_data: str) -> str: ...

# exemple
def my_timer_cb(data: str, remaining_calls: int) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

# minuteur appelé toutes les 20 secondes
hook = weechat.hook_timer(20 * 1000, 0, 0, "my_timer_cb", "")
----

==== hook_fd

_Mis à jour dans la 1.3, 1.5, 2.0._

Accrocher un descripteur de fichier (fichier ou socket).

Prototype :

[source,c]
----
struct t_hook *weechat_hook_fd (int fd,
                                int flag_read,
                                int flag_write,
                                int flag_exception,
                                int (*callback)(const void *pointer,
                                                void *data,
                                                int fd),
                                const void *callback_pointer,
                                void *callback_data);
----

Paramètres :

* _fd_ : descripteur de fichier
* _flag_read_ : 1 = intercepter un évènement de lecture, 0 = ignorer
* _flag_write_ : 1 = intercepter un évènement d'écriture, 0 = ignorer
* _flag_exception_ : 1 = intercepter un évènement d'exception, 0 = ignorer
  (_WeeChat ≥ 1.3_ : ce paramètre est ignoré et n'est plus utilisé)
* _callback_ : fonction appelée lorsqu'un des évènements sélectionnés se
  produit pour le fichier (ou le socket), paramètres et valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _int fd_ : descripteur de fichier
** valeur de retour :
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat
* _callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou une
  fonction similaire) et est automatiquement libéré (par free) lorsque le
  "hook" est supprimé

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

[IMPORTANT]
Dans les scripts, avec WeeChat ≥ 2.0, le paramètre de la fonction de rappel _fd_
est un entier (avec WeeChat ≤ 1.9, il était une chaîne). +
Pour être compatible avec toutes les versions, il est recommandé de convertir le
paramètre en entier avant de l'utiliser, par exemple en Python : `int(fd)`.

Exemple en C :

[source,c]
----
int
my_fd_cb (const void *pointer, void *data, int fd)
{
    /* ... */
    return WEECHAT_RC_OK;
}

int sock = socket (AF_INET, SOCK_STREAM, 0);
/* définir les options du socket */
/* ... */
struct t_hook *my_fd_hook = weechat_hook_fd (sock, 1, 0, 0, &my_fd_cb, NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def hook_fd(fd: int, flag_read: int, flag_write: int, flag_exception: int, callback: str, callback_data: str) -> str: ...

# exemple
def my_fd_cb(data: str, fd: int) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

sock = ...
hook = weechat.hook_fd(sock, 1, 0, 0, "my_fd_cb", "")
----

==== hook_process

_Mis à jour dans la 1.5._

Accrocher un processus (lancé par un fork), et intercepter sa sortie.

[NOTE]
Depuis la version 0.3.9.2, le shell n'est plus utilisé pour exécuter la
commande. WeeChat effectue un découpage automatique de la commande et de ses
paramètres (comme le fait le shell). +
Si le découpage n'est pas correct (selon les guillemets utilisés dans votre
commande), ou si vous souhaitez utiliser le shell, vous pouvez utiliser la
fonction <<_hook_process_hashtable,hook_process_hashtable>> avec
les paramètres dans la table de hachage _options_ _(WeeChat ≥ 0.4.0)_.

Prototype :

[source,c]
----
struct t_hook *weechat_hook_process (const char *command,
                                     int timeout,
                                     int (*callback)(const void *pointer,
                                                     void *data,
                                                     const char *command,
                                                     int return_code,
                                                     const char *out,
                                                     const char *err),
                                     const void *callback_pointer,
                                     void *callback_data);
----

Paramètres :

* _command_ : commande à lancer dans le processus fils, URL _(WeeChat ≥ 0.3.7)_
  ou fonction _(WeeChat ≥ 1.5)_ (voir ci-dessous)
* _timeout_ : timeout pour la commande (en millisecondes) : après ce délai, le
  processus fils est tué (0 signifie pas de limite)
* _callback_ : fonction appelée quand des données du fils sont disponibles, or
  ou quand le fils s'est terminé, paramètres et valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _const char *command_ : commande exécutée par le fils
** _int return_code_ : code retour :
*** _≥ 0_ : code retour du fils pour une commande, et pour l'URL, les valeurs
    possibles sont :
**** _0_ : transfert ok
**** _1_ : URL invalide
**** _2_ : erreur de transfert
**** _3_ : pas assez de mémoire
**** _4_ : erreur avec un fichier
*** _< 0_ :
**** _WEECHAT_HOOK_PROCESS_RUNNING_ (-1) : données disponibles, mais le fils tourne
     toujours
**** _WEECHAT_HOOK_PROCESS_ERROR_ (-2) : erreur en lançant la commande
**** _WEECHAT_HOOK_PROCESS_CHILD_ (-3) : la fonction de rappel est appelée dans le
     processus fils (utilisé seulement dans l'API C, pas l'API script)
** _out_ : sortie standard de la commande (stdout)
** _err_ : erreurs de la commande (stderr)
** valeur de retour :
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
*** code retour du processus fils (dans le cas d'une fonction avec "func:" dans
    la commande)
* _callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat
* _callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou une
  fonction similaire) et est automatiquement libéré (par free) lorsque le
  "hook" est supprimé

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Lorsque la commande est terminée, ou si le timeout est atteint, WeeChat
supprimera automatiquement le "hook" (et tuera le processus s'il tourne
toujours).

La commande peut être une URL avec le format : "url:https://www.example.com",
pour télécharger le contenu de l'URL _(WeeChat ≥ 0.3.7)_.
Des options pour l'URL sont possibles avec la fonction
<<_hook_process_hashtable,hook_process_hashtable>>.

La commande peut aussi être le nom d'une fonction avec le format : "func:nom",
pour exécuter la fonction "nom" _(WeeChat ≥ 1.5)_. Cette fonction reçoit un
paramètre (_data_) et doit retourner une chaîne de caractères, qui sera envoyée
à la fonction de rappel. +
Dans l'API C, la fonction de rappel est appelée avec le code retour qui vaut
_WEECHAT_HOOK_PROCESS_CHILD_, cela signifie que la fonction de rappel tourne
dans le processus fils (après le fork). +
Dans l'API script, la fonction _nom_ est appelée directement et le résultat
(chaîne de caractères) est envoyé à la fonction de rappel (comme la sortie
d'une commande externe).

[TIP]
Si vous souhaitez récupérer des infos à propos de WeeChat (comme la version
stable actuelle, le dernier commit git, etc.), vous pouvez utiliser les URLs
sur https://weechat.org/dev/info/[cette page ^↗^^].

[NOTE]
La taille du tampon pour l'envoi des données à la fonction de rappel est de
64 Ko (il y a 2 tampons : un pour stdout et un pour stderr).
Si la sortie du processus fils (stdout ou stderr) est plus longue que 64 Ko, la
fonction de rappel sera appelée plusieurs fois.

[IMPORTANT]
Même si la plupart du temps la fonction de rappel n'est appelée qu'une seule
fois, vous devez vous assurer que plusieurs appels à la fonction de rappel sont
OK dans votre code : vous devez concaténer les données issues de plusieurs
appels et n'utiliser les données que lorsque le code retour est positif ou nul.

Exemple en C :

[source,c]
----
/* exemple avec une commande externe */
int
my_process_cb (const void *pointer, void *data, const char *command,
               int return_code, const char *out, const char *err)
{
    if (return_code == WEECHAT_HOOK_PROCESS_ERROR)
    {
        weechat_printf (NULL, "Erreur avec la commande '%s'", command);
        return WEECHAT_RC_OK;
    }

    if (return_code >= 0)
    {
        weechat_printf (NULL, "return_code = %d", return_code);
    }

    if (out)
    {
        weechat_printf (NULL, "stdout : %s", out);
    }

    if (err)
    {
        weechat_printf (NULL, "stderr : %s", err);
    }

    return WEECHAT_RC_OK;
}

struct t_hook *my_process_hook = weechat_hook_process ("ls", 5000,
                                                       &my_process_cb, NULL, NULL);

/* exemple avec la fonction de rappel appelée dans le processus fils */
int
my_process_func_cb (const void *pointer, void *data, const char *command,
                    int return_code, const char *out, const char *err)
{
    if (return_code == WEECHAT_HOOK_PROCESS_CHILD)
    {
        /* faire quelque chose de bloquant... */
        /* ... */

        /* la sortie "stdout" sera envoyée comme "out" à la fonction de rappel parente */
        printf ("ceci est le résultat");

        /* code retour du processus */
        return 0;
    }
    else
    {
        if (return_code == WEECHAT_HOOK_PROCESS_ERROR)
        {
            weechat_printf (NULL, "Erreur avec la commande '%s'", command);
            return WEECHAT_RC_OK;
        }

        if (return_code >= 0)
        {
            weechat_printf (NULL, "return_code = %d", return_code);
        }

        if (out)
        {
            weechat_printf (NULL, "stdout : %s", out);
        }

        if (err)
        {
            weechat_printf (NULL, "stderr : %s", err);
        }

        return WEECHAT_RC_OK;
    }
}

struct t_hook *my_process_hook = weechat_hook_process ("func:get_status", 5000,
                                                       &my_process_func_cb, NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def hook_process(command: str, timeout: int, callback: str, callback_data: str) -> str: ...

# exemple avec une commande externe
def my_process_cb(data: str, command: str, return_code: int, out: str, err: str) -> int:
    if return_code == weechat.WEECHAT_HOOK_PROCESS_ERROR:
        weechat.prnt("", "Erreur avec la commande '%s'" % command)
        return weechat.WEECHAT_RC_OK
    if return_code >= 0:
        weechat.prnt("", "return_code = %d" % return_code)
    if out:
        weechat.prnt("", "stdout : %s" % out)
    if err:
        weechat.prnt("", "stderr : %s" % err)
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_process("ls", 5000, "my_process_cb", "")

# exemple avec une fonction du script
def get_status(data: str) -> str:
    # faire quelque chose de bloquant...
    # ...
    return "ceci est le résultat"

def my_process_cb(data: str, command: str, return_code: int, out: str, err: str) -> int:
    if return_code == weechat.WEECHAT_HOOK_PROCESS_ERROR:
        weechat.prnt("", "Erreur avec la commande '%s'" % command)
        return weechat.WEECHAT_RC_OK
    if return_code >= 0:
        weechat.prnt("", "return_code = %d" % return_code)
    if out:
        weechat.prnt("", "stdout : %s" % out)
    if err:
        weechat.prnt("", "stderr : %s" % err)
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_process("func:get_status", 5000, "my_process_cb", "")
----

==== hook_process_hashtable

_WeeChat ≥ 0.3.7, mis à jour dans la 1.5._

Accrocher un processus (lancé par un fork) en utilisant des options dans une
table de hachage, et intercepter sa sortie.

Prototype :

[source,c]
----
struct t_hook *weechat_hook_process_hashtable (const char *command,
                                               struct t_hashtable *options,
                                               int timeout,
                                               int (*callback)(const void *pointer,
                                                               void *data,
                                                               const char *command,
                                                               int return_code,
                                                               const char *out,
                                                               const char *err),
                                               const void *callback_pointer,
                                               void *callback_data);
----

Les paramètres sont les mêmes que ceux de la fonction
<<_hook_process,hook_process>>, avec un paramètre supplémentaire :

* _options_ : options pour la commande exécutée ; la table de hachage est
  dupliquée dans la fonction, donc il est possible de la supprimer après cet
  appel

Pour une commande standard (ne commençant pas par "url:"), les options suivantes
sont disponibles :

[width="100%",cols="^1,^1,1,1,5",options="header"]
|===
| Option | WeeChat mini | Valeur | Défaut | Description

| argN (N ≥ 1) | 0.4.0 | toute chaîne | pas de paramètres
| Paramètres pour la commande ; si aucun paramètre n'est donné avec ces options,
  la commande sera automatiquement découpée comme le fait le shell (et donc les
  paramètres de la commande sont lus dans le paramètre _command_).

| stdin | 0.4.3 | (non utilisée) | pas de stdin
| Créer un tuyau pour écrire sur l'entrée standard (stdin) du processus fils
  (voir la fonction <<_hook_set,hook_set>>).

| buffer_flush | 1.0 | nombre d'octets | 65536
| Nombre minimum d'octets pour vider stdout/stderr (pour envoyer la sortie à la
  fonction de rappel), entre 1 et 65536. Avec la valeur 1, la sortie est envoyée
  immédiatement à la fonction de rappel.

| detached | 1.0 | (non utilisée) | non détaché
| Lancer le process dans un mode détaché : stdout et stderr sont redirigés vers
  _/dev/null_.
|===

Pour la commande "url:...", voir les options disponibles dans la fonction
<<_hook_url,hook_url>>.

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,c]
----
int
my_process_cb (const void *pointer, void *data, const char *command,
               int return_code, const char *out, const char *err)
{
    if (return_code == WEECHAT_HOOK_PROCESS_ERROR)
    {
        weechat_printf (NULL, "Erreur avec la commande '%s'", command);
        return WEECHAT_RC_OK;
    }

    if (return_code >= 0)
    {
        weechat_printf (NULL, "return_code = %d", return_code);
    }

    if (out)
    {
        weechat_printf (NULL, "stdout : %s", out);
    }

    if (err)
    {
        weechat_printf (NULL, "stderr : %s", err);
    }

    return WEECHAT_RC_OK;
}

/* exemple 1 : téléchargement d'une URL */
struct t_hashtable *options_url1 = weechat_hashtable_new (8,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          NULL,
                                                          NULL);
if (options_url1)
{
    weechat_hashtable_set (options_url1, "file_out", "/tmp/weechat.org.html");
    struct t_hook *my_process_hook = weechat_hook_process_hashtable ("url:https://weechat.org/",
                                                                     options_url1,
                                                                     20000,
                                                                     &my_process_cb, NULL, NULL);
    weechat_hashtable_free (options_url1);
}

/* exemple 2 : ouverture d'une URL avec des en-têtes HTTP personnalisés */
struct t_hashtable *options_url2 = weechat_hashtable_new (8,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          NULL,
                                                          NULL);
if (options_url2)
{
    weechat_hashtable_set (options_url2, "httpheader",
                           "Header1: valeur1\n"
                           "Header2: valeur2");
    struct t_hook *my_process_hook = weechat_hook_process_hashtable ("url:http://localhost:8080/",
                                                                     options_url2,
                                                                     20000,
                                                                     &my_process_cb, NULL, NULL);
    weechat_hashtable_free (options_url2);
}

/* exemple 3 : exécution d'un programme de notification avec le message de quelqu'un */
struct t_hashtable *options_cmd1 = weechat_hashtable_new (8,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          NULL,
                                                          NULL);
if (options_cmd1)
{
    weechat_hashtable_set (options_cmd1, "arg1", "-from");
    weechat_hashtable_set (options_cmd1, "arg2", nick);
    weechat_hashtable_set (options_cmd1, "arg3", "-msg");
    weechat_hashtable_set (options_cmd1, "arg4", message);  /* paramètre non sûr */
    struct t_hook *my_process_hook = weechat_hook_process_hashtable ("my-notify-command",
                                                                     options_cmd1,
                                                                     20000,
                                                                     &my_process_cb, NULL, NULL);
    weechat_hashtable_free (options_cmd1);
}

/* exemple 4 : appeler le shell pour exécuter la commande (la commande doit être SURE) */
struct t_hashtable *options_cmd2 = weechat_hashtable_new (8,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          NULL,
                                                          NULL);
if (options_cmd2)
{
    weechat_hashtable_set (options_cmd2, "arg1", "-c");
    weechat_hashtable_set (options_cmd2, "arg2", "ls -l /tmp | grep something");
    struct t_hook *my_process_hook = weechat_hook_process_hashtable ("sh",
                                                                     options_cmd2,
                                                                     20000,
                                                                     &my_process_cb, NULL, NULL);
    weechat_hashtable_free (options_cmd2);
}
----

Script (Python) :

[source,python]
----
# prototype
def hook_process_hashtable(command: str, options: Dict[str, str], timeout: int, callback: str, callback_data: str) -> str: ...

# exemple
def my_process_cb(data: str, command: str, return_code: int, out: str, err: str) -> int:
    if return_code == weechat.WEECHAT_HOOK_PROCESS_ERROR:
        weechat.prnt("", "Erreur avec la commande '%s'" % command)
        return weechat.WEECHAT_RC_OK
    if return_code >= 0:
        weechat.prnt("", "return_code = %d" % return_code)
    if out:
        weechat.prnt("", "stdout : %s" % out)
    if err:
        weechat.prnt("", "stderr : %s" % err)
    return weechat.WEECHAT_RC_OK

# exemple 1 : téléchargement d'une URL
hook1 = weechat.hook_process_hashtable("url:https://weechat.org/",
                                       {"file_out": "/tmp/weechat.org.html"},
                                       20000, "my_process_cb", "")

# exemple 2 : ouverture d'une URL avec des en-têtes HTTP personnalisés
options = {
    "httpheader": "\n".join([
        "Header1: valeur1",
        "Header2: valeur2",
    ]),
}
hook2 = weechat.hook_process_hashtable("url:http://localhost:8080/",
                                       options,
                                       20000, "my_process_cb", "")

# exemple 3 : exécution d'un programme de notification avec le message de quelqu'un
hook3 = weechat.hook_process_hashtable("my-notify-command",
                                       {"arg1": "-from",
                                        "arg2": nick,
                                        "arg3": "-msg",
                                        "arg4": message},  # paramètre non sûr
                                       20000, "my_process_cb", "")

# exemple 4 : appeler le shell pour exécuter la commande (la commande doit être SURE)
hook4 = weechat.hook_process_hashtable("sh",
                                       {"arg1": "-c",
                                        "arg2": "ls -l /tmp | grep something"},
                                       20000, "my_process_cb", "")
----

==== hook_url

_WeeChat ≥ 4.1.0._

Transfert d'URL.

Prototype :

[source,c]
----
struct t_hook *weechat_hook_url (const char *url,
                                 struct t_hashtable *options,
                                 int timeout,
                                 int (*callback)(const void *pointer,
                                                 void *data,
                                                 const char *url,
                                                 struct t_hashtable *options,
                                                 struct t_hashtable *output),
                                 const void *callback_pointer,
                                 void *callback_data);
----

Paramètres :

* _url_ : URL
* _options_ : options pour le transfert d'URL (voir ci-dessous) ; la table de
  hachage est dupliquée dans la fonction, donc il est possible de la supprimer
  après cet appel
* _timeout_ : timeout pour le transfert d'URL (en millisecondes) : après de délai,
  le transfert est stoppé (0 signifie pas de limite)
* _callback_ : fonction appelée lorsque le transfert est terminé, paramètres et
  valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _const char *url_ : URL
** _struct t_hashtable *options_ : options
** _struct t_hashtable *output_ : résultat (les clés et valeurs sont des chaînes),
   qui peut contenir les clés suivantes :
*** _response_code_ : code réponse HTTP
*** _headers_ : en-têtes HTTP dans la réponse
*** _output_ : sortie standard (défini seulement si _file_out_ n'était pas défini
    dans les options)
*** _error_ : message d'erreur (défini seulement en cas d'erreur)
** valeur de retour :
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat
* _callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou une
  fonction similaire) et est automatiquement libéré (par free) lorsque le
  "hook" est supprimé

Les options Curl suivantes sont disponibles (voir `+man curl_easy_setopt+` pour
une description de chaque option) :

include::{autogendir}/autogen_api_url_options.fr.adoc[tag=url_options]

[NOTE]
^(1)^ Pour les options avec le type "mask", le format est :
"value1+value2+value3" ;
pour les options avec le type "list", les éléments de la liste doivent être
séparés par un retour à la ligne (`\n`). +
^(2)^ Lorsque des constantes sont disponibles, elles doivent être utilisées
comme valeur pour l'option.

Ces deux options supplémentaires (chaînes) sont autorisées, pour le fichier en
entrée/sortie :

[width="100%",cols="2,^1,7",options="header"]
|===
| Option   | Type   | Description
| file_in  | string | fichier à lire pour envoyer avec l'URL (envoi de fichier "post")
| file_out | string | écrire l'URL/fichier dans ce fichier (au lieu de la sortie standard)
|===

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,c]
----
int
my_url_cb (const void *pointer, void *data, const char *url,
           struct t_hashtable *options, struct t_hashtable *output)
{
    weechat_printf (NULL, "response_code : %s", weechat_hashtable_get (output, "response_code"));
    weechat_printf (NULL, "headers : %s", weechat_hashtable_get (output, "headers"));
    weechat_printf (NULL, "output : %s", weechat_hashtable_get (output, "output"));
    weechat_printf (NULL, "error : %s", weechat_hashtable_get (output, "error"));
    return WEECHAT_RC_OK;
}

/* example 1: sortie dans un fichier */
struct t_hashtable *options_url1 = weechat_hashtable_new (8,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          NULL,
                                                          NULL);
if (options_url1)
{
    weechat_hashtable_set (options_url1, "file_out", "/tmp/weechat.org.html");
    struct t_hook *my_url_hook = weechat_hook_url ("https://weechat.org/",
                                                   options_url1,
                                                   20000,
                                                   &my_url_cb, NULL, NULL);
    weechat_hashtable_free (options_url1);
}

/* example 2: en-têtes HTTP personnalisés, sortie envoyée à la fonction de rappel */
struct t_hashtable *options_url2 = weechat_hashtable_new (8,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          NULL,
                                                          NULL);
if (options_url2)
{
    weechat_hashtable_set (options_url2, "httpheader",
                           "Header1: valeur1\n"
                           "Header2: valeur2");
    struct t_hook *my_url_hook = weechat_hook_url ("http://localhost:8080/",
                                                   options_url2,
                                                   20000,
                                                   &my_url_cb, NULL, NULL);
    weechat_hashtable_free (options_url2);
}
----

Script (Python) :

[source,python]
----
# prototype
def hook_url(url: str, options: Dict[str, str], timeout: int, callback: str, callback_data: str) -> str: ...

# exemple
def my_url_cb(data: str, url: str, options: Dict[str, str], output: Dict[str, str]) -> int:
    weechat.prnt("", "output: %s" % output)
    return weechat.WEECHAT_RC_OK

# exemple 1 : sortie dans un fichier
hook1 = weechat.hook_url("https://weechat.org/",
                         {"file_out": "/tmp/weechat.org.html"},
                         20000, "my_url_cb", "")

# exemple 2 : en-têtes HTTP personnalisés, sortie envoyée à la fonction de rappel
options = {
    "httpheader": "\n".join([
        "Header1: valeur1",
        "Header2: valeur2",
    ]),
}
hook2 = weechat.hook_url("http://localhost:8080/", options, 20000, "my_url_cb", "")
----

==== hook_connect

_Mis à jour dans la 1.5, 2.0._

Accrocher une connexion (connexion à une machine distante en tâche de fond).

Prototype :

[source,c]
----
struct t_hook *weechat_hook_connect (const char *proxy,
                                     const char *address,
                                     int port,
                                     int ipv6,
                                     int retry,
                                     void *gnutls_sess,
                                     void *gnutls_cb,
                                     int gnutls_dhkey_size,
                                     const char *gnutls_priorities,
                                     const char *local_hostname,
                                     int (*callback)(const void *pointer,
                                                     void *data,
                                                     int status,
                                                     int gnutls_rc,
                                                     int sock,
                                                     const char *error,
                                                     const char *ip_address),
                                     const void *callback_pointer,
                                     void *callback_data);
----

Paramètres :

* _proxy_ : nom du proxy à utiliser pour la connexion (optionnel, NULL signifie
  une connexion sans proxy)
* _address_ : nom ou adresse IP de la machine à laquelle se connecter
* _port_ : numéro de port
* _ipv6_ : 1 pour utiliser IPv6 (avec repli sur IPv4), 0 pour utiliser seulement
  IPv4
* _retry_ : numéro de nouvelle tentative, utilisé pour se rabattre sur les
  adresses IPv4 si la connexion IPv6 échoue
* _gnutls_sess_ : session GnuTLS (optionnel)
* _gnutls_cb_ : fonction de rappel pour GnuTLS (optionnelle)
* _gnutls_dhkey_size_ : taille de clé utilisée pour l'échange de clé
  Diffie-Hellman (GnuTLS)
* _gnutls_priorities_ : priorités pour gnutls (pour la syntaxe, voir la
  documentation de la fonction _gnutls_priority_init_ dans le manuel gnutls),
  les valeurs de base sont :
** _PERFORMANCE_
** _NORMAL_ (défaut)
** _SECURE128_
** _SECURE256_
** _EXPORT_
** _NONE_
* _local_hostname_ : nom de machine local à utiliser pour la connexion
  (optionnel)
* _callback_ : fonction appelée lorsque la connexion est OK ou a échoué,
  paramètres et valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _int status_ : statut de connexion :
*** _WEECHAT_HOOK_CONNECT_OK_ : connexion ok
*** _WEECHAT_HOOK_CONNECT_ADDRESS_NOT_FOUND_ : adresse non trouvée
*** _WEECHAT_HOOK_CONNECT_IP_ADDRESS_NOT_FOUND_ : adresse IP non trouvée
*** _WEECHAT_HOOK_CONNECT_CONNECTION_REFUSED_ : connexion refusée
*** _WEECHAT_HOOK_CONNECT_PROXY_ERROR_ : erreur avec le proxy
*** _WEECHAT_HOOK_CONNECT_LOCAL_HOSTNAME_ERROR_ : erreur avec le nom local
*** _WEECHAT_HOOK_CONNECT_GNUTLS_INIT_ERROR_ : erreur d'initialisation GnuTLS
*** _WEECHAT_HOOK_CONNECT_GNUTLS_HANDSHAKE_ERROR_ : erreur avec la
    "poignée de main" GnuTLS
*** _WEECHAT_HOOK_CONNECT_MEMORY_ERROR_ : mémoire insuffisante
*** _WEECHAT_HOOK_CONNECT_TIMEOUT_ : temps maximum dépassé
*** _WEECHAT_HOOK_CONNECT_SOCKET_ERROR_ : erreur de création socket
** _gnutls_rc_ : valeur retour de _gnutls_handshake()_
** _sock_ : socket utilisé pour la connexion
** _const char *error_ : valeur retour de _gnutls_strerror(gnutls_rc)_
** _const char *ip_address_ : adresse IP trouvée
** valeur de retour :
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat
* _callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou une
  fonction similaire) et est automatiquement libéré (par free) lorsque le
  "hook" est supprimé

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

[IMPORTANT]
Dans les scripts, avec WeeChat ≥ 2.0, les paramètres de la fonction de rappel
_status_, _gnutls_rc_ et _sock_ sont des entiers (avec WeeChat ≤ 1.9, ils étaient
des chaînes). +
Pour être compatible avec toutes les versions, il est recommandé de convertir
le paramètre avant de l'utiliser, par exemple en Python: `int(sock)`.

Exemple en C :

[source,c]
----
int
my_connect_cb (const void *pointer, void *data, int status, int gnutls_rc,
               int sock, const char *error, const char *ip_address)
{
    switch (status)
    {
        case WEECHAT_HOOK_CONNECT_OK:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_ADDRESS_NOT_FOUND:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_IP_ADDRESS_NOT_FOUND:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_CONNECTION_REFUSED:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_PROXY_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_LOCAL_HOSTNAME_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_GNUTLS_INIT_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_GNUTLS_HANDSHAKE_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_MEMORY_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_TIMEOUT:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_SOCKET_ERROR:
            /* ... */
            break;
    }
    return WEECHAT_RC_OK;
}

struct t_hook *my_connect_hook = weechat_hook_connect (NULL,
                                                       "my.server.org", 1234,
                                                       1, 0,
                                                       NULL, NULL, 0,  /* GnuTLS */
                                                       NULL,
                                                       &my_connect_cb, NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def hook_connect(proxy: str, address: str, port: int, ipv6: int, retry: int, local_hostname: str,
                 callback: str, callback_data: str) -> str: ...

# exemple
def my_connect_cb(data: str, status: int, gnutls_rc: int, sock: int, error: str, ip_address: str) -> int:
    if status == WEECHAT_HOOK_CONNECT_OK:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_ADDRESS_NOT_FOUND:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_IP_ADDRESS_NOT_FOUND:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_CONNECTION_REFUSED:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_PROXY_ERROR:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_LOCAL_HOSTNAME_ERROR:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_GNUTLS_INIT_ERROR:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_GNUTLS_HANDSHAKE_ERROR:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_MEMORY_ERROR:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_TIMEOUT:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_SOCKET_ERROR:
        # ...
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_connect("", "my.server.org", 1234, 1, 0, "",
                            "my_connect_cb", "")
----

==== hook_line

_WeeChat ≥ 2.3, mis à jour dans la 4.2.0._

Intercepter une ligne sur le point d'être affichée dans un tampon.

Lorsqu'une ligne est affichée dans un tampon, les "hooks" suivants sont
appelés dans cet ordre :

* <<_hook_line,hook line>> (ce "hook") : il peut changer le tampon, préfixe,
  message, étiquettes, niveau de notification, … (voir ci-dessous)
* <<_hook_modifier,hook modifier>> "<<hook_modifier_weechat_print,weechat_print>>" :
  il peut changer le préfixe et le message sur un tampon avec contenu formaté
* <<_hook_print,hook print>> : appelé quand une ligne a été ajoutée dans un
  tampon avec contenu formaté (rien ne peut être changé directement avec ce
  "hook").

[NOTE]
Le "hook" "line" est le seul parmi ces trois "hooks" qui peut fonctionner sur
un tampon avec contenu libre.

Prototype :

[source,c]
----
struct t_hook *weechat_hook_line (const char *buffer_type,
                                  const char *buffer_name,
                                  const char *tags,
                                  struct t_hashtable *(*callback)(const void *pointer,
                                                                  void *data,
                                                                  struct t_hashtable *line),
                                  const void *callback_pointer,
                                  void *callback_data);
----

Paramètres :

* _buffer_type_ : intercepter les lignes affichées sur ce type de tampon
  (si NULL ou chaîne vide, _formatted_ est utilisé par défaut)
  (_WeeChat ≥ 3.7_ : une priorité est autorisée avant le type de tampon,
  voir la note sur la <<hook_priority,priorité>>) :
** _formatted_ : intercepter les lignes sur un tampon avec contenu formaté
   seulement (par défaut)
** _free_ : intercepter les lignes sur un tampon avec contenu libre seulement
** _*_ : intercepter les lignes sur tous les types de tampons
* _buffer_name_ : liste de masques de tampons séparés par des virgules
  (voir <<_buffer_match_list,buffer_match_list>>); NULL, chaîne vide ou "*"
  correspondent à n'importe quel tampon
* _tags_ : intercepter seulement les messages avec ces étiquettes (optionnel) :
  liste d'étiquettes (séparées par des virgules) qui doivent être dans le message
  ("ou" logique); il est possible de combiner plusieurs étiquettes sous forme
  d'un "et" logique avec le séparateur `+++`; le caractère joker `+*+` est
  autorisé dans les étiquettes
* _callback_ : fonction appelée lorsqu'une ligne est ajoutée dans un tampon,
  paramètres et valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _struct t_hashtable *line_ : table de hachage avec les informations sur la ligne,
   les clés et valeurs sont des chaînes (voir le tableau ci-dessous)
** valeur de retour : table de hachage avec les nouvelles valeurs
   (voir le tableau ci-dessous)
* _callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat
* _callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou une
  fonction similaire) et est automatiquement libéré (par free) lorsque le
  "hook" est supprimé

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Les données de la ligne envoyées à la fonction de rappel sont dans une table
de hachage, avec les valeurs suivantes (les clés et valeurs sont des chaînes) :

[width="100%",cols="^1,3,3,2",options="header"]
|===
| Clé | Valeur (tampon formaté) | Valeur (tampon libre) | Exemples

| buffer
| Pointeur vers le tampon.
| Pointeur vers le tampon.
| `+0x1234abcd+`

| buffer_name
| Nom du tampon.
| Nom du tampon.
| `+core.weechat+` +
  `+irc.server.libera+` +
  `+irc.libera.#weechat+`

| buffer_type
| "formatted"
| "free"
| `+formatted+` +
  `+free+`

| y
| N/A ("-1").
| Numéro de ligne (≥ "0").
| `+-1+` +
  `+8+`

| date
| Date de la ligne (horodatage).
| N/A ("0").
| `+1533792000+`

| date_usec
| Microsecondes de la date de la ligne (entre 0 et 999999).
| N/A ("0").
| `+123456+`

| date_printed
| Date d'affichage de la ligne (horodatage).
| N/A ("0").
| `+1533792012+`

| date_usec_printed
| Microsecondes de la date d'affichage de la ligne (entre 0 et 999999).
| N/A ("0").
| `+654321+`

| str_time
| Date pour l'affichage (elle peut contenir des codes couleur).
| N/A (chaîne vide).
| `+09:07:20+`

| tags_count
| Nombre d'étiquettes dans la ligne (≥ "0").
| N/A ("0").
| `+2+`

| tags
| Liste des étiquettes séparées par des virgules.
| N/A (chaîne vide).
| `+irc_join,nick_test+`

| displayed
| "0" = la ligne est filtrée (cachée) +
  "1" = la ligne n'est pas filtrée (affichée).
| "0" = la ligne est filtrée (cachée) +
  "1" = la ligne n'est pas filtrée (affichée).
| `+0+` +
  `+1+`

| notify_level
| "-1" = pas de notification +
  "0" = niveau bas +
  "1" = message +
  "2" = message privé +
  "3" = highlight
| N/A ("0").
| `+2+`

| highlight
| "0" = pas de highlight +
  "1" = la ligne a un highlight.
| N/A ("0").
| `+0+` +
  `+1+`

| prefix
| Préfixe de la ligne.
| N/A (chaîne vide).
| `+-->+`

| message
| Message de la ligne.
| Message de la ligne.
| `+test (~test@example.com) a rejoint #canal+`
|===

La fonction de retour peut retourner une table de hachage avec quelques champs
pour mettre à jour la ligne.
Toute valeur invalide dans un champ est silencieusement ignorée par WeeChat.

Les clés suivantes peuvent être définies dans la table de hachage (les clés et
valeurs sont des chaînes dans cette table de hachage) :

[width="100%",cols="^1,2,2,5",options="header"]
|===
| Clé | Valeur autorisée (tampon formaté) | Valeur autorisée (tampon libre) | Résultat

| buffer
| Pointeur vers un tampon avec contenu formaté.
| Pointeur vers un tampon avec contenu libre.
| La ligne est affichée sur ce tampon. +
  Si la valeur est vide, la ligne est supprimée (le reste de la table de hachage
  est alors ignoré) ; les "hooks" suivants de type "line" ne sont pas appelés.

| buffer_name
| Nom d'un tampon avec contenu formaté.
| Nom d'un tampon avec contenu libre.
| La ligne est affichée sur ce tampon. +
  Si `buffer` est également défini, la valeur de `+buffer_name+` a une priorité
  plus haute est est utilisée. +
  Si la valeur est vide, la ligne est supprimée (le reste de la table de hachage
  est alors ignoré) ; les "hooks" suivants de type "line" ne sont pas appelés.

| y
| N/A.
| Entier (≥ "0").
| Le numéro de ligne est positionné à cette valeur.

| date
| Horodatage.
| N/A.
| La date est positionnée à cet horodatage. +
  La valeur de `+str_time+` est mise à jour en conséquence.

| date_usec
| Entier ("0" à "999999").
| N/A.
| Les microsecondes de la date sont positionnées à cette valeur. +
  La valeur de `+str_time+` est mise à jour en conséquence.

| date_printed
| Horodatage.
| N/A.
| La date d'affichage est positionnée à cet horodatage (non affichée).

| date_usec_printed
| Entier ("0" à "999999").
| N/A.
| Les microsecondes de la date d'affichage sont positionnées à cette valeur.

| str_time
| Chaîne.
| N/A.
| Cette chaîne est utilisée pour afficher la date de la ligne. +
  Si `date` est également défini, la valeur de `+str_time+` a une priorité plus
  haute et est utilisée.

| tags
| Chaîne.
| N/A.
| Les étiquettes de la ligne sont remplacées avec cette liste d'étiquettes
  (séparées par des virgules). +
  Les valeurs de `+notify_level+` et `highlight` sont mises à jour en conséquence.

| notify_level
| Entier ("-1" à "3").
| N/A.
| Le niveau de notification est positionné à cette valeur. La hotlist sera mise
  à jour en conséquence une fois que la ligne sera ajoutée dans la tampon. +
  La valeur de `highlight` est mise à jours en conséquence. +
  Si `tags` est également défini, la valeur de `+notify_level+` a une priorité
  plus haute et est utilisée.

| highlight
| Entier ("0" ou "1").
| N/A.
| "0" désactive le highlight sur la ligne, "1" force un highlight sur la ligne. +
  Si `tags` ou `+notify_level+` sont définis, la valeur de `highlight` a une
  priorité plus haute et est utilisée.

| prefix
| Chaîne.
| N/A.
| Le préfixe de la ligne est positionné à cette valeur.

| message
| Chaîne.
| Chaîne.
| Le message de la ligne est positionné à cette valeur.
|===

Exemple en C :

[source,c]
----
int
my_line_cb (const void *pointer, void *data, struct t_hasbtable *line)
{
    struct t_hashtable *hashtable;

    hashtable = weechat_hashtable_new (8,
                                       WEECHAT_HASHTABLE_STRING,
                                       WEECHAT_HASHTABLE_STRING,
                                       NULL,
                                       NULL);
    /* forcer un highlight sur la ligne */
    weechat_hashtable_set (hashtable, "highlight", "1");
    return hashtable;
}

/* intercepter les lignes avec l'étiquette "irc_join" */
struct t_hook *my_line_hook =
    weechat_hook_line ("", "", "irc_join", &my_line_cb, NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def hook_line(buffer_type: str, buffer_name: str, tags: str, callback: str, callback_data: str) -> str: ...

# exemple
def my_line_cb(data: str, line: Dict[str, str]) -> Dict[str, str]:
    # forcer un highlight sur la ligne
    return {"highlight": "1"}

# intercepter les lignes avec l'étiquette "irc_join"
hook = weechat.hook_line("", "", "irc_join", "my_line_cb", "")
----

==== hook_print

_Mis à jour dans la 0.4.3, 1.0, 1.5, 4.2.0._

Intercepter un message affiché. Il est appelée quand une ligne a été ajoutée
dans un tampon avec contenu formaté.

Pour plus d'informations sur les "hooks" appelés lorsqu'une ligne est affichée,
voir <<_hook_line,hook_line>>.

Prototype :

[source,c]
----
struct t_hook *weechat_hook_print (struct t_gui_buffer *buffer,
                                   const char *tags,
                                   const char *message,
                                   int strip_colors,
                                   int (*callback)(const void *pointer,
                                                   void *data,
                                                   struct t_gui_buffer *buffer,
                                                   time_t date,
                                                   int date_usec,
                                                   int tags_count,
                                                   const char **tags,
                                                   int displayed,
                                                   int highlight,
                                                   const char *prefix,
                                                   const char *message),
                                   const void *callback_pointer,
                                   void *callback_data);
----

Paramètres :

* _buffer_ : pointeur vers le tampon, si NULL, les messages de tous les tampons
  sont interceptés
* _tags_ : intercepter seulement les messages avec ces étiquettes (optionnel) :
** avec WeeChat ≥ 0.4.3 : liste d'étiquettes (séparées par des virgules) qui
   doivent être dans le message ("ou" logique); il est possible de combiner
   plusieurs étiquettes sous forme d'un "et" logique avec le séparateur `+++`;
   le caractère joker `+*+` est autorisé dans les étiquettes
** avec WeeChat ≤ 0.4.2 : liste d'étiquettes (séparées par des virgules) qui
   doivent toutes être dans le message ("et" logique)
* _message_ : seulement les messages contenant cette chaîne seront interceptés
  (optionnel, insensible à la casse)
* _strip_colors_ : si 1, les couleurs seront supprimées du message affiché,
  avant d'appeler la fonction de rappel
* _callback_ : fonction appelée lorsqu'un message est affiché, paramètres et
  valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _struct t_gui_buffer *buffer_ : pointeur vers le tampon
** _time_t date_ : date
** _int date_usec_ : microsecondes de la date
** _int tags_count_ : nombre d'étiquettes de la ligne
** _const char **tags_ : tableau avec les étiquettes de la ligne
** _int displayed_ : 1 si la ligne est affichée, 0 si elle est filtrée (cachée)
** _int highlight_ : 1 si la ligne contient un highlight, sinon 0
** _const char *prefix_ : préfixe
** _const char *message_ : message
** valeur de retour :
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat
* _callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou une
  fonction similaire) et est automatiquement libéré (par free) lorsque le
  "hook" est supprimé

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

[IMPORTANT]
Dans les scripts, avec WeeChat ≥ 1.0, les paramètres de la fonction de rappel
_displayed_ et _highlight_ sont des entiers (avec WeeChat ≤ 0.4.3, ils étaient
des chaînes). +
Pour être compatible avec toutes les versions, il est recommandé de convertir
le paramètre en entier avant de le tester, par exemple en Python :
`if int(highlight):`.

Exemple en C :

[source,c]
----
int
my_print_cb (const void *pointer, void *data, struct t_gui_buffer *buffer,
             time_t date, int date_usec, int tags_count, const char **tags,
             int displayed, int highlight,
             const char *prefix, const char *message)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* intercepter tous les messages, de tous les tampons, sans couleur */
struct t_hook *my_print_hook =
    weechat_hook_print (NULL, NULL, NULL, 1, &my_print_cb, NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def hook_print(buffer: str, tags: str, message: str, strip_colors: int, callback: str, callback_data: str) -> str: ...

# exemple
def my_print_cb(data: str, buffer: str, date: str, tags: str, displayed: int, highlight: int, prefix: str, message: str) -> int:
    if highlight:
        # ...
    return weechat.WEECHAT_RC_OK

# intercepter tous les messages, de tous les tampons, sans couleur
hook = weechat.hook_print("", "", "", 1, "my_print_cb", "")
----

==== hook_signal

_Mis à jour dans la 1.5, 3.6._

S'accrocher à un signal.

Prototype :

[source,c]
----
struct t_hook *weechat_hook_signal (const char *signal,
                                    int (*callback)(const void *pointer,
                                                    void *data,
                                                    const char *signal,
                                                    const char *type_data,
                                                    void *signal_data),
                                    const void *callback_pointer,
                                    void *callback_data);
----

Paramètres :

* _signal_ : signal à intercepter, le caractère joker `+*+` est autorisé,
  plusieurs signaux peuvent être séparés par des point-virgules
  (une priorité est autorisée avant le ou les signaux, voir la note sur la <<hook_priority,priorité>>)
  (voir le tableau ci-dessous)
* _callback_ : fonction appelée quand le signal est reçu, paramètres et valeur
  de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _const char *signal_ : signal reçu
** _const char *type_data_ : type de donnée reçu avec le signal :
*** _WEECHAT_HOOK_SIGNAL_STRING_ : chaîne de caractères
*** _WEECHAT_HOOK_SIGNAL_INT_ : nombre entier
*** _WEECHAT_HOOK_SIGNAL_POINTER_ : pointeur
** _void *signal_data_ : données envoyées avec le signal
** valeur de retour :
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_OK_EAT_ (arrêter l'envoi du signal immédiatement)
    _(WeeChat ≥ 0.4.0)_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat
* _callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou une
  fonction similaire) et est automatiquement libéré (par free) lorsque le
  "hook" est supprimé

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Liste des signaux envoyés par WeeChat et les extensions :

[width="100%",cols="^2,^4,^1,6,9",options="header"]
|===
| Extension | Signal | WeeChat mini | Paramètres | Description

| guile | [[hook_signal_guile_script_loaded]] guile_script_loaded | 0.3.9
| Chaîne : chemin vers le script.
| Script scheme chargé.

| guile | [[hook_signal_guile_script_unloaded]] guile_script_unloaded | 0.3.9
| Chaîne : chemin vers le script.
| Script scheme déchargé.

| guile | [[hook_signal_guile_script_installed]] guile_script_installed | 0.3.9
| Chaîne : liste de chemins vers scripts installés (séparés par des virgules).
| Script(s) scheme installé(s).

| guile | [[hook_signal_guile_script_removed]] guile_script_removed | 0.3.9
| Chaîne : liste de scripts supprimés (séparés par des virgules).
| Script(s) scheme supprimé(s).

| irc | [[hook_signal_xxx_irc_in_yyy]] xxx,irc_in_yyy ^(1)^ |
| Chaîne : message.
| Message IRC du serveur (avant utilisation par l'extension irc,
  signal envoyé uniquement si le message n'est *pas* ignoré). +
  Depuis la version 2.2, le message IRC entier est envoyé, en incluant
  les étiquettes. +
  Si le code retour d'une fonction de rappel est _WEECHAT_RC_OK_EAT_, alors
  le message IRC est immédiatement détruit et non traité _(WeeChat ≥ 3.3)_.

| irc | [[hook_signal_xxx_irc_in2_yyy]] xxx,irc_in2_yyy ^(1)^ |
| Chaîne : message.
| Message IRC du serveur (après utilisation par l'extension irc,
  signal envoyé uniquement si le message n'est *pas* ignoré). +
  Depuis la version 2.2, le message IRC entier est envoyé, en incluant
  les étiquettes.

| irc | [[hook_signal_xxx_irc_raw_in_yyy]] xxx,irc_raw_in_yyy ^(1)^ + | 0.3.2
| Chaîne : message.
| Message IRC du serveur (avant utilisation par l'extension irc,
  signal envoyé même si le message est ignoré). +
  Depuis la version 2.2, le message IRC entier est envoyé, en incluant
  les étiquettes. +
  Si le code retour d'une fonction de rappel est _WEECHAT_RC_OK_EAT_, alors
  le message IRC est immédiatement détruit et non traité _(WeeChat ≥ 3.3)_.

| irc | [[hook_signal_xxx_irc_raw_in2_yyy]] xxx,irc_raw_in2_yyy ^(1)^ | 0.3.2
| Chaîne : message.
| Message IRC du serveur (après utilisation par l'extension irc,
  signal envoyé même si le message est ignoré). +
  Depuis la version 2.2, le message IRC entier est envoyé, en incluant
  les étiquettes.

| irc | [[hook_signal_xxx_irc_out1_yyy]] xxx,irc_out1_yyy ^(1)^ | 0.3.7
| Chaîne : message.
| Message IRC envoyé au serveur avant découpage automatique
  (pour tenir dans les 512 octets par défaut). +
  *Attention :* la chaîne peut contenir des données invalides UTF-8.
  Le signal "xxx,irc_out1_yyy" est recommandé à la place de celui-ci.

| irc | [[hook_signal_xxx_irc_out_yyy]] xxx,irc_out_yyy ^(1)^ |
| Chaîne : message.
| Message IRC envoyé au serveur après découpage automatique
  (pour tenir dans les 512 octets par défaut). +
  *Attention :* la chaîne peut contenir des données invalides UTF-8.
  Le signal "xxx,irc_out1_yyy" est recommandé à la place de celui-ci.

| irc | [[hook_signal_xxx_irc_outtags_yyy]] xxx,irc_outtags_yyy ^(1)^ | 0.3.4
| Chaîne : étiquettes + ";" + message.
| Étiquettes + message IRC envoyé au serveur.

| irc | [[hook_signal_irc_ctcp]] irc_ctcp |
| Chaîne : message.
| CTCP reçu.

| irc | [[hook_signal_irc_dcc]] irc_dcc |
| Chaîne : message.
| Nouveau DCC.

| irc | [[hook_signal_irc_pv]] irc_pv |
| Chaîne : message.
| Message privé reçu.

| irc | [[hook_signal_irc_channel_opened]] irc_channel_opened |
| Pointeur : tampon.
| Canal ouvert.

| irc | [[hook_signal_irc_pv_opened]] irc_pv_opened |
| Pointeur : tampon.
| Discussion privée ouverte.

| irc | [[hook_signal_irc_server_opened]] irc_server_opened | 0.3.7
| Pointeur : tampon.
| Tampon du serveur ouvert.

| irc | [[hook_signal_irc_server_connecting]] irc_server_connecting |
| Chaîne : nom du serveur.
| Connexion en cours au serveur.

| irc | [[hook_signal_irc_server_connected]] irc_server_connected |
| Chaîne : nom du serveur.
| Connecté au serveur.

| irc | [[hook_signal_irc_server_disconnected]] irc_server_disconnected |
| Chaîne : nom du serveur.
| Déconnecté du serveur.

| irc | [[hook_signal_irc_server_lag_changed]] irc_server_lag_changed | 1.8
| Chaîne : nom du serveur.
| Le lag a changé sur le serveur.

| irc | [[hook_signal_irc_ignore_removing]] irc_ignore_removing |
| Pointeur : ignore.
| Suppression d'un ignore en cours.

| irc | [[hook_signal_irc_ignore_removed]] irc_ignore_removed |
| -
| Ignore supprimé.

| irc | [[hook_signal_irc_notify_join]] irc_notify_join | 0.3.8
| Chaîne : nom du serveur + "," + pseudo.
| Un pseudo dans la liste de notifications a rejoint le serveur.

| irc | [[hook_signal_irc_notify_quit]] irc_notify_quit | 0.3.8
| Chaîne : nom du serveur + "," + pseudo.
| Un pseudo dans la liste de notifications a quitté le serveur.

| irc | [[hook_signal_irc_notify_away]] irc_notify_away | 0.3.8
| Chaîne : nom du serveur + "," + pseudo + "," + message d'absence.
| Un pseudo dans la liste de notifications est maintenant absent sur le serveur.

| irc | [[hook_signal_irc_notify_still_away]] irc_notify_still_away | 0.3.8
| Chaîne : nom du serveur + "," + pseudo + "," + message d'absence.
| Un pseudo dans la liste de notifications est toujours absent sur le serveur
  (le message d'absence a changé).

| irc | [[hook_signal_irc_notify_back]] irc_notify_back | 0.3.8
| Chaîne : nom du serveur + "," + pseudo.
| Un pseudo dans la liste de notifications est de retour (statut d'absence
  supprimé).

| javascript | [[hook_signal_javascript_script_loaded]] javascript_script_loaded | 1.2
| Chaîne : chemin vers le script.
| Script JavaScript chargé.

| javascript | [[hook_signal_javascript_script_unloaded]] javascript_script_unloaded | 1.2
| Chaîne : chemin vers le script.
| Script JavaScript déchargé.

| javascript | [[hook_signal_javascript_script_installed]] javascript_script_installed | 1.2
| Chaîne : liste de chemins vers scripts installés (séparés par des virgules).
| Script(s) JavaScript installé(s).

| javascript | [[hook_signal_javascript_script_removed]] javascript_script_removed | 1.2
| Chaîne : liste de scripts supprimés (séparés par des virgules).
| Script(s) JavaScript supprimé(s).

| logger | [[hook_signal_logger_start]] logger_start |
| Pointeur : tampon.
| Démarrage de l'enregistrement sur disque pour le tampon.

| logger | [[hook_signal_logger_stop]] logger_stop |
| Pointeur : tampon.
| Fin de l'enregistrement sur disque pour le tampon.

| logger | [[hook_signal_logger_backlog]] logger_backlog |
| Pointeur : tampon.
| Affichage du backlog pour le tampon.

| lua | [[hook_signal_lua_script_loaded]] lua_script_loaded | 0.3.9
| Chaîne : chemin vers le script.
| Script lua chargé.

| lua | [[hook_signal_lua_script_unloaded]] lua_script_unloaded | 0.3.9
| Chaîne : chemin vers le script.
| Script lua déchargé.

| lua | [[hook_signal_lua_script_installed]] lua_script_installed | 0.3.9
| Chaîne : liste de chemins vers scripts installés (séparés par des virgules).
| Script(s) lua installé(s).

| lua | [[hook_signal_lua_script_removed]] lua_script_removed | 0.3.9
| Chaîne : liste de scripts supprimés (séparés par des virgules).
| Script(s) lua supprimé(s).

| perl | [[hook_signal_perl_script_loaded]] perl_script_loaded | 0.3.9
| Chaîne : chemin vers le script.
| Script perl chargé.

| perl | [[hook_signal_perl_script_unloaded]] perl_script_unloaded | 0.3.9
| Chaîne : chemin vers le script.
| Script perl déchargé.

| perl | [[hook_signal_perl_script_installed]] perl_script_installed | 0.3.9
| Chaîne : liste de chemins vers scripts installés (séparés par des virgules).
| Script(s) perl installé(s).

| perl | [[hook_signal_perl_script_removed]] perl_script_removed | 0.3.9
| Chaîne : liste de scripts supprimés (séparés par des virgules).
| Script(s) perl supprimé(s).

| php | [[hook_signal_php_script_loaded]] php_script_loaded | 2.0
| Chaîne : chemin vers le script.
| Script PHP chargé.

| php | [[hook_signal_php_script_unloaded]] php_script_unloaded | 2.0
| Chaîne : chemin vers le script.
| Script PHP déchargé.

| php | [[hook_signal_php_script_installed]] php_script_installed | 2.0
| Chaîne : liste de chemins vers scripts installés (séparés par des virgules).
| Script(s) PHP installé(s).

| php | [[hook_signal_php_script_removed]] php_script_removed | 2.0
| Chaîne : liste de scripts supprimés (séparés par des virgules).
| Script(s) PHP supprimé(s).

| python | [[hook_signal_python_script_loaded]] python_script_loaded | 0.3.9
| Chaîne : chemin vers le script.
| Script python chargé.

| python | [[hook_signal_python_script_unloaded]] python_script_unloaded | 0.3.9
| Chaîne : chemin vers le script.
| Script python déchargé.

| python | [[hook_signal_python_script_installed]] python_script_installed | 0.3.9
| Chaîne : liste de chemins vers scripts installés (séparés par des virgules).
| Script(s) python installé(s).

| python | [[hook_signal_python_script_removed]] python_script_removed | 0.3.9
| Chaîne : liste de scripts supprimés (séparés par des virgules).
| Script(s) python supprimé(s).

| relay | [[hook_signal_relay_client_connecting]] relay_client_connecting | 1.0
| Pointeur : client relay.
| Un client relay est en train de se connecter.

| relay | [[hook_signal_relay_client_waiting_auth]] relay_client_waiting_auth | 1.0
| Pointeur : client relay.
| Attente de l'authentification d'un client relay.

| relay | [[hook_signal_relay_client_auth_ok]] relay_client_auth_ok | 1.0
| Pointeur : client relay.
| Authentification réussie d'un client relay.

| relay | [[hook_signal_relay_client_connected]] relay_client_connected | 1.0
| Pointeur : client relay.
| Un client relay est connecté.

| relay | [[hook_signal_relay_client_auth_failed]] relay_client_auth_failed | 1.0
| Pointeur : client relay.
| L'authentification d'un client relay a échoué.

| relay | [[hook_signal_relay_client_disconnected]] relay_client_disconnected | 1.0
| Pointeur : client relay.
| Un client relay est déconnecté.

| ruby | [[hook_signal_ruby_script_loaded]] ruby_script_loaded | 0.3.9
| Chaîne : chemin vers le script.
| Script ruby chargé.

| ruby | [[hook_signal_ruby_script_unloaded]] ruby_script_unloaded | 0.3.9
| Chaîne : chemin vers le script.
| Script ruby déchargé.

| ruby | [[hook_signal_ruby_script_installed]] ruby_script_installed | 0.3.9
| Chaîne : liste de chemins vers scripts installés (séparés par des virgules).
| Script(s) ruby installé(s).

| ruby | [[hook_signal_ruby_script_removed]] ruby_script_removed | 0.3.9
| Chaîne : liste de scripts supprimés (séparés par des virgules).
| Script(s) ruby supprimé(s).

| spell | [[hook_signal_spell_suggest]] spell_suggest | 2.4
| Pointeur : tampon.
| Nouvelles suggestions pour un mot mal orthographié.

| tcl | [[hook_signal_tcl_script_loaded]] tcl_script_loaded | 0.3.9
| Chaîne : chemin vers le script.
| Script tcl chargé.

| tcl | [[hook_signal_tcl_script_unloaded]] tcl_script_unloaded | 0.3.9
| Chaîne : chemin vers le script.
| Script tcl déchargé.

| tcl | [[hook_signal_tcl_script_installed]] tcl_script_installed | 0.3.9
| Chaîne : liste de chemins vers scripts installés (séparés par des virgules).
| Script(s) tcl installé(s).

| tcl | [[hook_signal_tcl_script_removed]] tcl_script_removed | 0.3.9
| Chaîne : liste de scripts supprimés (séparés par des virgules).
| Script(s) tcl supprimé(s).

| typing | [[hook_signal_typing_self_typing]] typing_self_typing | 3.3
| Pointeur : tampon.
| L'utilisateur est en train de taper un message (envoyé par l'extension typing,
  utilisé par l'extension irc).

| typing | [[hook_signal_typing_self_paused]] typing_self_paused | 3.3
| Pointeur : tampon.
| L'utilisateur a fait une pause pendant la saisie du message (envoyé par
  l'extension typing, utilisé par l'extension irc).

| typing | [[hook_signal_typing_self_cleared]] typing_self_cleared | 3.3
| Pointeur : tampon.
| L'utilisateur a effacé la ligne de commande sans envoyer le message
  (envoyé par l'extension typing, utilisé par l'extension irc).

| typing | [[hook_signal_typing_self_sent]] typing_self_sent | 3.3
| Pointeur : tampon.
| Message (pas une commande) envoyé au tampon (envoyé par l'extension typing,
  utilisé par l'extension irc).

| typing | [[hook_signal_typing_set_nick]] typing_set_nick | 3.3
| Chaîne : pointeur tampon + ";" + état (un parmi ceux-ci : "off",
  "typing", "paused", "cleared") + ";" + pseudo.
| Définir l'état de la saisie du pseudo sur le tampon (envoyé par l'extension irc,
  géré par l'extension typing).

| typing | [[hook_signal_typing_reset_buffer]] typing_reset_buffer | 3.3
| Pointeur : tampon.
| Supprimer l'état de saisir pour tous les pseudos d'un tampon (envoyé par
  l'extension irc, géré par l'extension typing).

| weechat | [[hook_signal_buffer_opened]] buffer_opened |
| Pointeur : tampon.
| Tampon ouvert.

| weechat | [[hook_signal_buffer_closing]] buffer_closing |
| Pointeur : tampon.
| Fermeture du tampon en cours.

| weechat | [[hook_signal_buffer_closed]] buffer_closed |
| Pointeur : tampon.
| Tampon fermé.

| weechat | [[hook_signal_buffer_cleared]] buffer_cleared |
| Pointeur : tampon.
| Tampon vidé.

| weechat | [[hook_signal_buffer_filters_enabled]] buffer_filters_enabled | 2.0
| Pointeur : tampon.
| Filtres activés dans le tampon.

| weechat | [[hook_signal_buffer_filters_disabled]] buffer_filters_disabled | 2.0
| Pointeur : tampon.
| Filtres désactivés dans le tampon.

| weechat | [[hook_signal_buffer_hidden]] buffer_hidden |
| Pointeur : tampon.
| Tampon masqué.

| weechat | [[hook_signal_buffer_unhidden]] buffer_unhidden |
| Pointeur : tampon.
| Tampon démasqué.

| weechat | [[hook_signal_buffer_line_added]] buffer_line_added | 0.3.7
| Pointeur : ligne.
| Ligne ajoutée dans un tampon.

| weechat | [[hook_signal_buffer_lines_hidden]] buffer_lines_hidden |
| Pointeur : tampon.
| Lignes cachées dans le tampon.

| weechat | [[hook_signal_buffer_localvar_added]] buffer_localvar_added |
| Pointeur : tampon.
| Variable locale ajoutée.

| weechat | [[hook_signal_buffer_localvar_changed]] buffer_localvar_changed |
| Pointeur : tampon.
| Variable locale modifiée.

| weechat | [[hook_signal_buffer_localvar_removed]] buffer_localvar_removed |
| Pointeur : tampon.
| Variable locale supprimée.

| weechat | [[hook_signal_buffer_merged]] buffer_merged |
| Pointeur : tampon.
| Tampon mélangé.

| weechat | [[hook_signal_buffer_unmerged]] buffer_unmerged |
| Pointeur : tampon.
| Le tampon n'est plus mélangé.

| weechat | [[hook_signal_buffer_moved]] buffer_moved |
| Pointeur : tampon.
| Tampon déplacé.

| weechat | [[hook_signal_buffer_renamed]] buffer_renamed |
| Pointeur : tampon.
| Tampon renommé.

| weechat | [[hook_signal_buffer_switch]] buffer_switch |
| Pointeur : tampon.
| Basculement vers un autre tampon.

| weechat | [[hook_signal_buffer_title_changed]] buffer_title_changed |
| Pointeur : tampon.
| Titre du tampon changé.

| weechat | [[hook_signal_buffer_modes_changed]] buffer_modes_changed | 4.3.0
| Pointeur : tampon.
| Modes du tampon changés.

| weechat | [[hook_signal_buffer_type_changed]] buffer_type_changed |
| Pointeur : tampon.
| Type de tampon changé.

| weechat | [[hook_signal_buffer_zoomed]] buffer_zoomed | 0.4.3
| Pointeur : tampon.
| Zoom sur un tampon mélangé.

| weechat | [[hook_signal_buffer_unzoomed]] buffer_unzoomed | 0.4.3
| Pointeur : tampon.
| Fin du zoom sur un tampon mélangé.

| weechat | [[hook_signal_buffer_user_input_xxx]] buffer_user_input_xxx ^(2)^ | 3.8
| Chaîne : texte envoyé au tampon.
| Texte envoyé au tampon utilisateur (envoyé seulement sur les tampons créés
  avec `/buffer add`). +
  Si le code retour d'une fonction de rappel est _WEECHAT_RC_OK_EAT_, alors
  la chaîne "q" ne peut plus être utilisée pour fermer le tampon.

| weechat | [[hook_signal_buffer_user_closing_xxx]] buffer_user_closing_xxx ^(2)^ | 3.8
| -
| Fermeture du tampon utilisateur en cours (envoyé seulement sur les tampons créés
  avec `/buffer add`).

| weechat | [[hook_signal_cursor_start]] cursor_start | 3.2
| -
| Début du mode curseur.

| weechat | [[hook_signal_cursor_end]] cursor_end | 3.2
| -
| Fin du mode curseur.

| weechat | [[hook_signal_day_changed]] day_changed | 0.3.2
| Chaîne : nouvelle date, format : "2010-01-31".
| Le jour de la date système a changé.

| weechat | [[hook_signal_debug_dump]] debug_dump |
| Chaîne : nom d'extension.
| Requête de "dump".

| weechat | [[hook_signal_debug_libs]] debug_libs |
| -
| Affichage des bibliothèques externes utilisées.

| weechat | [[hook_signal_filter_added]] filter_added |
| Pointeur : filtre.
| Filtre ajouté.

| weechat | [[hook_signal_filter_removing]] filter_removing |
| Pointeur : filtre.
| Suppression de filtre en cours.

| weechat | [[hook_signal_filter_removed]] filter_removed |
| -
| Filtre supprimé.

| weechat | [[hook_signal_filters_enabled]] filters_enabled |
| -
| Filtres activés.

| weechat | [[hook_signal_filters_disabled]] filters_disabled |
| -
| Filtres désactivés.

| weechat | [[hook_signal_hotlist_changed]] hotlist_changed |
| Pointeur : tampon (peut être NULL).
| La hotlist a changé.

| weechat | [[hook_signal_input_paste_pending]] input_paste_pending |
| -
| Coller de lignes en cours.

| weechat | [[hook_signal_input_search]] input_search |
| Pointeur : tampon.
| Recherche de texte dans le tampon.

| weechat | [[hook_signal_input_prompt_changed]] input_prompt_changed | 4.3.0
| Pointer: buffer.
| Invite de la zone de saisie modifiée.

| weechat | [[hook_signal_input_text_changed]] input_text_changed |
| Pointeur : tampon.
| Texte modifié dans la barre "input".

| weechat | [[hook_signal_input_text_cursor_moved]] input_text_cursor_moved |
| Pointeur : tampon.
| Curseur déplacé dans la barre "input".

| weechat | [[hook_signal_key_bind]] key_bind |
| Chaîne : touche.
| Touche ajoutée.

| weechat | [[hook_signal_key_unbind]] key_unbind |
| Chaîne : touche.
| Touche supprimée.

| weechat | [[hook_signal_key_pressed]] key_pressed |
| Chaîne : touche appuyée.
| Touche appuyée.

| weechat | [[hook_signal_key_combo_default]] key_combo_default | 1.0
| Chaîne : combinaison de touches.
| Combinaison de touches dans le contexte _default_.

| weechat | [[hook_signal_key_combo_search]] key_combo_search | 1.0
| Chaîne : combinaison de touches.
| Combinaison de touches dans le contexte _search_.

| weechat | [[hook_signal_key_combo_cursor]] key_combo_cursor | 1.0
| Chaîne : combinaison de touches.
| Combinaison de touches dans le contexte _cursor_.

| weechat | [[hook_signal_mouse_enabled]] mouse_enabled | 1.1
| -
| Souris activée.

| weechat | [[hook_signal_mouse_disabled]] mouse_disabled | 1.1
| -
| Souris désactivée.

| weechat | [[hook_signal_nicklist_group_added]] nicklist_group_added | 0.3.2
| Chaîne : pointeur tampon + "," + nom du groupe.
| Groupe ajouté dans la liste des pseudos.

| weechat | [[hook_signal_nicklist_group_changed]] nicklist_group_changed | 0.3.4
| Chaîne : pointeur tampon + "," + nom du groupe.
| Groupe modifié dans la liste des pseudos.

| weechat | [[hook_signal_nicklist_group_removing]] nicklist_group_removing | 0.4.1
| Chaîne : pointeur tampon + "," + nom du groupe.
| Suppression du groupe de la liste des pseudos.

| weechat | [[hook_signal_nicklist_group_removed]] nicklist_group_removed | 0.3.2
| Chaîne : pointeur tampon + "," + nom du groupe.
| Groupe supprimé de la liste des pseudos.

| weechat | [[hook_signal_nicklist_nick_added]] nicklist_nick_added | 0.3.2
| Chaîne : pointeur tampon + "," + pseudo.
| Pseudo ajouté dans la liste des pseudos.

| weechat | [[hook_signal_nicklist_nick_changed]] nicklist_nick_changed | 0.3.4
| Chaîne : pointeur tampon + "," + pseudo.
| Pseudo modifié dans la liste des pseudos.

| weechat | [[hook_signal_nicklist_nick_removing]] nicklist_nick_removing | 0.4.1
| Chaîne : pointeur tampon + "," + pseudo.
| Suppression du pseudo de la liste des pseudos.

| weechat | [[hook_signal_nicklist_nick_removed]] nicklist_nick_removed | 0.3.2
| Chaîne : pointeur tampon + "," + pseudo.
| Pseudo supprimé de la liste des pseudos.

| weechat | [[hook_signal_partial_completion]] partial_completion |
| -
| Une complétion partielle a été faite.

| weechat | [[hook_signal_plugin_loaded]] plugin_loaded | 0.3.9
| Chaîne : chemin vers l'extension chargée.
| Extension chargée.

| weechat | [[hook_signal_plugin_unloaded]] plugin_unloaded | 0.3.9
| Chaîne : nom de l'extension déchargée (exemple : "irc").
| Extension déchargée.

| weechat | [[hook_signal_quit]] quit |
| Chaîne : paramètres pour le /quit.
| La commande `/quit` a été exécutée par l'utilisateur.

| weechat | [[hook_signal_signal_sighup]] signal_sighup | 1.3
| -
| Signal SIGHUP reçu.

| weechat | [[hook_signal_signal_sigquit]] signal_sigquit | 1.2
| -
| Signal SIGQUIT reçu (requête pour quitter avec une copie de la mémoire).

| weechat | [[hook_signal_signal_sigterm]] signal_sigterm | 1.2
| -
| Signal SIGTERM reçu (arrêt propre du processus WeeChat).

| weechat | [[hook_signal_signal_sigwinch]] signal_sigwinch | 0.4.3
| -
| Signal SIGWINCH reçu (le terminal a été redimensionné).

| weechat | [[hook_signal_upgrade]] upgrade |
| Chaîne : "quit" si le paramètre "-quit" a été donné pour /upgrade, "-save"
  si le paramètre "-save" a été donné pour /upgrade, sinon NULL.
| La commande `/upgrade` a été exécutée par l'utilisateur.

| weechat | [[hook_signal_upgrade_ended]] upgrade_ended | 0.3.4
| -
| Fin du processus de mise à jour (commande `/upgrade`).

| weechat | [[hook_signal_weechat_highlight]] weechat_highlight |
| Chaîne : message avec le préfixe.
| Un highlight est survenu.

| weechat | [[hook_signal_weechat_pv]] weechat_pv |
| Chaîne : message avec le préfixe.
| Un message privé a été affiché.

| weechat | [[hook_signal_window_closing]] window_closing | 0.3.6
| Pointeur : fenêtre.
| Fermeture de la fenêtre en cours.

| weechat | [[hook_signal_window_closed]] window_closed | 0.3.6
| Pointeur : fenêtre.
| Fenêtre fermée.

| weechat | [[hook_signal_window_opened]] window_opened | 0.4.1
| Pointeur : fenêtre.
| Fenêtre ouverte.

| weechat | [[hook_signal_window_scrolled]] window_scrolled |
| Pointeur : fenêtre.
| Défilement dans la fenêtre.

| weechat | [[hook_signal_window_switch]] window_switch | 0.3.7
| Pointeur : fenêtre.
| Basculement vers une autre fenêtre.

| weechat | [[hook_signal_window_zoom]] window_zoom |
| Pointeur : fenêtre courante.
| Zoom en cours sur la fenêtre.

| weechat | [[hook_signal_window_zoomed]] window_zoomed |
| Pointeur : fenêtre courante.
| Zoom effectué sur la fenêtre.

| weechat | [[hook_signal_window_unzoom]] window_unzoom |
| Pointeur : fenêtre courante.
| Fin du zoom en cours sur la fenêtre.

| weechat | [[hook_signal_window_unzoomed]] window_unzoomed |
| Pointeur : fenêtre courante.
| Fin du zoom effectué sur la fenêtre.

| xfer | [[hook_signal_xfer_add]] xfer_add |
| Pointeur : infolist avec l'info xfer.
| Nouveau xfer.

| xfer | [[hook_signal_xfer_send_ready]] xfer_send_ready |
| Pointeur : infolist avec l'info xfer.
| Xfer prêt.

| xfer | [[hook_signal_xfer_accept_resume]] xfer_accept_resume |
| Pointeur : infolist avec l'info xfer.
| Accepter la reprise xfer.

| xfer | [[hook_signal_xfer_send_accept_resume]] xfer_send_accept_resume |
| Pointeur : infolist avec l'info xfer.
| Reprise xfer acceptée.

| xfer | [[hook_signal_xfer_start_resume]] xfer_start_resume |
| Pointeur : infolist avec l'info xfer.
| Redémarrage.

| xfer | [[hook_signal_xfer_resume_ready]] xfer_resume_ready |
| Pointeur : infolist avec l'info xfer.
| Redémarrage prêt.

| xfer | [[hook_signal_xfer_ended]] xfer_ended | 0.3.2
| Pointeur : infolist avec l'info xfer.
| Le xfer s'est terminé.
|===

[NOTE]
^(1)^ _xxx_ est le nom du serveur IRC, _yyy_ est le nom d'une commande IRC. +
^(2)^ _xxx_ est le nom du tampon.

Exemple en C :

[source,c]
----
int
my_signal_cb (const void *pointer, void *data, const char *signal,
              const char *type_data, void *signal_data)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* intercepter les signaux "quit" et "upgrade" */
struct t_hook *my_signal_hook = weechat_hook_signal ("quit;upgrade",
                                                     &my_signal_cb, NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def hook_signal(signal: str, callback: str, callback_data: str) -> str: ...

# exemple
def my_signal_cb(data: str, signal: str, signal_data: str) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

# intercepter les signaux "quit" et "upgrade"
hook = weechat.hook_signal("quit;upgrade", "my_signal_cb", "")
----

==== hook_signal_send

_Mis à jour dans la 1.0._

Envoyer un signal.

Prototype :

[source,c]
----
int weechat_hook_signal_send (const char *signal, const char *type_data,
                              void *signal_data);
----

Paramètres :

* _signal_ : signal à envoyer
* _type_data_ : type de données à envoyer avec le signal (voir
  <<_hook_signal,hook_signal>>)
* _signal_data_ : données envoyées avec le signal

Valeur de retour _(WeeChat ≥ 1.0)_ :

* code retour de la dernière fonction de rappel exécutée (_WEECHAT_RC_OK_ si
  aucune fonction de rappel n'a été exécuté) :
** _WEECHAT_RC_OK_
** _WEECHAT_RC_OK_EAT_
** _WEECHAT_RC_ERROR_

Exemple en C :

[source,c]
----
int rc = weechat_hook_signal_send ("mon_signal", WEECHAT_HOOK_SIGNAL_STRING, ma_chaine);
----

Script (Python) :

[source,python]
----
# prototype
def hook_signal_send(signal: str, type_data: str, signal_data: str) -> int: ...

# exemple
rc = weechat.hook_signal_send("mon_signal", weechat.WEECHAT_HOOK_SIGNAL_STRING, ma_chaine)
----

[[signal_logger_backlog]]
===== Signal logger_backlog

Le signal "logger_backlog" peut être envoyé pour afficher l'historique de
discussion dans le tampon (par exemple si vous ouvrez votre propre tampon dans
votre extension/script).

Le paramètre est un pointeur vers le tampon.

Exemple en C :

[source,c]
----
weechat_hook_signal_send ("logger_backlog", WEECHAT_HOOK_SIGNAL_POINTER, buffer);
----

Script (Python) :

[source,python]
----
weechat.hook_signal_send("logger_backlog", weechat.WEECHAT_HOOK_SIGNAL_POINTER, buffer)
----

[[signals_xxx_script_install]]
===== Signaux xxx_script_install

Cinq signaux peuvent être envoyés pour installer un script, selon le langage :

* _perl_script_install_
* _python_script_install_
* _ruby_script_install_
* _lua_script_install_
* _tcl_script_install_
* _guile_script_install_
* _javascript_script_install_
* _php_script_install_

La fonction de rappel effectuera les actions suivantes lorsqu'elle recevra le
signal :

. Déchargement et suppression du script installé.
. Déplacement du nouveau script vers le répertoire _~/.local/share/weechat/xxx/_
  (où _xxx_ est le langage).
. Création d'un lien vers le nouveau script dans le répertoire
  _~/.local/share/weechat/xxx/autoload/_ (seulement si le script était déjà
  automatiquement chargé ou si l'option _script.scripts.autoload_ est activée
  pour un nouveau script).
. Chargement du nouveau script (si le script était chargé).

Ces signaux sont utilisés par l'extension _script_ pour installer des scripts.

Le paramètre est une chaîne avec le chemin vers le script à installer.

Exemple en C :

[source,c]
----
weechat_hook_signal_send ("python_script_install", WEECHAT_HOOK_SIGNAL_STRING, "/path/to/test.py");
----

Script (Python) :

[source,python]
----
weechat.hook_signal_send("python_script_install", WEECHAT_HOOK_SIGNAL_STRING, "/path/to/test.py")
----

[[signals_xxx_script_remove]]
===== Signaux xxx_script_remove

Cinq signaux peuvent être envoyés pour supprimer une liste de scripts, selon le
langage :

* _perl_script_remove_
* _python_script_remove_
* _ruby_script_remove_
* _lua_script_remove_
* _tcl_script_remove_
* _guile_script_remove_
* _javascript_script_remove_
* _php_script_remove_

Pour chaque script dans la liste, la fonction de rappel déchargera et
supprimera le script.

Ces signaux sont utilisés par l'extension _script_ pour supprimer des scripts.

Le paramètre est une chaîne avec une liste de scripts à supprimer (séparés par
des virgules, nom du script sans le chemin, par exemple _script.py_).

Exemple en C :

[source,c]
----
/* décharge et supprime les scripts test.py et script.py */
weechat_hook_signal_send ("python_script_remove", WEECHAT_HOOK_SIGNAL_STRING,
                          "test.py,script.py");
----

Script (Python) :

[source,python]
----
# décharge et supprime les scripts test.py et script.py
weechat.hook_signal_send("python_script_remove", WEECHAT_HOOK_SIGNAL_STRING,
                         "test.py,script.py")
----

[[signal_irc_input_send]]
===== Signal irc_input_send

_WeeChat ≥ 0.3.4, mis à jour dans la 1.5._

Le signal "irc_input_send" peut être envoyé pour simuler une entrée de texte
dans un tampon irc (serveur, canal ou privé).

Le paramètre est une chaîne avec le format suivant :

* nom interne du serveur (requis)
* point-virgule
* nom de canal (optionnel)
* point-virgule
* liste d'options séparées par des virgules (optionnel) :
** _priority_high_ : file d'attente avec haute priorité (comme les messages
   utilisateur) ; c'est la priorité par défaut
** _priority_low_ : file d'attente avec basse priorité (comme les messages
   envoyés automatiquement par WeeChat)
** _user_message_ : forcer un message utilisateur (ne pas exécuter de commande)
* point-virgule
* liste d'étiquettes (séparées par des virgules) utilisées lors de l'envoi du
  message (optionnel)
* point-virgule
* texte ou commande (requis)

Exemples en C :

[source,c]
----
/* dis "Bonjour !" sur le serveur libera, canal #weechat */
weechat_hook_signal_send ("irc_input_send", WEECHAT_HOOK_SIGNAL_STRING,
                          "libera;#weechat;priority_high,user_message;;Bonjour !");

/* envoie la commande "/whois FlashCode" sur le canal libera, en basse priorité */
weechat_hook_signal_send ("irc_input_send", WEECHAT_HOOK_SIGNAL_STRING,
                          "libera;;priority_low;;/whois FlashCode");
----

Script (Python) :

[source,python]
----
# dis "Bonjour !" sur le serveur libera, canal #weechat
weechat.hook_signal_send("irc_input_send", weechat.WEECHAT_HOOK_SIGNAL_STRING,
                         "libera;#weechat;priority_high,user_message;;Bonjour !")

# envoie la commande "/whois FlashCode" sur le canal libera, en basse priorité
weechat.hook_signal_send("irc_input_send", weechat.WEECHAT_HOOK_SIGNAL_STRING,
                         "libera;;priority_low;;/whois FlashCode")
----

==== hook_hsignal

_WeeChat ≥ 0.3.4, mis à jour dans la 1.5, 3.6._

S'accrocher à un hsignal (signal avec une table de hachage).

Prototype :

[source,c]
----
struct t_hook *weechat_hook_hsignal (const char *signal,
                                     int (*callback)(const void *pointer,
                                                     void *data,
                                                     const char *signal,
                                                     struct t_hashtable *hashtable),
                                     const void *callback_pointer,
                                     void *callback_data);
----

Paramètres :

* _signal_ : signal à intercepter, le caractère joker `+*+` est autorisé,
  plusieurs signaux peuvent être séparés par des point-virgules
  (une priorité est autorisée avant le ou les signaux, voir la note sur la <<hook_priority,priorité>>)
  (voir le tableau ci-dessous)
* _callback_ : fonction appelée quand le signal est reçu, paramètres et valeur
  de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _const char *signal_ : signal reçu
** _struct t_hashtable *hashtable_ : table de hachage
** valeur de retour :
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_OK_EAT_ (arrêter l'envoi du signal immédiatement)
    _(WeeChat ≥ 0.4.0)_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat
* _callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou une
  fonction similaire) et est automatiquement libéré (par free) lorsque le
  "hook" est supprimé

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Liste des hsignaux envoyés par WeeChat et les extensions :

[width="100%",cols="^1,^3,^1,5,5",options="header"]
|===
| Extension | Signal | WeeChat mini | Paramètres | Description

| irc | [[hook_hsignal_irc_redirection_xxx_yyy]] irc_redirection_xxx_yyy ^(1)^ | 0.3.4
| Voir <<hsignal_irc_redirect_command,hsignal_irc_redirect_command>>
| Sortie de la redirection.

| weechat | [[hook_hsignal_nicklist_group_added]] nicklist_group_added | 0.4.1
| _buffer_ (_struct t_gui_buffer *_) : tampon +
  _parent_group_ (_struct t_gui_nick_group *_) : groupe parent +
  _group_ (_struct t_gui_nick_group *_) : groupe
| Groupe ajouté dans la liste de pseudos.

| weechat | [[hook_hsignal_nicklist_nick_added]] nicklist_nick_added | 0.4.1
| _buffer_ (_struct t_gui_buffer *_) : tampon +
  _parent_group_ (_struct t_gui_nick_group *_) : groupe parent +
  _nick_ (_struct t_gui_nick *_) : pseudo
| Pseudo ajouté dans la liste de pseudos.

| weechat | [[hook_hsignal_nicklist_group_removing]] nicklist_group_removing | 0.4.1
| _buffer_ (_struct t_gui_buffer *_) : tampon +
  _parent_group_ (_struct t_gui_nick_group *_) : groupe parent +
  _group_ (_struct t_gui_nick_group *_) : groupe
| Suppression d'un groupe de la liste de pseudos.

| weechat | [[hook_hsignal_nicklist_nick_removing]] nicklist_nick_removing | 0.4.1
| _buffer_ (_struct t_gui_buffer *_) : tampon +
  _parent_group_ (_struct t_gui_nick_group *_) : groupe parent +
  _nick_ (_struct t_gui_nick *_) : pseudo
| Suppression d'un pseudo de la liste de pseudos.

| weechat | [[hook_hsignal_nicklist_group_changed]] nicklist_group_changed | 0.4.1
| _buffer_ (_struct t_gui_buffer *_) : tampon +
  _parent_group_ (_struct t_gui_nick_group *_) : groupe parent +
  _group_ (_struct t_gui_nick_group *_) : groupe
| Groupe changé dans la liste de pseudos.

| weechat | [[hook_hsignal_nicklist_nick_changed]] nicklist_nick_changed | 0.4.1
| _buffer_ (_struct t_gui_buffer *_) : tampon +
  _parent_group_ (_struct t_gui_nick_group *_) : parent +
  _nick_ (_struct t_gui_nick *_) : pseudo
| Pseudo changé dans la liste de pseudos.
|===

[NOTE]
^(1)^ _xxx_ est l'argument "signal" utilisé dans la redirection, _yyy_ est le
modèle de redirection ("pattern").

Exemple en C :

[source,c]
----
int
my_hsignal_cb (const void *pointer, void *data, const char *signal,
               struct t_hashtable *hashtable)
{
    /* ... */
    return WEECHAT_RC_OK;
}

struct t_hook *my_hsignal_hook = weechat_hook_hsignal ("test",
                                                       &my_hsignal_cb, NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def hook_hsignal(signal: str, callback: str, callback_data: str) -> str: ...

# exemple
def my_hsignal_cb(data: str, signal: str, hashtable: Dict[str, str]) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_hsignal("test", "my_hsignal_cb", "")
----

==== hook_hsignal_send

_WeeChat ≥ 0.3.4, mis à jour dans la 1.0._

Envoyer un hsignal (signal avec table de hachage).

Prototype :

[source,c]
----
int weechat_hook_hsignal_send (const char *signal, struct t_hashtable *hashtable);
----

Paramètres :

* _signal_ : signal à envoyer
* _hashtable_ : table de hachage

Valeur de retour _(WeeChat ≥ 1.0)_ :

* code retour de la dernière fonction de rappel exécutée (_WEECHAT_RC_OK_ si
  aucune fonction de rappel n'a été exécutée) :
** _WEECHAT_RC_OK_
** _WEECHAT_RC_OK_EAT_
** _WEECHAT_RC_ERROR_

Exemple en C :

[source,c]
----
int rc;
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
if (hashtable)
{
    weechat_hashtable_set (hashtable, "clé", "valeur");
    rc = weechat_hook_hsignal_send ("my_hsignal", hashtable);
    weechat_hashtable_free (hashtable);
}
----

Script (Python) :

[source,python]
----
# prototype
def hook_hsignal_send(signal: str, hashtable: Dict[str, str]) -> int: ...

# exemple
rc = weechat.hook_hsignal_send("my_hsignal", {"clé": "valeur"})
----

[[hsignal_irc_redirect_command]]
===== Hsignal irc_redirect_command

_WeeChat ≥ 0.3.4._

Le hsignal "irc_redirect_command" peut être envoyé pour rediriger la sortie
d'une commande irc vers une fonction de rappel.

Le paramètre est une table de hachage avec les entrées suivantes (les clés et
valeurs sont des chaînes) :

* _server_ : nom interne du serveur (requis)
* _pattern_ : modèle de redirection à utiliser (requis), soit un par défaut
  (défini par l'extension irc), ou un modèle utilisateur (voir
  <<hsignal_irc_redirect_pattern>>), les modèles par défaut sont :
** _ison_
** _list_
** _mode_channel_
** _mode_channel_ban_ ("mode #channel b")
** _mode_channel_ban_exception_ ("mode #channel e")
** _mode_channel_invite_ ("mode #channel I")
** _mode_user_
** _monitor_
** _names_
** _ping_
** _time_
** _topic_
** _userhost_
** _who_
** _whois_
** _whowas_
* _signal_ : nom du signal (requis)
* _count_ : nombre de fois que la redirection sera exécutée (optionnel, 1 par
  défaut)
* _string_ : chaîne qui doit être dans les messages irc reçus (optionnel, mais
  recommandé, si une chaîne peut être utilisée pour identifier les messages)
* _timeout_ : temps d'attente maximum pour la redirection, en secondes
  (optionnel, 60 par défaut)
* _cmd_filter_ : liste de commandes irc (séparées par des virgules) à filtrer
  (seules ces commandes seront transmises à la fonction de rappel, les autres
  seront ignorées) (optionnel)

Immédiatement après l'envoi de ce hsignal, vous devez envoyer la commande au
serveur irc, et la redirection sera utilisée pour cette commande.

Lorsque la réponse complète à votre commande a été reçue, un hsignal est envoyé.
Ce hsignal a le nom _irc_redirection_xxx_yyy_ où _xxx_ est le _signal_ et _yyy_
le _pattern_ utilisé.

La table de hachage envoyée dans le hsignal a le contenu suivant (les clés et
valeurs sont des chaînes) :

* _output_ : sortie de la commande (les messages sont séparés par "\n")
* _output_size_ : nombre d'octets dans _output_ (sous forme de chaîne)
* _error_ : chaîne d'erreur (si une erreur s'est produite) :
** _timeout_ : redirection stoppée après le délai maximum dépassé
* _server_ : nom interne du serveur
* _pattern_ : modèle de redirection
* _signal_ : nom du signal
* _command_ : commande redirigée

Exemple en C :

[source,c]
----
int
test_whois_cb (const void *pointer, void *data, const char *signal,
               struct t_hashtable *hashtable)
{
    weechat_printf (NULL, "erreur = %s", weechat_hashtable_get (hashtable, "error"));
    weechat_printf (NULL, "sortie = %s", weechat_hashtable_get (hashtable, "output"));
    return WEECHAT_RC_OK;
}

weechat_hook_hsignal ("irc_redirection_test_whois", &test_whois_cb, NULL, NULL);
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
if (hashtable)
{
    weechat_hashtable_set (hashtable, "server", "libera");
    weechat_hashtable_set (hashtable, "pattern", "whois");
    weechat_hashtable_set (hashtable, "signal", "test");
    weechat_hashtable_set (hashtable, "string", "FlashCode");
    weechat_hook_hsignal_send ("irc_redirect_command", hashtable);
    weechat_hook_signal_send ("irc_input_send", WEECHAT_HOOK_SIGNAL_STRING,
                              "libera;;2;;/whois FlashCode");
    weechat_hashtable_free (hashtable);
}
----

Script (Python) :

[source,python]
----
def test_whois_cb(data: str, signal: str, hashtable: Dict[str, str]) -> int:
    weechat.prnt("", "erreur = %s" % hashtable["error"])
    weechat.prnt("", "sortie = %s" % hashtable["output"])
    return weechat.WEECHAT_RC_OK

weechat.hook_hsignal("irc_redirection_test_whois", "test_whois_cb", "")
weechat.hook_hsignal_send("irc_redirect_command",
                          {"server": "libera", "pattern": "whois", "signal": "test",
                           "string": "FlashCode"})
weechat.hook_signal_send("irc_input_send", weechat.WEECHAT_HOOK_SIGNAL_STRING,
                         "libera;;2;;/whois FlashCode")
----

[[hsignal_irc_redirect_pattern]]
===== Hsignal irc_redirect_pattern

_WeeChat ≥ 0.3.4._

Le hsignal "irc_redirect_pattern" peut être envoyé pour créer un modèle de
redirection irc (voir <<hsignal_irc_redirect_command>>).

Le paramètre est une table de hachage avec les entrées suivantes (les clés et
valeurs sont des chaînes) :

* _pattern_ : nom du modèle (requis)
* _timeout_ : temps d'attente maximum pour le modèle, en secondes (optionnel, 60
  par défaut)
* _cmd_start_ : liste de commandes (séparées par des virgules) démarrant la
  redirection (optionnel)
* _cmd_stop_ : liste de commandes (séparées par des virgules) stoppant la
  redirection (requis)
* _cmd_extra_ : liste de commandes (séparées par des virgules) pouvant être
  reçues après les commandes de stop (optionnel)

Pour chaque commande dans _cmd_start_, _cmd_stop_ et _cmd_extra_, il est
possible de donner un entier avec la position de la chaîne "string" qui doit
être trouvée dans le message reçu, par exemple :

----
352:1,354,401:1
----

Pour les commandes 352 et 401, la chaîne "string" doit être trouvée dans le
message reçu, comme premier paramètre.

[IMPORTANT]
Le modèle est détruit dès qu'il est utilisé dans une redirection. Si vous avez
besoin du modèle pour plusieurs redirections, vous devez créer un modèle pour
chaque redirection.

Exemple en C :

[source,c]
----
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
if (hashtable)
{
    weechat_hashtable_set (hashtable, "pattern", "my_whois");
    weechat_hashtable_set (hashtable, "timeout", "30");
    weechat_hashtable_set (hashtable, "cmd_start", "311:1");
    weechat_hashtable_set (hashtable, "cmd_stop", "318:1,401:1,402:1,431:1,461");
    weechat_hashtable_set (hashtable, "cmd_extra", "318:1");
    weechat_hook_hsignal_send ("irc_redirect_pattern", hashtable);
    /*
     * rediriger maintenant la commande irc whois avec le hsignal irc_redirect_command,
     * en utilisant le modèle "my_whois"
     */
    /* ... */
    weechat_hashtable_free (hashtable);
}
----

Script (Python) :

[source,python]
----
weechat.hook_hsignal_send("irc_redirect_pattern",
                          {"pattern": "my_whois", "timeout": "30",
                           "cmd_start": "311:1",
                           "cmd_stop": "318:1,401:1,402:1,431:1,461",
                           "cmd_extra": "318:1"})
# rediriger maintenant la commande irc whois avec le hsignal irc_redirect_command,
# en utilisant le modèle "my_whois"
# ...
----

==== hook_config

_Mis à jour dans la 1.5._

S'accrocher à une option de configuration.

Prototype :

[source,c]
----
struct t_hook *weechat_hook_config (const char *option,
                                    int (*callback)(const void *pointer,
                                                    void *data,
                                                    const char *option,
                                                    const char *value),
                                    const void *callback_pointer,
                                    void *callback_data);
----

Paramètres :

* _option_ : option, le format est le nom complet, celui utilisé avec la
  commande `/set` (par exemple : `+weechat.look.item_time_format+`), le caractère
  joker `+*+` est autorisé
  (une priorité est autorisée avant l'option, voir la note sur la <<hook_priority,priorité>>)
* _callback_ : fonction appelée lorsque l'option de configuration est modifiée,
  paramètres et valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _const char *option_ : nom de l'option
** _const char *value_ : nouvelle valeur pour l'option
** valeur de retour :
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelé par WeeChat
* _callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou une
  fonction similaire) et est automatiquement libéré (par free) lorsque le
  "hook" est supprimé

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,c]
----
int
my_config_cb (const void *pointer, void *data, const char *option,
              const char *value)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* intercepter les changements de l'option "weechat.look.item_time_format" */
struct t_hook *my_config_hook = weechat_hook_config ("weechat.look.item_time_format",
                                                     &my_config_cb, NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def hook_config(option: str, callback: str, callback_data: str) -> str: ...

# exemple
def my_config_cb(data: str, option: str, value: str) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

# intercepter les changements de l'option "weechat.look.item_time_format"
hook = weechat.hook_config("weechat.look.item_time_format", "my_config_cb", "")
----

==== hook_modifier

_Mis à jour dans la 1.5._

Accrocher un modificateur.

Prototype :

[source,c]
----
struct t_hook *weechat_hook_modifier (const char *modifier,
                                      char *(*callback)(const void *pointer,
                                                        void *data,
                                                        const char *modifier,
                                                        const char *modifier_data,
                                                        const char *string),
                                      const void *callback_pointer,
                                      void *callback_data);
----

Paramètres :

* _modifier_ : nom du modificateur
  (une priorité est autorisée avant le modificateur, voir la note sur la <<hook_priority,priorité>>)
  (voir le tableau ci-dessous)
* _callback_ : fonction appelée lorsque le modificateur est utilisé, paramètres
  et valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _const char *modifier_ : nom du modificateur
** _const char *modifier_data_ : données pour le modificateur
** _const char *string_ : chaîne à modifier
** valeur de retour : nouvelle chaîne
* _callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat
* _callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou une
  fonction similaire) et est automatiquement libéré (par free) lorsque le
  "hook" est supprimé

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Liste des modificateurs utilisés par WeeChat et les extensions :

[width="100%",cols="^2,^1,3,4,4",options="header"]
|===
| Modificateur | WeeChat mini | Données du modificateur | Chaîne | Sortie

| [[hook_modifier_irc_batch]] irc_batch | 4.0.0
| Nom de serveur + "," + type de batch + "," + paramètres du batch
| Contenu de plusieurs messages, séparés par un caractère de retour chariot ("\n").
| Nouveau contenu des messages (le nombre peut être différent), une chaîne vide
  annule tous les messages du batch.

| [[hook_modifier_irc_cap_sync_req]] irc_cap_sync_req | 4.0.0
| Nom de serveur + "," + capacités supportées par le serveur (séparées par
  des espaces)
| Capacités à demander (séparées par des espaces).
| Nouveau contenu des capacités à demander (séparées par des espaces).

| [[hook_modifier_irc_in_xxx]] irc_in_xxx ^(1)^ |
| Nom de serveur
| Contenu du message reçu du serveur IRC (avant décodage du jeu de caractères). +
  *Attention :* la chaîne peut contenir des données invalides UTF-8 ; à utiliser
  seulement pour les opérations de bas niveau sur le message.
  Le modificateur <<hook_modifier_irc_in2_xxx,irc_in2_xxx>> est recommandé à la
  place de celui-ci.
| Nouveau contenu du message.

| [[hook_modifier_irc_in2_xxx]] irc_in2_xxx ^(1)^ | 0.3.5
| Nom de serveur
| Contenu du message reçu du serveur IRC (après décodage du jeu de caractères).
| Nouveau contenu du message.

| [[hook_modifier_irc_out1_xxx]] irc_out1_xxx ^(1)^ | 0.3.7
| Nom de serveur
| Contenu du message qui va être envoyé au serveur IRC avant découpage automatique
  (pour tenir dans les 512 octets par défaut).
| Nouveau contenu du message.

| [[hook_modifier_irc_out_xxx]] irc_out_xxx ^(1)^ |
| Nom de serveur
| Contenu du message qui va être envoyé au serveur IRC après découpage automatique
  (pour tenir dans les 512 octets par défaut).
| Nouveau contenu du message.

| [[hook_modifier_relay_client_irc_in]] relay_client_irc_in | 4.0.0
| Chaîne avec un pointeur vers le client relay (par exemple : "0x1234abcd")
| Contenu du message reçu du client relay IRC.
| Nouveau contenu du message.

| [[hook_modifier_relay_client_irc_out1]] relay_client_irc_out1 | 4.0.0
| Chaîne avec un pointeur vers le client relay (par exemple : "0x1234abcd")
| Contenu du message qui va être envoyé au client relay IRC avant découpage automatique
  (pour tenir dans les 512 octets par défaut).
| Nouveau contenu du message.

| [[hook_modifier_relay_client_irc_out]] relay_client_irc_out | 4.0.0
| Chaîne avec un pointeur vers le client relay (par exemple : "0x1234abcd")
| Contenu du message qui va être envoyé au client relay IRC après découpage automatique
  (pour tenir dans les 512 octets par défaut).
| Nouveau contenu du message.

| [[hook_modifier_bar_condition_yyy]] bar_condition_yyy ^(2)^ |
| Chaîne avec un pointeur vers la fenêtre (par exemple : "0x1234abcd")
| Chaîne vide.
| "1" pour afficher la barre, "0" pour la cacher.

| [[hook_modifier_history_add]] history_add | 0.3.2
| Chaîne avec un pointeur vers le tampon (par exemple : "0x1234abcd")
| Contenu de la ligne de commande à ajouter à l'historique des commandes
  (tampon et global).
| Chaîne ajoutée à l'historique des commandes.

| [[hook_modifier_input_text_content]] input_text_content |
| Chaîne avec un pointeur vers le tampon (par exemple : "0x1234abcd")
| Contenu de la ligne de commande.
| Nouvelle chaîne pour la ligne de commande.

| [[hook_modifier_input_text_display]] input_text_display |
| Chaîne avec un pointeur vers le tampon (par exemple : "0x1234abcd")
| Contenu de la ligne de commande, sans le code du curseur dedans.
| Nouvelle chaîne, pour affichage seulement (la ligne de commande n'est pas
  modifiée).

| [[hook_modifier_input_text_display_with_cursor]] input_text_display_with_cursor |
| Chaîne avec un pointeur vers le tampon (par exemple : "0x1234abcd")
| Contenu de la ligne de commande, avec le code du curseur dedans.
| Nouvelle chaîne, pour affichage seulement (la ligne de commande n'est pas
  modifiée).

| [[hook_modifier_input_text_for_buffer]] input_text_for_buffer | 0.3.7
| Chaîne avec un pointeur vers le tampon (par exemple : "0x1234abcd")
| Contenu de la ligne de commande envoyée au tampon (texte ou commande).
| Nouveau contenu de la ligne de commande envoyée au tampon.

| [[hook_modifier_weechat_print]] weechat_print |
| pointeur vers le tampon (par exemple : "0x1234abcd") + ";" + étiquettes ^(3)^
| Message affiché.
| Nouveau message affiché. +
  Pour plus d'informations sur les "hooks" appelés lorsqu'une ligne est affichée,
  voir <<_hook_line,hook_line>>.
|===

[NOTE]
^(1)^ _xxx_ est un nom de commande IRC. +
^(2)^ _yyy_ est le nom de la barre. +
^(3)^ Avec WeeChat ≤ 2.8, le format était : extension + ";" + nom_tampon + ";" + étiquettes.

Exemple en C :

[source,c]
----
char *
my_modifier_cb (const void *pointer, void *data, const char *modifier,
                const char *modifier_data,
                const char *string)
{
    char *result;
    int length;

    if (!string)
        return NULL;

    length = strlen (string) + 5;
    result = malloc (length);
    if (result)
    {
        /* ajouter "xxx" à chaque message affiché */
        snprintf (result, length, "%s xxx", string);
    }

    return result;
}

struct t_hook *my_modifier_hook = weechat_hook_modifier ("weechat_print",
                                                         &my_modifier_cb, NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def hook_modifier(modifier: str, callback: str, callback_data: str) -> str: ...

# exemple
def my_modifier_cb(data: str, modifier: str, modifier_data: str, string: str) -> str:
    return "%s xxx" % string

hook = weechat.hook_modifier("weechat_print", "my_modifier_cb", "")
----

==== hook_modifier_exec

Exécuter un ou plusieurs modificateurs.

Prototype :

[source,c]
----
char *weechat_hook_modifier_exec (const char *modifier,
                                  const char *modifier_data,
                                  const char *string);
----

Paramètres :

* _modifier_ : nom du modificateur
* _modifier_data_ : données du modificateur
* _string_ : chaîne à modifier

Valeur de retour :

* chaîne modifiée, NULL en cas d'erreur

Liste des modificateurs définis par WeeChat et les extensions qui peuvent être
utilisés :

[width="100%",cols="^2,^1,3,4,4",options="header"]
|===
| Modificateur | WeeChat mini | Données du modificateur | Chaîne | Sortie

| [[hook_modifier_charset_decode]] charset_decode |
| extension.nom_tampon
| Toute chaîne.
| Chaîne décodée depuis le jeu de caractères trouvé pour l'extension/tampon
  vers UTF-8.

| [[hook_modifier_charset_encode]] charset_encode |
| extension.nom_tampon
| Toute chaîne.
| Chaîne encodée depuis UTF-8 vers le jeu de caractères trouvé pour
  l'extension/tampon.

| [[hook_modifier_irc_color_decode]] irc_color_decode |
| "1" pour garder les couleurs, "0" pour les supprimer
| Toute chaîne.
| Chaîne avec les couleurs IRC converties en couleurs WeeChat (ou avec les
  couleurs IRC supprimées).

| [[hook_modifier_irc_color_encode]] irc_color_encode |
| "1" pour garder les couleurs, "0" pour les supprimer
| Toute chaîne.
| Chaîne avec les couleurs IRC (ou avec les couleurs IRC supprimées).

| [[hook_modifier_irc_color_decode_ansi]] irc_color_decode_ansi | 1.0
| "1" pour garder les couleurs, "0" pour les supprimer
| Toute chaîne.
| Chaîne avec les couleurs ANSI converties en couleurs IRC (ou avec les couleurs
  ANSI supprimées).

| [[hook_modifier_irc_command_auth]] irc_command_auth | 0.4.1
| Nom du serveur
| Commande d'authentification (par exemple : `+/msg nickserv identify password+`).
| Commande avec le mot de passe caché (par exemple : `+/msg nickserv identify ********+`).

| [[hook_modifier_irc_message_auth]] irc_message_auth | 0.4.1
| Nom du serveur
| Message affiché après `msg` envoyé à nickserv.
| Message avec le mot de passe caché.

| [[hook_modifier_irc_tag_escape_value]] irc_tag_escape_value | 3.3
| -
| Toute chaîne.
| Chaîne avec la valeur de l'étiquette IRC échappée,
  voir https://ircv3.net/specs/extensions/message-tags#escaping-values[cette page ^↗^^].

| [[hook_modifier_irc_tag_unescape_value]] irc_tag_unescape_value | 3.3
| -
| Toute chaîne.
| Chaîne avec la valeur de l'étiquette IRC sans échappements,
  voir https://ircv3.net/specs/extensions/message-tags#escaping-values[cette page ^↗^^].

| [[hook_modifier_color_decode]] color_decode | 4.3.0
| Chaîne de remplacement pour les couleurs supprimées
| Toute chaîne.
| Chaîne avec les couleurs WeeChat converties vers la chaîne de remplacement
  (couleurs supprimées si la chaîne de remplacement est vide).

| [[hook_modifier_color_decode_ansi]] color_decode_ansi | 1.0
| "1" pour garder les couleurs, "0" pour les supprimer
| Toute chaîne.
| Chaîne avec les couleurs ANSI converties en couleurs WeeChat (ou avec les
  couleurs ANSI supprimées).

| [[hook_modifier_color_encode_ansi]] color_encode_ansi | 2.7
| -
| Toute chaîne.
| Chaîne avec les couleurs WeeChat converties en couleurs ANSI.

| [[hook_modifier_eval_path_home]] eval_path_home | 2.7
| Facultatif : `directory=xxx` où `xxx` peut être : `config`, `data`, `cache`, `runtime`
| Toute chaîne.
| Chemin évalué, résultat de la fonction
  <<_string_eval_path_home,string_eval_path_home>>.
|===

Exemple en C :

[source,c]
----
char *new_string = weechat_hook_modifier_exec ("mon_modifier",
                                               mes_donnees, ma_chaine);
----

Script (Python) :

[source,python]
----
# prototype
def hook_modifier_exec(modifier: str, modifier_data: str, string: str) -> str: ...

# exemple
weechat.hook_modifier_exec("mon_modifier", mes_donnees, ma_chaine)
----

==== hook_info

_Mis à jour dans la 1.5, 2.5._

Accrocher une information (la fonction de rappel prend et retourne une chaîne).

Prototype :

[source,c]
----
struct t_hook *weechat_hook_info (const char *info_name,
                                  const char *description,
                                  const char *args_description,
                                  char *(*callback)(const void *pointer,
                                                    void *data,
                                                    const char *info_name,
                                                    const char *arguments),
                                  const void *callback_pointer,
                                  void *callback_data);
----

Paramètres :

* _info_name_ : nom de l'information
  (une priorité est autorisée avant le nom de l'information, voir la note sur la <<hook_priority,priorité>>)
* _description_ : description
* _args_description_ : description des paramètres (optionnel, peut être NULL)
* _callback_ : fonction appelée quand l'information est demandée, paramètres et
  valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _const char *info_name_ : nom de l'information
** _const char *arguments_ : paramètres additionnels, dépendant de
   l'information
** valeur de retour : valeur de l'information demandée
* _callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat
* _callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou une
  fonction similaire) et est automatiquement libéré (par free) lorsque le
  "hook" est supprimé

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

[NOTE]
Avec WeeChat ≥ 2.5, la fonction de rappel renvoie une chaîne allouée
(avec WeeChat ≤ 2.4, il s'agissait d'un pointeur vers une chaîne statique).

Exemple en C :

[source,c]
----
char *
my_info_cb (const void *pointer, void *data, const char *info_name,
            const char *arguments)
{
    /* ... */
    return strdup ("some_info");
}

/* ajoute l'information "mon_info" */
struct t_hook *my_info_hook = weechat_hook_info ("mon_info",
                                                 "Une information",
                                                 "Info sur les paramètres",
                                                 &my_info_cb, NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def hook_info(info_name: str, description: str, args_description: str,
              callback: str, callback_data: str) -> str: ...

# exemple
def my_info_cb(data: str, info_name: str, arguments: str) -> str:
    return "some_info"

hook = weechat.hook_info("mon_info", "Une information", "Info sur les paramètres",
                         "my_info_cb", "")
----

==== hook_info_hashtable

_WeeChat ≥ 0.3.4, mis à jour dans la 1.5._

Accrocher une information (la fonction de rappel prend et retourne une table de
hachage).

Prototype :

[source,c]
----
struct t_hook *weechat_hook_info_hashtable (const char *info_name,
                                            const char *description,
                                            const char *args_description,
                                            const char *output_description,
                                            struct t_hashtable *(*callback)(const void *pointer,
                                                                            void *data,
                                                                            const char *info_name,
                                                                            struct t_hashtable *hashtable),
                                            const void *callback_pointer,
                                            void *callback_data);
----

Paramètres :

* _info_name_ : nom de l'information
  (une priorité est autorisée avant le nom de l'information, voir la note sur la <<hook_priority,priorité>>)
* _description_ : description
* _args_description_ : description de la table de hachage attendue
  (optionnel, peut être NULL)
* _output_description_ : description de la table de hachage retournée par la
  fonction de rappel (optionnel, peut être NULL)
* _callback_ : fonction appelée quand l'information est demandée, paramètres et
  valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _const char *info_name_ : nom de l'information
** _struct t_hashtable *hashtable_ : table de hachage, dépendant de
   l'information
** valeur de retour : table de hachage demandée
* _callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat
* _callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou une
  fonction similaire) et est automatiquement libéré (par free) lorsque le
  "hook" est supprimé

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,c]
----
struct t_hashtable *
my_info_hashtable_cb (const void *pointer, void *data, const char *info_name,
                      struct t_hashtable *hashtable)
{
    /* ... */
    return pointer_vers_nouvelle_table_de_hachage;
}

/* ajoute l'information "mon_info_hashtable" */
struct t_hook *my_info_hook = weechat_hook_info_hashtable ("mon_info_hashtable",
                                                           "Une information",
                                                           "Info sur la table de hachage en entrée",
                                                           "Info sur la table de hachage en sortie",
                                                           &my_info_hashtable_cb, NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def hook_info_hashtable(info_name: str, description: str, args_description: str,
                        output_description: str, callback: str, callback_data: str) -> str: ...

# exemple
def my_info_hashtable_cb(data: str, info_name: str, hashtable: Dict[str, str]) -> Dict[str, str]:
    return {"test_cle": "test_valeur"}

hook = weechat.hook_info_hashtable("mon_info_hashtable", "Une information",
                                   "Info sur la table de hachage en entrée",
                                   "Info sur la table de hachage en sortie",
                                   "my_info_hashtable_cb", "")
----

==== hook_infolist

_Mis à jour dans la 1.5._

Accrocher une infolist : la fonction de rappel retournera un pointeur vers
l'infolist demandée.

Prototype :

[source,c]
----
struct t_hook *weechat_hook_infolist (const char *infolist_name,
                                      const char *description,
                                      const char *pointer_description,
                                      const char *args_description,
                                      struct t_infolist *(*callback)(const void *pointer,
                                                                     void *data,
                                                                     const char *infolist_name,
                                                                     void *obj_pointer,
                                                                     const char *arguments),
                                      const void *callback_pointer,
                                      void *callback_data);
----

Paramètres :

* _infolist_name_ : nom de l'infolist
  (une priorité est autorisée avant le nom de l'infolist, voir la note sur la <<hook_priority,priorité>>)
* _description_ : description
* _pointer_description_ : description du pointeur (optionnel, peut être NULL)
* _args_description_ : description des paramètres (optionnel, peut être NULL)
* _callback_ : fonction appelée quand l'infolist est demandée, paramètres et
  valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _const char *infolist_name_ : nom de l'infolist
** _void *pointer_ : pointeur vers un objet que l'infolist doit retourner (pour
   obtenir uniquement cet objet dans l'infolist)
** _const char *arguments_ : paramètres additionnels, dépendant de l'infolist
** valeur de retour : infolist demandée
* _callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat
* _callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou une
  fonction similaire) et est automatiquement libéré (par free) lorsque le
  "hook" est supprimé

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,c]
----
struct t_infolist *
my_infolist_cb (const void *pointer, void *data, const char *infolist_name,
                void *obj_pointer, const char *arguments)
{
    struct t_infolist *mon_infolist;

    /* construction de l'infolist */
    /* ... */

    return mon_infolist;
}

/* ajoute l'infolist "mon_infolist" */
struct t_hook *my_infolist = weechat_hook_infolist ("mon_infolist",
                                                    "Mon infolist",
                                                    "Info sur le pointeur",
                                                    "Info sur les paramètres",
                                                    &my_infolist_cb, NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def hook_infolist(infolist_name: str, description: str, pointer_description: str,
                  args_description: str, callback: str, callback_data: str) -> str: ...

# exemple
def my_infolist_cb(data: str, infolist_name: str, pointer: str, arguments: str) -> str:
    # construction de l'infolist
    # ...
    return my_infolist

hook = weechat.hook_infolist("mon_infolist", "Mon infolist",
                             "Info sur le pointeur", "Info sur les paramètres",
                             "my_infolist_cb", "")
----

==== hook_hdata

_Mis à jour dans la 1.5._

Accrocher un hdata : la fonction de rappel retournera un pointeur vers le hdata
demandé.

Prototype :

[source,c]
----
struct t_hook *weechat_hook_hdata (const char *hdata_name,
                                   const char *description,
                                   struct t_hdata *(*callback)(const void *pointer,
                                                               void *data,
                                                               const char *hdata_name),
                                   const void *callback_pointer,
                                   void *callback_data);
----

Paramètres :

* _hdata_name_ : nom du hdata
  (une priorité est autorisée avant le nom du hdata, voir la note sur la <<hook_priority,priorité>>)
* _description_ : description
* _callback_ : fonction appelée quand le hdata est demandé, paramètres et valeur
  de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _const char *hdata_name_ : nom du hdata
** valeur de retour : hdata demandé
* _callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat
* _callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou une
  fonction similaire) et est automatiquement libéré (par free) lorsque le
  "hook" est supprimé

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,c]
----
struct t_hdata *
my_hdata_cb (const void *pointer, void *data, const char *hdata_name)
{
    struct t_hdata *mon_hdata;

    /* construction du hdata */
    /* ... */

    return mon_hdata;
}

/* ajoute le hdata "mon_hdata" */
struct t_hook *my_hdata = weechat_hook_hdata ("mon_hdata",
                                              "Hdata pour ma structure",
                                              &my_hdata_cb, NULL, NULL);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== hook_focus

_Mis à jour dans la 1.5, 4.0.0, 4.1.0._

Accrocher un focus : évènement souris ou touche du clavier pressée dans le mode
"curseur" (mouvement libre du curseur).

Prototype :

[source,c]
----
struct t_hook *weechat_hook_focus (const char *area,
                                   struct t_hashtable *(*callback)(const void *pointer,
                                                                   void *data,
                                                                   struct t_hashtable *info),
                                   const void *callback_pointer,
                                   void *callback_data);
----

Paramètres :

* _area_ : "chat" pour la zone de discussion, ou un nom d'objet de barre
  (une priorité est autorisée avant la zone, voir la note sur la <<hook_priority,priorité>>)
* _callback_ : fonction appelée quand le focus est fait, paramètres et valeur de
  retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _struct t_hashtable *info_ : table de hachage avec les informations sur le
   focus et les chaînes retournées par les autres appels aux fonctions de
   rappel de focus (avec plus haute priorité) (voir le tableau ci-dessous)
** valeur de retour : soit le pointeur vers la table de hachage "info" (avec la
   table de hachage complétée), ou un pointeur vers une nouvelle table de
   hachage (créée par la fonction de rappel, avec clés et valeurs de type
   "string"), le contenu de cette nouvelle table de hachage sera ajouté à
   _info_ pour les autres appels aux fonctions de rappel focus
* _callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat
* _callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou une
  fonction similaire) et est automatiquement libéré (par free) lorsque le
  "hook" est supprimé

[IMPORTANT]
Pour un geste de souris, votre fonction de rappel sera appelée deux fois : la
première lorsque le bouton est pressé (ici la zone correspond à vôtre zone), la
seconde fois lorsque le bouton est relâché, et la zone peut ne pas correspondre
à la vôtre : donc vous devez *toujours* tester dans la fonction de rappel si la
zone correspond avant d'utiliser les informations de la table de hachage.

Contenu de la table de hachage envoyée à la fonction de rappel (les clés et
valeurs sont de type "string") :

[width="100%",cols="5,5,8,3",options="header"]
|===
| Clé ^(1)^ | Description | Exemples de valeur | Valeur si non applicable

| _x | Colonne sur l'écran.
| "0" ... "n" |

| _y | Ligne sur l'écran.
| "0" ... "n" |

| _key | Touche ou évènement souris.
| "button1", "button2-gesture-left", ... |

| _window | Pointeur vers la fenêtre.
| "0x1234abcd" | ""

| _window_number | Numéro de la fenêtre.
| "1" ... "n" | "*"

| _buffer | Pointeur vers le tampon.
| "0x1234abcd" | ""

| _buffer_number | Numéro du tampon.
| "1" ... "n" | "-1"

| _buffer_plugin | Nom d'extension du tampon.
| "core", "irc", ... | ""

| _buffer_name | Nom du tampon.
| "weechat", "libera.#weechat", ... | ""

| _buffer_full_name | Nom complet du tampon.
| "core.weechat", "irc.libera.#weechat", ... | ""

| _buffer_localvar_XXX ^(2)^ | Variables locales du tampon.
| toute chaîne | non défini

| _chat | Indicateur zone "chat".
| "0" ou "1" | "0"

| _chat_line | Pointeur vers la ligne _(WeeChat ≥ 1.2)_.
| "0x1234abcd" | ""

| _chat_line_x | Colonne de la ligne ^(3)^.
| "0" ... "n" | "-1"

| _chat_line_y | Numéro de ligne ^(3)^.
| "0" ... "n" | "-1"

| _chat_line_date | Date/heure de la ligne.
| "1313237175" | "0"

| _chat_line_date_usec | Microsecondes de la date/heure de la ligne.
| "123456" | "0"

| _chat_line_date_printed | Date/heure de la ligne ^(4)^.
| "1313237175" | "0"

| _chat_line_date_usec_printed | Microsecondes de la date/heure de la ligne ^(4)^.
| "123456" | "0"

| _chat_line_time | Heure affichée.
| "14:06:15" | ""

| _chat_line_tags | Étiquettes de la ligne.
| "irc_privmsg,nick_flashy,log1" | ""

| _chat_line_nick | Pseudo de la ligne.
| "FlashCode" | ""

| _chat_line_prefix | Préfixe de la ligne.
| "@FlashCode" | ""

| _chat_line_message | Message de la ligne.
| "Hello world!" | ""

| _chat_focused_line | Ligne à la position (x, y) _(WeeChat ≥ 4.0.0)_.
| "Hello world!" | ""

| _chat_focused_line_bol | Texte du début de la ligne jusqu'à (x-1, y) _(WeeChat ≥ 4.1.0)_.
| "Hello" | ""

| _chat_focused_line_eol | Texte de (x, y) jusqu'à la fin de la ligne _(WeeChat ≥ 4.1.0)_.
| "llo world!" | ""

| _chat_word | Mot à la position (x,y).
| "Hello" | ""

| _chat_bol | Texte du début du message jusqu'à (x-1, y).
| "He" | ""

| _chat_eol | Texte de (x, y) jusqu'à la fin du message.
| "llo world!" | ""

| _bar_name | Nom de la barre.
| "title", "nicklist", ... | ""

| _bar_filling | Remplissage de la barre.
| "horizontal", "vertical", ... | ""

| _bar_item_name | Nom de l'objet de barre.
| "buffer_nicklist", "hotlist", ... | ""

| _bar_item_line | Ligne dans l'objet de barre.
| "0" ... "n" | "-1"

| _bar_item_col | Colonne dans l'objet de barre.
| "0" ... "n" | "-1"

| _bar_window | Pointeur vers la fenêtre de barre _(WeeChat ≥ 2.9)_.
| "0x1234abcd" | ""
|===

[NOTE]
^(1)^ Il y a les mêmes clés suffixées par "2" (c'est-à-dire : "_x2", "_y2",
"_window2", ...) avec l'information sur le second point (pratique seulement
pour les gestes de souris, pour savoir où le bouton de la souris a été
relâché). +
^(2)^ `XXX` est le nom d'une variable locale du tampon. +
^(3)^ Renseigné seulement pour les tampons avec contenu libre. +
^(4)^ Il s'agit de la date lorsque WeeChat ajoute la ligne dans le tampon
(supérieure ou égale à "_chat_line_date").

Informations additionnelles pour l'objet de barre "buffer_nicklist" :

[width="100%",cols="^1,^1,5",options="header"]
|===
| Extension ^(1)^ | Clé      | Description
| irc             | irc_nick | Pointeur vers le pseudo IRC _(WeeChat ≥ 3.0)_.
| irc             | irc_host | Nom d'hôte pour le pseudonyme (si connu).
| weechat         | nick     | Pseudonyme.
| weechat         | prefix   | Préfixe du pseudonyme.
| weechat         | group    | Nom du groupe.
|===

[NOTE]
^(1)^ Le nom de l'extension qui définit un hook_focus pour retourner des infos
pour cet objet de barre (donc par exemple si l'extension est "irc", ces infos
ne seront disponibles que sur les tampons irc).

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,c]
----
struct t_hashtable *
my_focus_nicklist_cb (const void *pointer, void *data, struct t_hashtable *info)
{
    /* ajout de chaînes dans la table de hachage */
    /* ... */

    return info;
}

/* ajoute le focus sur la liste des pseudos */
struct t_hook *my_focus = weechat_hook_focus ("buffer_nicklist",
                                              &my_focus_nicklist_cb, NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def hook_focus(area: str, callback: str, callback_data: str) -> str: ...

# exemple
def my_focus_nicklist_cb(data: str, info: Dict[str, str]) -> Dict[str, str]:
    # construction du dict
    # ...
    return my_dict

hook = weechat.hook_focus("buffer_nicklist", "my_focus_nicklist_cb", "")
----

==== hook_set

_WeeChat ≥ 0.3.9 (script : WeeChat ≥ 0.4.3)._

Affecter une valeur à une propriété d'un hook.

Prototype :

[source,c]
----
void weechat_hook_set (struct t_hook *hook, const char *property,
                       const char *value);
----

Paramètres :

* _hook_ : quelque chose d'accroché avec "weechat_hook_xxx()"
* _property_ : nom de la propriété (voir le tableau ci-dessous)
* _value_ : nouvelle valeur pour la propriété

Propriétés :

[width="100%",cols="^1,^1,2,2,5",options="header"]
|===
| Nom | WeeChat mini | Type de hook | Valeur | Description

| subplugin | | tout type
| toute chaîne
| Nom de la sous-extension (couramment un nom de script, qui est affiché dans
  `/help commande` pour un hook de type _command_).

| stdin | 0.4.3 | _process_, _process_hashtable_ | toute chaîne
| Envoyer les données sur l'entrée standard (_stdin_) du processus fils.

| stdin_close | 0.4.3 | _process_, _process_hashtable_ | (non utilisée)
| Fermer le tuyau utilisé pour envoyer les données sur l'entrée standard
  (_stdin_) du processus fils.

| signal | 1.0 | _process_, _process_hashtable_
| numéro de signal ou un de ces noms : `hup`, `int`, `quit`, `kill`, `term`,
  `usr1`, `usr2`
| Envoyer un signal au proces.sus fils
|===

Exemple en C :

[source,c]
----
struct t_hook *my_command_hook =
    weechat_hook_command ("abcd", "description",
                          "args", "description args",
                          "", &my_command_cb, NULL, NULL);
weechat_hook_set (my_command_hook, "subplugin", "test");
----

Script (Python) :

[source,python]
----
# prototype
def hook_set(hook: str, property: str, value: str) -> int: ...

# exemple
def my_process_cb(data: str, command: str, return_code: int, out: str, err: str) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_process_hashtable("/chemin/vers/commande", {"stdin": "1"},
                                      20000, "my_process_cb", "")
weechat.hook_set(hook, "stdin", "données envoyées sur le stdin du processus fils")
weechat.hook_set(hook, "stdin_close", "")  # facultatif
----

==== unhook

Décrocher quelque chose qui est a été accroché.

Prototype :

[source,c]
----
void weechat_unhook (struct t_hook *hook);
----

Paramètres :

* _hook_ : quelque chose accroché avec "weechat_hook_xxx()"

Exemple en C :

[source,c]
----
struct t_hook *my_hook = weechat_hook_command ( /* ... */ );
/* ... */
weechat_unhook (my_hook);
----

Script (Python) :

[source,python]
----
# prototype
def unhook(hook: str) -> int: ...

# exemple
weechat.unhook(my_hook)
----

==== unhook_all

_Mis à jour dans la 1.5._

Décrocher tout ce qui a été accroché par l'extension courante.

Prototype :

[source,c]
----
void weechat_unhook_all (const char *subplugin);
----

Paramètres :

* _subplugin_ : si non NULL, décrocher uniquement les "hooks" qui ont ce
  "subplugin" défini (ce paramètre n'est pas disponible dans l'API script)

Exemple en C :

[source,c]
----
weechat_unhook_all (NULL);
----

Script (Python) :

[source,python]
----
# prototype
def unhook_all() -> int: ...

# exemple
weechat.unhook_all()
----

[[buffers]]
=== Tampons

Fonctions pour créer/interroger/fermer les tampons.

==== buffer_new

_Mis à jour dans la 1.5._

Ouvrir un nouveau tampon.

[NOTE]
Si vous souhaitez définir immédiatement des propriétés du tampon (type de tampon,
variables locales, touches de raccourci, etc.), alors il vaut mieux utiliser
la fonction <<_buffer_new_props,buffer_new_props>> qui définit ces propriétés
durant la création du tampon, avant d'envoyer le signal
<<hook_signal_buffer_opened,buffer_opened>>.

Prototype :

[source,c]
----
struct t_gui_buffer *weechat_buffer_new (const char *name,
                                         int (*input_callback)(const void *pointer,
                                                               void *data,
                                                               struct t_gui_buffer *buffer,
                                                               const char *input_data),
                                         const void *input_callback_pointer,
                                         void *input_callback_data,
                                         int (*close_callback)(const void *pointer,
                                                               void *data,
                                                               struct t_gui_buffer *buffer),
                                         const void *close_callback_pointer,
                                         void *close_callback_data);
----

Paramètres :

* _name_ : nom du tampon (doit être unique pour l'extension)
* _input_callback_ : fonction appelée lorsque du texte saisi est envoyé au
  tampon, paramètres et valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _struct t_gui_buffer *buffer_ : pointeur vers le tampon
** _const char *input_data_ : données en entrée
** valeur de retour :
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _input_callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle
  est appelée par WeeChat
* _input_callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle
  est appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou
  une fonction similaire) et est automatiquement libéré (par free) lorsque le
  tampon est fermé
* _close_callback_ : fonction appelée lorsque le tampon est fermé, paramètres et
  valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _struct t_gui_buffer *buffer_ : pointeur vers le tampon
** valeur de retour :
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _close_callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle
  est appelée par WeeChat
* _close_callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle
  est appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou
  une fonction similaire) et est automatiquement libéré (par free) lorsque le
  tampon est fermé

Valeur de retour :

* pointeur vers le nouveau tampon, NULL en cas d'erreur

Exemple en C :

[source,c]
----
int
my_input_cb (const void *pointer, void *data,
             struct t_gui_buffer *buffer, const char *input_data)
{
    weechat_printf (buffer, "Texte : %s", input_data);
    return WEECHAT_RC_OK;
}

int
my_close_cb (const void *pointer, void *data, struct t_gui_buffer *buffer)
{
    weechat_printf (NULL, "Le tampon '%s' va être fermé !",
                    weechat_buffer_get_string (buffer, "name"));
    return WEECHAT_RC_OK;
}

struct t_gui_buffer *my_buffer = weechat_buffer_new ("mon_buffer",
                                                     &my_input_cb, NULL, NULL,
                                                     &my_close_cb, NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def buffer_new(name: str, input_callback: str, input_callback_data: str,
               close_callback: str, close_callback_data: str) -> str: ...

# exemple
def my_input_cb(data: str, buffer: str, input_data: str) -> int:
    weechat.prnt(buffer, "Texte : %s" % input_data)
    return weechat.WEECHAT_RC_OK

def my_close_cb(data: str, buffer: str) -> int:
    weechat.prnt("", "Le tampon '%s' va être fermé !" % weechat.buffer_get_string(buffer, "name"))
    return weechat.WEECHAT_RC_OK

buffer = weechat.buffer_new("mon_buffer", "my_input_cb", "", "my_close_cb", "")
----

==== buffer_new_props

_WeeChat ≥ 3.5._

Ouvrir un nouveau tampon et appliquer des propriétés.

Prototype :

[source,c]
----
struct t_gui_buffer *weechat_buffer_new_props (const char *name,
                                               struct t_hashtable *properties,
                                               int (*input_callback)(const void *pointer,
                                                                     void *data,
                                                                     struct t_gui_buffer *buffer,
                                                                     const char *input_data),
                                               const void *input_callback_pointer,
                                               void *input_callback_data,
                                               int (*close_callback)(const void *pointer,
                                                                     void *data,
                                                                     struct t_gui_buffer *buffer),
                                               const void *close_callback_pointer,
                                               void *close_callback_data);
----

Paramètres :

* _name_ : nom du tampon (doit être unique pour l'extension)
* _properties_ : propriétés à appliquer
  (voir la fonction <<_buffer_set,buffer_set>> pour les propriétés autorisées)
* _input_callback_ : fonction appelée lorsque du texte saisi est envoyé au
  tampon, paramètres et valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _struct t_gui_buffer *buffer_ : pointeur vers le tampon
** _const char *input_data_ : données en entrée
** valeur de retour :
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _input_callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle
  est appelée par WeeChat
* _input_callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle
  est appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou
  une fonction similaire) et est automatiquement libéré (par free) lorsque le
  tampon est fermé
* _close_callback_ : fonction appelée lorsque le tampon est fermé, paramètres et
  valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _struct t_gui_buffer *buffer_ : pointeur vers le tampon
** valeur de retour :
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _close_callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle
  est appelée par WeeChat
* _close_callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle
  est appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou
  une fonction similaire) et est automatiquement libéré (par free) lorsque le
  tampon est fermé

Valeur de retour :

* pointeur vers le nouveau tampon, NULL en cas d'erreur

Exemple en C :

[source,c]
----
int
my_input_cb (const void *pointer, void *data,
             struct t_gui_buffer *buffer, const char *input_data)
{
    weechat_printf (buffer, "Texte : %s", input_data);
    return WEECHAT_RC_OK;
}

int
my_close_cb (const void *pointer, void *data, struct t_gui_buffer *buffer)
{
    weechat_printf (NULL, "Le tampon '%s' va être fermé !",
                    weechat_buffer_get_string (buffer, "name"));
    return WEECHAT_RC_OK;
}

struct t_hashtable *properties = weechat_hashtable_new (8,
                                                        WEECHAT_HASHTABLE_STRING,
                                                        WEECHAT_HASHTABLE_STRING,
                                                        NULL,
                                                        NULL);
/* tampon avec contenu libre */
weechat_hashtable_set (properties, "type", "free");
/* pas d'enregistrement sur ce tampon */
weechat_hashtable_set (properties, "localvar_set_no_log", "1");
/* associer la touche alt-c sur ce tampon */
weechat_hashtable_set (properties, "key_bind_meta-c", "/ma_commande");

struct t_gui_buffer *my_buffer = weechat_buffer_new_props ("mon_buffer",
                                                           properties,
                                                           &my_input_cb, NULL, NULL,
                                                           &my_close_cb, NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def buffer_new_props(name: str, properties: Dict[str, str],
                     input_callback: str, input_callback_data: str,
                     close_callback: str, close_callback_data: str) -> str: ...

# exemple
def my_input_cb(data: str, buffer: str, input_data: str) -> int:
    weechat.prnt(buffer, "Texte : %s" % input_data)
    return weechat.WEECHAT_RC_OK

def my_close_cb(data: str, buffer: str) -> int:
    weechat.prnt("", "Le tampon '%s' va être fermé !" % weechat.buffer_get_string(buffer, "name"))
    return weechat.WEECHAT_RC_OK

properties = {
    "type": "free",                     # tampon avec contenu libre
    "localvar_set_no_log": "1",         # pas d'enregistrement sur ce tampon
    "key_bind_meta-c": "/ma_commande",  # associer la touche alt-c sur ce tampon
}
buffer = weechat.buffer_new_props("mon_buffer", properties, "my_input_cb", "", "my_close_cb", "")
----

==== current_buffer

Retourner un pointeur vers le tampon courant (le tampon affiché par la fenêtre
courante).

Prototype :

[source,c]
----
struct t_gui_buffer *weechat_current_buffer ();
----

Valeur de retour :

* pointeur vers le tampon courant

Exemple en C :

[source,c]
----
weechat_printf (weechat_current_buffer (), "Texte sur le tampon courant");
----

Script (Python) :

[source,python]
----
# prototype
def current_buffer() -> str: ...

# exemple
weechat.prnt(weechat.current_buffer(), "Texte sur le tampon courant")
----

==== buffer_search

_Mis à jour dans la 1.0, 4.3.0._

Rechercher un tampon par l'extension/nom, nom complet ou identifiant unique (`id`).

Prototype :

[source,c]
----
struct t_gui_buffer *weechat_buffer_search (const char *plugin,
                                            const char *name);
----

Paramètres :

* _plugin_ : nom de l'extension, les valeurs spéciales suivantes sont autorisées :
** `+==+` : le nom utilisé est le nom complet du tampon (par exemple :
   `irc.libera.#weechat` au lieu de `libera.#weechat`)
   _(WeeChat ≥ 1.0)_
** `+==id+` : le nom utilisé est l'identifiant unique du tampon (`id`) _(WeeChat ≥ 4.3.0)_
* _name_ : nom du tampon, si c'est NULL ou une chaîne vide, le tampon courant
  est retourné (tampon affiché par la fenêtre courante); si le nom commence par
  `(?i)`, la recherche est insensible à la casse _(WeeChat ≥ 1.0)_

Valeur de retour :

* pointeur vers le tampon trouvé, NULL s'il n'a pas été trouvé

Exemples en C :

[source,c]
----
struct t_gui_buffer *buffer1 = weechat_buffer_search ("irc", "libera.#weechat");
struct t_gui_buffer *buffer2 = weechat_buffer_search ("==", "irc.libera.#test");  /* WeeChat ≥ 1.0 */
struct t_gui_buffer *buffer3 = weechat_buffer_search ("==id", "1709797810942688");  /* WeeChat ≥ 4.3.0 */
----

Script (Python) :

[source,python]
----
# prototype
def buffer_search(plugin: str, name: str) -> str: ...

# exemple
buffer = weechat.buffer_search("mon_extension", "mon_tampon")
----

==== buffer_search_main

Rechercher le tampon principal de WeeChat (tampon _core_, premier tampon
affiché lorsque WeeChat démarre).

Prototype :

[source,c]
----
struct t_gui_buffer *weechat_buffer_search_main ();
----

Valeur de retour :

* pointeur vers le tampon principal WeeChat (tampon _core_)

Exemple en C :

[source,c]
----
struct t_gui_buffer *weechat_buffer = weechat_buffer_search_main ();
----

Script (Python) :

[source,python]
----
# prototype
def buffer_search_main() -> str: ...

# exemple
buffer = weechat.buffer_search_main()
----

==== buffer_clear

Effacer le contenu d'un tampon.

Prototype :

[source,c]
----
void weechat_buffer_clear (struct t_gui_buffer *buffer);
----

Paramètres :

* _buffer_ : pointeur vers le tampon

Exemple en C :

[source,c]
----
struct t_gui_buffer *my_buffer = weechat_buffer_search ("mon_extension",
                                                        "mon_tampon");
if (my_buffer)
{
    weechat_buffer_clear (my_buffer);
}
----

Script (Python) :

[source,python]
----
# prototype
def buffer_clear(buffer: str) -> int: ...

# exemple
buffer = weechat.buffer_search("mon_extension", "mon_tampon")
if buffer:
    weechat.buffer_clear(buffer)
----

==== buffer_close

Fermer un tampon.

Prototype :

[source,c]
----
void weechat_buffer_close (struct t_gui_buffer *buffer);
----

Paramètres :

* _buffer_ : pointeur vers le tampon

Exemple en C :

[source,c]
----
struct t_gui_buffer *my_buffer = weechat_buffer_new ("mon_tampon",
                                                     &my_input_cb, NULL,
                                                     &my_close_cb, NULL);
/* ... */
weechat_buffer_close (my_buffer);
----

Script (Python) :

[source,python]
----
# prototype
def buffer_close(buffer: str) -> int: ...

# exemple
buffer = weechat.buffer_new("mon_tampon", "my_input_cb", "", "my_close_cb", "")
# ...
weechat.buffer_close(buffer)
----

==== buffer_merge

Mélanger le tampon avec un autre tampon : les deux tampons continueront
d'exister chacun de leur côté, mais avec le même numéro, et WeeChat affichera
les lignes des deux tampons (lignes mélangées).

Prototype :

[source,c]
----
void weechat_buffer_merge (struct t_gui_buffer *buffer,
                           struct t_gui_buffer *target_buffer);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _target_buffer_ : tampon cible avec lequel on doit mélanger

Exemple en C :

[source,c]
----
/* mélanger le tampon courant avec le tampon "core" */
weechat_buffer_merge (weechat_current_buffer (),
                      weechat_buffer_search_main ());
----

Script (Python) :

[source,python]
----
# prototype
def buffer_merge(buffer: str, target_buffer: str) -> int: ...

# exemple
# mélanger le tampon courant avec le tampon "core"
weechat.buffer_merge(weechat.current_buffer(), weechat.buffer_search_main())
----

==== buffer_unmerge

Supprimer le mélange d'un tampon.

Prototype :

[source,c]
----
void weechat_buffer_unmerge (struct t_gui_buffer *buffer,
                             int number);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _number_ : numéro cible pour le tampon détaché, s'il est < 1, alors le tampon
  sera déplacé vers le numéro du tampon + 1

Exemple en C :

[source,c]
----
weechat_buffer_unmerge (weechat_current_buffer (), 1);
----

Script (Python) :

[source,python]
----
# prototype
def buffer_unmerge(buffer: str, number: int) -> int: ...

# exemple
weechat.buffer_unmerge(weechat.current_buffer(), 1)
----

==== buffer_get_integer

Retourner une valeur entière pour une propriété du tampon.

Prototype :

[source,c]
----
int weechat_buffer_get_integer (struct t_gui_buffer *buffer,
                                const char *property);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _property_ : nom de la propriété :
** _opening_ : 1 si le tampon est en cours d'ouverture, sinon 0 _(WeeChat ≥ 4.2.0)_
** _number_ : numéro du tampon (commence à 1)
** _layout_number_ : numéro du tampon sauvegardé dans le "layout"
** _layout_number_merge_order_ : ordre du tampon mélangé pour le "layout"
** _short_name_is_set_ : 1 si le nom court est défini, 0 si non défini
** _type_ : type de tampon (0 : formaté, 1 : contenu libre)
** _notify_ : niveau de notification du tampon
** _num_displayed_ : nombre de fenêtres affichant ce tampon
** _active_ : 2 si le tampon est le seul actif (mélangé), 1 si le tampon est actif, 0 si le tampon est mélangé et n'est pas sélectionné
** _hidden_ : 1 si le tampon est caché, sinon 0 _(WeeChat ≥ 1.0)_
** _zoomed_ : 1 si le tampon est mélangé et zoomé, sinon 0 _(WeeChat ≥ 1.0)_
** _print_hooks_enabled_ : 1 si les hooks "print" sont activés, sinon 0
** _day_change_ : 1 si les messages de changement de jour sont affichés, sinon 0 _(WeeChat ≥ 0.4.3)_
** _clear_ : 1 si le tampon peut être effacé avec la commande `/buffer clear`, sinon 0 _(WeeChat ≥ 1.0)_
** _filter_ : 1 si les filtres sont activés sur le tampon, sinon 0 _(WeeChat ≥ 1.0)_
** _closing_ : 1 si le tampon est en cours de fermeture, sinon 0 _(WeeChat ≥ 1.0)_
** _lines_hidden_ : 1 si au moins une ligne est cachée dans le tampon (filtrée), ou 0 si toutes les lignes sont affichées
** _prefix_max_length_ : longueur maximale du préfixe dans ce tampon
** _next_line_id_ : prochain identifiant de ligne dans le tampon _(WeeChat ≥ 3.8)_
** _time_for_each_line_ : 1 si l'heure est affichée pour chaque ligne du tampon (par défaut), sinon 0
** _nicklist_ : 1 si la liste de pseudos est activée, sinon 0
** _nicklist_case_sensitive_ : 1 si les pseudos sont sensibles à la casse, sinon 0
** _nicklist_max_length_ : longueur maximale d'un pseudo
** _nicklist_display_groups_ : 1 si les groupes sont affichés, sinon 0
** _nicklist_count_ : nombre de pseudos et groupes dans la liste de pseudos
** _nicklist_visible_count_ : nombre de pseudos/groupes affichés
** _nicklist_groups_count_ : nombre de groupes dans la liste de pseudos
** _nicklist_groups_visible_count_ : nombre de groupes affichés
** _nicklist_nicks_count_ : nombre de pseudos dans la liste de pseudos
** _nicklist_nicks_visible_count_ : nombre de pseudos affichés
** _input_ : 1 si la zone de saisie est activée, sinon 0
** _input_get_any_user_data_ : 1 si toutes les données utilisateur, y compris les commandes, sont envoyées à la fonction de rappel "input", sinon 0
** _input_get_unknown_commands_ : 1 si les commandes inconnues sont envoyées à la fonction de rappel "input", sinon 0
** _input_get_empty_ : 1 si une entrée vide est envoyée à la fonction de rappel "input", sinon 0
** _input_multiline_ : 1 si plusieurs lignes sont envoyées comme un seul message à la fonction de rappel "input", sinon 0
** _input_size_ : taille de la zone de saisie (en octets)
** _input_length_ : longueur de la zone de saisie (nombre de caractères)
** _input_pos_ : position du curseur dans la zone de saisie
** _input_1st_display_ : premier caractère affiché à l'écran
** _num_history_ : nombre de commandes dans l'historique
** _text_search_ : type de recherche de texte :
*** 0 : pas de recherche en cours
*** 1 : recherche dans les lignes du tampon
*** 2 : recherche dans l'historique de commandes
** _text_search_direction_ : direction pour la recherche :
*** 0 : recherche arrière (vers les messages/commandes plus anciens)
*** 1 : recherche avant (vers les messages/commandes plus récents)
** _text_search_exact_ : 1 si la recherche de texte est sensible à la casse
** _text_search_regex_ : 1 si la recherche est avec une expression régulière
** _text_search_where_ :
*** 0 : pas de recherche en cours
*** 1 : recherche dans le message
*** 2 : recherche dans le préfixe
*** 3 : recherche dans le préfixe et le message
** _text_search_history_:
*** 0 : pas de recherche en cours
*** 1 : recherche dans l'historique local du tampon
*** 2 : recherche dans l'historique global
** _text_search_found_ : 1 si du texte a été trouvé, sinon 0

Valeur de retour :

* valeur entière de la propriété

Exemple en C :

[source,c]
----
weechat_printf (NULL, "mon numéro de tampon est : %d",
                weechat_buffer_get_integer (mon_tampon, "number"));
----

Script (Python) :

[source,python]
----
# prototype
def buffer_get_integer(buffer: str, property: str) -> int: ...

# exemple
weechat.prnt("", "mon numéro de tampon est : %d" % weechat.buffer_get_integer(my_buffer, "number"))
----

==== buffer_get_string

Retourner la valeur d'une propriété du tampon sous forme de chaîne.

Prototype :

[source,c]
----
const char *weechat_buffer_get_string (struct t_gui_buffer *buffer,
                                       const char *property);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _property_ : nom de la propriété :
** _id_ : identifiant unique _(WeeChat ≥ 4.3.0)_
** _plugin_ : nom de l'extension qui a créé ce tampon ("core" pour le tampon principal WeeChat)
** _name_ : nom du tampon
** _full_name_ : nom complet du tampon ("extension.nom") _(WeeChat ≥ 0.3.7)_
** _old_full_name_ : ancien nom complet du tampon ("extension.nom"), défini avant que le tampon ne soit renommé _(WeeChat ≥ 2.8)_
** _short_name_ : nom court du tampon (note : utilisé pour l'affichage seulement et peut être changé par l'utilisateur, il ne doit pas être utilisé pour trouver le nom du tampon, utilisez à la place _name_, _full_name_ ou bien la variable locale _channel_)
** _type_ : type de tampon : "formatted" (formaté) ou "free" (contenu libre) _(WeeChat ≥ 4.2.0)_
** _title_ : titre du tampon
** _modes_ : modes _(WeeChat ≥ 4.3.0)_
** _nicklist_last_id_assigned_ : dernier identifiant unique utilisé dans ce tampon pour un groupe ou un pseudo _(WeeChat ≥ 4.3.0)_
** _input_prompt_ : invite de la zone saisie _(WeeChat ≥ 4.3.0)_
** _input_ : texte saisi
** _text_search_input_ : texte saisi sauvegardé avant la recherche de texte
** _highlight_words_ : liste des mots pour le highlight
** _highlight_disable_regex_ : expression régulière POSIX étendue pour désactiver le highlight
** _highlight_regex_ : expression régulière POSIX étendue pour le highlight
** _highlight_tags_restrict_ : restreindre les highlights aux messages comportant ces étiquettes
** _highlight_tags_ : forcer le highlight pour les messages avec ces étiquettes
** _hotlist_max_level_nicks_ : niveau maximum pour la hotlist pour certains pseudos
** _localvar_xxx_ : contenu de la variable locale "xxx" (remplacer "xxx" par le nom de la variable locale à lire)

Valeur de retour :

* valeur de la propriété, sous forme de chaîne

Exemple en C :

[source,c]
----
weechat_printf (NULL, "nom / nom court du tampon sont : %s / %s",
                weechat_buffer_get_string (my_buffer, "name"),
                weechat_buffer_get_string (my_buffer, "short_name"));
----

Script (Python) :

[source,python]
----
# prototype
def buffer_get_string(buffer: str, property: str) -> str: ...

# exemple
weechat.prnt("", "nom / nom court du tampon sont : %s / %s"
    % (weechat.buffer_get_string(my_buffer, "name"),
    weechat.buffer_get_string(my_buffer, "short_name")))
----

==== buffer_get_pointer

Retourner la valeur d'une propriété sous forme d'un pointeur.

Prototype :

[source,c]
----
void *weechat_buffer_pointer (struct t_gui_buffer *buffer,
                              const char *property);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _property_ : nom de la propriété :
** _plugin_ : pointeur vers l'extension qui a créé le tampon (NULL pour le tampon principal WeeChat)
** _text_search_regex_compiled_ : expression régulière compilée
** _text_search_ptr_history_ : entrée d'historique trouvée
** _highlight_disable_regex_compiled_ : expression régulière _highlight_disable_regex_ compilée
** _highlight_regex_compiled_ : expression régulière _highlight_regex_ compilée

Valeur de retour :

* valeur de la propriété, sous forme de pointeur

Exemple en C :

[source,c]
----
weechat_printf (NULL, "pointeur vers l'extension de mon tampon : %lx",
                weechat_buffer_get_pointer (mon_tampon, "plugin"));
----

Script (Python) :

[source,python]
----
# prototype
def buffer_get_pointer(buffer: str, property: str) -> str: ...

# exemple
weechat.prnt("", "pointeur vers l'extension de mon tampon : %s" % weechat.buffer_get_pointer(my_buffer, "plugin"))
----

==== buffer_set

Affecter une valeur à une propriété d'un tampon.

Prototype :

[source,c]
----
void weechat_buffer_set (struct t_gui_buffer *buffer, const char *property,
                         const char *value);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _property_ : nom de la propriété (voir le tableau ci-dessous)
* _value_ : nouvelle valeur pour la propriété

Propriétés :

[width="100%",cols="^2,^1,4,8",options="header"]
|===
| Nom | WeeChat mini | Valeur | Description.

| hotlist | | "+", "-", WEECHAT_HOTLIST_LOW, WEECHAT_HOTLIST_MESSAGE,
  WEECHAT_HOTLIST_PRIVATE, WEECHAT_HOTLIST_HIGHLIGHT, "-1"
| "+" : active la hotlist (option globale, le pointeur vers le tampon n'est pas
  utilisé) +
  "-" : désactive la hotlist (option globale, le pointeur vers le tampon n'est
  pas utilisé) +
  priorité : ajouter ce tampon dans la hotlist avec cette priorité
  (les conditions définies dans l'option _weechat.look.hotlist_add_conditions_
  ne sont *PAS* vérifiées) +
  "-1" : supprimer ce tampon de la hotlist _(WeeChat ≥ 1.0)_.

| completion_freeze | | "0" ou "1"
| "0" : pas de gel de la complétion (valeur par défaut)
  (option globale, le pointeur vers le tampon n'est pas utilisé) +
  "1" : ne pas arrêter la complétion lorsque la ligne de commande est mise à
  jour (option globale, le pointeur vers le tampon n'est pas utilisé).

| unread | | chaîne vide, "0", "+N", "-N" ou "N" (N est un entier)
| chaîne vide : définir le marqueur de données non lues après la dernière ligne du tampon +
  "0" : supprimer le marqueur de données non lues du tampon +
  "N" : déplacer le marqueur de données non lues de N lignes depuis la fin vers la première ligne du tampon +
  "-N" : déplacer le marqueur de données non lues de N lignes vers la première ligne du tampon +
  "+N" : déplacer le marqueur de données non lues de N lignes vers la dernière ligne du tampon.

| display | | "1" ou "auto"
| "1" : basculer vers ce tampon dans la fenêtre active +
  "auto" : basculer vers ce tampon dans la fenêtre active, le marqueur de
  données non lues n'est pas réinitialisé.

| hidden | 1.0 | "0" ou "1"
| "0" : démasquer le tampon +
  "1" : masquer le tampon.

| number | | numéro
| Déplace le tampon vers ce numéro.

| name | | toute chaîne
| Change le nom du tampon.

| short_name | | toute chaîne
| Change le nom court du tampon.

| type | | "formatted" ou "free"
| Définit le type de tampon : "formatted" (pour afficher les messages d'une
  discussion), ou "free" (pour du contenu libre); lorsque la valeur est "free",
  la propriété _clear_ est forcée à "0" _(WeeChat ≥ 1.0)_.

| notify | | "0", "1", "2", "3"
| Définit le niveau de notification du tampon : "0" = ne jamais ajouter à la
  hotlist, "1" = ajouter pour les highlights seulement, "2" = ajouter pour les
  highlights et les messages, "3" = ajouter pour tous les messages.

| print_hooks_enabled | | "0" ou "1"
| "0" pour désactiver les hooks "print", "1" pour les activer
  (par défaut pour un nouveau tampon).

| day_change | 0.4.3 | "0" ou "1"
| "0" pour cacher les messages de changement de jour, "1" pour les voir
  (par défaut pour un nouveau tampon).

| clear | 1.0 | "0" ou "1"
| "0" pour empêcher l'utilisateur d'effacer le tampon avec la commande
  `/buffer clear`, "1" pour autoriser l'utilisateur à effacer le tampon (par
   défaut pour un nouveau tampon) (note : même lorsque la valeur est "0", le
   tampon peut toujours être effacé avec la fonction <<_buffer_clear,buffer_clear>>).

| filter | 1.0 | "0" or "1"
| "0" : désactiver les filtres sur le tampon +
  "1" : activer les filtres sur le tampon.

| title | | toute chaîne
| Change le titre du tampon.

| modes | 4.3.0 | toue chaîne
| Change les modes du tampon.

| time_for_each_line | | "0" ou "1"
| "0" pour cacher l'heure sur toutes les lignes du tampon, "1" pour afficher
  l'heure sur toutes les lignes (par défaut pour un nouveau tampon).

| nicklist | | "0" ou "1"
| "0" pour supprimer la liste des pseudos du tampon, "1" pour ajouter la liste
  des pseudos du tampon.

| nicklist_case_sensitive | | "0" ou "1"
| "0" pour avoir la liste des pseudos insensible à la casse, "1" pour avoir
  la liste des pseudos sensible à la casse.

| nicklist_display_groups | | "0" ou "1"
| "0" pour cacher les groupes de la liste des pseudos, "1" pour afficher les
  groupes de la liste des pseudos.

| highlight_words | | "-" ou une liste de mots séparés par des virgules
| "-" est une valeur spéciale pour désactiver tout highlight sur ce tampon, ou
  une liste de mots à mettre en valeur dans ce tampon, par exemple :
  "abc,def,ghi".

| highlight_words_add | | liste de mots séparés par des virgules
| Liste de mots à mettre en valeur dans ce tampon, ces mots sont ajoutés aux
  mots existants pour le tampon.

| highlight_words_del | | liste de mots séparés par des virgules
| Liste de mots à supprimer de la liste des mots à mettre en valeur dans ce
  tampon.

| highlight_disable_regex | | any string
| Expression régulière POSIX étendue pour désactiver le highlight.

| highlight_regex | | toute chaîne
| Expression régulière POSIX étendue pour le highlight.

| highlight_tags_restrict | | liste d'étiquettes séparées par des virgules
| Restreindre les highlights aux messages avec ces étiquettes dans ce tampon
  (il est possible de combiner plusieurs étiquettes sous forme d'un "et" logique
  avec le séparateur "+", par exemple : "nick_toto+irc_action").

| highlight_tags | | liste d'étiquettes séparées par des virgules
| Forcer le highlight pour les messages avec ces étiquettes dans ce tampon
  (il est possible de combiner plusieurs étiquettes sous forme d'un "et" logique
  avec le séparateur "+", par exemple : "nick_toto+irc_action").

| hotlist_max_level_nicks | | liste de "pseudo:niveau" séparés par des virgules
| Liste de pseudos avec niveau max pour la hotlist sur ce tampon (le niveau peut
  être : -1 : jamais dans la hotlist, 0 : faible, 1 : message, 2 : privé,
  3 : highlight), par exemple : "joe:2,mike:-1,robert:-1" (joe ne produira
  jamais de highlight sur le tampon, mike et robert ne changeront jamais la
  hotlist).

| hotlist_max_level_nicks_add | | liste de "pseudo:niveau" séparés par des virgules"
| Liste de pseudos avec niveau pour la hotlist, ces pseudos sont ajoutés aux
  pseudos existant dans le tampon.

| hotlist_max_level_nicks_del | | liste de pseudos séparés par des virgules
| Liste de pseudos à supprimer des niveaux max de hotlist.

| key_bind_xxx | | toute chaîne
| Associe la nouvelle touche _xxx_, spécifique à ce tampon, la valeur est la
  commande à exécuter pour cette touche.

| key_unbind_xxx | | -
| Supprime la touche _xxx_ pour ce tampon.

| input_prompt | 4.3.0 | toute chaîne
| Change le contenu de l'invite dans la zone de saisie.

| input | | toute chaîne
| Change le contenu de la zone de saisie.

| input_pos | | position
| Change la position du curseur dans la zone de saisie.

| input_get_any_user_data | 4.3.0 | "0" or "1"
| "0" pour recevoir seulement les messages utilisateur (comportement par défaut),
  "1" pour tout recevoir, y compris les commandes.

| input_get_unknown_commands | | "0" ou "1"
| "0" pour désactiver les commandes inconnues sur ce tampon (comportement par
  défaut), "1" pour recevoir les commandes inconnues, par exemple si
  l'utilisateur tape "/commandeinconnue", le tampon le recevra (pas d'erreur
  sur la commande inconnue).

| input_get_empty | | "0" ou "1"
| "0" pour désactiver l'entrée vide sur ce tampon (comportement par défaut),
  "1" pour recevoir l'entrée vide.

| input_multiline | | "0" ou "1"
| "0" pour envoyer chaque ligne séparément au tampon (comportement par défaut),
  "1" pour envoyer plusieurs lignes comme un seul message.

| localvar_set_xxx | | toute chaîne
| Change la valeur de la variable locale _xxx_ (la variable est créée si elle
  n'existe pas).

| localvar_del_xxx | | -
| Supprime la variable locale _xxx_.
|===

Exemple en C :

[source,c]
----
/* désactiver la hotlist (pour tous les tampons) */
weechat_buffer_set (NULL, "hotlist", "-");

/* activer à nouveau la hotlist */
weechat_buffer_set (NULL, "hotlist", "+");

/* changer le nom du tampon */
weechat_buffer_set (mon_tampon, "name", "nouveau_nom");

/* ajouter une variable locale "toto" avec la valeur "abc" */
weechat_buffer_set (mon_tampon, "localvar_set_toto", "abc");

/* supprimer la variable locale "toto" */
weechat_buffer_set (mon_tampon, "localvar_del_toto", "");
----

Script (Python) :

[source,python]
----
# prototype
def buffer_set(buffer: str, property: str, value: str) -> int: ...

# exemples

# désactiver la hotlist (pour tous les tampons)
weechat.buffer_set("", "hotlist", "-")

# activer à nouveau la hotlist
weechat.buffer_set("", "hotlist", "+")

# changer le nom du tampon
weechat.buffer_set(my_buffer, "name", "my_new_name")

# ajouter une variable locale "toto" avec la valeur "abc"
weechat.buffer_set(my_buffer, "localvar_set_toto", "abc")

# supprimer la variable locale "toto"
weechat.buffer_set(my_buffer, "localvar_del_toto", "")
----

==== buffer_set_pointer

Affecter un pointeur à une propriété d'un tampon.

Prototype :

[source,c]
----
void weechat_buffer_set_pointer (struct t_gui_buffer *buffer, const char *property,
                                 void *pointer);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _property_ : nom de la propriété :
** _close_callback_ : définit la fonction de rappel de fermeture du tampon
** _close_callback_data_ : définit les données pour la fonction de rappel de
   fermeture du tampon
** _input_callback_ : définit la fonction de rappel pour les données en entrée
** _input_callback_data_ : définit les données pour la fonction de rappel des
   données en entrée
** _nickcmp_callback_ : définit la fonction de rappel de comparaison de pseudos
   (cette fonction de rappel est appelée lors de la recherche d'un pseudo dans
   la liste des pseudos) _(WeeChat ≥ 0.3.9)_
** _nickcmp_callback_data_ : définit les données pour la fonction de rappel de
   comparaison de pseudos _(WeeChat ≥ 0.3.9)_
* _pointer_ : nouvelle valeur de pointeur pour la propriété

Prototypes pour les fonctions de rappel :

[source,c]
----
int close_callback (const void *pointer, void *data,
                    struct t_gui_buffer *buffer);

int input_callback (const void *pointer, void *data,
                    struct t_gui_buffer *buffer, const char *input_data);

int nickcmp_callback (const void *pointer, void *data,
                      struct t_gui_buffer *buffer,
                      const char *nick1, const char *nick2);
----

Exemple en C :

[source,c]
----
int
my_close_cb (const void *pointer, void *data, struct t_gui_buffer *buffer)
{
    /* ... */
    return WEECHAT_RC_OK;
}

weechat_buffer_set_pointer (mon_tampon, "close_callback", &my_close_cb);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== buffer_string_replace_local_var

Remplacer les variables locales dans une chaîne par leurs valeurs, en utilisant
les variables locales du tampon.

Prototype :

[source,c]
----
char *weechat_buffer_string_replace_local_var (struct t_gui_buffer *buffer,
                                               const char *string);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _string_ : chaîne avec du texte et des variables locales, au format "$var"

Valeur de retour :

* chaîne avec les valeurs des variables locales

Exemple en C :

[source,c]
----
weechat_buffer_set (mon_tampon, "localvar_set_toto", "abc");

char *str = weechat_buffer_string_replace_local_var (mon_tampon,
                                                     "test avec $toto");
/* str contient "test avec abc" */
----

Script (Python) :

[source,python]
----
# prototype
def buffer_string_replace_local_var(buffer: str, string: str) -> str: ...

# exemple
weechat.buffer_set(my_buffer, "localvar_set_toto", "abc")
str = weechat.buffer_string_replace_local_var(my_buffer, "test avec $toto")
# str contient "test avec abc"
----

==== buffer_match_list

_WeeChat ≥ 0.3.5, mis à jour dans la 4.0.0._

Vérifier si le tampon correspond à la liste de tampons.

Prototype :

[source,c]
----
int weechat_buffer_match_list (struct t_gui_buffer *buffer, const char *string);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _string_ : liste de tampons, séparés par des virgules :
** `+*+` signifie tous les tampons
** un nom commençant par `+!+` est exclu
** le caractère joker `+*+` est autorisé dans le nom

[NOTE]
Depuis la version 4.0.0, la comparaison des noms de tampons est sensible à la casse.

Valeur de retour :

* 1 si le tampon correspond à la liste de tampons, 0 sinon

Exemple en C :

[source,c]
----
struct t_gui_buffer *buffer = weechat_buffer_search ("irc", "libera.#weechat");
if (buffer)
{
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "*"));                    /* 1 */
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "*,!*#weechat*"));        /* 0 */
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "irc.libera.*"));         /* 1 */
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "irc.oftc.*,python.*"));  /* 0 */
}
----

Script (Python) :

[source,python]
----
# prototype
def buffer_match_list(buffer: str, string: str) -> int: ...

# exemple
buffer = weechat.buffer_search("irc", "libera.#weechat")
if buffer:
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "*"))                    # 1
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "*,!*#weechat*"))        # 0
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "irc.libera.*"))         # 1
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "irc.oftc.*,python.*"))  # 0
----

[[windows]]
=== Fenêtres

Fonctions pour interroger les fenêtres.

==== current_window

Retourner le pointeur vers la fenêtre courante.

Prototype :

[source,c]
----
struct t_gui_window *weechat_current_window ();
----

Valeur de retour :

* pointeur vers la fenêtre courante

Exemple en C :

[source,c]
----
struct t_gui_window *current_window = weechat_current_window ();
----

Script (Python) :

[source,python]
----
# prototype
def current_window() -> str: ...

# exemple
current_window = weechat.current_window()
----

==== window_search_with_buffer

_WeeChat ≥ 0.3.5._

Retourner le pointeur vers la fenêtre affichant un tampon.

Prototype :

[source,c]
----
struct t_gui_window *weechat_window_search_with_buffer (struct t_gui_buffer *buffer);
----

Paramètre :

* _buffer_ : pointeur vers le tampon

Valeur de retour :

* pointeur vers la fenêtre affichant un tampon (NULL si aucune fenêtre n'affiche
  ce tampon)

Exemple en C :

[source,c]
----
weechat_printf (NULL,
                "fenêtre affichant le tampon core : %lx",
                weechat_window_search_with_buffer (weechat_buffer_search_main ()));
----

Script (Python) :

[source,python]
----
# prototype
def window_search_with_buffer(buffer: str) -> str: ...

# exemple
weechat.prnt("", "fenêtre affichant le tampon core : %s"
    % weechat.window_search_with_buffer(weechat.buffer_search_main()))
----

==== window_get_integer

Retourner la valeur entière d'une propriété de la fenêtre.

Prototype :

[source,c]
----
int weechat_window_get_integer (struct t_gui_window *window,
                                const char *property);
----

Paramètres :

* _window_ : pointeur vers la fenêtre
* _property_ : nom de la propriété :
** _number_ : numéro de la fenêtre (commence à 1)
** _win_x_ : position X de la fenêtre dans le terminal (la première colonne est
   0)
** _win_y_ : position Y de la fenêtre dans le terminal (la première ligne est
   0)
** _win_width_ : largeur de la fenêtre, en caractères
** _win_height_ : hauteur de la fenêtre, en caractères
** _win_width_pct_ : taille en pourcentage, en comparaison avec la fenêtre
   parente (par exemple 50 indique une largeur de moitié)
** _win_height_pct_ : taille en pourcentage, en comparaison avec la fenêtre
   parente (par exemple 50 indique une hauteur de moitié)
** _win_chat_x_ : position X de la fenêtre de discussion ("chat") dans le
   terminal (la première colonne est 0)
** _win_chat_y_ : position Y de la fenêtre de discussion ("chat") dans le
   terminal (la première ligne est 0)
** _win_chat_width_ : largeur de la fenêtre de discussion ("chat"), en
   caractères
** _win_chat_height_ : hauteur de la fenêtre de discussion ("chat"), en
   caractères
** _first_line_displayed_ : 1 si la première du tampon est affichée à l'écran,
   sinon 0
** _scrolling_ : 1 s'il y a un défilement en cours dans la fenêtre (la dernière
   ligne n'est pas affichée)
** _lines_after_ : nombre de lignes non affichées après la dernière ligne
   affichée (lors d'un défilement)

Valeur de retour :

* valeur entière de la propriété

Exemple en C :

[source,c]
----
weechat_printf (NULL, "la fenêtre courante est en position (x,y) : (%d,%d)",
                weechat_window_get_integer (weechat_current_window (), "win_x"),
                weechat_window_get_integer (weechat_current_window (), "win_y"));
----

Script (Python) :

[source,python]
----
# prototype
def window_get_integer(window: str, property: str) -> int: ...

# exemple
weechat.prnt("", "la fenêtre courante est en position (x,y) : (%d,%d)"
    % (weechat.window_get_integer(weechat.current_window(), "win_x"),
    weechat.window_get_integer(weechat.current_window(), "win_y")))
----

==== window_get_string

Retourner la valeur d'une propriété de la fenêtre sous forme d'une chaîne.

[NOTE]
Cette fonction n'est pas utilisée aujourd'hui, elle est réservée pour une
version future.

Prototype :

[source,c]
----
const char *weechat_window_get_string (struct t_gui_window *window,
                                       const char *property);
----

Paramètres :

* _window_ : pointeur vers la fenêtre
* _property_ : nom de la propriété

Valeur de retour :

* valeur de la propriété, sous forme de chaîne

Script (Python) :

[source,python]
----
# prototype
def window_get_string(window: str, property: str) -> str: ...
----

==== window_get_pointer

Retourner la valeur d'une propriété, sous forme d'un pointeur.

Prototype :

[source,c]
----
void *weechat_window_get_pointer (struct t_gui_window *window,
                                  const char *property);
----

Paramètres :

* _window_ : pointeur vers la fenêtre
* _property_ : nom de la propriété :
** _current_ : pointeur vers la fenêtre courante
** _buffer_ : pointeur vers le tampon affiché par la fenêtre

Valeur de retour :

* valeur de la propriété, sous forme de pointeur

Exemple en C :

[source,c]
----
weechat_printf (NULL,
                "tampon affiché dans la fenêtre courante : %lx",
                weechat_window_get_pointer (weechat_current_window (), "buffer"));
----

Script (Python) :

[source,python]
----
# prototype
def window_get_pointer(window: str, property: str) -> str: ...

# exemple
weechat.prnt("", "tampon affiché dans la fenêtre courante : %s"
    % weechat.window_get_pointer(weechat.current_window(), "buffer"))
----

==== window_set_title

Définir le titre du terminal.

Prototype :

[source,c]
----
void weechat_window_set_title (const char *title);
----

Paramètres :

* _title_ : nouveau titre pour le terminal (NULL pour réinitialiser le titre) ;
  la chaîne est évaluée, donc les variables comme `${info:version}` peuvent
  être utilisées (voir <<_string_eval_expression,string_eval_expression>>)

Exemple en C :

[source,c]
----
weechat_window_set_title ("nouveau titre ici");
----

Script (Python) :

[source,python]
----
# prototype
def window_set_title(title: str) -> int: ...

# exemple
weechat.window_set_title("nouveau titre ici")
----

[[nicklist]]
=== Nicklist

Fonctions pour la liste des pseudos.

==== nicklist_add_group

Ajouter un groupe dans la liste des pseudos.

Prototype :

[source,c]
----
struct t_gui_nick_group *weechat_nicklist_add_group (struct t_gui_buffer *buffer,
                                                     struct t_gui_nick_group *parent_group,
                                                     const char *name,
                                                     const char *color,
                                                     int visible);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _parent_group_ : pointeur vers le parent du groupe, NULL si le groupe n'a pas
  de parent (racine de la liste des pseudos)
* _name_ : nom du groupe
* _color_ : nom de l'option contenant la couleur :
** une option WeeChat, par exemple _weechat.color.nicklist_group_
** une couleur avec un fond optionnel, par exemple _yellow_ ou _yellow,red_
** nom d'une couleur de barre :
*** _bar_fg_ : couleur de texte pour la barre
*** _bar_delim_ : couleur des délimiteurs pour la barre
*** _bar_bg_ : couleur de fond pour la barre
* _visible_ :
** _1_ : le groupe et ses sous-groupes/pseudos sont visibles
** _0_ : le groupe et ses sous-groupes/pseudos sont cachés

[NOTE]
Le nom du groupe peut commencer par un ou plusieurs chiffres, suivis d'un pipe
("|"), puis du nom du groupe. Quand une telle chaîne est trouvée au début, elle
est utilisée pour trier les groupes dans la liste des pseudos. Par exemple les
groupes "1|test" et "2|abc" seront affichés dans cet ordre : "test" en premier,
puis "abc" en second.

Valeur de retour :

* pointeur vers le nouveau groupe, NULL en cas d'erreur

Exemple en C :

[source,c]
----
struct t_gui_nick_group *my_group =
    weechat_nicklist_add_group (my_buffer,
                                my_parent_group,
                                "groupe_test",
                                "weechat.color.nicklist_group",
                                1);
----

Script (Python) :

[source,python]
----
# prototype
def nicklist_add_group(buffer: str, parent_group: str, name: str, color: str, visible: int) -> str: ...

# exemple
group = weechat.nicklist_add_group(my_buffer, my_parent_group, "groupe_test",
    "weechat.color.nicklist_group", 1)
----

==== nicklist_search_group

_Mis à jour dans la 4.3.0._

Rechercher un groupe dans la liste des pseudos par nom ou identifiant unique (`id`).

Prototype :

[source,c]
----
struct t_gui_nick_group *weechat_nicklist_search_group (struct t_gui_buffer *buffer,
                                                        struct t_gui_nick_group *from_group,
                                                        const char *name);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _from_group_ : recherche depuis ce groupe seulement, si NULL, alors recherche
  dans toute la liste des pseudos
* _name_ : nom du groupe à rechercher ; avec WeeChat ≥ 4.3.0, un identifiant
  unique peut être donné avec le format : `==id:xxx` (où `xxx` est l'identifiant)

Valeur de retour :

* pointeur vers le groupe trouvé, NULL s'il n'est pas trouvé

Exemple en C :

[source,c]
----
struct t_gui_nick_group *ptr_group1 = weechat_nicklist_search_group (my_buffer,
                                                                     NULL, "groupe_test");
struct t_gui_nick_group *ptr_group2 = weechat_nicklist_search_group (my_buffer,
                                                                     NULL, "==id:1714382231198764");
----

Script (Python) :

[source,python]
----
# prototype
def nicklist_search_group(buffer: str, from_group: str, name: str) -> str: ...

# exemples
group1 = weechat.nicklist_search_group(my_buffer, "", "groupe_test")
group2 = weechat.nicklist_search_group(my_buffer, "", "==id:1714382231198764")
----

==== nicklist_add_nick

Ajouter un pseudo dans un groupe.

Prototype :

[source,c]
----
struct t_gui_nick *weechat_nicklist_add_nick (struct t_gui_buffer *buffer,
                                              struct t_gui_nick_group *group,
                                              const char *name,
                                              const char *color,
                                              const char *prefix,
                                              const char *prefix_color,
                                              int visible);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _group_ : pointeur vers le groupe
* _name_ : nom du pseudo
* _color_ : nom de l'option contenant la couleur pour le pseudo :
** une option WeeChat, par exemple _weechat.color.nicklist_group_
** une couleur avec un fond optionnel, par exemple _yellow_ ou _yellow,red_
** nom d'une couleur de barre :
*** _bar_fg_ : couleur de texte pour la barre
*** _bar_delim_ : couleur des délimiteurs pour la barre
*** _bar_bg_ : couleur de fond pour la barre
* _prefix_ : préfixe affiché avant le pseudo
* _prefix_color_ : nom de l'option contenant la couleur pour le préfixe :
** une option WeeChat, par exemple _weechat.color.nicklist_group_
** une couleur avec un fond optionnel, par exemple _yellow_ ou _yellow,red_
** nom d'une couleur de barre :
*** _bar_fg_ : couleur de texte pour la barre
*** _bar_delim_ : couleur des délimiteurs pour la barre
*** _bar_bg_ : couleur de fond pour la barre
* _visible_ :
** _1_ : le pseudo est visible
** _0_ : le pseudo est caché

Valeur de retour :

* pointeur vers le nouveau pseudo, NULL en cas d'erreur

Exemple en C :

[source,c]
----
struct t_gui_nick *my_nick =
    weechat_nicklist_add_nick (my_buffer, my_group,
                               "test_nick",
                               (nick_away) ? "weechat.color.nicklist_away" : "bar_fg",
                               "@", "lightgreen",
                               1);
----

Script (Python) :

[source,python]
----
# prototype
def nicklist_add_nick(buffer: str, group: str, name: str, color: str, prefix: str, prefix_color: str, visible: int) -> str: ...

# exemple
if nick_away:
    color = "weechat.color.nicklist_away"
else:
    color = "bar_fg"
nick = weechat.nicklist_add_nick(my_buffer, my_group, "test_nick", color, "@", "lightgreen", 1)
----

==== nicklist_search_nick

_Mis à jour dans la 4.3.0._

Rechercher un pseudo dans la liste des pseudos par nom ou identifiant unique (`id`).

Prototype :

[source,c]
----
struct t_gui_nick *weechat_nicklist_search_nick (struct t_gui_buffer *buffer,
                                                 struct t_gui_nick_group *from_group,
                                                 const char *name);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _from_group_ : recherche depuis ce groupe seulement, si NULL, alors recherche
  dans toute la liste des pseudos
* _name_ : nom du pseudo à rechercher ; avec WeeChat ≥ 4.3.0, un identifiant
  unique peut être donné avec le format : `==id:xxx` (où `xxx` est l'identifiant)

Valeur de retour :

* pointeur vers le pseudo trouvé, NULL s'il n'est pas trouvé

Exemple en C :

[source,c]
----
struct t_gui_nick *ptr_nick1 = weechat_nicklist_search_nick (my_buffer,
                                                             NULL, "test_nick");
struct t_gui_nick *ptr_nick2 = weechat_nicklist_search_nick (my_buffer,
                                                             NULL, "==id:1714382252187496");
----

Script (Python) :

[source,python]
----
# prototype
def nicklist_search_nick(buffer: str, from_group: str, name: str) -> str: ...

# exemples
nick1 = weechat.nicklist_search_nick(my_buffer, "", "test_nick")
nick2 = weechat.nicklist_search_nick(my_buffer, "", "==id:1714382252187496")
----

==== nicklist_remove_group

Supprimer un groupe de la liste des pseudos.

Prototype :

[source,c]
----
void weechat_nicklist_remove_group (struct t_gui_buffer *buffer,
                                    struct t_gui_nick_group *group);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _group_ : pointeur vers le groupe à supprimer (tous les sous-groupes/pseudos
  seront supprimés également)

Exemple en C :

[source,c]
----
weechat_nicklist_remove_group (my_buffer, my_group);
----

Script (Python) :

[source,python]
----
# prototype
def nicklist_remove_group(buffer: str, group: str) -> int: ...

# exemple
weechat.nicklist_remove_group(my_buffer, my_group)
----

==== nicklist_remove_nick

Supprimer un pseudo de la liste des pseudos.

Prototype :

[source,c]
----
void weechat_nicklist_remove_nick (struct t_gui_buffer *buffer,
                                   struct t_gui_nick *nick);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _nick_ : pointeur vers le pseudo à supprimer

Exemple en C :

[source,c]
----
weechat_nicklist_remove_nick (my_buffer, my_nick);
----

Script (Python) :

[source,python]
----
# prototype
def nicklist_remove_nick(buffer: str, nick: str) -> int: ...

# exemple
weechat.nicklist_remove_nick(my_buffer, my_nick)
----

==== nicklist_remove_all

Supprimer tous les groupes/pseudos de la liste des pseudos.

Prototype :

[source,c]
----
void weechat_nicklist_remove_all (struct t_gui_buffer *buffer);
----

Paramètres :

* _buffer_ : pointeur vers le tampon

Exemple en C :

[source,c]
----
weechat_nicklist_remove_all (my_buffer);
----

Script (Python) :

[source,python]
----
# prototype
def nicklist_remove_all(buffer: str) -> int: ...

# exemple
weechat.nicklist_remove_all(my_buffer)
----

==== nicklist_get_next_item

_WeeChat ≥ 0.3.7._

Retourner le prochain groupe ou pseudo de la liste des pseudos (utilisé
principalement pour afficher la liste des pseudos).

Prototype :

[source,c]
----
void weechat_nicklist_get_next_item (struct t_gui_buffer *buffer,
                                     struct t_gui_nick_group **group,
                                     struct t_gui_nick **nick);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _group_ : pointeur vers un pointeur sur le groupe
* _nick_ : pointeur vers un pointeur sur le pseudo

Exemple en C :

[source,c]
----
struct t_gui_nick_group *ptr_group;
struct t_gui_nick *ptr_nick;

ptr_group = NULL;
ptr_nick = NULL;
weechat_nicklist_get_next_item (buffer, &ptr_group, &ptr_nick);
while (ptr_group || ptr_nick)
{
    if (ptr_nick)
    {
        /* pseudo */
        /* ... */
    }
    else
    {
        /* groupe */
        /* ... */
    }
    weechat_nicklist_get_next_item (buffer, &ptr_group, &ptr_nick);
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== nicklist_group_get_integer

_WeeChat ≥ 0.3.4._

Retourner une valeur entière pour une propriété du groupe.

Prototype :

[source,c]
----
int weechat_nicklist_group_get_integer (struct t_gui_buffer *buffer,
                                        struct t_gui_nick_group *group,
                                        const char *property);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _group_ : pointeur vers le groupe
* _property_ : nom de la propriété :
** _visible_ : 1 si le groupe est visible, sinon 0
** _level_ : niveau du groupe (la racine est 0)

Valeur de retour :

* valeur entière de la propriété

Exemple en C :

[source,c]
----
int visible = weechat_nicklist_group_get_integer (buffer, group, "visible");
----

Script (Python) :

[source,python]
----
# prototype
def nicklist_group_get_integer(buffer: str, group: str, property: str) -> int: ...

# exemple
visible = weechat.nicklist_group_get_integer(buffer, group, "visible")
----

==== nicklist_group_get_string

_WeeChat ≥ 0.3.4._

Retourner la valeur d'une propriété du groupe sous forme de chaîne.

Prototype :

[source,c]
----
const char *weechat_nicklist_group_get_string (struct t_gui_buffer *buffer,
                                               struct t_gui_nick_group *group,
                                               const char *property);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _group_ : pointeur vers le groupe
* _property_ : nom de la propriété :
** _id_ : identifiant unique _(WeeChat ≥ 4.3.0)_
** _name_ : nom du groupe
** _color_ : couleur du groupe dans la liste des pseudos

Valeur de retour :

* valeur de la propriété, sous forme de chaîne

Exemple en C :

[source,c]
----
const char *color = weechat_nicklist_group_get_string (buffer, group, "color");
----

Script (Python) :

[source,python]
----
# prototype
def nicklist_group_get_string(buffer: str, group: str, property: str) -> str: ...

# exemple
color = weechat.nicklist_group_get_string(buffer, group, "color")
----

==== nicklist_group_get_pointer

_WeeChat ≥ 0.3.4._

Retourner la valeur d'une propriété du groupe sous forme d'un pointeur.

Prototype :

[source,c]
----
void *weechat_nicklist_group_get_pointer (struct t_gui_buffer *buffer,
                                          struct t_gui_nick_group *group,
                                          const char *property);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _group_ : pointeur vers le groupe
* _property_ : nom de la propriété :
** _parent_ : pointeur vers le groupe parent

Valeur de retour :

* valeur de la propriété, sous forme de pointeur

Exemple en C :

[source,c]
----
struct t_gui_nick_group *parent = weechat_nicklist_group_get_pointer (buffer, group, "parent");
----

Script (Python) :

[source,python]
----
# prototype
def nicklist_group_get_pointer(buffer: str, group: str, property: str) -> str: ...

# exemple
parent = weechat.nicklist_group_get_pointer(buffer, group, "parent")
----

==== nicklist_group_set

_WeeChat ≥ 0.3.4, mis à jour dans la 4.3.0._

Affecter une valeur à une propriété d'un groupe.

Prototype :

[source,c]
----
void weechat_nicklist_group_set (struct t_gui_buffer *buffer,
                                 struct t_gui_nick_group *group,
                                 const char *property,
                                 const char *value);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _group_ : pointeur vers le groupe
* _property_ : nom de la propriété (voir le tableau ci-dessous)
* _value_ : nouvelle valeur pour la propriété

Propriétés :

[width="100%",cols="^2,^1,4,8",options="header"]
|===
| Nom | WeeChat mini | Valeur | Description

| id | 4.3.0 | entier de type "long long" ≥ 0
| Nouvel identifiant pour le groupe (il doit être unique dans le tampon). +
  Note : il n'est pas recommandé de changer cet identifiant.

| color | | nom d'option de couleur WeeChat
| Voir le paramètre "color" de la fonction
  <<_nicklist_add_group,nicklist_add_group>>.

| visible | | "0", "1"
| "0" = groupe caché, "1" = groupe visible.
|===

Exemples en C :

[source,c]
----
/* changer la couleur du groupe en "bar_fg" */
weechat_nicklist_group_set (buffer, group, "color", "bar_fg");

/* changer la couleur du groupe en jaune */
weechat_nicklist_group_set (buffer, group, "color", "yellow");

/* cacher le groupe dans la liste des pseudos */
weechat_nicklist_group_set (buffer, group, "visible", "0");
----

Script (Python) :

[source,python]
----
# prototype
def nicklist_group_set(buffer: str, group: str, property: str, value: str) -> int: ...

# exemples

# changer la couleur du groupe en "bar_fg"
weechat.nicklist_group_set(buffer, group, "color", "bar_fg")

# changer la couleur du groupe en jaune
weechat.nicklist_group_set(buffer, group, "color", "yellow")

# cacher le groupe dans la liste des pseudos
weechat.nicklist_group_set(buffer, group, "visible", "0")
----

==== nicklist_nick_get_integer

_WeeChat ≥ 0.3.4._

Retourner une valeur entière pour une propriété du pseudo.

Prototype :

[source,c]
----
int weechat_nicklist_nick_get_integer (struct t_gui_buffer *buffer,
                                       struct t_gui_nick *nick,
                                       const char *property);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _nick_ : pointeur vers le pseudo
* _property_ : nom de la propriété :
** _visible_ : 1 si le pseudo est visible, sinon 0

Valeur de retour :

* valeur entière de la propriété

Exemple en C :

[source,c]
----
int visible = weechat_nicklist_nick_get_integer (buffer, nick, "visible");
----

Script (Python) :

[source,python]
----
# prototype
def nicklist_nick_get_integer(buffer: str, nick: str, property: str) -> int: ...

# exemple
visible = weechat.nicklist_nick_get_integer(buffer, nick, "visible")
----

==== nicklist_nick_get_string

_WeeChat ≥ 0.3.4._

Retourner la valeur d'une propriété du pseudo sous forme de chaîne.

Prototype :

[source,c]
----
const char *weechat_nicklist_nick_get_string (struct t_gui_buffer *buffer,
                                              struct t_gui_nick *nick,
                                              const char *property);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _nick_ : pointeur vers le pseudo
* _property_ : nom de la propriété :
** _id_ : identifiant unique _(WeeChat ≥ 4.3.0)_
** _name_ : nom du pseudo
** _color_ : couleur du pseudo dans la liste des pseudos
** _prefix_ : préfixe du pseudo
** _prefix_color_ : couleur du préfixe dans la liste des pseudos

Valeur de retour :

* valeur de la propriété, sous forme de chaîne

Exemple en C :

[source,c]
----
const char *color = weechat_nicklist_nick_get_string (buffer, nick, "color");
----

Script (Python) :

[source,python]
----
# prototype
def nicklist_nick_get_string(buffer: str, nick: str, property: str) -> str: ...

# exemple
color = weechat.nicklist_nick_get_string(buffer, nick, "color")
----

==== nicklist_nick_get_pointer

_WeeChat ≥ 0.3.4._

Retourner la valeur d'une propriété du pseudo sous forme d'un pointeur.

Prototype :

[source,c]
----
void *weechat_nicklist_nick_get_pointer (struct t_gui_buffer *buffer,
                                         struct t_gui_nick *nick,
                                         const char *property);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _nick_ : pointeur vers le pseudo
* _property_ : nom de la propriété :
** _group_ : pointeur vers le groupe contenant ce pseudo

Valeur de retour :

* valeur de la propriété, sous forme de pointeur

Exemple en C :

[source,c]
----
struct t_gui_nick_group *group = weechat_nicklist_nick_get_pointer (buffer, nick, "group");
----

Script (Python) :

[source,python]
----
# prototype
def nicklist_nick_get_pointer(buffer: str, nick: str, property: str) -> str: ...

# exemple
group = weechat.nicklist_nick_get_pointer(buffer, nick, "group")
----

==== nicklist_nick_set

_WeeChat ≥ 0.3.4, mis à jour dans la 4.3.0._

Affecter une valeur à une propriété d'un pseudo.

Prototype :

[source,c]
----
void weechat_nicklist_nick_set (struct t_gui_buffer *buffer,
                                struct t_gui_nick *nick,
                                const char *property,
                                const char *value);
----

Paramètres :

* _buffer_ : pointeur vers le tampon
* _nick_ : pointeur vers le pseudo
* _property_ : nom de la propriété (voir le tableau ci-dessous)
* _value_ : nouvelle valeur pour la propriété

Propriétés :

[width="100%",cols="^2,^1,4,8",options="header"]
|===
| Nom | WeeChat mini | Valeur | Description

| id | 4.3.0 | entier de type "long long" ≥ 0
| Nouvel identifiant pour le pseudo (il doit être unique dans le tampon). +
  Note : il n'est pas recommandé de changer cet identifiant.

| color | | nom d'option de couleur WeeChat
| Voir le paramètre "color" de la fonction
  <<_nicklist_add_nick,nicklist_add_nick>>.

| prefix | | toute chaîne
| Préfixe du pseudo.

| prefix_color | | nom d'option de couleur WeeChat
| Voir le paramètre "prefix_color" de la fonction
  <<_nicklist_add_nick,nicklist_add_nick>>.

| visible | | "0", "1"
| "0" = pseudo caché, "1" = pseudo visible.
|===

Exemples en C :

[source,c]
----
/* changer la couleur du pseudo en cyan */
weechat_nicklist_nick_set (buffer, nick, "color", "cyan");

/* changer le préfixe en "+" */
weechat_nicklist_nick_set (buffer, nick, "prefix", "+");

/* changer la couleur du préfixe en jaune */
weechat_nicklist_nick_set (buffer, nick, "prefix_color", "yellow");

/* cacher le pseudo dans la liste des pseudos */
weechat_nicklist_nick_set (buffer, nick, "visible", "0");
----

Script (Python) :

[source,python]
----
# prototype
def nicklist_nick_set(buffer: str, nick: str, property: str, value: str) -> int: ...

# exemples

# changer la couleur du pseudo en cyan
weechat.nicklist_nick_set(buffer, nick, "color", "cyan")

# changer le préfixe en "+"
weechat.nicklist_nick_set(buffer, nick, "prefix", "+")

# changer la couleur du préfixe en jaune
weechat.nicklist_nick_set(buffer, nick, "prefix_color", "yellow")

# cacher le pseudo dans la liste des pseudos
weechat.nicklist_nick_set(buffer, nick, "visible", "0")
----

[[bars]]
=== Barres

Fonctions pour les barres.

==== bar_item_search

Rechercher un objet de barre.

Prototype :

[source,c]
----
struct t_gui_bar_item *weechat_bar_item_search (const char *name);
----

Paramètres :

* _name_ : nom de l'objet de barre

Valeur de retour :

* pointeur vers l'objet de barre trouvé, NULL s'il n'a pas été trouvé

Exemple en C :

[source,c]
----
struct t_gui_bar_item *bar_item = weechat_bar_item_search ("myitem");
----

Script (Python) :

[source,python]
----
# prototype
def bar_item_search(name: str) -> str: ...

# exemple
bar_item = weechat.bar_item_search("myitem")
----

==== bar_item_new

_Mis à jour dans la 0.4.2, 1.5._

Créer un nouvel objet de barre.

Prototype :

[source,c]
----
struct t_gui_bar_item *weechat_bar_item_new (const char *name,
                                             char *(*build_callback)(const void *pointer,
                                                                     void *data,
                                                                     struct t_gui_bar_item *item,
                                                                     struct t_gui_window *window,
                                                                     struct t_gui_buffer *buffer,
                                                                     struct t_hashtable *extra_info),
                                             const void *build_callback_pointer,
                                             void *build_callback_data);
----

Paramètres :

* _name_ : nom de l'objet de barre
* _build_callback_ : fonction appelée lorsque l'objet est construit, paramètres
  et valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _struct t_gui_bar_item *item_ : pointeur vers l'objet de barre
** _struct t_gui_window *window_ : pointeur vers la fenêtre (NULL lors d'un
   appel pour une barre "root")
** _struct t_gui_buffer *buffer_ : tampon affiché dans la fenêtre (si la fenêtre
   est NULL alors c'est le tampon courant) ou tampon passé dans l'objet de
   barre avec la syntaxe : "@buffer:item" _(WeeChat ≥ 0.4.2)_
** _struct t_hashtable *extra_info_ : toujours NULL (le paramètre est réservé
   pour une version future) _(WeeChat ≥ 0.4.2)_
** valeur de retour : contenu de l'objet de barre
* _build_callback_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle
  est appelée par WeeChat
* _build_callback_data_ : pointeur donné à la fonction de rappel lorsqu'elle
  est appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou
  une fonction similaire) et est automatiquement libéré (par free) lorsque
  l'objet de barre est supprimé

Valeur de retour :

* pointeur vers le nouvel objet de barre, NULL en cas d'erreur

Exemple en C :

[source,c]
----
char *
my_build_callback (const void *pointer, void *data,
                   struct t_gui_bar_item *item,
                   struct t_gui_window *window,
                   struct t_gui_buffer *buffer,
                   struct t_hashtable *extra_info)
{
    return strdup ("mon contenu");
}

struct t_gui_bar_item *my_item = weechat_bar_item_new ("myitem",
                                                       &my_build_callback,
                                                       NULL, NULL);
----

Script (Python) :

[IMPORTANT]
Pour la compatibilité avec les versions ≤ 0.4.1, la fonction de rappel par
défaut a seulement 3 paramètres : _data_, _item_ et _window_ (pas de _buffer_
et _extra_info_). +
Pour utiliser la fonction de rappel avec tous les paramètres, vous devez
ajouter "(extra)" avant le nom, voir l'exemple ci-dessous (supporté seulement
dans WeeChat ≥ 0.4.2).

[source,python]
----
# prototype
def bar_item_new(name: str, build_callback: str, build_callback_data: str) -> str: ...

# exemple (fonction de rappel sans "buffer" et "extra_info")
def my_build_callback(data: str, item: str, window: str) -> str:
    return "mon contenu"

bar_item = weechat.bar_item_new("myitem", "my_build_callback", "")

# exemple (fonction de rappel avec tous les paramètres, pour WeeChat ≥ 0.4.2)
def my_build_callback2(data: str, item: str, window: str, buffer: str, extra_info: Dict[str, str]) -> str:
    return "mon contenu"

bar_item2 = weechat.bar_item_new("(extra)myitem2", "my_build_callback2", "")  # WeeChat ≥ 0.4.2
----

==== bar_item_update

Mettre à jour le contenu d'un objet de barre, en appelant sa fonction de rappel
de construction.

Prototype :

[source,c]
----
void weechat_bar_item_update (const char *name);
----

Paramètres :

* _name_ : nom de l'objet de barre

Exemple en C :

[source,c]
----
weechat_bar_item_update ("myobjet");
----

Script (Python) :

[source,python]
----
# prototype
def bar_item_update(name: str) -> int: ...

# exemple
weechat.bar_item_update("myitem")
----

==== bar_item_remove

Supprimer un objet de barre.

Prototype :

[source,c]
----
void weechat_bar_item_remove (struct t_gui_bar_item *item);
----

Paramètres :

* _item_ : pointeur vers l'objet de barre

Exemple en C :

[source,c]
----
weechat_bar_item_remove (&my_item);
----

Script (Python) :

[source,python]
----
# prototype
def bar_item_remove(item: str) -> int: ...

# exemple
weechat.bar_item_remove(myitem)
----

==== bar_search

Rechercher une barre.

Prototype :

[source,c]
----
struct t_gui_bar *weechat_bar_search (const char *name);
----

Paramètres :

* _name_ : nom de la barre

Valeur de retour :

* pointeur vers la barre trouvée, NULL si elle n'est pas trouvée

Exemple en C :

[source,c]
----
struct t_gui_bar *bar = weechat_bar_search ("my_barre");
----

Script (Python) :

[source,python]
----
# prototype
def bar_search(name: str) -> str: ...

# exemple
bar = weechat.bar_search("mybar")
----

==== bar_new

_Mis à jour dans la 2.9, 4.0.0._

Créer une nouvelle barre.

Prototype :

[source,c]
----
struct t_gui_bar *weechat_bar_new (const char *name,
                                   const char *hidden,
                                   const char *priority,
                                   const char *type,
                                   const char *condition,
                                   const char *position,
                                   const char *filling_top_bottom,
                                   const char *filling_left_right,
                                   const char *size,
                                   const char *size_max,
                                   const char *color_fg,
                                   const char *color_delim,
                                   const char *color_bg,
                                   const char *color_bg_inactive,
                                   const char *separator,
                                   const char *items);
----

Paramètres :

* _name_ : nom de la barre
* _hidden_ :
** _on_ : la barre est cachée
** _off_ : la barre est visible
* _priority_ : priorité de la barre (nombre entier)
* _type_ :
** _root_ : la barre est affichée une seule fois, hors des fenêtres
** _window_ : la barre est affichée dans chaque fenêtre
* _condition_ : condition pour afficher la barre :
** _active_ : la barre est affichée dans la fenêtre active seulement
** _inactive_ : la barre est affichée dans les fenêtres inactives seulement
** _nicklist_ : la barre est affichée dans les fenêtres possédant une liste des
   pseudos
** expression évaluée : voir le
   link:weechat_user.fr.html#bar_conditions[Guide utilisateur WeeChat / Conditions de barres ^↗^^]
* _position_ : _top_ (en haut), _bottom_ (en bas), _left_ (à gauche) ou _right_
  (à droite)
* _filling_top_bottom_ :
** _horizontal_ : les objets sont remplis horizontalement (avec un espace
   entre chaque objet)
** _vertical_ : les objets sont remplis verticalement (avec une nouvelle ligne
   entre chaque objet)
** _columns_horizontal_ : les objets sont remplis horizontalement, affichés
   sous forme de colonnes
** _columns_vertical_ : les objets sont remplis verticalement, affichés sous
   forme de colonnes
* _filling_left_right_ :
** _horizontal_ : les objets sont remplis horizontalement (avec un espace
   entre chaque objet)
** _vertical_ : les objets sont remplis verticalement (avec une nouvelle ligne
   entre chaque objet)
** _columns_horizontal_ : les objets sont remplis horizontalement, affichés
   sous forme de colonnes
** _columns_vertical_ : les objets sont remplis verticalement, affichés sous
   forme de colonnes
* _size_ : taille de la barre en caractères (0 indique une taille automatique)
* _size_max_ : taille maximum de la barre (0 pour pas de maximum)
* _color_fg_ : couleur du texte dans la barre
* _color_delim_ : couleur pour les délimiteurs dans la barre
* _color_bg_ : couleur de fond pour la barre
* _color_bg_inactive_ : couleur de fond pour une barre de type "window" qui
  n'est pas affichée dans la fenêtre active
* _separator_ :
** _on_ : la barre a un séparateur avec les autres fenêtres/barres
** _off_ : pas de séparateur
* _items_ : liste des objets dans la barre, séparés par une virgule (espace
  entre les objets), ou "+" (objets collés)

Valeur de retour :

* pointeur vers la nouvelle barre, NULL en cas d'erreur

[NOTE]
Depuis la version 4.0.0, si la barre existe déjà, WeeChat définit les valeurs
reçues comme valeurs par défaut des options de la barre et retourne le pointeur
vers la barre au lieu de NULL.

Exemple en C :

[source,c]
----
struct t_gui_bar *my_bar = weechat_bar_new (
    "mybar", "off", "100", "window", "", "top", "horizontal", "vertical",
    "0", "5", "default", "cyan", "blue", "darkgray", "off",
    "time,buffer_number+buffer_name");
----

Script (Python) :

[source,python]
----
# prototype
def bar_new(name: str, hidden: str, priority: str, type: str, condition: str, position: str,
            filling_top_bottom: str, filling_left_right: str, size: str, size_max: str,
            color_fg: str, color_delim: str, color_bg: str, color_bg_inactive: str,
            separator: str, items: str) -> str: ...

# exemple
bar = weechat.bar_new("mybar", "off", "100", "window", "", "top", "horizontal", "vertical",
    "0", "5", "default", "cyan", "blue", "darkgray", "off", "time,buffer_number+buffer_name")
----

[NOTE]
Avec WeeChat ≥ 2.9, en Ruby, les 4 couleurs (color_fg, color_delim, color_bg,
color_bg_inactive) doivent être données dans un tableau de 4 chaînes de caractères
(en raison d'une limitation de Ruby à 15 paramètres par fonction), voir le
link:++weechat_scripting.fr.html#_ruby++[Guide pour scripts WeeChat ^↗^^]
pour plus d'infos.

==== bar_set

Affecter une nouvelle valeur pour une propriété de la barre.

Prototype :

[source,c]
----
int weechat_bar_set (struct t_gui_bar *bar, const char *property,
                     const char *value);
----

Paramètres :

* _bar_ : pointeur vers la barre
* _property_ : name, hidden, priority, conditions, position, filling_top_bottom,
  filling_left_right, size, size_max, color_fg, color_delim, color_bg,
  separator, items (voir <<_bar_new,bar_new>>)
* _value_ : nouvelle valeur pour la propriété

Valeur de retour :

* 1 si la valeur a été affectée, 0 en cas d'erreur

Exemple en C :

[source,c]
----
weechat_bar_set (my_bar, "position", "bottom");
----

Script (Python) :

[source,python]
----
# prototype
def bar_set(bar: str, property: str, value: str) -> int: ...

# exemple
weechat.bar_set(my_bar, "position", "bottom")
----

==== bar_update

Mettre à jour le contenu d'une barre à l'écran.

Prototype :

[source,c]
----
void weechat_bar_update (const char *name);
----

Paramètres :

* _name_ : nom de la barre

Exemple en C :

[source,c]
----
weechat_bar_update ("mybar");
----

Script (Python) :

[source,python]
----
# prototype
def bar_update(name: str) -> int: ...

# exemple
weechat.bar_update("mybar")
----

==== bar_remove

Supprimer une barre.

Prototype :

[source,c]
----
void weechat_bar_remove (struct t_gui_bar *bar);
----

Paramètres :

* _bar_ : pointeur vers la barre

Exemple en C :

[source,c]
----
weechat_bar_remove (my_bar);
----

Script (Python) :

[source,python]
----
# prototype
def bar_remove(bar: str) -> int: ...

# exemple
weechat.bar_remove(my_bar)
----

[[commands]]
=== Commandes

Fonctions pour exécuter des commandes WeeChat.

==== command

_Mis à jour dans la 1.1, 4.0.0._

Exécuter une commande ou envoyer du texte au tampon.

Prototype :

[source,c]
----
int weechat_command (struct t_gui_buffer *buffer, const char *command);
----

Paramètres :

* _buffer_ : pointeur vers le tampon (la commande est exécutée sur ce tampon,
  NULL pour le tampon courant)
* _command_ : commande à exécuter (si elle commence par "/"), ou texte à
  envoyer au tampon

[NOTE]
Sur un tampon avec `input_multiline` défini à `0` (par défaut), seule la première
commande est exécutée (avant le premier caractère de retour à la ligne : `\n`).

Valeur de retour _(WeeChat ≥ 1.1)_ :

* _WEECHAT_RC_OK_ si ok
* _WEECHAT_RC_ERROR_ si erreur

Exemple en C :

[source,c]
----
int rc;
rc = weechat_command (weechat_buffer_search ("irc", "libera.#weechat"),
                      "/whois FlashCode");
----

Script (Python) :

[source,python]
----
# prototype
def command(buffer: str, command: str) -> int: ...

# exemple
rc = weechat.command(weechat.buffer_search("irc", "libera.#weechat"), "/whois FlashCode")
----

==== command_options

_WeeChat ≥ 2.5, mis à jour dans la 4.0.0._

Exécuter une commande ou envoyer du texte au tampon avec des options.

Prototype :

[source,c]
----
int weechat_command_options (struct t_gui_buffer *buffer, const char *command,
                             struct t_hashtable *options);
----

Paramètres :

* _buffer_ : pointeur vers le tampon (la commande est exécutée sur ce tampon,
  NULL pour le tampon courant)
* _command_ : commande à exécuter (si elle commence par "/"), ou texte à
  envoyer au tampon
* _options_ : table de hachage avec des options (les clés et valeurs doivent
  être des chaînes) (peut être NULL) :
** _commands_ : une liste de commandes autorisées pendant l'appel, séparées par
   des virgules ; voir la fonction <<_string_match_list,string_match_list>>
   pour le format
** _delay_ : délai pour exécuter la commande, en millisecondes
** _split_newline_ : `1` pour découper les commandes sur le caractère de retour
   à la ligne (`\n`) (_WeeChat ≥ 4.0.0_)

Valeur de retour :

* _WEECHAT_RC_OK_ si ok
* _WEECHAT_RC_ERROR_ si erreur

Exemple en C :

[source,c]
----
/* autoriser toute commande sauf /exec, lancer la commande dans 2 secondes */
int rc;
struct t_hashtable *options = weechat_hashtable_new (8,
                                                     WEECHAT_HASHTABLE_STRING,
                                                     WEECHAT_HASHTABLE_STRING,
                                                     NULL,
                                                     NULL);
weechat_hashtable_set (options, "commands", "*,!exec");
weechat_hashtable_set (options, "delay", "2000");
rc = weechat_command_options (NULL, "/une_commande paramètres", options);
----

Script (Python) :

[source,python]
----
# prototype
def command_options(buffer: str, command: str, options: Dict[str, str]) -> int: ...

# exemple : autoriser toute commande sauf /exec
rc = weechat.command_options("", "/une_commande paramètres", {"commands": "*,!exec"})
----

[[completion]]
=== Completion

Fonctions pour compléter une ligne de commande.

==== completion_new

_WeeChat ≥ 2.9._

Créer une complétion.

Prototype :

[source,c]
----
struct t_gui_completion *weechat_completion_new (struct t_gui_buffer *buffer);
----

Paramètres :

* _buffer_ : pointeur vers le tampon

Valeur de retour :

* pointer to new completion

Exemple en C :

[source,c]
----
struct t_gui_completion *completion = weechat_completion_new (weechat_buffer_search_main ());
----

Script (Python) :

[source,python]
----
# prototype
def completion_new(buffer: str) -> str: ...

# exemple
completion = weechat.completion_new(weechat.buffer_search_main())
----

==== completion_search

_WeeChat ≥ 2.9._

Chercher les mots possibles à une position donnée d'une chaîne, dans le contexte
de la complétion.

Prototype :

[source,c]
----
int weechat_completion_search (struct t_gui_completion *completion, const char *data,
                               int position, int direction);
----

Paramètres :

* _completion_ : pointeur vers la complétion
* _data_ : la chaîne à compléter
* _position_ : index du caractère dans la chaîne à compléter (commence à 0)
* _direction_ : 1 pour la complétion suivante, -1 pour la complétion précédente

Valeur de retour :

* 1 si OK, 0 si erreur

Exemple en C :

[source,c]
----
struct t_gui_completion *completion = weechat_completion_new (weechat_buffer_search_main ());
if (weechat_completion_search (completion, "/help filt", 10, 1))
{
    /* ... */
}
----

Script (Python) :

[source,python]
----
# prototype
def completion_search(completion: str, data: str, position: int, direction: int) -> int: ...

# exemple
completion = weechat.completion_new(weechat.buffer_search_main())
if weechat.completion_search(completion, "/help filt", 10, 1):
    # ...
----

==== completion_get_string

_WeeChat ≥ 2.9._

Retourner la valeur d'une propriété de la complétion sous forme de chaîne.

Prototype :

[source,c]
----
const char *weechat_completion_get_string (struct t_gui_completion *completion,
                                           const char *property);
----

Paramètres :

* _completion_ : pointeur vers la complétion
* _property_ : nom de la propriété :
** _base_command_ : commande utilisée pour la complétion
** _base_word_ : le mot qui va être complété
** _args_ : paramètres de la commande (incluant le mot de base "base_word")

Exemple en C :

[source,c]
----
int
my_completion_cb (const void *pointer, void *data, const char *completion_item,
                  struct t_gui_buffer *buffer,
                  struct t_gui_completion *completion)
{
    /* récupère les paramètres de la commande */
    const char *args = weechat_completion_get_string (completion, "args");

    /* complétion selon les paramètres */
    /* ... */

    return WEECHAT_RC_OK;
}
----

Script (Python) :

[source,python]
----
# prototype
def completion_get_string(completion: str, property: str) -> str: ...

# exemple
def my_completion_cb(data: str, completion_item: str, buffer: str, completion: str) -> int:
    # récupère les paramètres de la commande
    args = weechat.completion_get_string(completion, "args")
    # complétion selon les paramètres
    # ...
    return weechat.WEECHAT_RC_OK
----

==== completion_list_add

_WeeChat ≥ 2.9._

Ajouter un mot pour une complétion.

Prototype :

[source,c]
----
void weechat_completion_list_add (struct t_gui_completion *completion,
                                  const char *word,
                                  int nick_completion,
                                  const char *where);
----

Paramètres :

* _completion_ : pointeur vers la complétion
* _word_ : mot à ajouter
* _nick_completion_ : 1 si le mot est un pseudo, sinon 0
* _where_ : position où sera inséré le mot dans la liste :
** _WEECHAT_LIST_POS_SORT_ : n'importe où, pour maintenir la liste triée
** _WEECHAT_LIST_POS_BEGINNING_ : au début de la liste
** _WEECHAT_LIST_POS_END_ : à la fin de la liste

Exemple en C : voir <<_hook_completion,hook_completion>>.

Script (Python) :

[source,python]
----
# prototype
def completion_list_add(completion: str, word: str, nick_completion: int, where: str) -> int: ...

# exemple : voir la fonction hook_completion
----

==== completion_free

_WeeChat ≥ 2.9._

Supprimer une complétion.

Prototype :

[source,c]
----
void weechat_completion_free (struct t_gui_completion *completion);
----

Paramètres :

* _completion_ : pointeur vers la complétion

Exemple en C :

[source,c]
----
weechat_completion_free (completion);
----

Script (Python) :

[source,python]
----
# prototype
def completion_free(completion: str) -> int: ...

# exemple
weechat.completion_free(completion)
----

[[network]]
=== Réseau

Fonctions pour le réseau.

==== network_pass_proxy

Établir une connexion/authentification avec un proxy.

[IMPORTANT]
Cette fonction est bloquante sur l'appel à connect(), donc elle doit être
appelée sans un processus issu d'un "fork", pour ne pas bloquer WeeChat.

Prototype :

[source,c]
----
int weechat_network_pass_proxy (const char *proxy,
                                int sock,
                                const char *address,
                                int port);
----

Paramètres :

* _proxy_ : nom du proxy à utiliser
* _sock_ : socket à utiliser
* _address_ : adresse (nom de machine ou adresse IP)
* _port_ : port

Valeur de retour :

* 1 si la connexion est ok, 0 en cas d'erreur

Exemple en C :

[source,c]
----
if (weechat_network_pass_proxy ("mon_proxy", sock, "irc.libera.chat", 6667))
{
    /* OK */
}
else
{
    /* erreur */
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== network_connect_to

_Mis à jour dans la 0.4.3._

Établir une connexion à une machine distante.

[IMPORTANT]
Cette fonction est bloquante sur l'appel à connect(), donc elle doit être
appelée sans un processus issu d'un "fork", pour ne pas bloquer WeeChat.

Prototype :

[source,c]
----
int weechat_network_connect_to (const char *proxy,
                                struct sockaddr *address,
                                socklen_t address_length);
----

Paramètres :

* _proxy_ : nom du proxy à utiliser
* _address_ : adresse où se connecter (avec le port)
* _address_length_ : longueur du paramètre _address_

Valeur de retour :

* numéro de socket (≥ 0) si la connexion est OK, -1 en cas d'erreur

Exemple en C :

[source,c]
----
struct sockaddr *addr;
socklen_t length;
int sock;

/* allouer/définir l'adresse et le port dans 'addr', définir 'length' */
/* ... */

sock = weechat_network_connect_to (NULL, addr, length);
if (sock >= 0)
{
    /* OK */
}
else
{
    /* erreur */
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

[[infos]]
=== Infos

Fonctions pour obtenir des informations.

==== info_get

_Mis à jour dans la 2.5._

Retourner une information, sous forme de chaîne, de WeeChat ou d'une extension.

Prototype :

[source,c]
----
char *weechat_info_get (const char *info_name, const char *arguments);
----

Paramètres :

* _info_name_ : nom de l'information à lire (voir le tableau ci-dessous)
* _arguments_ : paramètres pour l'information demandée (optionnels, NULL si
  aucun paramètre n'est nécessaire)

Valeur de retour :

* chaîne avec l'information demandée, NULL en cas d'erreur
  (doit être supprimée par un appel à "free" après utilisation)

[NOTE]
Avec WeeChat ≥ 2.5, la valeur retournée est une chaîne allouée
(avec WeeChat ≤ 2.4, il s'agissait d'un pointeur vers une chaîne statique).

Infos :

include::{autogendir}/autogen_api_infos.fr.adoc[tag=infos]

Exemple en C :

[source,c]
----
char *version = weechat_info_get ("version", NULL);
char *date = weechat_info_get ("date", NULL);
weechat_printf (NULL, "La version de WeeChat est : %s (compilée le %s)",
                version, date);
if (version)
    free (version);
if (date)
    free (date);

weechat_config_dir = weechat_info_get ("weechat_config_dir", NULL);
weechat_printf (NULL, "Le répertoire de config WeeChat est : %s", weechat_config_dir);
if (weechat_config_dir)
    free (weechat_config_dir);
----

Script (Python) :

[source,python]
----
# prototype
def info_get(info_name: str, arguments: str) -> str: ...

# exemple
weechat.prnt("", "La version de WeeChat est : %s (compilée le %s)"
    % (weechat.info_get("version", ""), weechat.info_get("date", ""))
weechat.prnt("", "Le répertoire de config WeeChat est : %s" % weechat.info_get("weechat_config_dir", ""))
----

==== info_get_hashtable

_WeeChat ≥ 0.3.4._

Retourner une information, sous forme de table de hachage, de WeeChat ou d'une
extension.

Prototype :

[source,c]
----
struct t_hashtable *weechat_info_get_hashtable (const char *info_name,
                                                struct t_hashtable *hashtable);
----

Paramètres :

* _info_name_ : nom de l'information à lire (voir le tableau ci-dessous)
* _hashtable_ : table de hachage avec les paramètres (dépendant de l'information
  demandée) (optionnel, NULL si aucun paramètre n'est nécessaire)

Valeur de retour :

* table de hachage avec l'information demandée, NULL en cas d'erreur (doit être
  supprimée par un appel à <<_hashtable_free,hashtable_free>> après utilisation)

Infos :

include::{autogendir}/autogen_api_infos_hashtable.fr.adoc[tag=infos_hashtable]

Exemple en C :

[source,c]
----
struct t_hashtable *hashtable_in, *hashtable_out;

hashtable_in = weechat_hashtable_new (8,
                                      WEECHAT_HASHTABLE_STRING,
                                      WEECHAT_HASHTABLE_STRING,
                                      NULL,
                                      NULL);
if (hashtable_in)
{
    weechat_hashtable_set (
        hashtable_in,
        "message",
        "@time=2015-06-27T16:40:35.000Z;tag2=value\\sspace :nick!user@host PRIVMSG #weechat :Hello world!");
    hashtable_out = weechat_info_get_hashtable ("irc_message_parse",
                                                hashtable_in);
    /*
     * maintenant hashtable_out a les clés/valeurs suivantes :
     *   "tags"                : "time=2015-06-27T16:40:35.000Z;tag2=value\\sspace"
     *   "tag_time"            : "2015-06-27T16:40:35.000Z"
     *   "tag_tag2"            : "value space"
     *   "message_without_tags": ":nick!user@host PRIVMSG #weechat :Hello world!"
     *   "nick"                : "nick"
     "   "user"                : "user"
     *   "host"                : "nick!user@host"
     *   "command"             : "PRIVMSG"
     *   "channel"             : "#weechat"
     *   "arguments"           : "#weechat :Hello world!"
     *   "text"                : "Hello world!"
     *   "param1"              : "#weechat"
     *   "param2"              : "Hello world!"
     *   "num_params"          : "2"
     *   "pos_command"         : "65"
     *   "pos_arguments"       : "73"
     *   "pos_channel"         : "73"
     *   "pos_text"            : "83"
     */
    weechat_hashtable_free (hashtable_in);
    weechat_hashtable_free (hashtable_out);
}
----

[NOTE]
Voir le link:weechat_scripting.fr.html#irc_message_parse[Guide pour scripts WeeChat / Analyser un message ^↗^^]
pour plus d'infos sur la sortie de "irc_message_parse".

Script (Python) :

[source,python]
----
# prototype
def info_get_hashtable(info_name: str, dict_in: Dict[str, str]) -> Dict[str, str]: ...

# exemple
dict_in = {"message": ":nick!user@host PRIVMSG #weechat :message ici"}
weechat.prnt("", "message analysé : %s"
             % weechat.info_get_hashtable("irc_message_parse", dict_in))
----

[[infolists]]
=== Infolists

Une "infolist" est une liste composée d'objets ("items"). Chaque objet contient
des variables.

Par exemple, l'infolist "irc_server" a N objets (N est le nombre de serveurs
IRC définis). Pour chaque objet, il y a des variables, comme "name", "buffer",
"is_connected", ...

Chaque variable a un type et une valeur. Les types possibles sont :

* _integer_ : nombre entier
* _string_ : chaîne de caractères
* _pointer_ : pointeur
* _buffer_ : tampon avec une taille fixe, peut contenir n'importe quel type de
  données
* _time_ : date/heure

==== infolist_new

Créer une "infolist".

Prototype :

[source,c]
----
struct t_infolist *weechat_infolist_new ();
----

Valeur de retour :

* pointeur vers la nouvelle "infolist"

Exemple en C :

[source,c]
----
struct t_infolist *infolist = weechat_infolist_new ();
----

Script (Python) :

[source,python]
----
# prototype
def infolist_new() -> str: ...

# exemple
infolist = weechat.infolist_new()
----

==== infolist_new_item

Ajouter un objet dans l'infolist.

Prototype :

[source,c]
----
struct t_infolist_item *weechat_infolist_new_item (struct t_infolist *infolist);
----

Paramètres :

* _infolist_ : pointeur vers l'infolist

Valeur de retour :

* pointeur vers le nouvel objet

Exemple en C :

[source,c]
----
struct t_infolist_item *item = weechat_infolist_new_item (infolist);
----

Script (Python) :

[source,python]
----
# prototype
def infolist_new_item(infolist: str) -> str: ...

# exemple
item = weechat.infolist_new_item(infolist)
----

==== infolist_new_var_integer

Ajouter une variable de type "integer" dans l'objet de l'infolist.

Prototype :

[source,c]
----
struct t_infolist_var *weechat_infolist_new_var_integer (struct t_infolist_item *item,
                                                         const char *name,
                                                         int value);
----

Paramètres :

* _item_ : pointeur vers l'objet de l'infolist
* _name_ : nom de la variable
* _value_ : valeur

Valeur de retour :

* pointeur vers la nouvelle variable

Exemple en C :

[source,c]
----
struct t_infolist_var *var = weechat_infolist_new_var_integer (item,
                                                               "mon_entier",
                                                               123);
----

Script (Python) :

[source,python]
----
# prototype
def infolist_new_var_integer(item: str, name: str, value: int) -> str: ...

# exemple
var = weechat.infolist_new_var_integer(item, "mon_entier", 123)
----

==== infolist_new_var_string

Ajouter une variable de type "string" dans l'objet de l'infolist.

Prototype :

[source,c]
----
struct t_infolist_var *weechat_infolist_new_var_string (struct t_infolist_item *item,
                                                        const char *name,
                                                        const char *value);
----

Paramètres :

* _item_ : pointeur vers l'objet de l'infolist
* _name_ : nom de la variable
* _value_ : valeur

Valeur de retour :

* pointeur vers la nouvelle variable

Exemple en C :

[source,c]
----
struct t_infolist_var *var = weechat_infolist_new_var_string (item,
                                                              "ma_chaine",
                                                              "valeur");
----

Script (Python) :

[source,python]
----
# prototype
def infolist_new_var_string(item: str, name: str, value: str) -> str: ...

# exemple
var = weechat.infolist_new_var_string(item, "ma_chaine", "valeur")
----

==== infolist_new_var_pointer

Ajouter une variable de type "pointer" dans l'objet de l'infolist.

Prototype :

[source,c]
----
struct t_infolist_var *weechat_infolist_new_var_pointer (struct t_infolist_item *item,
                                                         const char *name,
                                                         void *pointer);
----

Paramètres :

* _item_ : pointeur vers l'objet de l'infolist
* _name_ : nom de la variable
* _pointer_ : pointeur

Valeur de retour :

* pointeur vers la nouvelle variable

Exemple en C :

[source,c]
----
struct t_infolist_var *var = weechat_infolist_new_var_pointer (item,
                                                               "mon_pointeur",
                                                               &pointer);
----

Script (Python) :

[source,python]
----
# prototype
def infolist_new_var_pointer(item: str, name: str, pointer: str) -> str: ...

# exemple
var = weechat.infolist_new_var_pointer(item, "mon_pointeur", pointer)
----

==== infolist_new_var_buffer

Ajouter une variable de type "buffer" dans l'objet de l'infolist.

Prototype :

[source,c]
----
struct t_infolist_var *weechat_infolist_new_var_buffer (struct t_infolist_item *item,
                                                        const char *name,
                                                        void *pointer,
                                                        int size);
----

Paramètres :

* _item_ : pointeur vers l'objet de l'infolist
* _name_ : nom de la variable
* _pointer_ : pointeur
* _size_ : taille du tampon

Valeur de retour :

* pointeur vers la nouvelle variable

Exemple en C :

[source,c]
----
char buffer[256];
/* ... */
struct t_infolist_var *var = weechat_infolist_new_var_buffer (item,
                                                              "mon_buffer",
                                                              buffer,
                                                              sizeof (buffer));
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== infolist_new_var_time

Ajouter une variable de type "time" dans l'objet de l'infolist.

Prototype :

[source,c]
----
struct t_infolist_var *weechat_infolist_new_var_time (struct t_infolist_item *item,
                                                      const char *name,
                                                      time_t time);
----

Paramètres :

* _item_ : pointeur vers l'objet de l'infolist
* _name_ : nom de la variable
* _time_ : valeur

Valeur de retour :

* pointeur vers la nouvelle variable

Exemple en C :

[source,c]
----
struct t_infolist_var *var = weechat_infolist_new_var_time (item,
                                                            "mon_time",
                                                            time (NULL));
----

Script (Python) :

[source,python]
----
# prototype
def infolist_new_var_time(item: str, name: str, time: int) -> str: ...

# exemple
var = weechat.infolist_new_var_time(item, "mon_time", int(time.time()))
----

==== infolist_get

Retourner une "infolist" de WeeChat ou d'une extension.

[IMPORTANT]
Le contenu d'une infolist est une duplication des données réelles. Donc si vous
demandez une infolist avec beaucoup de données (comme "buffer_lines"), WeeChat
allouera de la mémoire pour dupliquer toutes les données, et cela peut prendre
du temps. +
Au lieu d'utiliser une grosse infolist, il est préférable d'utiliser un hdata
(mais l'infolist peut contenir plus de données que le hdata, qui contient des
données brutes), voir <<hdata,hdata>>.

Prototype :

[source,c]
----
struct t_infolist *weechat_infolist_get (const char *infolist_name,
                                         void *pointer,
                                         const char *arguments);
----

Paramètres :

* _infolist_name_ : nom de l'infolist à lire (voir le tableau ci-dessous)
* _pointer_ : pointeur vers un objet, pour n'obtenir que celui-ci dans
  l'infolist (optionnel, peut être NULL)
* _arguments_ : paramètres pour l'infolist demandée (optionnels, NULL si aucun
  paramètre n'est nécessaire)

Valeur de retour :

* pointeur vers l'infolist, NULL en cas d'erreur

Infolists :

include::{autogendir}/autogen_api_infolists.fr.adoc[tag=infolists]

Exemple en C :

[source,c]
----
struct t_infolist *infolist = weechat_infolist_get ("irc_server", NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def infolist_get(infolist_name: str, pointer: str, arguments: str) -> str: ...

# exemple
infolist = weechat.infolist_get("irc_server", "", "")
----

==== infolist_next

Déplacer le "curseur" vers l'objet suivant dans l'infolist. Le premier appel à
cette fonction sur une infolist déplace le curseur sur le premier objet de
l'infolist.

Prototype :

[source,c]
----
int weechat_infolist_next (struct t_infolist *infolist);
----

Paramètres :

* _infolist_ : pointeur vers l'infolist

Valeur de retour :

* 1 si le curseur a été déplacé sur l'objet suivant, 0 si la fin de la liste a
  été atteinte

Exemple en C :

[source,c]
----
if (weechat_infolist_next (infolist))
{
    /* lecture des variables dans l'objet... */
}
else
{
    /* pas d'autre objet disponible */
}
----

Script (Python) :

[source,python]
----
# prototype
def infolist_next(infolist: str) -> int: ...

# exemple
rc = weechat.infolist_next(infolist)
if rc:
    # lecture des variables dans l'objet...
else:
    # pas d'autre objet disponible
----

==== infolist_prev

Déplacer le "curseur" vers l'objet précédent dans l'infolist. Le premier appel à
cette fonction sur une infolist déplace le curseur sur le dernier objet de
l'infolist.

Prototype :

[source,c]
----
int weechat_infolist_prev (struct t_infolist *infolist);
----

Paramètres :

* _infolist_ : pointeur vers l'infolist

Valeur de retour :

* 1 si le curseur a été déplacé sur l'objet précédent, 0 si le début de liste a
  été atteint

Exemple en C :

[source,c]
----
if (weechat_infolist_prev (infolist))
{
    /* lecture des variables dans l'objet... */
}
else
{
    /* pas d'autre objet disponible */
}
----

Script (Python) :

[source,python]
----
# prototype
def infolist_prev(infolist: str) -> int: ...

# exemple
rc = weechat.infolist_prev(infolist)
if rc:
    # lecture des variables dans l'objet
else:
    # pas d'autre objet disponible
----

==== infolist_reset_item_cursor

Réinitialiser le "curseur" de l'infolist.

Prototype :

[source,c]
----
void weechat_infolist_reset_item_cursor (struct t_infolist *infolist);
----

Paramètres :

* _infolist_ : pointeur vers l'infolist

Exemple en C :

[source,c]
----
weechat_infolist_reset_item_cursor (infolist);
----

Script (Python) :

[source,python]
----
# prototype
def infolist_reset_item_cursor(infolist: str) -> int: ...

# exemple
weechat.infolist_reset_item_cursor(infolist)
----

==== infolist_search_var

_WeeChat ≥ 0.4.3._

Chercher une variable dans l'objet courant de l'infolist.

Prototype :

[source,c]
----
struct t_infolist_var *weechat_infolist_search_var (struct t_infolist *infolist,
                                                    const char *name);
----

Paramètres :

* _infolist_ : pointeur vers l'infolist
* _name_ : nom de la variable

Valeur de retour :

* pointeur vers la variable trouvée, NULL si la variable n'est pas trouvée

Exemple en C :

[source,c]
----
if (weechat_infolist_search_var (infolist, "name"))
{
    /* la variable "name" existe */
    /* ... */
}
----

Script (Python) :

[source,python]
----
# prototype
def infolist_search_var(infolist: str, name: str) -> str: ...

# exemple
if weechat.infolist_search_var(infolist, "name"):
    # la variable "name" existe
    # ...
----

==== infolist_fields

Retourner la liste des champs pour l'objet courant de l'infolist.

Prototype :

[source,c]
----
const char *weechat_infolist_fields (struct t_infolist *infolist);
----

Paramètres :

* _infolist_ : pointeur vers l'infolist

Valeur de retour :

* chaîne avec la liste des champs pour l'objet courant de l'infolist. La liste,
  séparée par des virgules, contient la lettre pour le type, suivi du nom de la
  variable. Les types sont : "i" (nombre entier), "s" (chaîne), "p" (pointeur),
  "b" (buffer), "t" (date/heure).

Exemple en C :

[source,c]
----
const char *fields = weechat_infolist_fields (infolist);
/* fields contient quelque chose comme :
   "i:mon_entier,s:ma_chaine,p:mon_pointeur,b:mon_buffer,t:ma_date" */
----

Script (Python) :

[source,python]
----
# prototype
def infolist_fields(infolist: str) -> str: ...

# exemple
fields = weechat.infolist_fields(infolist)
# fields contient quelque chose comme :
# "i:mon_entier,s:ma_chaine,p:mon_pointeur,b:mon_buffer,t:ma_date"
----

==== infolist_integer

Retourner la valeur de la variable de l'objet courant de l'infolist, sous forme
d'entier.

Prototype :

[source,c]
----
int weechat_infolist_integer (struct t_infolist *infolist, const char *var);
----

Paramètres :

* _infolist_ : pointeur vers l'infolist
* _var_ : nom de la variable (doit être de type "integer")

Valeur de retour :

* valeur de la variable, sous forme d'entier

Exemple en C :

[source,c]
----
weechat_printf (NULL, "entier = %d",
                weechat_infolist_integer (infolist, "mon_entier"));
----

Script (Python) :

[source,python]
----
# prototype
def infolist_integer(infolist: str, var: str) -> int: ...

# exemple
weechat.prnt("", "entier = %d" % weechat.infolist_integer(infolist, "mon_entier"))
----

==== infolist_string

Retourner la valeur de la variable de l'objet courant de l'infolist, sous forme
de chaîne de caractères.

Prototype :

[source,c]
----
const char *weechat_infolist_string (struct t_infolist *infolist, const char *var);
----

Paramètres :

* _infolist_ : pointeur vers l'infolist
* _var_ : nom de la variable (doit être de type "string")

Valeur de retour :

* valeur de la variable, sous forme de chaîne

Exemple en C :

[source,c]
----
weechat_printf (NULL, "chaîne = %s",
                weechat_infolist_string (infolist, "ma_chaine"));
----

Script (Python) :

[source,python]
----
# prototype
def infolist_string(infolist: str, var: str) -> str: ...

# exemple
weechat.prnt("", "chaîne = %s" % weechat.infolist_string(infolist, "ma_chaine"))
----

==== infolist_pointer

Retourner la valeur de la variable de l'objet courant de l'infolist, sous forme
de pointeur.

Prototype :

[source,c]
----
void *weechat_infolist_pointer (struct t_infolist *infolist, const char *var);
----

Paramètres :

* _infolist_ : pointeur vers l'infolist
* _var_ : nom de la variable (doit être de type "pointer")

Valeur de retour :

* valeur de la variable, sous forme de pointeur

Exemple en C :

[source,c]
----
weechat_printf (NULL, "pointeur = %p", weechat_infolist_pointer (infolist, "mon_pointeur"));
----

Script (Python) :

[source,python]
----
# prototype
def infolist_pointer(infolist: str, var: str) -> str: ...

# exemple
weechat.prnt("", "pointeur = 0x%s" % weechat.infolist_pointer(infolist, "mon_pointeur"))
----

==== infolist_buffer

Retourner la valeur de la variable de l'objet courant de l'infolist, sous forme
de tampon de données.

Prototype :

[source,c]
----
void *weechat_infolist_buffer (struct t_infolist *infolist, const char *var,
                               int *size);
----

Paramètres :

* _infolist_ : pointeur vers l'infolist
* _var_ : nom de la variable (doit être de type "buffer")
* _size_ : pointeur vers une variable entière, qui sera alimenté avec la taille
  de la zone

Valeur de retour :

* pointeur vers le tampon de données

Exemple en C :

[source,c]
----
int size;
void *pointer = weechat_infolist_buffer (infolist, "mon_buffer", &size);
weechat_printf (NULL, "buffer = %p, taille = %d", pointer, size);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== infolist_time

Retourner la valeur de la variable de l'objet courant de l'infolist, sous forme
de date/heure.

Prototype :

[source,c]
----
time_t weechat_infolist_time (struct t_infolist *infolist, const char *var);
----

Paramètres :

* _infolist_ : pointeur vers l'infolist
* _var_ : nom de la variable (doit être de type "time")

Valeur de retour :

* valeur de la variable, sous forme de date/heure

Exemple en C :

[source,c]
----
weechat_printf (NULL, "date/heure = %ld",
                weechat_infolist_time (infolist, "mon_time"));
----

Script (Python) :

[source,python]
----
# prototype
def infolist_time(infolist: str, var: str) -> int: ...

# exemple
weechat.prnt("", "date/heure = %d" % weechat.infolist_time(infolist, "mon_time"))
----

==== infolist_free

Supprimer une infolist.

Prototype :

[source,c]
----
void weechat_infolist_free (struct t_infolist *infolist);
----

Paramètres :

* _infolist_ : pointeur vers l'infolist

Exemple en C :

[source,c]
----
weechat_infolist_free (infolist);
----

Script (Python) :

[source,python]
----
# prototype
def infolist_free(infolist: str) -> int: ...

# exemple
weechat.infolist_free(infolist)
----

[[hdata]]
=== Hdata

Fonctions pour les hdata (accès brut aux données de WeeChat ou des extensions).

[IMPORTANT]
Le "hdata" fournit seulement un accès en lecture seule aux données. Il est
*STRICTEMENT INTERDIT* d'écrire quelque chose dans une zone mémoire pointée par
les variables du hdata. +
Le seul moyen pour mettre à jour des données est d'appeler la fonction
<<_hdata_update,hdata_update>>.

==== hdata_new

_WeeChat ≥ 0.3.6, mis à jour dans la 0.3.9, 0.4.0._

Créer un "hdata".

[NOTE]
.hdata vs infolist
====
Le "hdata" est un moyen rapide de lire des données de WeeChat ou des extensions.
Il est similaire à l'infolist, mais il y a quelques différences :

* Il est plus rapide et utilise moins de mémoire : accès direct aux données sans
  duplication.
* Il peut contenir des informations différentes de l'infolist : il contient
  seulement les données brutes des structures (l'infolist peut ajouter des
  données supplémentaires pour plus de commodité).
====

Prototype :

[source,c]
----
struct t_hdata *weechat_hdata_new (const char *hdata_name, const char *var_prev, const char *var_next,
                                   int create_allowed, int delete_allowed,
                                   int (*callback_update)(void *data,
                                                          struct t_hdata *hdata,
                                                          void *pointer,
                                                          struct t_hashtable *hashtable),
                                   void *callback_update_data);
----

Paramètres :

* _hdata_name_ : nom du hdata
* _var_prev_ : nom de la variable dans la structure qui est un pointeur vers
  l'élément précédent dans la liste (peut être NULL si une telle variable
  n'existe pas)
* _var_next_ : nom de la variable dans la structure qui est un pointeur vers
  l'élément suivant dans la liste (peut être NULL si une telle variable
  n'existe pas)
* _create_allowed_ : 1 si la création de structure est autorisée, sinon 0
  _(WeeChat ≥ 0.4.0)_
* _delete_allowed_ : 1 si la suppression de structure est autorisée, sinon 0
  _(WeeChat ≥ 0.3.9)_
* _callback_update_ : fonction appelée pour mettre à jour des données dans le
  hdata, peut être NULL si aucune mise à jour n'est autorisée
  _(WeeChat ≥ 0.3.9)_, paramètres et valeur de retour :
** _void *data_ : pointeur
** _struct t_hdata *hdata_ : pointeur vers le hdata
** _struct t_hashtable *hashtable_ : table de hachage avec les variables à
   mettre à jour (voir <<_hdata_update,hdata_update>>)
** valeur de retour : nombre de variables mises à jour
* _callback_update_data_ : pointeur donné à la fonction de rappel lorsqu'elle
  est appelée par WeeChat _(WeeChat ≥ 0.3.9)_

Valeur de retour :

* pointeur vers le nouveau "hdata"

Exemple en C :

[source,c]
----
struct t_hdata *hdata = weechat_hdata_new ("myplugin_list", "prev", "next", 0, 0, &callback_update, NULL);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== hdata_new_var

_WeeChat ≥ 0.3.6, mis à jour dans la 0.3.7, 0.3.9, 0.4.3, 3.4, 4.3.0._

Créer une nouvelle variable dans le hdata.

Prototype :

[source,c]
----
void weechat_hdata_new_var (struct t_hdata *hdata, const char *name, int offset, int type,
                            int update_allowed, const char *array_size, const char *hdata_name);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _name_ : nom de la variable
* _offset_ : position (offset) de la variable dans la structure
* _type_ : type de la variable, un parmi ceux-ci :
** _WEECHAT_HDATA_CHAR_
** _WEECHAT_HDATA_INTEGER_
** _WEECHAT_HDATA_LONG_
** _WEECHAT_HDATA_LONGLONG_ (_WeeChat ≥ 4.3.0_)
** _WEECHAT_HDATA_STRING_
** _WEECHAT_HDATA_SHARED_STRING_ (_WeeChat ≥ 0.4.3_)
** _WEECHAT_HDATA_POINTER_
** _WEECHAT_HDATA_TIME_
** _WEECHAT_HDATA_HASHTABLE_ (_WeeChat ≥ 0.3.7_)
** _WEECHAT_HDATA_OTHER_
* _update_allowed_ : 1 si la mise à jour de la variable est autorisée, sinon 0
  _(WeeChat ≥ 0.3.9)_
* _array_size_ : non NULL seulement si la variable est un tableau, et peut
  être : _(WeeChat ≥ 0.3.9)_
** nom d'une variable du hdata : cette variable sera utilisée comme taille de
   tableau (taille dynamique pour le tableau)
** entier (sous forme de chaîne) : taille fixe pour le tableau
** _*_ : taille automatique : la taille est calculée en examinant les valeurs,
   lorsque le premier NULL est trouvé (seulement pour le type string, pointeur
   ou hashtable)
* _hdata_name_ : nom d'un hdata (si c'est un pointeur vers une structure qui a
  un hdata)

Avec WeeChat ≥ 3.4, le paramètre _array_size_ peut être préfixé par `*,` pour
un pointeur vers un tableau alloué dynamiquement (sans ce préfixe, le tableau
est considéré statique).

Exemples de variables avec la taille de tableau correspondante (_WeeChat ≥ 3.4_) :

[width="100%",cols="3,3m,2,7",options="header"]
|===
| Déclaration de variable en C | Type Hdata | Taille de tableau | Description

| `+int *numbers;+` | WEECHAT_HDATA_INTEGER | `+*,2+`
| Tableau alloué de 2 entiers.

| `+int *numbers;+` | WEECHAT_HDATA_INTEGER | `+*,array_size+`
| Tableau alloué d'entiers, la taille est stockée dans une autre variable
  nommée "array_size".

| `+int numbers[3];+` | WEECHAT_HDATA_INTEGER | `+3+`
| Tableau statique de 3 entiers.

| `+char **words;+` | WEECHAT_HDATA_STRING | `+*,*+`
| Tableau alloué de chaînes, taille dynamique (un pointeur NULL doit être
  présent après le dernier mot).

| `+char **words;+` | WEECHAT_HDATA_STRING | `+*,count_words+`
| Tableau alloué de chaînes, la taille est stockée dans une autre variable
  nommée "count_words".
|===

Exemple en C :

[source,c]
----
struct t_myplugin_list
{
    char *name;
    struct t_gui_buffer *buffer;
    int numbers[3];
    int tags_count;
    char **tags_array;
    char **string_split;
    struct t_myplugin_list *prev;
    struct t_myplugin_list *next;
};

/* ... */

struct t_hdata *hdata = weechat_hdata_new ("myplugin_list", "prev", "next");
weechat_hdata_new_var (hdata, "name", offsetof (struct t_myplugin_list, name), WEECHAT_HDATA_STRING, 0, NULL, NULL);
weechat_hdata_new_var (hdata, "buffer", offsetof (struct t_myplugin_list, buffer), WEECHAT_HDATA_POINTER, 0, NULL, NULL);
weechat_hdata_new_var (hdata, "numbers", offsetof (struct t_myplugin_list, numbers), WEECHAT_HDATA_INTEGER, 0, "3", NULL);
weechat_hdata_new_var (hdata, "tags_count", offsetof (struct t_myplugin_list, tags_count), WEECHAT_HDATA_INTEGER, 0, NULL, NULL);
weechat_hdata_new_var (hdata, "tags_array", offsetof (struct t_myplugin_list, tags_array), WEECHAT_HDATA_STRING, 0, "*,tags_count", NULL);
weechat_hdata_new_var (hdata, "string_split", offsetof (struct t_myplugin_list, string_split), WEECHAT_HDATA_STRING, 0, "*,*", NULL);
weechat_hdata_new_var (hdata, "prev", offsetof (struct t_myplugin_list, prev), WEECHAT_HDATA_POINTER, 0, NULL, "myplugin_list");
weechat_hdata_new_var (hdata, "next", offsetof (struct t_myplugin_list, next), WEECHAT_HDATA_POINTER, 0, NULL, "myplugin_list");
----

La macro "WEECHAT_HDATA_VAR" peut être utilisée pour raccourcir le code :

[source,c]
----
WEECHAT_HDATA_VAR(struct t_myplugin_list, name, STRING, 0, NULL, NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, buffer, POINTER, 0, NULL, NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, numbers, INTEGER, 0, "3", NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, tags_count, INTEGER, 0, NULL, NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, tags_array, STRING, 0, "*,tags_count", NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, string_split, STRING, 0, "*,*", NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, prev, POINTER, 0, NULL, "myplugin_list");
WEECHAT_HDATA_VAR(struct t_myplugin_list, next, POINTER, 0, NULL, "myplugin_list");
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== hdata_new_list

_WeeChat ≥ 0.3.6, mis à jour dans la 1.0._

Créer un nouveau pointeur vers une liste dans le hdata.

Prototype :

[source,c]
----
void weechat_hdata_new_list (struct t_hdata *hdata, const char *name, void *pointer, int flags);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _name_ : nom de la variable
* _pointer_ : pointeur vers la liste
* _flags_ : combinaison des valeurs suivantes : _(WeeChat ≥ 1.0)_
** _WEECHAT_HDATA_LIST_CHECK_POINTERS_ : liste utilisée pour vérifier les
   pointeurs

Exemple en C :

[source,c]
----
struct t_myplugin_list
{
    char *name;
    struct t_gui_buffer *buffer;
    int tags_count;
    char **tags_array;
    char **string_split;
    struct t_myplugin_list *prev;
    struct t_myplugin_list *next;
};

/* ... */

struct t_hdata *hdata = weechat_hdata_new ("myplugin_list", "prev", "next");
weechat_hdata_new_var (hdata, "name", offsetof (struct t_myplugin_list, name), WEECHAT_HDATA_STRING, NULL, NULL);
weechat_hdata_new_var (hdata, "buffer", offsetof (struct t_myplugin_list, buffer), WEECHAT_HDATA_POINTER, NULL, NULL);
weechat_hdata_new_var (hdata, "tags_count", offsetof (struct t_myplugin_list, tags_count), WEECHAT_HDATA_INTEGER, NULL, NULL);
weechat_hdata_new_var (hdata, "tags_array", offsetof (struct t_myplugin_list, tags_array), WEECHAT_HDATA_STRING, "tags_count", NULL);
weechat_hdata_new_var (hdata, "string_split", offsetof (struct t_myplugin_list, string_split), WEECHAT_HDATA_STRING, "*", NULL);
weechat_hdata_new_var (hdata, "prev", offsetof (struct t_myplugin_list, prev), WEECHAT_HDATA_POINTER, NULL, "myplugin_list");
weechat_hdata_new_var (hdata, "next", offsetof (struct t_myplugin_list, next), WEECHAT_HDATA_POINTER, NULL, "myplugin_list");

weechat_hdata_new_list (hdata, "buffers", &buffers, WEECHAT_HDATA_LIST_CHECK_POINTERS);
weechat_hdata_new_list (hdata, "last_buffer", &last_buffer, 0);
----

La macro "WEECHAT_HDATA_LIST" peut être utilisée pour raccourcir le code :

[source,c]
----
WEECHAT_HDATA_LIST(buffers, WEECHAT_HDATA_LIST_CHECK_POINTERS);
WEECHAT_HDATA_LIST(last_buffer, 0);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== hdata_get

_WeeChat ≥ 0.3.6._

Retourner un "hdata" pour une structure de WeeChat ou d'une extension.

[NOTE]
Le "hdata" ne contient aucune donnée, il s'agit seulement d'une table de hachage
avec la position (offset) des variables dans la structure. Cela signifie que
vous aurez besoin de ce hdata et d'un pointeur vers un objet WeeChat ou d'une
extension pour lire des données.

Prototype :

[source,c]
----
struct t_hdata *weechat_hdata_get (const char *hdata_name);
----

Paramètres :

* _hdata_name_ : nom du hdata (voir la liste ci-dessous)

Valeur de retour :

* pointeur vers le hdata, NULL en cas d'erreur

Liste des hdata :

include::{autogendir}/autogen_api_hdata.fr.adoc[tag=hdata]

Exemple en C :

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("irc_server");
----

Script (Python) :

[source,python]
----
# prototype
def hdata_get(hdata_name: str) -> str: ...

# exemple
hdata = weechat.hdata_get("irc_server")
----

==== hdata_get_var_offset

_WeeChat ≥ 0.3.6._

Retourner la position (offset) de la variable dans le hdata.

Prototype :

[source,c]
----
int weechat_hdata_get_var_offset (struct t_hdata *hdata, const char *name);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _name_ : nom de la variable

Valeur de retour :

* position (offset) de la variable, -1 en cas d'erreur

Exemple en C :

[source,c]
----
int offset = weechat_hdata_get_var_offset (hdata, "name");
----

Script (Python) :

[source,python]
----
# prototype
def hdata_get_var_offset(hdata: str, name: str) -> int: ...

# exemple
offset = weechat.hdata_get_var_offset(hdata, "name")
----

==== hdata_get_var_type

_WeeChat ≥ 0.3.6._

Retourner le type de la variable dans le hdata (sous forme d'entier).

Prototype :

[source,c]
----
int weechat_hdata_get_var_type (struct t_hdata *hdata, const char *name);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _name_ : nom de la variable

Valeur de retour :

* type de la variable, -1 en cas d'erreur

Exemple en C :

[source,c]
----
int type = weechat_hdata_get_var_type (hdata, "name");
switch (type)
{
    case WEECHAT_HDATA_CHAR:
        /* ... */
        break;
    case WEECHAT_HDATA_INTEGER:
        /* ... */
        break;
    case WEECHAT_HDATA_LONG:
        /* ... */
        break;
    case WEECHAT_HDATA_LONGLONG:
        /* ... */
        break;
    case WEECHAT_HDATA_STRING:
        /* ... */
        break;
    case WEECHAT_HDATA_SHARED_STRING:
        /* ... */
        break;
    case WEECHAT_HDATA_POINTER:
        /* ... */
        break;
    case WEECHAT_HDATA_TIME:
        /* ... */
        break;
    case WEECHAT_HDATA_HASHTABLE:
        /* ... */
        break;
    case WEECHAT_HDATA_OTHER:
        /* ... */
        break;
    default:
        /* variable non trouvée */
        break;
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== hdata_get_var_type_string

_WeeChat ≥ 0.3.6._

Retourner le type de la variable dans le hdata (sous forme de chaîne).

Prototype :

[source,c]
----
const char *weechat_hdata_get_var_type_string (struct t_hdata *hdata, const char *name);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _name_ : nom de la variable

Valeur de retour :

* type de la variable, NULL en cas d'erreur

Exemple en C :

[source,c]
----
weechat_printf (NULL, "type = %s", weechat_hdata_get_var_type_string (hdata, "name"));
----

Script (Python) :

[source,python]
----
# prototype
def hdata_get_var_type_string(hdata: str, name: str) -> str: ...

# exemple
weechat.prnt("", "type = %s" % weechat.hdata_get_var_type_string(hdata, "name"))
----

==== hdata_get_var_array_size

_WeeChat ≥ 0.3.9._

Retourner la taille du tableau pour la variable dans le hdata.

Prototype :

[source,c]
----
int weechat_hdata_get_var_array_size (struct t_hdata *hdata, void *pointer, const char *name);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _pointer_ : pointeur vers un objet WeeChat ou d'une extension
* _name_ : nom de la variable

Valeur de retour :

* taille du tableau pour la variable, -1 si la variable n'est pas un tableau ou
  en cas d'erreur

Exemple en C :

[source,c]
----
int array_size = weechat_hdata_get_var_array_size (hdata, pointer, "name");
----

Script (Python) :

[source,python]
----
# prototype
def hdata_get_var_array_size(hdata: str, pointer: str, name: str) -> int: ...

# exemple
array_size = weechat.hdata_get_var_array_size(hdata, pointer, "name")
----

==== hdata_get_var_array_size_string

_WeeChat ≥ 0.3.9._

Retourner la taille du tableau pour la variable dans le hdata (sous forme de
chaîne).

Prototype :

[source,c]
----
const char *weechat_hdata_get_var_count_array_size (struct t_hdata *hdata, void *pointer,
                                                    const char *name);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _pointer_ : pointeur vers un objet WeeChat ou d'une extension
* _name_ : nom de la variable

Valeur de retour :

* taille du tableau pour la variable sous forme de chaîne, -1 si la variable
  n'est pas un tableau ou en cas d'erreur

Exemple en C :

[source,c]
----
const char *array_size = weechat_hdata_get_var_array_size_string (hdata, pointer, "name");
----

Script (Python) :

[source,python]
----
# prototype
def hdata_get_var_array_size_string(hdata: str, pointer: str, name: str) -> str: ...

# exemple
array_size = weechat.hdata_get_var_array_size_string(hdata, pointer, "name")
----

==== hdata_get_var_hdata

_WeeChat ≥ 0.3.6._

Retourner le hdata pour la variable dans le hdata.

Prototype :

[source,c]
----
const char *weechat_hdata_get_var_hdata (struct t_hdata *hdata, const char *name);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _name_ : nom de la variable

Valeur de retour :

* hdata pour la variable, NULL si pas de hdata ou en cas d'erreur

Exemple en C :

[source,c]
----
weechat_printf (NULL, "hdata = %s", weechat_hdata_get_var_hdata (hdata, "name"));
----

Script (Python) :

[source,python]
----
# prototype
def hdata_get_var_hdata(hdata: str, name: str) -> str: ...

# exemple
weechat.prnt("", "hdata = %s" % weechat.hdata_get_var_hdata(hdata, "name"))
----

==== hdata_get_var

_WeeChat ≥ 0.3.6._

Retourner un pointeur vers le contenu de la variable dans le hdata.

Prototype :

[source,c]
----
void *weechat_hdata_get_var (struct t_hdata *hdata, void *pointer, const char *name);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _pointer_ : pointeur vers un objet WeeChat ou d'une extension
* _name_ : nom de la variable

Valeur de retour :

* pointeur vers le contenu de la variable, NULL en cas d'erreur

Exemple en C :

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
void *pointer = weechat_hdata_get_var (hdata, buffer, "name");
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== hdata_get_var_at_offset

_WeeChat ≥ 0.3.6._

Retourner un pointeur vers le contenu de la variable dans le hdata, en utilisant
une position (offset).

Prototype :

[source,c]
----
void *weechat_hdata_get_var_at_offset (struct t_hdata *hdata, void *pointer, int offset);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _pointer_ : pointeur vers un objet WeeChat ou d'une extension
* _offset_ : position (offset) de la variable

Valeur de retour :

* pointeur vers le contenu de la variable, NULL en cas d'erreur

Exemple en C :

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
int offset = weechat_hdata_get_var_offset (hdata, "name");
void *pointer = weechat_hdata_get_var_at_offset (hdata, buffer, offset);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== hdata_get_list

_WeeChat ≥ 0.3.6._

Retourner un pointeur de liste du hdata.

Prototype :

[source,c]
----
void *weechat_hdata_get_list (struct t_hdata *hdata, const char *name);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _name_ : nom de la liste

Valeur de retour :

* pointeur vers la liste, NULL en cas d'erreur

Exemple en C :

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffers = weechat_hdata_get_list (hdata, "gui_buffers");
----

Script (Python) :

[source,python]
----
# prototype
def hdata_get_list(hdata: str, name: str) -> str: ...

# exemple
hdata = weechat.hdata_get("buffer")
buffers = weechat.hdata_get_list(hdata, "gui_buffers")
----

==== hdata_check_pointer

_WeeChat ≥ 0.3.7, mis à jour dans la 1.0._

Vérifier si un pointeur est valide pour un hdata et un pointeur de liste.

Prototype :

[source,c]
----
int weechat_hdata_check_pointer (struct t_hdata *hdata, void *list, void *pointer);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _list_ : pointeur vers une liste; si NULL _(WeeChat ≥ 1.0)_, le pointeur est
  vérifié avec les listes dans le hdata qui ont le drapeau
  "vérifier les pointeurs" (voir
  <<_hdata_new_list,hdata_new_list>>), et s'il n'y a pas de telle liste,
  le pointeur est considéré comme valide
* _pointer_ : pointeur à vérifier

Valeur de retour :

* 1 si le pointeur est dans la liste, 0 si non trouvé

Exemple en C :

[source,c]
----
/* vérifie si le pointeur vers le tampon est valide */
struct t_hdata *hdata = weechat_hdata_get ("buffer");
if (weechat_hdata_check_pointer (hdata,
                                 weechat_hdata_get_list (hdata, "gui_buffers"),
                                 ptr_buffer))
{
    /* pointeur valide */
}
else
{
    /* pointeur invalide */
}
----

Script (Python) :

[source,python]
----
# prototype
def hdata_check_pointer(hdata: str, list: str, pointer: str) -> int: ...

# exemple
hdata = weechat.hdata_get("buffer")
if weechat.hdata_check_pointer(hdata, weechat.hdata_get_list(hdata, "gui_buffers"), ptr_buffer):
    # pointeur valide
    # ...
else:
    # pointeur invalide
    # ...
----

==== hdata_move

_WeeChat ≥ 0.3.6._

Déplacer le pointeur vers un autre élément dans la liste.

Prototype :

[source,c]
----
void *weechat_hdata_move (struct t_hdata *hdata, void *pointer, int count);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _pointer_ : pointeur vers un objet WeeChat ou d'une extension
* _count_ : nombre de saut(s) à exécuter (entier négatif ou positif, différent
  de 0)

Valeur de retour :

* pointeur vers l'élément atteint, NULL si l'élément n'est pas trouvé
  (par exemple fin de la liste), ou en cas d'erreur

Exemple en C :

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();

/* se déplacer au tampon suivant, 2 fois */
buffer = weechat_hdata_move (hdata, buffer, 2);

/* se déplacer au tampon précédent */
if (buffer)
    buffer = weechat_hdata_move (hdata, buffer, -1);
----

Script (Python) :

[source,python]
----
# prototype
def hdata_move(hdata: str, pointer: str, count: int) -> str: ...

# exemple
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()

# se déplacer au tampon suivant, 2 fois
buffer = weechat.hdata_move(hdata, buffer, 2)

# se déplacer au tampon précédent
if buffer:
    buffer = weechat.hdata_move(hdata, buffer, -1)
----

==== hdata_search

_WeeChat ≥ 0.4.1, mis à jour dans la 3.4._

Chercher un élément dans la liste : l'expression _search_ est évaluée pour
chaque élément dans la liste, jusqu'à trouver l'élément (ou la fin de la liste).

Prototype :

[source,c]
----
void *weechat_hdata_search (struct t_hdata *hdata, void *pointer, const char *search,
                            struct t_hashtable *pointers, struct t_hashtable *extra_vars,
                            struct t_hashtable *options, int move);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _pointer_ : pointeur vers un objet WeeChat ou d'une extension
* _search_ : expression à évaluer, le pointeur par défaut dans l'expression est
  le nom du hdata (et ce pointeur change pour chaque élément dans la liste);
  pour l'aide sur l'expression, voir le
  link:weechat_user.fr.html#command_weechat_eval[Guide utilisateur WeeChat / Commande /eval ^↗^^]
* _pointers_ : table de hachage pour l'appel à la fonction
  <<_string_eval_expression,string_eval_expression>>
* _extra_vars_ : table de hachage pour l'appel à la fonction
  <<_string_eval_expression,string_eval_expression>>
* _options_ : table de hachage pour l'appel à la fonction
  <<_string_eval_expression,string_eval_expression>>
* _move_ : nombre de saut(s) à exécuter après une recherche infructueuse (entier
  négatif ou positif, différent de 0)

[IMPORTANT]
Vous devez vous assurer que l'expression _search_ est sûre et ne contient
aucune donnée utilisateur. De telles données non sûres doivent être données
dans la table de hachage _extra_vars_ et être référencées par `${xxx}` dans
l'expression _search_ (voir l'exemple ci-dessous).

Valeur de retour :

* pointeur vers l'élément trouvé, ou NULL si non trouvé

Exemple en C :

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("irc_server");
void *servers = weechat_hdata_get_list (hdata, "irc_servers");
struct t_hashtable *extra_vars = weechat_hashtable_new (8,
                                                        WEECHAT_HASHTABLE_STRING,
                                                        WEECHAT_HASHTABLE_STRING,
                                                        NULL,
                                                        NULL);

/* cherche un serveur irc avec le nom "libera" */
weechat_hashtable_set (extra_vars, "server_name", "libera");
void *server = weechat_hdata_search (hdata, servers, "${irc_server.name} == ${server_name}",
                                     NULL, extra_vars, NULL, 1);
if (server)
{
    /* ... */
}
weechat_hashtable_free (extra_vars);
----

Script (Python) :

[source,python]
----
# prototype
def hdata_search(hdata: str, pointer: str, search: str,
                 pointers: Dict[str, str], extra_vars: Dict[str, str], options: Dict[str, str],
                 count: int) -> str: ...

# exemple
hdata = weechat.hdata_get("irc_server")
servers = weechat.hdata_get_list(hdata, "irc_servers")

# cherche un serveur irc avec le nom "libera"
server = weechat.hdata_search(hdata, servers, "${irc_server.name} == ${server_name}",
                              {}, {"server_name": "libera"}, {}, 1)
if server:
    # ...
----

==== hdata_char

_WeeChat ≥ 0.3.7._

Retourner la valeur de la variable dans la structure en utilisant le hdata, sous
forme de caractère.

Prototype :

[source,c]
----
char weechat_hdata_char (struct t_hdata *hdata, void *pointer, const char *name);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _pointer_ : pointeur vers un objet WeeChat ou d'une extension
* _name_ : nom de la variable (doit être de type "char"); pour les tableaux,
  le nom peut être "N|name" où N est un index dans le tableau (démarrant à 0),
  par exemple : "2|name"

Valeur de retour :

* valeur de la variable, sous forme de caractère

Exemple en C :

[source,c]
----
weechat_printf (NULL, "letter = %c", weechat_hdata_char (hdata, pointer, "letter"));
----

Script (Python) :

[source,python]
----
# prototype
def hdata_char(hdata: str, pointer: str, name: str) -> int: ...

# exemple
weechat.prnt("", "letter = %c" % weechat.hdata_char(hdata, pointer, "letter"))
----

==== hdata_integer

_WeeChat ≥ 0.3.6._

Retourner la valeur de la variable dans la structure en utilisant le hdata, sous
forme d'entier.

Prototype :

[source,c]
----
int weechat_hdata_integer (struct t_hdata *hdata, void *pointer, const char *name);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _pointer_ : pointeur vers un objet WeeChat ou d'une extension
* _name_ : nom de la variable (doit être de type "integer"); pour les tableaux,
  le nom peut être "N|name" où N est un index dans le tableau (démarrant à 0),
  par exemple : "2|name"

Valeur de retour :

* valeur de la variable, sous forme d'entier

Exemple en C :

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
weechat_printf (NULL, "number = %d", weechat_hdata_integer (hdata, buffer, "number"));
----

Script (Python) :

[source,python]
----
# prototype
def hdata_integer(hdata: str, pointer: str, name: str) -> int: ...

# exemple
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
weechat.prnt("", "number = %d" % weechat.hdata_integer(hdata, buffer, "number"))
----

==== hdata_long

_WeeChat ≥ 0.3.6._

Retourner la valeur de la variable dans la structure en utilisant le hdata, sous
forme d'entier "long".

Prototype :

[source,c]
----
long weechat_hdata_long (struct t_hdata *hdata, void *pointer, const char *name);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _pointer_ : pointeur vers un objet WeeChat ou d'une extension
* _name_ : nom de la variable (doit être de type "long"); pour les tableaux,
  le nom peut être "N|name" où N est un index dans le tableau (démarrant à 0),
  par exemple : "2|name"

Valeur de retour :

* valeur de la variable, sous forme d'entier long

Exemple en C :

[source,c]
----
weechat_printf (NULL, "longvar = %ld", weechat_hdata_long (hdata, pointer, "longvar"));
----

Script (Python) :

[source,python]
----
# prototype
def hdata_long(hdata: str, pointer: str, name: str) -> int: ...

# exemple
weechat.prnt("", "longvar = %d" % weechat.hdata_long(hdata, pointer, "longvar"))
----

==== hdata_longlong

_WeeChat ≥ 4.3.0._

Retourner la valeur de la variable dans la structure en utilisant le hdata, sous
forme d'entier "long long".

Prototype :

[source,c]
----
long long weechat_hdata_longlong (struct t_hdata *hdata, void *pointer, const char *name);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _pointer_ : pointeur vers un objet WeeChat ou d'une extension
* _name_ : nom de la variable (doit être de type "long long"); pour les tableaux,
  le nom peut être "N|name" où N est un index dans le tableau (démarrant à 0),
  par exemple : "2|name"

Valeur de retour :

* valeur de la variable, sous forme d'entier "long long".

Exemple en C :

[source,c]
----
weechat_printf (NULL, "longlongvar = %llu", weechat_hdata_longlong (hdata, pointer, "longlongvar"));
----

Script (Python) :

[source,python]
----
# prototype
def hdata_longlong(hdata: str, pointer: str, name: str) -> int: ...

# exemple
weechat.prnt("", "longlongvar = %d" % weechat.hdata_longlong(hdata, pointer, "longlongvar"))
----

==== hdata_string

_WeeChat ≥ 0.3.6._

Retourner la valeur de la variable dans la structure en utilisant le hdata, sous
forme de chaîne.

Prototype :

[source,c]
----
const char *weechat_hdata_string (struct t_hdata *hdata, void *pointer, const char *name);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _pointer_ : pointeur vers un objet WeeChat ou d'une extension
* _name_ : nom de la variable (doit être de type "string"); pour les tableaux,
  le nom peut être "N|name" où N est un index dans le tableau (démarrant à 0),
  par exemple : "2|name"

Valeur de retour :

* valeur de la variable, sous forme de chaîne

Exemple en C :

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
weechat_printf (NULL, "name = %s", weechat_hdata_string (hdata, buffer, "name"));
----

Script (Python) :

[source,python]
----
# prototype
def hdata_string(hdata: str, pointer: str, name: str) -> str: ...

# exemple
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
weechat.prnt("", "name = %s" % weechat.hdata_string(hdata, buffer, "name"))
----

==== hdata_pointer

_WeeChat ≥ 0.3.6._

Retourner la valeur de la variable dans la structure en utilisant le hdata, sous
forme de pointeur.

Prototype :

[source,c]
----
void *weechat_hdata_pointer (struct t_hdata *hdata, void *pointer, const char *name);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _pointer_ : pointeur vers un objet WeeChat ou d'une extension
* _name_ : nom de la variable (doit être de type "pointeur"); pour les tableaux,
  le nom peut être "N|name" où N est un index dans le tableau (démarrant à 0),
  par exemple : "2|name"

Valeur de retour :

* valeur de la variable, sous forme de pointeur

Exemple en C :

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
weechat_printf (NULL, "lines = %lx", weechat_hdata_pointer (hdata, buffer, "lines"));
----

Script (Python) :

[source,python]
----
# prototype
def hdata_pointer(hdata: str, pointer: str, name: str) -> str: ...

# exemple
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
weechat.prnt("", "lines = %x" % weechat.hdata_pointer(hdata, buffer, "lines"))
----

==== hdata_time

_WeeChat ≥ 0.3.6._

Retourner la valeur de la variable dans la structure en utilisant le hdata, sous
forme de date/heure.

Prototype :

[source,c]
----
time_t weechat_hdata_time (struct t_hdata *hdata, void *pointer, const char *name);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _pointer_ : pointeur vers un objet WeeChat ou d'une extension
* _name_ : nom de la variable (doit être de type "time"); pour les tableaux,
  le nom peut être "N|name" où N est un index dans le tableau (démarrant à 0),
  par exemple : "2|name"

Valeur de retour :

* valeur de la variable, sous forme de date/heure

Exemple en C :

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *ptr = weechat_buffer_search_main ();
ptr = weechat_hdata_pointer (hdata, ptr, "lines");
if (ptr)
{
    hdata = weechat_hdata_get ("lines");
    ptr = weechat_hdata_pointer (hdata, ptr, "first_line");
    if (ptr)
    {
        hdata = weechat_hdata_get ("line");
        ptr = weechat_hdata_pointer (hdata, ptr, "data");
        if (ptr)
        {
            hdata = weechat_hdata_get ("line_data");
            time_t date = weechat_hdata_time (hdata, hdata, "date");
            weechat_printf (NULL, "heure de la première ligne affichée = %s", ctime (&date));
        }
    }
}
----

Script (Python) :

[source,python]
----
# prototype
def hdata_time(hdata: str, pointer: str, name: str) -> int: ...

# exemple
buf = weechat.buffer_search_main()
ptr = weechat.hdata_pointer(weechat.hdata_get("buffer"), buf, "lines")
if ptr:
    ptr = weechat.hdata_pointer(weechat.hdata_get("lines"), ptr, "first_line")
    if ptr:
        ptr = weechat.hdata_pointer(weechat.hdata_get("line"), ptr, "data")
        if ptr:
            date = weechat.hdata_time(weechat.hdata_get("line_data"), ptr, "date")
            weechat.prnt("", "heure de la première ligne affichée = %s" % time.strftime("%F %T", time.localtime(int(date))))
----

==== hdata_hashtable

_WeeChat ≥ 0.3.7._

Retourner la valeur de la variable dans la structure en utilisant le hdata, sous
forme de table de hachage.

Prototype :

[source,c]
----
struct t_hashtable *weechat_hdata_hashtable (struct t_hdata *hdata, void *pointer, const char *name);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _pointer_ : pointeur vers un objet WeeChat ou d'une extension
* _name_ : nom de la variable (doit être de type "hashtable"); pour les
  tableaux, le nom peut être "N|name" où N est un index dans le tableau
  (démarrant à 0), par exemple : "2|name"

Valeur de retour :

* valeur de la variable, sous forme de pointeur vers la table de hachage

Exemple en C :

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
struct t_hashtable *hashtable = weechat_hdata_hashtable (hdata, buffer, "local_variables");
weechat_printf (NULL, "%d variables locales dans le tampon principal",
                weechat_hashtable_get_integer (hashtable, "items_count"));
----

Script (Python) :

[source,python]
----
# prototype
def hdata_hashtable(hdata: str, pointer: str, name: str) -> Dict[str, str]: ...

# exemple
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
hash = weechat.hdata_hashtable(hdata, buffer, "local_variables")
weechat.prnt("", "variables locales dans le tampon principal :")
for key in hash:
    weechat.prnt("", "  %s == %s" % (key, hash[key]))
----

==== hdata_compare

_WeeChat ≥ 1.9, mis à jour dans la 4.1.0._

Comparer une variable hdata de deux objets.

Prototype :

[source,c]
----
int weechat_hdata_compare (struct t_hdata *hdata, void *pointer1, void *pointer2, const char *name, int case_sensitive);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _pointer1_ : pointeur vers le premier objet WeeChat ou d'une extension
* _pointer2_ : pointeur vers le second objet WeeChat ou d'une extension
* _name_ : nom de la variable ou chemin vers le nom de la variable ; pour les
  tableaux, le nom peut être "N|name" où N est un index dans le tableau
  (démarrant à 0), par exemple : "2|name"
* _case_sensitive_ : 1 pour une comparaison tenant compte de la casse pour les chaînes,
  sinon 0

Valeur de retour :

* -1 si variable1 < variable2
* 0 si variable1 == variable2
* 1 si variable1 > variable2

Exemple en C :

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer1 = weechat_buffer_search ("irc", "libera.#weechat");
struct t_gui_buffer *buffer2 = weechat_buffer_search ("irc", "libera.#weechat-fr");
weechat_printf (NULL, "comparaison de numéro de tampon = %d",
                weechat_hdata_compare (hdata, buffer1, buffer2, "number", 0));
weechat_printf (NULL, "comparaison du nombre de lignes = %d",
                weechat_hdata_compare (hdata, buffer1, buffer2, "own_lines.lines_count", 0));
weechat_printf (NULL, "comparaison de variable locale = %d",
                weechat_hdata_compare (hdata, buffer1, buffer2, "local_variables.myvar", 0));
----

Script (Python) :

[source,python]
----
# prototype
def hdata_compare(hdata: str, pointer1: str, pointer2: str, name: str, case_sensitive: int) -> int: ...

# exemple
hdata = weechat.hdata_get("buffer")
buffer1 = weechat.buffer_search("irc", "libera.#weechat")
buffer2 = weechat.buffer_search("irc", "libera.#weechat-fr")
weechat.prnt("", "comparaison de numéro de tampon = %d" % weechat.hdata_compare(hdata, buffer1, buffer2, "number", 0))
weechat.prnt("", "comparaison du nombre de lignes = %d" % weechat.hdata_compare(hdata, buffer1, buffer2, "own_lines.lines_count", 0))
weechat.prnt("", "comparaison de variable locale = %d" % weechat.hdata_compare(hdata, buffer1, buffer2, "local_variables.myvar", 0))
----

==== hdata_set

_WeeChat ≥ 0.3.9._

Définir une nouvelle valeur pour une variable dans un hdata.

[NOTE]
Cette fonction ne peut être appelée que dans une fonction de rappel de mise à
jour (voir <<_hdata_new,hdata_new>> et <<_hdata_update,hdata_update>>), si la
variable peut être mise à jour.

Prototype :

[source,c]
----
int weechat_hdata_set (struct t_hdata *hdata, void *pointer, const char *name, const char *value);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _pointer_ : pointeur vers un objet WeeChat ou d'une extension
* _name_ : nom de la variable (types autorisés : char, integer, long, string,
  pointer, time)
* _value_ : nouvelle valeur pour la variable

Valeur de retour :

* 1 si ok, 0 en cas d'erreur

Exemple en C :

[source,c]
----
weechat_hdata_set (hdata, pointer, "message", "test");
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== hdata_update

_WeeChat ≥ 0.3.9._

Mettre à jour des données dans le hdata.

Prototype :

[source,c]
----
int weechat_hdata_update (struct t_hdata *hdata, void *pointer, struct t_hashtable *hashtable);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _pointer_ : pointeur vers un objet WeeChat ou d'une extension
* _hashtable_ : variables à mettre à jour : les clés sont les noms des
  variables, les valeurs sont les nouvelles valeurs pour les variables (clés et
  valeurs sont des chaînes de caractères), quelques clés spéciales sont
  acceptées :
** clé `+__create_allowed+` (avec n'importe quelle valeur) : retourne 1 si la
   création est autorisée pour la structure, sinon 0
   _(WeeChat ≥ 0.4.0)_
** clé `+__delete_allowed+` (avec n'importe quelle valeur) : retourne 1 si la
   suppression est autorisée pour la structure, sinon 0
** clé `+__update_allowed+`, la valeur est le nom d'une variable : retourne 1 si
   la mise à jour est autorisée pour la variable, sinon 0
** clé `+__delete+` (avec n'importe quelle valeur) : supprime la structure
   (si autorisé)

Valeur de retour :

* nombre de variables mises à jour

Exemple en C :

[source,c]
----
/* soustrait une heure sur le dernier message affiché dans le tampon courant */

struct t_gui_lines *own_lines;
struct t_gui_line *line;
struct t_gui_line_data *line_data;
struct t_hdata *hdata;
struct t_hashtable *hashtable;
char str_date[64];

own_lines = weechat_hdata_pointer (weechat_hdata_get ("buffer"), weechat_current_buffer (), "own_lines");
if (own_lines)
{
    line = weechat_hdata_pointer (weechat_hdata_get ("lines"), own_lines, "last_line");
    if (line)
    {
        line_data = weechat_hdata_pointer (weechat_hdata_get ("line"), line, "data");
        hdata = weechat_hdata_get ("line_data");
        hashtable = weechat_hashtable_new (8,
                                           WEECHAT_HASHTABLE_STRING,
                                           WEECHAT_HASHTABLE_STRING,
                                           NULL,
                                           NULL);
        if (hashtable)
        {
            snprintf (str_date, sizeof (str_date), "%ld", ((long int)weechat_hdata_time (hdata, line_data, "date")) - 3600);
            weechat_hashtable_set (hashtable, "date", str_date);
            weechat_hdata_update (hdata, line_data, hashtable);
            weechat_hashtable_free (hashtable);
        }
    }
}
----

Script (Python) :

[source,python]
----
# prototype
def hdata_update(hdata: str, pointer: str, hashtable: Dict[str, str]) -> int: ...

# exemple : soustrait une heure sur le dernier message affiché dans le tampon courant
own_lines = weechat.hdata_pointer(weechat.hdata_get("buffer"), weechat.current_buffer(), "own_lines")
if own_lines:
    line = weechat.hdata_pointer(weechat.hdata_get("lines"), own_lines, "last_line")
    if line:
        line_data = weechat.hdata_pointer(weechat.hdata_get("line"), line, "data")
        hdata = weechat.hdata_get("line_data")
        weechat.hdata_update(hdata, line_data, {"date": str(weechat.hdata_time(hdata, line_data, "date") - 3600)})
----

==== hdata_get_string

_WeeChat ≥ 0.3.6._

Retourner une valeur pour une propriété d'un hdata sous forme de chaîne.

Prototype :

[source,c]
----
const char *weechat_hdata_get_string (struct t_hdata *hdata, const char *property);
----

Paramètres :

* _hdata_ : pointeur vers le hdata
* _property_ : nom de la propriété :
** _var_keys_ : chaîne avec la liste des clés pour les variables du hdata
   (format : "key1,key2,key3")
** _var_values_ : chaîne avec la liste des valeurs pour les variables du hdata
   (format : "value1,value2,value3")
** _var_keys_values_ : chaîne avec la liste des clés et valeurs pour les
   variables du hdata (format : "key1:value1,key2:value2,key3:value3")
** _var_prev_ : nom de la variable dans la structure qui est un pointeur vers
   l'élément précédent dans la liste
** _var_next_ : nom de la variable dans la structure qui est un pointeur vers
   l'élément suivant dans la liste
** _list_keys_ : chaîne avec la liste des clés pour les listes du hdata
   (format : "key1,key2,key3")
** _list_values_ : chaîne avec la liste des valeurs pour les listes du hdata
   (format : "value1,value2,value3")
** _list_keys_values_ : chaîne avec la liste des clés et valeurs pour les listes
   du hdata (format : "key1:value1,key2:value2,key3:value3")

Valeur de retour :

* valeur de la propriété sous forme de chaîne

Exemple en C :

[source,c]
----
weechat_printf (NULL, "variables dans le hdata : %s", weechat_hdata_get_string (hdata, "var_keys"));
weechat_printf (NULL, "listes dans le hdata : %s", weechat_hdata_get_string (hdata, "list_keys"));
----

Script (Python) :

[source,python]
----
# prototype
def hdata_get_string(hdata: str, property: str) -> str: ...

# exemple
weechat.prnt("", "variables dans le hdata : %s" % weechat.hdata_get_string(hdata, "var_keys"))
weechat.prnt("", "listes dans le hdata : %s" % weechat.hdata_get_string(hdata, "list_keys"))
----

[[upgrade]]
=== Mise à jour

Fonctions pour la mise à jour de WeeChat (commande "/upgrade").

==== upgrade_new

_Mis à jour dans la 1.5._

Créer ou lire un fichier pour la mise à jour.

Prototype :

[source,c]
----
struct t_upgrade_file *upgrade_file_new (const char *filename,
                                         int (*callback_read)(const void *pointer,
                                                              void *data,
                                                              struct t_upgrade_file *upgrade_file,
                                                              int object_id,
                                                              struct t_infolist *infolist),
                                         const void *callback_read_pointer,
                                         void *callback_read_data);
----

Paramètres :

* _filename_ : nom du fichier (l'extension ".upgrade" est ajoutée
  automatiquement par WeeChat)
* _callback_read_ : fonction appelée pour chaque objet lu dans le fichier de
  mise à jour (si NULL, le fichier pour la mise à jour est ouvert en
  écriture), paramètres et valeur de retour :
** _const void *pointer_ : pointeur
** _void *data_ : pointeur
** _struct t_upgrade_file *upgrade_file_ : pointeur vers le fichier de mise à
   jour
** _int object_id_ : identifiant de l'objet
** _struct t_infolist *infolist_ : infolist avec le contenu de l'objet
** valeur de retour :
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_read_pointer_ : pointeur donné à la fonction de rappel lorsqu'elle
  est appelée par WeeChat
* _callback_read_data_ : pointeur donné à la fonction de rappel lorsqu'elle est
  appelée par WeeChat; si non NULL, doit avoir été alloué par malloc (ou une
  fonction similaire) et est automatiquement libéré (par free) lorsque le
  fichier de mise à jour est fermé

Valeur de retour :

* pointeur vers le fichier de mise à jour

Exemple en C :

[source,c]
----
struct t_upgrade_file *upgrade_file = weechat_upgrade_new ("mon_fichier",
                                                           NULL, NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
def upgrade_new(filename: str, callback_read: str, callback_read_data: str) -> str: ...

# exemple
upgrade_file = weechat.upgrade_new("mon_fichier", "", "")
----

==== upgrade_write_object

Écrire un objet dans le fichier de mise à jour.

Prototype :

[source,c]
----
int weechat_upgrade_write_object (struct t_upgrade_file *upgrade_file,
                                  int object_id,
                                  struct t_infolist *infolist);
----

Paramètres :

* _upgrade_file_ : pointeur vers le fichier de mise à jour
* _object_id_ : identifiant de l'objet
* _infolist_ : infolist à écrire dans le fichier

Valeur de retour :

* 1 si ok, 0 en cas d'erreur

Exemple en C :

[source,c]
----
if (weechat_upgrade_write_object (upgrade_file, 1, &infolist))
{
    /* ok */
}
else
{
    /* erreur */
}
----

Script (Python) :

[source,python]
----
# prototype
def upgrade_write_object(upgrade_file: str, object_id: int, infolist: str) -> int: ...

# exemple
weechat.upgrade_write_object(upgrade_file, 1, infolist)
----

==== upgrade_read

_Mis à jour dans la 1.5._

Lire un fichier de mise à jour.

Prototype :

[source,c]
----
int weechat_upgrade_read (struct t_upgrade_file *upgrade_file);
----

Paramètres :

* _upgrade_file_ : pointeur vers le fichier de mise à jour

Valeur de retour :

* 1 si ok, 0 en cas d'erreur

Exemple en C :

[source,c]
----
weechat_upgrade_read (upgrade_file);
----

Script (Python) :

[source,python]
----
# prototype
def upgrade_read(upgrade_file: str) -> int: ...

# exemple
weechat.upgrade_read(upgrade_file)
----

==== upgrade_close

Fermer un fichier de mise à jour.

Prototype :

[source,c]
----
void weechat_upgrade_close (struct t_upgrade_file *upgrade_file);
----

Paramètres :

* _upgrade_file_ : pointeur vers le fichier de mise à jour

Exemple en C :

[source,c]
----
weechat_upgrade_close (upgrade_file);
----

Script (Python) :

[source,python]
----
# prototype
def upgrade_close(upgrade_file: str) -> int: ...

# exemple
weechat.upgrade_close(upgrade_file)
----
