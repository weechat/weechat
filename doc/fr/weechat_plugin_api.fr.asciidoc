= Référence API extension WeeChat
:author: Sébastien Helleu
:email: flashcode@flashtux.org
:lang: fr
:toc:
:toclevels: 4


Ce manuel documente le client de messagerie instantanée WeeChat, il fait
partie de WeeChat.

La dernière version de ce document peut être téléchargée sur cette page :
https://weechat.org/doc


[[introduction]]
== Introduction

WeeChat (Wee Enhanced Environment for Chat) est un client de discussion libre,
rapide et léger, conçu pour différents systèmes d'exploitation.

Ce manuel documente l'API WeeChat des extensions, utilisée par les extensions
en C pour interagir avec le cœur de WeeChat.

[[plugins_in_weechat]]
== Extensions dans WeeChat

Une extension est un programme C qui peut appeler des fonctions WeeChat
définies dans une interface.

Ce programme C n'a pas besoin des sources WeeChat pour être compilé et peut
être dynamiquement chargé dans WeeChat avec la commande `/plugin`.

Cette extension doit être une bibliothèque dynamique, pour un chargement
dynamique par le système d'exploitation.
Sous GNU/Linux, le fichier a une extension ".so" et ".dll" sous Windows.

L'extension doit inclure le fichier "weechat-plugin.h" (disponible dans le code
source WeeChat).
Ce fichier définit les structures et types utilisés pour communiquer avec
WeeChat.

[[macros]]
=== Macros

L'extension doit utiliser des macros (pour définir quelques variables) :

WEECHAT_PLUGIN_NAME("name")::
    nom de l'extension

WEECHAT_PLUGIN_DESCRIPTION("description")::
    description courte de l'extension

WEECHAT_PLUGIN_VERSION("1.0")::
    version de l'extension

WEECHAT_PLUGIN_LICENSE("GPL3")::
    licence de l'extension

[[main_functions]]
=== Fonctions principales

L'extension doit utiliser deux fonctions :

* weechat_plugin_init
* weechat_plugin_end

==== weechat_plugin_init

Cette fonction est appelée quand l'extension est chargée par WeeChat.

Prototype :

[source,C]
----
int weechat_plugin_init (struct t_weechat_plugin *plugin,
                         int argc, char *argv[]);
----

Paramètres :

* 'plugin' : pointeur vers la structure d'extension WeeChat
* 'argc' : nombre de paramètres pour l'extension (donnés sur la ligne de
  commande par l'utilisateur)
* 'argv' : paramètres pour l'extension

Valeur de retour :

* 'WEECHAT_RC_OK' si ok (l'extension sera chargée)
* 'WEECHAT_RC_ERROR' si erreur (l'extension ne sera PAS chargée)

==== weechat_plugin_end

Cette fonction est appelée quand l'extension est déchargée par WeeChat.

Prototype :

[source,C]
----
int weechat_plugin_end (struct t_weechat_plugin *plugin);
----

Paramètres :

* 'plugin' : pointeur vers la structure d'extension WeeChat

Valeur de retour :

* 'WEECHAT_RC_OK' si ok
* 'WEECHAT_RC_ERROR' si erreur

[[compile_plugin]]
=== Compilation de l'extension

La compilation ne nécessite pas les sources de WeeChat, seul le fichier
 'weechat-plugin.h' est requis.

Pour compiler l'extension qui n'a qu'un fichier "toto.c" (sous GNU/Linux) :

----
$ gcc -fPIC -Wall -c toto.c
$ gcc -shared -fPIC -o libtoto.so toto.o
----

[[load_plugin]]
=== Chargement de l'extension

Copiez le fichier 'libtoto.so' dans le répertoire système des extensions (par
exemple '/usr/local/lib/weechat/plugins') ou dans le répertoire utilisateur des
extensions (par exemple '/home/xxx/.weechat/plugins').

Sous WeeChat :

----
/plugin load toto
----

[[plugin_example]]
=== Exemple d'extension

Exemple complet d'extension, qui ajoute une commande '/double' : affiche deux
fois les paramètres sur le tampon courant, ou exécute deux fois une commande
(ok ce n'est pas très utile, mais c'est juste un exemple !) :

[source,C]
----
#include <stdlib.h>

#include "weechat-plugin.h"

WEECHAT_PLUGIN_NAME("double");
WEECHAT_PLUGIN_DESCRIPTION("Extension de test pour WeeChat");
WEECHAT_PLUGIN_AUTHOR("Sébastien Helleu <flashcode@flashtux.org>");
WEECHAT_PLUGIN_VERSION("0.1");
WEECHAT_PLUGIN_LICENSE("GPL3");

struct t_weechat_plugin *weechat_plugin = NULL;


/* callback pour la commande "/double" */

int
commande_double_cb (void *data, struct t_gui_buffer *buffer, int argc,
                    char **argv, char **argv_eol)
{
    /* pour que le compilateur C soit content */
    (void) data;
    (void) buffer;
    (void) argv;

    if (argc > 1)
    {
        weechat_command (NULL, argv_eol[1]);
        weechat_command (NULL, argv_eol[1]);
    }

    return WEECHAT_RC_OK;
}

int
weechat_plugin_init (struct t_weechat_plugin *plugin,
                     int argc, char *argv[])
{
    weechat_plugin = plugin;

    weechat_hook_command ("double",
                          "Affiche deux fois un message "
                          "ou exécute deux fois une commande",
                          "message | commande",
                          "message : message à afficher deux fois\n"
                          "commande : commande à exécuter deux fois",
                          NULL,
                          &commande_double_cb, NULL);

    return WEECHAT_RC_OK;
}

int
weechat_plugin_end (struct t_weechat_plugin *plugin)
{
    /* pour que le compilateur C soit content */
    (void) plugin;

    return WEECHAT_RC_OK;
}
----

[[plugin_api]]
== API extension

Les chapitres ci-dessous décrivent les fonctions de l'API, classées par
catégorie.

Pour chaque fonction, on donne :

* une description de la fonction,
* le prototype en C,
* le détail des paramètres,
* la valeur de retour,
* un exemple en C,
* un exemple en script Python (la syntaxe pour les autres langages de script est
  similaire).

[[plugins]]
=== Extensions

Fonctions pour obtenir des informations sur les extensions.

==== weechat_plugin_get_name

Retourner le nom d'une extension.

Prototype :

[source,C]
----
const char *weechat_plugin_get_name (struct t_weechat_plugin *plugin);
----

Paramètres :

* 'plugin' : pointeur vers la structure d'extension WeeChat (peut être NULL)

Valeur de retour :

* nom de l'extension, "core" pour le cœur de WeeChat (si le pointeur vers
  l'extension est NULL)

Exemple en C :

[source,C]
----
const char *name = weechat_plugin_get_name (plugin);
----

Script (Python) :

[source,python]
----
# prototype
name = weechat.plugin_get_name(plugin)

# exemple
plugin = weechat.buffer_get_pointer(weechat.current_buffer(), "plugin")
name = weechat.plugin_get_name(plugin)
----

[[strings]]
=== Chaînes de caractères

Plusieurs fonctions sur les chaînes de caractères sont déjà disponibles via
les fonctions standard du C, mais il est recommandé d'utiliser celles de l'API
car elles sont ok avec UTF-8 et la locale.

==== weechat_charset_set

Définir le nouveau jeu de caractères (le jeu de caractères par défaut est
'UTF-8', donc si votre extension utilise 'UTF-8', vous n'avez pas besoin
d'appeler cette fonction).

Prototype :

[source,C]
----
void weechat_charset_set (const char *charset);
----

Paramètres :

* 'charset' : nouveau jeu de caractères à utiliser

Exemple en C :

[source,C]
----
weechat_charset_set ("iso-8859-1");
----

Script (Python) :

[source,python]
----
# prototype
weechat.charset_set(charset)

# exemple
weechat.charset_set("iso-8859-1")
----

==== weechat_iconv_to_internal

Convertir une chaîne vers le jeu de caractères interne (UTF-8).

Prototype :

[source,C]
----
char *weechat_iconv_to_internal (const char *charset, const char *string);
----

Paramètres :

* 'charset' : jeu de caractères à convertir
* 'string' : chaîne à convertir

Valeur de retour :

* chaîne convertie (doit être supprimée par un appel à "free" après utilisation)

Exemple en C :

[source,C]
----
char *str = weechat_iconv_to_internal ("iso-8859-1", "chaîne iso : é à");
/* ... */
free (str);
----

Script (Python) :

[source,python]
----
# prototype
str = weechat.iconv_to_internal(charset, string)

# exemple
str = weechat.iconv_to_internal("iso-8859-1", "chaîne iso : é à")
----

==== weechat_iconv_from_internal

Convertir une chaîne du jeu de caractères interne (UTF-8) vers un autre.

Prototype :

[source,C]
----
char *weechat_iconv_from_internal (const char *charset, const char *string);
----

Paramètres :

* 'charset' : jeu de caractères cible
* 'string' : chaîne à convertir

Valeur de retour :

* chaîne convertie (doit être supprimée par un appel à "free" après utilisation)

Exemple en C :

[source,C]
----
char *str = weechat_iconv_from_internal ("iso-8859-1", "chaîne utf-8 : é à");
/* ... */
free (str);
----

Script (Python) :

[source,python]
----
# prototype
str = weechat.iconv_from_internal(charset, string)

# exemple
str = weechat.iconv_from_internal("iso-8859-1", "chaîne utf-8 : é à")
----

==== weechat_gettext

Retourner la chaîne traduite (dépend de la langue locale).

Prototype :

[source,C]
----
const char *weechat_gettext (const char *string);
----

Paramètres :

* 'string' : chaîne à traduire

Valeur de retour :

* chaîne traduite

Exemple en C :

[source,C]
----
char *str = weechat_gettext ("hello");
----

Script (Python) :

[source,python]
----
# prototype
str = weechat.gettext(string)

# exemple
str = weechat.gettext("hello")
----

==== weechat_ngettext

Retourner la chaîne traduite, en utilisant le singulier ou le pluriel, selon
le paramètre 'count'.

Prototype :

[source,C]
----
const char *weechat_ngettext (const char *string, const char *plural,
                              int count);
----

Paramètres :

* 'string' : chaîne à traduire, au singulier
* 'plural' : chaîne à traduire, au pluriel
* 'count' : utilisé pour choisir entre le singulier et le pluriel (le choix est
  fonction de la langue utilisée)

Valeur de retour :

* chaîne traduite

Exemple en C :

[source,C]
----
char *str = weechat_ngettext ("file", "files", num_files);
----

Script (Python) :

[source,python]
----
# prototype
str = weechat.ngettext(string, plural, count)

# exemple
num_files = 2
str = weechat.ngettext("file", "files", num_files)
----

==== weechat_strndup

Retourner la chaîne dupliquée, avec au plus 'length' caractères.

Prototype :

[source,C]
----
char *weechat_strndup (const char *string, int length);
----

Paramètres :

* 'string' : chaîne à dupliquer
* 'length' : nombre maximum de caractères à dupliquer

Valeur de retour :

* chaîne dupliquée (doit être supprimée par un appel à "free" après utilisation)

Exemple en C :

[source,C]
----
char *str = weechat_strndup ("abcdef", 3);  /* résultat : "abc" */
/* ... */
free (str);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_string_tolower

Convertir une chaîne UTF-8 en minuscules.

Prototype :

[source,C]
----
void weechat_string_tolower (char *string);
----

Paramètres :

* 'string' : chaîne à convertir

Exemple en C :

[source,C]
----
char str[] = "AbCdé";
weechat_string_tolower (str);  /* str vaut maintenant : "abcdé" */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_string_toupper

Convertir une chaîne UTF-8 en majuscules.

Prototype :

[source,C]
----
void weechat_string_toupper (char *string);
----

Paramètres :

* 'string' : chaîne à convertir

Exemple en C :

[source,C]
----
char str[] = "AbCdé";
weechat_string_toupper (str);  /* str vaut maintenant : "ABCDé" */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_strcasecmp

_Mis à jour dans la 1.0._

Comparer deux chaînes indépendemment de la locale et de la casse.

Prototype :

[source,C]
----
int weechat_strcasecmp (const char *string1, const char *string2);
----

Paramètres :

* 'string1' : première chaîne à comparer
* 'string2' : seconde chaîne à comparer

Valeur de retour :

* -1 si string1 < string2
* 0 si string1 == string2
* 1 si string1 > string2

Exemple en C :

[source,C]
----
int diff = weechat_strcasecmp ("aaa", "CCC");  /* == -2 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_strcasecmp_range

_WeeChat ≥ 0.3.7, mis à jour dans la 1.0._

Comparer deux chaînes indépendemment de la locale et de la casse, avec un
intervalle pour comparer la casse.

Prototype :

[source,C]
----
int weechat_strcasecmp_range (const char *string1, const char *string2, int range);
----

Paramètres :

* 'string1' : première chaîne à comparer
* 'string2' : seconde chaîne à comparer
* 'range' : nombre de caractères pour la comparaison de casse, par exemple :
** 26 : "A-Z" deviennent en minuscules "a-z"
** 29 : "A-Z [ \ ]" deviennent minuscules "a-z { | }"
** 30 : "A-Z [ \ ] ^" deviennent minuscules "a-z { | } ~"

[NOTE]
Les valeurs 29 et 30 sont utilisés par quelques protocoles comme IRC.

Valeur de retour :

* -1 si string1 < string2
* 0 si string1 == string2
* 1 si string1 > string2

Exemple en C :

[source,C]
----
int diff = weechat_strcasecmp_range ("nick{away}", "NICK[away]", 29);  /* == 0 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_strncasecmp

_Mis à jour dans la 1.0._

Comparer deux chaînes indépendemment de la locale et de la casse, pour 'max'
caractères.

Prototype :

[source,C]
----
int weechat_strncasecmp (const char *string1, const char *string2, int max);
----

Paramètres :

* 'string1' : première chaîne à comparer
* 'string2' : seconde chaîne à comparer
* 'max' : nombre maximum de caractères à comparer

Valeur de retour :

* -1 si string1 < string2
* 0 si string1 == string2
* 1 si string1 > string2

Exemple en C :

[source,C]
----
int diff = weechat_strncasecmp ("aabb", "aacc", 2);  /* == 0 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_strncasecmp_range

_WeeChat ≥ 0.3.7, mis à jour dans la 1.0._

Comparer deux chaînes indépendemment de la locale et de la casse, pour 'max'
caractères, avec un intervalle pour comparer la casse.

Prototype :

[source,C]
----
int weechat_strncasecmp_range (const char *string1, const char *string2, int max, int range);
----

Paramètres :

* 'string1' : première chaîne à comparer
* 'string2' : seconde chaîne à comparer
* 'max' : nombre maximum de caractères à comparer
* 'range' : nombre de caractères pour la comparaison de casse, par exemple :
** 26 : "A-Z" deviennent en minuscules "a-z"
** 29 : "A-Z [ \ ]" deviennent minuscules "a-z { | }"
** 30 : "A-Z [ \ ] ^" deviennent minuscules "a-z { | } ~"

[NOTE]
Les valeurs 29 et 30 sont utilisés par quelques protocoles comme IRC.

Valeur de retour :

* -1 si string1 < string2
* 0 si string1 == string2
* 1 si string1 > string2

Exemple en C :

[source,C]
----
int diff = weechat_strncasecmp_range ("nick{away}", "NICK[away]", 6, 29);  /* == 0 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_strcmp_ignore_chars

_Mis à jour dans la 1.0._

Comparer deux chaînes indépendemment de la locale (et en option de la casse), en
ignorant des caractères.

Prototype :

[source,C]
----
int weechat_strcmp_ignore_chars (const char *string1, const char *string2,
                                 const char *chars_ignored,
                                 int case_sensitive);
----

Paramètres :

* 'string1' : première chaîne à comparer
* 'string2' : seconde chaîne à comparer
* 'chars_ignored' : chaîne avec les caractères à ignorer
* 'case_sensitive' : 1 pour une comparaison tenant compte de la casse, sinon 0

Valeur de retour :

* -1 si string1 < string2
* 0 si string1 == string2
* 1 si string1 > string2

Exemple en C :

[source,C]
----
int diff = weechat_strcmp_ignore_chars ("a-b", "--a-e", "-", 1);  /* == -3 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_strcasestr

Rechercher une chaîne indépendemment de la locale et de la casse.

Prototype :

[source,C]
----
char *weechat_strcasestr (const char *string, const char *search);
----

Paramètres :

* 'string' : chaîne
* 'search' : chaîne à rechercher dans 'string'

Valeur de retour :

* pointeur vers la chaîne trouvée, ou NULL si non trouvée

Exemple en C :

[source,C]
----
char *pos = weechat_strcasestr ("aBcDeF", "de");  /* résultat : pointeur vers "DeF" */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_strlen_screen

_WeeChat ≥ 0.4.2._

Retourner le nombre de caractères nécessaires pour afficher la chaîne UTF-8
sur l'écran.
Les caractères non affichables ont une longueur de 1 (c'est la différence avec
la fonction <<_weechat_utf8_strlen_screen,weechat_utf8_strlen_screen>>).

Prototype :

[source,C]
----
int weechat_strlen_screen (const char *string);
----

Paramètres :

* 'string' : chaîne

Valeur de retour :

* nombre de caractères nécessaires pour afficher la chaîne UTF-8 sur l'écran

Exemple en C :

[source,C]
----
int length_on_screen = weechat_strlen_screen ("é");  /* == 1 */
----

Script (Python) :

[source,python]
----
# prototype
length = weechat.strlen_screen(string)

# exemple
length = weechat.strlen_screen("é")  # 1
----

==== weechat_string_match

_Mis à jour dans la 1.0._

Vérifier si une chaîne correspond à un masque.

Prototype :

[source,C]
----
int weechat_string_match (const char *string, const char *mask,
                          int case_sensitive);
----

Paramètres :

* 'string' : chaîne
* 'mask' : masque avec des caractères joker ("*"), chaque joker correspond à 0
  ou plusieurs caractères dans la chaîne
* 'case_sensitive' : 1 pour une comparaison tenant compte de la casse, sinon 0

[NOTE]
Depuis la version 1.0, les caractères joker sont autorisés à l'intérieur du
masque (pas seulement au début et à la fin du masque).

Valeur de retour :

* 1 si la chaîne correspond au masque, sinon 0

Exemple en C :

[source,C]
----
int match1 = weechat_string_match ("abcdef", "abc*", 0);   /* == 1 */
int match2 = weechat_string_match ("abcdef", "*dd*", 0);   /* == 0 */
int match3 = weechat_string_match ("abcdef", "*def", 0);   /* == 1 */
int match4 = weechat_string_match ("abcdef", "*de*", 0);   /* == 1 */
int match5 = weechat_string_match ("abcdef", "*b*d*", 0);  /* == 1 */
----

Script (Python) :

[source,python]
----
# prototype
match = weechat.string_match(string, mask, case_sensitive)

# exemples
match1 = weechat.string_match("abcdef", "abc*", 0)   # 1
match2 = weechat.string_match("abcdef", "*dd*", 0)   # 0
match3 = weechat.string_match("abcdef", "*def", 0)   # 1
match4 = weechat.string_match("abcdef", "*de*", 0)   # 1
match5 = weechat.string_match("abcdef", "*b*d*", 0)  # 1
----

==== weechat_string_expand_home

_WeeChat ≥ 0.3.3._

Remplacer le `~` en début de chaîne par le répertoire "home". Si la chaîne ne
débute pas par `~`, alors une chaîne identique est retournée.

Prototype :

[source,C]
----
char *weechat_string_expand_home (const char *path);
----

Paramètres :

* 'path' : chemin

Valeur de retour :

* chemin avec le `~` en début remplacé par le répertoire "home" (doit être
  supprimé par un appel à "free" après utilisation)

Exemple en C :

[source,C]
----
char *str = weechat_string_expand_home ("~/fichier.txt");
/* résultat : "/home/xxx/fichier.txt" */
/* ... */
free (str);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_string_remove_quotes

Supprimer les apostrophes/guillemets au début et à la fin d'une chaîne (les
espaces avant la première apostrophe ou après la dernière sont ignorés).

Prototype :

[source,C]
----
char *weechat_string_remove_quotes (const char *string, const char *quotes);
----

Paramètres :

* 'string' : chaîne
* 'quotes' : chaîne avec la liste des apostrophes/guillemets à supprimer

Valeur de retour :

* chaîne sans les apostrophes/guillemets au début et à la fin (doit être
  supprimée par un appel à "free" après utilisation)

Exemple en C :

[source,C]
----
char *str = weechat_string_remove_quotes (string, " 'aujourd'hui' ", "'");
/* résultat : "aujourd'hui" */
/* ... */
free (str);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_string_strip

Supprimer des caractères au début et/ou à la fin d'une chaîne.

Prototype :

[source,C]
----
char *weechat_string_strip (const char *string, int left, int right,
                            const char *chars);
----

Paramètres :

* 'string' : chaîne
* 'left' : supprime les caractères en début de chaîne si différent de 0
* 'right' : supprime les caractères en fin de chaîne si différent de 0
* 'chars' : chaîne avec les caractères à supprimer

Valeur de retour :

* chaîne avec les caractères supprimés (doit être supprimée par un appel à
  "free" après utilisation)

Exemple en C :

[source,C]
----
char *str = weechat_string_strip (".abc -", 0, 1, "- .");  /* résultat : ".abc" */
/* ... */
free (str);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_string_convert_escaped_chars

_WeeChat ≥ 1.0._

Convertir les caractères échappés par leur valeur :

* `\"` : double guillemet droit
* `\\` : barre oblique inversée
* `\a` : alerte (BEL)
* `\b` : retour arrière
* `\e` : échappement
* `\f` : saut de page
* `\n` : nouvelle ligne
* `\r` : retour chariot
* `\t` : tabulation horizontale
* `\v` : tabulation verticale
* `\0ooo` : caractère sous forme de valeur octale (ooo a 0 à 3 chiffres)
* `\xhh` : caractère sous forme de valeur hexadécimale (hh a 1 à 2 chiffres)
* `\uhhhh` : caractère unicode sous forme de valeur hexadécimale (hhhh a 1 à 4
  chiffres)
* `\Uhhhhhhhh` : caractère unicode sous forme de valeur hexadécimale (hhhhhhhh
  a 1 à 8 chiffres)

Prototype :

[source,C]
----
char *weechat_string_convert_escaped_chars (const char *string);
----

Paramètres :

* 'string' : chaîne

Valeur de retour :

* chaîne avec les caractères échappés remplacés par leur valeur (doit être
  supprimée par un appel à "free" après utilisation)

Exemple en C :

[source,C]
----
char *str = weechat_string_convert_escaped_chars ("snowman: \\u2603");
/* str == "snowman: ☃" */
/* ... */
free (str);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_string_mask_to_regex

Retourner une expression régulière ("regex"), construite avec un masque où le
seul caractère spécial est "`*`". Tous les autres caractères spéciaux
d'expression régulière sont échappés.

Prototype :

[source,C]
----
char *weechat_string_mask_to_regex (const char *mask);
----

Paramètres :

* 'mask' : masque

Valeur de retour :

* expression régulière, sous forme de chaîne (doit être supprimée par un appel à
  "free" après utilisation)

Exemple en C :

[source,C]
----
char *str_regex = weechat_string_mask_to_regex ("test*mask");
/* résultat : "test.*mask" */
/* ... */
free (str_regex);
----

Script (Python) :

[source,python]
----
# prototype
regex = weechat.string_mask_to_regex(mask)

# exemple
regex = weechat.string_mask_to_regex("test*mask")  # "test.*mask"
----

==== weechat_string_regex_flags

_WeeChat ≥ 0.3.7._

Retourner un pointeur dans la chaîne après les "flags" et le masque avec les
"flags" pour compiler l'expression régulière.

Prototype :

[source,C]
----
const char *weechat_string_regex_flags (const char *regex, int default_flags, int *flags)
----

Paramètres :

* 'regex' : expression régulière POSIX étendue
* 'default_flags' : combinaison des valeurs suivantes (voir `man regcomp`) :
** REG_EXTENDED
** REG_ICASE
** REG_NEWLINE
** REG_NOSUB
* 'flags' : la valeur du pointer est alimentée avec les "flags" utilisés dans
  l'expression régulière ("flags" par défaut + "flags" définis dans l'expression
  régulière)

Les "flags" doivent être au début de l'expression régulière. Le format est :
"(?eins-eins)chaîne".

Les "flags" autorisés sont :

* 'e' : expression régulière POSIX étendue ('REG_EXTENDED')
* 'i' : insensible à la casse ('REG_ICASE')
* 'n' : les opérateurs qui cherchent n'importe quel caractère ne trouvent pas
  les nouvelles lignes ('REG_NEWLINE')
* 's' : le support d'adressage des sous-chaînes de correspondance n'est pas
  requis ('REG_NOSUB')

Valeur de retour :

* pointeur dans la 'regex', après les "flags"

Exemple en C :

[source,C]
----
const char *regex = "(?i)test";
int flags;
const char *ptr_regex = weechat_string_regex_flags (regex, REG_EXTENDED, &flags);
/* ptr_regex == "test", flags == REG_EXTENDED | REG_ICASE */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_string_regcomp

_WeeChat ≥ 0.3.7._

Compiler une expression régulière avec des "flags" optionnels en début de chaîne
(pour le format des "flags", voir
<<_weechat_string_regex_flags,weechat_string_regex_flags>>).

Prototype :

[source,C]
----
int weechat_string_regcomp (void *preg, const char *regex, int default_flags)
----

Paramètres :

* 'preg' : pointeur vers la structure 'regex_t'
* 'regex' : expression régulière POSIX étendue
* 'default_flags' : combinaison des valeurs suivantes (voir `man regcomp`) :
** REG_EXTENDED
** REG_ICASE
** REG_NEWLINE
** REG_NOSUB

Valeur de retour :

* même code retour que la fonction `regcomp` (0 si ok, autre valeur pour une
  erreur, voir `man regcomp`)

Exemple en C :

[source,C]
----
regex_t my_regex;
if (weechat_string_regcomp (&my_regex, "(?i)test", REG_EXTENDED) != 0)
{
    /* erreur */
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_string_has_highlight

Vérifier si une chaîne a un ou plusieurs "highlights", en utilisant une liste
de mots "highlight".

Prototype :

[source,C]
----
int weechat_string_has_highlight (const char *string,
                                  const char highlight_words);
----

Paramètres :

* 'string' : chaîne
* 'highlight_words' : liste de mots "highlight", séparés par des virgules

Valeur de retour :

* 1 si la chaîne a un ou plusieurs "highlights", sinon 0

Exemple en C :

[source,C]
----
int hl = weechat_string_has_highlight ("my test string", "test,word2");  /* == 1 */
----

Script (Python) :

[source,python]
----
# prototype
highlight = weechat.string_has_highlight(string, highlight_words)

# exemple
highlight = weechat.string_has_highlight("my test string", "test,word2")  # 1
----

==== weechat_string_has_highlight_regex

_WeeChat ≥ 0.3.4._

Vérifier si une chaîne a un ou plusieurs "highlights", en utilisant une
expression régulière POSIX étendue. +
Pour au moins une correspondance dans la chaîne, elle doit être entourée de
délimiteurs (caractères différents de : alphanumérique, "-", "_" et "|").

Prototype :

[source,C]
----
int weechat_string_has_highlight_regex (const char *string, const char *regex);
----

Paramètres :

* 'string' : chaîne
* 'regex' : expression régulière POSIX étendue

Valeur de retour :

* 1 si la chaîne a un ou plusieurs "highlights", sinon 0

Exemple en C :

[source,C]
----
int hl = weechat_string_has_highlight_regex ("my test string", "test|word2");  /* == 1 */
----

Script (Python) :

[source,python]
----
# prototype
highlight = weechat.string_has_highlight_regex(string, regex)

# exemple
highlight = weechat.string_has_highlight_regex("my test string", "test|word2")  # 1
----

==== weechat_string_replace

Remplacer toutes les occurrences d'une chaîne par une autre chaîne.

Prototype :

[source,C]
----
char *weechat_string_replace (const char *string, const char *search,
                              const char *replace);
----

Paramètres :

* 'string' : chaîne
* 'search' : chaîne à remplacer
* 'replace' : remplacement pour la chaîne 'search'

Valeur de retour :

* chaîne avec 'search' remplacée par 'replace' (doit être supprimée par un appel
  à "free" après utilisation)

Exemple en C :

[source,C]
----
char *str = weechat_string_replace ("test, test", "s", "x");  /* résultat : "text" */
/* ... */
free (str);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_string_replace_regex

_WeeChat ≥ 1.0._

Remplacer du texte dans une chaîne en utilisant une expression régulière, du
texte de remplacement et un "callback" optionnel.

Prototype :

[source,C]
----
char *weechat_string_replace_regex (const char *string, void *regex,
                                    const char *replace, const char reference_char,
                                    char *(*callback)(void *data, const char *text),
                                    void *callback_data);
----

Paramètres :

* 'string' : chaîne
* 'regex' : pointeur vers une expression régulière (structure 'regex_t')
  compilée avec la fonction WeeChat
  <<_weechat_string_regcomp,weechat_string_regcomp>> ou regcomp (voir
  `man regcomp`)
* 'replace' : texte de remplacement, où les références suivantes sont
  autorisées :
** `$0` à `$99` : correspondance 0 à 99 dans l'expression régulière (0 est la
   correspondance entière, 1 à 99 sont les groupes capturés entre parenthèses)
** `$+` : la dernière correspondance (avec le numéro le plus élevé)
** `$.*N` : correspondance `N` (peut être `+` ou de `0` à `99`), avec tous les
   caractères remplacés par `*` (le caractère `*` peut être n'importe quel
   caractère entre l'espace (32) et `~` (126))
* 'reference_char' : le caractère utilisé pour les références aux
  correspondances (en général '$')
* 'callback' : un "callback" optionnel appelé pour chaque référence dans
  'replace' (sauf pour les correspondances remplacées par un caractère); le
  "callback" doit retourner :
** une chaîne nouvellement allouée : elle est utilisée en texte de remplacement
   (elle est libérée après utilisation)
** NULL : le texte reçu dans le "callback" est utilisé comme texte de
   remplacement (sans changement)
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé

Valeur de retour :

* chaîne avec le texte remplacé, NULL en cas de problème (doit être supprimée
  par un appel à "free" après utilisation)

Exemple en C :

[source,C]
----
regex_t my_regex;
char *string;
if (weechat_string_regcomp (&my_regex, "([0-9]{4})-([0-9]{2})-([0-9]{2})",
                            REG_EXTENDED) == 0)
{
    string = weechat_string_replace_regex ("date: 2014-02-14", &my_regex,
                                           "$3/$2/$1", '$', NULL, NULL);
    /* string == "date: 14/02/2014" */
    if (string)
        free (string);
    regfree (&my_regex);
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_string_split

Découper une chaîne à l'aide de délimiteur(s).

Prototype :

[source,C]
----
char **weechat_string_split (const char *string, const char *separators,
                             int keep_eol, int num_items_max,
                             int *num_items);
----

Paramètres :

* 'string' : chaîne à découper
* 'separators' : délimiteurs utilisés pour le découpage
* 'keep_eol' : si différent de 0, alors chaque paramètre contiendra toutes les
  chaînes jusqu'à la fin de la ligne (voir exemple ci-dessous)
** 0 : chaque chaîne contiendra un mot
** 1 : chaque chaîne contiendra toute la chaîne jusqu'à la fin de la ligne (voir
   exemple ci-dessous)
** 2 : comme 1, mais ne supprime pas les séparateurs en fin de chaîne avant le
   découpage _(WeeChat ≥ 0.3.6)_
* 'num_items_max' : nombre maximum de chaînes à créer (0 = pas de limite)
* 'num_items' : pointeur vers un entier qui contiendra le nombre de chaînes
  créées

Valeur de retour :

* tableau de chaînes, NULL en cas de problème (doit être supprimé par un appel à
  <<_weechat_string_free_split,weechat_string_free_split>> après utilisation)

Exemples en C :

[source,C]
----
char **argv;
int argc;
argv = weechat_string_split ("abc de  fghi", " ", 0, 0, &argc);
/* résultat :  argv[0] == "abc"
               argv[1] == "de"
               argv[2] == "fghi"
               argv[3] == NULL
               argc == 3
*/
weechat_string_free_split (argv);

argv = weechat_string_split ("abc de  fghi", " ", 1, 0, &argc);
/* résultat : argv[0] == "abc de  fghi"
              argv[1] == "de  fghi"
              argv[2] == "fghi"
              argv[3] == NULL
              argc == 3
*/
weechat_string_free_split (argv);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_string_split_shell

_WeeChat ≥ 1.0._

Découper une chaîne comme le shell le fait pour une commande avec ses
paramètres.

Cette fonction est une conversion en C de la classe Python "shlex" (fichier :
Lib/shlex.py dans le dépôt Python), voir :
http://docs.python.org/3/library/shlex.html.

Prototype :

[source,C]
----
char **weechat_string_split_shell (const char *string, int *num_items);
----

Paramètres :

* 'string' : chaîne à découper
* 'num_items' : pointeur vers un entier qui contiendra le nombre de chaînes
  créées

Valeur de retour :

* tableau de chaînes, NULL en cas de problème (doit être supprimé par un appel à
  <<_weechat_string_free_split,weechat_string_free_split>> après utilisation)

Exemple en C :

[source,C]
----
char **argv;
int argc;
argv = weechat_string_split_shell ("test 'first arg'  \"second arg\"", &argc);
/* résultat: argv[0] == "test"
             argv[1] == "first arg"
             argv[2] == "second arg"
             argv[3] == NULL
             argc == 3
*/
weechat_string_free_split (argv);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_string_free_split

Supprimer une chaîne découpée.

Prototype :

[source,C]
----
void weechat_string_free_split (char **split_string);
----

Paramètres :

* 'split_string' : chaîne découpée par
  <<_weechat_string_split,weechat_string_split>>

Exemple en C :

[source,C]
----
char *argv;
int argc;
argv = weechat_string_split (string, " ", 0, 0, &argc);
/* ... */
weechat_string_free_split (argv);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_string_build_with_split_string

Construire une chaîne à partir d'une chaîne découpée.

Prototype :

[source,C]
----
char *weechat_string_build_with_split_string (char **split_string
                                              const char *separator);
----

Paramètres :

* 'split_string' : chaîne découpée par la fonction
  <<_weechat_string_split,weechat_string_split>>
* 'separator' : chaîne utilisée pour séparer les différentes chaînes

Valeur de retour :

* chaîne construite avec la chaîne découpée (doit être supprimée par un appel à
  "free" après utilisation)

Exemple en C :

[source,C]
----
char **argv;
int argc;
argv = weechat_string_split ("abc def ghi", " ", 0, 0, &argc);
char *str = weechat_string_build_with_split_string (argv, ";");
/* str == "abc;def;ghi" */
/* ... */
free (str);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_string_split_command

Découper une liste de commandes séparées par 'separator' (qui peut être échappé
par "\" dans la chaîne).

Prototype :

[source,C]
----
char **weechat_string_split_command (const char *command, char separator);
----

Paramètres :

* 'command' : commande à découper
* 'separator' : séparateur

Valeur de retour :

* tableau de chaînes, NULL en cas de problème (doit être supprimé par un appel à
  <<_weechat_free_split_command,weechat_free_split_command>> après utilisation)

Exemple en C :

[source,C]
----
char **argv = weechat_string_split_command ("/commande1 arg;/commande2", ';');
/* résultat : argv[0] == "/commande1 arg"
              argv[1] == "/commande2"
*/
weechat_free_split_command (argv);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_string_free_split_command

Supprimer une commande découpée.

Prototype :

[source,C]
----
void weechat_string_free_split_command (char **split_command);
----

Paramètres :

* 'split_command' : commande découpée par
  <<_weechat_string_split_command,weechat_string_split_command>>

Exemple en C :

[source,C]
----
char **argv = weechat_string_split_command ("/commande1 arg;/commande2", ';');
/* ... */
weechat_free_split_command (argv);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_string_format_size

Construire une chaîne avec une taille de fichier formatée et une unité traduite
dans la langue locale.

Prototype :

[source,C]
----
char *weechat_string_format_size (unsigned long long size);
----

Paramètres :

* 'size' : taille (en octets)

Valeur de retour :

* chaîne formatée (doit être supprimée par un appel à "free" après utilisation)

Exemples en C :

[source,C]
----
/* exemples avec la langue française */

char *str = weechat_string_format_size (0);  /* str == "0 octet" */
/* ... */
free (str);

char *str = weechat_string_format_size (1);  /* str == "1 octet" */
/* ... */
free (str);

char *str = weechat_string_format_size (200);  /* str == "200 octets" */
/* ... */
free (str);

char *str = weechat_string_format_size (15200);  /* str == "15.2 Ko" */
/* ... */
free (str);

char *str = weechat_string_format_size (2097152);  /* str == "2.10 Mo" */
/* ... */
free (str);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_string_remove_color

Supprimer les couleurs WeeChat dans une chaîne.

Prototype :

[source,C]
----
char *weechat_string_remove_color (const char *string,
                                   const char *replacement);
----

Paramètres :

* 'string' : chaîne
* 'replacement' : si non NULL et non vide, les couleurs WeeChat sont remplacées
  par le premier caractère de cette chaîne, sinon les codes couleurs WeeChat et
  les caractères suivants (rattachés à la couleur) sont supprimés de la chaîne

Valeur de retour :

* chaîne sans couleur (doit être supprimée par un appel à "free" après
  utilisation)

Exemples en C :

[source,C]
----
/* supprime les codes couleur */
char *str = weechat_string_remove_color (ma_chaine1, NULL);
/* ... */
free (str);

/* remplace les codes couleur par "?" */
char *str = weechat_string_remove_color (ma_chaine2, "?");
/* ... */
free (str);
----

Script (Python) :

[source,python]
----
# prototype
str = weechat.string_remove_color(string, replacement)

# exemple
str = weechat.string_remove_color(ma_chaine, "?")
----

==== weechat_string_encode_base64

_WeeChat ≥ 0.3.2._

Encoder une chaîne en base64.

Prototype :

[source,C]
----
void weechat_string_encode_base64 (const char *from, int length, char *to);
----

Paramètres :

* 'from' : chaîne à encoder
* 'length' : longueur de chaîne à encoder (par exemple `strlen(from)`)
* 'to' : pointeur vers la chaîne pour stocker le résultat (doit être
  suffisamment long, le résultat est plus long que la chaîne initiale)

Exemple en C :

[source,C]
----
char *string = "abcdefgh", result[128];
weechat_string_encode_base64 (string, strlen (string), result);
/* result == "YWJjZGVmZ2g=" */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_string_decode_base64

_WeeChat ≥ 0.3.2._

Décoder une chaîne base64.

Prototype :

[source,C]
----
int weechat_string_decode_base64 (const char *from, char *to);
----

Paramètres :

* 'from' : chaîne à décoder
* 'to' : pointeur vers la chaîne pour stocker le résultat (doit être
  suffisamment long, le résultat est plus court que la chaîne initiale)

Valeur de retour :

* longueur de la chaîne stockée dans *to (ne compte pas le '\0' final)

Exemple en C :

[source,C]
----
char *string = "YWJjZGVmZ2g=", result[128];
int length;
length = weechat_string_decode_base64 (string, result);
/* length == 8, result == "abcdefgh" */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_string_is_command_char

_WeeChat ≥ 0.3.2._

Vérifier si le premier caractère de la chaîne est un caractère de commande (le
caractère par défaut de commande est '/').

Prototype :

[source,C]
----
int weechat_string_is_command_char (const char *string);
----

Paramètres :

* 'string' : chaîne

Valeur de retour :

* 1 si le premier caractère de la chaîne est un caractère de commande, sinon 0

Exemples en C :

[source,C]
----
int command_char1 = weechat_string_is_command_char ("/test");  /* == 1 */
int command_char2 = weechat_string_is_command_char ("test");   /* == 0 */
----

Script (Python) :

[source,python]
----
# prototype
is_cmdchar = weechat.string_is_command_char(string)

# exemples
command_char1 = weechat.string_is_command_char("/test")  # == 1
command_char2 = weechat.string_is_command_char("test")   # == 0
----

==== weechat_string_input_for_buffer

_WeeChat ≥ 0.3.2._

Retourner un pointeur vers le texte envoyé vers le tampon (pointeur à
l'intérieur du paramètre "string"), ou NULL si c'est une commande.

Prototype :

[source,C]
----
const char *weechat_string_input_for_buffer (const char *string);
----

Paramètres :

* 'string' : chaîne

Valeur de retour :

* pointeur vers "string", ou NULL

Exemples en C :

[source,C]
----
const char *str1 = weechat_string_input_for_buffer ("test");    /* "test"  */
const char *str2 = weechat_string_input_for_buffer ("/test");   /* NULL    */
const char *str3 = weechat_string_input_for_buffer ("//test");  /* "/test" */
----

Script (Python) :

[source,python]
----
# prototype
str = weechat.string_input_for_buffer(string)

# exemples
str1 = weechat.string_input_for_buffer("test")    # "test"
str2 = weechat.string_input_for_buffer("/test")   # ""
str3 = weechat.string_input_for_buffer("//test")  # "/test"
----

==== weechat_string_eval_expression

_WeeChat ≥ 0.4.0, mis à jour dans la 0.4.2 et 1.1._

Évaluer l'expression et retourner le résultat sous forme de chaîne.
Les variables spéciales avec le format `${variable}` sont étendues (voir le
tableau ci-dessous).

[NOTE]
Depuis la version 1.0, les variables imbriquées sont supportées, par exemple :
`${color:${variable}}`.

Prototype :

[source,C]
----
char *weechat_string_eval_expression (const char *expr,
                                      struct t_hashtable *pointers,
                                      struct t_hashtable *extra_vars,
                                      struct t_hashtable *options);
----

Paramètres :

* 'expr' : l'expression à évaluer (voir le tableau ci-dessous)
* 'pointers' : table de hachage avec les pointeurs (les clés doivent être des
  chaînes, les valeurs doivent être des pointeurs); les pointeurs "window" et
  "buffer" sont automatiquement ajoutés s'ils ne sont pas dans la table de
  hachage (avec le pointer vers fenêtre/tampon courants) (peut être NULL) :
** 'regex' : pointeur vers une expression régulière (structure 'regex_t')
   compilée avec la fonction WeeChat
   <<_weechat_string_regcomp,weechat_string_regcomp>> ou regcomp (voir
   `man regcomp`) ; cette option est similaire à 'regex' dans la table de
   hachage 'options' (ci-dessous), mais est utilisée pour de meilleures
   performances
* 'extra_vars' : variables additionnelles qui seront étendues (peut être NULL)
* 'options' : table de hachage avec des options (les clés et valeurs doivent
  être des chaînes) (peut être NULL) :
** 'type' : le comportement par défaut est de juste remplacer les valeurs dans
   l'expression, d'autres types peuvent être choisis :
*** 'condition' : l'expression est évaluée comme une condition : les opérateurs
    et parenthèses sont utilisés, le résultat est un booléen ("0" ou "1")
** 'prefix' : préfixe avant les variables à remplacer (par défaut : "${")
** 'suffix' : suffixe après les variables à remplacer (par défaut : "}")
** 'regex' : une expression regulière pour remplacer du texte dans 'expr' (qui
   n'est alors pas évalué)
** 'regex_replace' : le texte de remplacement à utiliser avec 'regex', pour
   remplacer du texte dans 'expr' ('regex_replace' est évalué sur chaque
   correspondance de 'regex' sur 'expr', jusqu'à ce que plus aucune
   correspondance ne soit trouvée)

Valeur de retour :

* expression évaluée (doit être supprimée après un appel à "free" après
  utilisation), ou NULL si problème (expression invalide ou pas assez de
  mémoire)

Liste des variables étendues dans l'expression (par ordre de priorité, de la
première étendue à la dernière) :

[width="100%",cols="2,8,3,3",options="header"]
|===
| Format | Description | Exemples | Résultats

| `${nom}` | Variable `nom` de la table de hachage 'extra_vars' |
  `${nom}` | `valeur`

| `${esc:xxx}` +
  `${\xxx}` | Chaîne avec caractères échappés |
  `${esc:préfixe\tmessage}` +
  `${\ua9}` |
  `préfixe<TAB>message` +
  `©`

| `${hide:x,valeur}` |
  Chaîne avec les caractères masqués (tous les caractères dans `valeur`
  remplacés par `x` |
  `${hide:*,mot_de_passe}` |
 `************`

| `${re:N}` |
  Groupe regex capturé : 0 = toute la chaîne correspondante, 1 à 99 = groupe
  capturé, `+` = dernier groupe capturé |
  `${re:1}` |
  `test`

| `${color:nom}` |
  Code couleur WeeChat (le nom de couleur a des attributs facultatifs) |
  `${color:red}texte rouge` +
  `${color:*214}texte orange gras` |
  `texte rouge` (en rouge) +
  `texte orange gras` (en orange gras)

| `${info:name}` +
  `${indo:name,arguments}` |
  Info de WeeChat ou d'une extension, voir la fonction
  <<_weechat_info_get,weechat_info_get>> |
  `${info:version}` +
  `${info:irc_nick_color_name,foo}` |
  `1.0` +
  `lightblue`

| `${sec.data.nom}` |
  Valeur de la donnée sécurisée `nom` |
  `${sec.data.freenode_pass}` |
  `mon_mot_de_passe`

| `${file.section.option}` |
  Valeur de l'option |
  `${weechat.look.buffer_time_format}` |
  `%H:%M:%S`

| `${nom}` |
  Valeur de la variable locale `nom` dans le tampon |
  `${nick}` |
  `FlashCode`

| `${hdata.var1.var2...}` +
  `${hdata[list].var1.var2...}` |
  Valeur d'un hdata (les pointeurs `window` et `buffer` sont définis par défaut
  avec la fenêtre et tampon courants) |
  `${buffer[gui_buffers].full_name}` +
  `${window.buffer.number}` |
  `core.weechat` +
  `1`
|===

Exemples en C :

[source,C]
----
/* conditions */
struct t_hashtable *options1 = weechat_hashtable_new (8,
                                                      WEECHAT_HASHTABLE_STRING,
                                                      WEECHAT_HASHTABLE_STRING,
                                                      NULL,
                                                      NULL);
weechat_hashtable_set (options1, "type", "condition");
char *str1 = weechat_string_eval_expression ("${window.win_width} > 100", NULL, NULL, options1);  /* "1" */
char *str2 = weechat_string_eval_expression ("abc =~ def", NULL, NULL, options1);                 /* "0" */

/* expression simple */
char *str3 = weechat_string_eval_expression ("${buffer.full_name}", NULL, NULL, NULL);  /* "core.weechat" */

/* remplacement avec regex */
struct t_hashtable *options2 = weechat_hashtable_new (8,
                                                      WEECHAT_HASHTABLE_STRING,
                                                      WEECHAT_HASHTABLE_STRING,
                                                      NULL,
                                                      NULL);
/* ajout de crochets autour des URLs */
weechat_hashtable_set (options2, "regex", "\\w+://\\S+");
weechat_hashtable_set (options2, "regex_replace", "[ ${re:0} ]");
char *str4 = weechat_string_eval_expression ("test: https://weechat.org", NULL, NULL, NULL);  /* "test: [ https://weechat.org ]" */

/* masquage des mots de passe */
weechat_hashtable_set (options2, "regex", "(password=)(\\S+)");
weechat_hashtable_set (options2, "regex_replace", "${re:1}${hide:*,${re:2}}");
char *str5 = weechat_string_eval_expression ("password=abc password=def", NULL, NULL, NULL);  /* "password=*** password=***" */
----

Script (Python) :

[source,python]
----
# prototype
str = weechat.string_eval_expression(expr, pointers, extra_vars, options)

# exemples

# conditions
str1 = weechat.string_eval_expression("${window.win_width} > 100", {}, {}, {"type": "condition"})  # "1"
str2 = weechat.string_eval_expression("abc =~ def", {}, {}, {"type": "condition"})                 # "0"

# expression simple
str3 = weechat.string_eval_expression("${buffer.full_name}", {}, {}, {}) # "core.weechat"

# remplacement avec regex : ajout de crochets autour des URLs
options = {
    "regex": "\\w+://\\S+",
    "regex_replace": "[ ${re:0} ]",
}
str4 = weechat.string_eval_expression("test: https://weechat.org", {}, {}, options)  # "test: [ https://weechat.org ]"

# replace with regex : masquage des mots de passe
options = {
    "regex": "(password=)(\\S+)",
    "regex_replace": "${re:1}${hide:*,${re:2}}",
}
str5 = weechat.string_eval_expression("password=abc password=def", {}, {}, options)  # "password=*** password=***"
----

[[utf-8]]
=== UTF-8

Fonctions pour les chaînes UTF-8.

==== weechat_utf8_has_8bits

Vérifier si une chaîne a des caractères 8-bits.

Prototype :

[source,C]
----
int weechat_utf8_has_8bits (const char *string);
----

Paramètres :

* 'string' : chaîne

Valeur de retour :

* 1 si la chaîne a des caractères 8-bits, 0 s'il y a seulement des caractères
  7-bits

Exemple en C :

[source,C]
----
if (weechat_utf8_has_8bits (string))
{
    /* ... */
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_utf8_is_valid

Vérifier si une chaîne est valide UTF-8.

Prototype :

[source,C]
----
int weechat_utf8_is_valid (const char *string, char **error);
----

Paramètres :

* 'string' : chaîne
* 'error' : si non NULL, '*error' est alimenté avec le pointeur vers le premier
  caractère non valide dans la chaîne, s'il y en a

Valeur de retour :

* 1 si la chaîne UTF-8 est valide, sinon 0

Exemple en C :

[source,C]
----
char *error;
if (weechat_utf8_is_valid (string, &error))
{
    /* ... */
}
else
{
    /* "error" pointe vers le premier caractère invalide */
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_utf8_normalize

Normaliser une chaîne UTF-8 : supprimer tous les caractères non valides UTF-8
en les remplaçant par un caractère.

Prototype :

[source,C]
----
void weechat_utf8_normalize (char *string, char replacement);
----

Paramètres :

* 'string' : chaîne
* 'replacement' : caractère de remplacement pour les caractères non valides

Exemple en C :

[source,C]
----
weechat_utf8_normalize (string, '?');
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_utf8_prev_char

Retourner un pointeur vers le caractère UTF-8 précédent dans une chaîne.

Prototype :

[source,C]
----
char *weechat_utf8_prev_char (const char *string_start, const char *string);
----

Paramètres :

* 'string_start' : début de la chaîne (la fonction ne retournera pas un
  caractère situé avant ce pointeur)
* 'string' : pointeur vers la chaîne (doit être ≥ 'string_start')

Valeur de retour :

* pointeur vers le caractère UTF-8 précédent, NULL si non trouvé (début de
  chaîne atteint)

Exemple en C :

[source,C]
----
char *prev_char = weechat_utf8_prev_char (string, ptr_in_string);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_utf8_next_char

Retourner un pointeur vers le caractère UTF-8 suivant dans une chaîne.

Prototype :

[source,C]
----
char *weechat_utf8_next_char (const char *string);
----

Paramètres :

* 'string' : chaîne

Valeur de retour :

* pointeur vers le caractère UTF-8 suivant, NULL si non trouvé (fin de la
  chaîne atteinte)

Exemple en C :

[source,C]
----
char *next_char = weechat_utf8_next_char (string);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_utf8_char_int

Retourner un caractère UTF-8 sous forme d'entier.

Prototype :

[source,C]
----
int weechat_utf8_char_int (const char *string);
----

Paramètres :

* 'string' : chaîne

Valeur de retour :

* caractère UTF-8 sous forme d'entier

Exemple en C :

[source,C]
----
int char_int = weechat_utf8_char_int ("être");  /* "ê" comme entier */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_utf8_char_size

Retourner la taille d'un caractère UTF-8 (en octets).

Prototype :

[source,C]
----
int weechat_utf8_char_size (const char *string);
----

Paramètres :

* 'string' : chaîne

Valeur de retour :

* taille du caractère UTF-8 (en octets)

Exemple en C :

[source,C]
----
int char_size = weechat_utf8_char_size ("être");  /* == 2 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_utf8_strlen

Retourner la taille d'une chaîne UTF-8 (en nombre de caractères UTF-8).

Prototype :

[source,C]
----
int weechat_utf8_strlen (const char *string);
----

Paramètres :

* 'string' : chaîne

Valeur de retour :

* longueur de la chaîne UTF-8 (nombre de caractères UTF-8)

Exemple en C :

[source,C]
----
int length = weechat_utf8_strlen ("chêne");  /* == 5 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_utf8_strnlen

Retourner la taille d'une chaîne UTF-8 (en nombre de caractères UTF-8), pour au
maximum 'bytes' octets dans la chaîne.

Prototype :

[source,C]
----
int weechat_utf8_strnlen (const char *string, int bytes);
----

Paramètres :

* 'string' : chaîne
* 'bytes' : nombre maximum d'octets

Valeur de retour :

* longueur de la chaîne UTF-8 (nombre de caractères UTF-8)

Exemple en C :

[source,C]
----
int length = weechat_utf8_strnlen ("chêne", 4);  /* == 3 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_utf8_strlen_screen

Retourner le nombre de caractères nécessaires pour afficher la chaîne UTF-8
sur l'écran.

Prototype :

[source,C]
----
int weechat_utf8_strlen_screen (const char *string);
----

Paramètres :

* 'string' : chaîne

Valeur de retour :

* nombre de caractères nécessaires pour afficher la chaîne UTF-8 sur l'écran

Exemple en C :

[source,C]
----
int length_on_screen = weechat_utf8_strlen_screen ("é");  /* == 1 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_utf8_charcmp

_Mis à jour dans la 1.0._

Comparer deux caractères UTF-8.

Prototype :

[source,C]
----
int weechat_utf8_charcmp (const char *string1, const char *string2);
----

Paramètres :

* 'string1' : première chaîne pour la comparaison
* 'string2' : seconde chaîne pour la comparaison

Valeur de retour :

* -1 si string1 < string2
* 0 si string1 == string2
* 1 si string1 > string2

Exemple en C :

[source,C]
----
int diff = weechat_utf8_charcmp ("aaa", "ccc");  /* == -2 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_utf8_charcasecmp

_Mis à jour dans la 1.0._

Comparer deux caractères UTF-8 en ignorant la casse.

Prototype :

[source,C]
----
int weechat_utf8_charcasecmp (const char *string1, const char *string2);
----

Paramètres :

* 'string1' : première chaîne pour la comparaison
* 'string2' : seconde chaîne pour la comparaison

Valeur de retour :

* -1 si string1 < string2
* 0 si string1 == string2
* 1 si string1 > string2

Exemple en C :

[source,C]
----
int diff = weechat_utf8_charcasecmp ("aaa", "CCC");  /* == -2 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_utf8_char_size_screen

Retourner le nombre de caractères nécessaires pour afficher le caractère UTF-8
sur l'écran.

Prototype :

[source,C]
----
int weechat_utf8_char_size_screen (const char *string);
----

Paramètres :

* 'string' : chaîne

Valeur de retour :

* nombre de caractères nécessaires pour afficher le caractère UTF-8 sur l'écran

Exemple en C :

[source,C]
----
int length_on_screen = weechat_utf8_char_size_screen ("é");  /* == 1 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_utf8_add_offset

Avancer de N caractères dans une chaîne UTF-8.

Prototype :

[source,C]
----
char *weechat_utf8_add_offset (const char *string, int offset);
----

Paramètres :

* 'string' : chaîne
* 'offset' : nombre de caractères

Valeur de retour :

* pointeur vers la chaîne, N caractères après (NULL s'il est impossible
  d'atteindre cette position dans la chaîne)

Exemple en C :

[source,C]
----
char *str = "chêne";
char *str2 = weechat_utf8_add_offset (str, 3);  /* pointe vers "ne" */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_utf8_real_pos

Retourner la position réelle dans une chaîne UTF-8.

Prototype :

[source,C]
----
int weechat_utf8_real_pos (const char *string, int pos);
----

Paramètres :

* 'string' : chaîne
* 'pos' : position (en nombre de caractères)

Valeur de retour :

* position réelle (en octets)

Exemple en C :

[source,C]
----
int pos = weechat_utf8_real_pos ("chêne", 3);  /* == 4 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_utf8_pos

Retourner la position dans une chaîne UTF-8.

Prototype :

[source,C]
----
int weechat_utf8_pos (const char *string, int real_pos);
----

Paramètres :

* 'string' : chaîne
* 'real_pos' : position (en octets)

Valeur de retour :

* position (en nombre de caractères)

Exemple en C :

[source,C]
----
int pos = weechat_utf8_pos ("chêne", 4);  /* == 3 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_utf8_strndup

Retourner une chaîne dupliquée, avec au plus 'length' caractères.

Prototype :

[source,C]
----
char *weechat_utf8_strndup (const char *string, int length);
----

Paramètres :

* 'string' : chaîne
* 'length' : nombre maximum de caractères à dupliquer

Valeur de retour :

* chaîne dupliquée (doit être supprimée avec un appel à "free" après
  utilisation)

Exemple en C :

[source,C]
----
char *string = weechat_utf8_strndup ("chêne", 3);  /* retourne "chê" */
/* ... */
free (str);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

[[directories]]
=== Répertoires

Fonctions liées aux répertoires.

==== weechat_mkdir_home

Créer un répertoire dans le répertoire de WeeChat.

Prototype :

[source,C]
----
int weechat_mkdir_home (char *directory, int mode);
----

Paramètres :

* 'directory' : nom du répertoire à créer
* 'mode' : mode pour le répertoire

Valeur de retour :

* 1 si le répertoire est créé, 0 en cas d'erreur

Exemple en C :

[source,C]
----
if (!weechat_mkdir_home ("temp", 0755))
{
    /* erreur */
}
----

Script (Python) :

[source,python]
----
# prototype
weechat.mkdir_home(directory, mode)

# exemple
weechat.mkdir_home("temp", 0755)
----

==== weechat_mkdir

Créer un répertoire.

Prototype :

[source,C]
----
int weechat_mkdir (char *directory, int mode);
----

Paramètres :

* 'directory' : nom du répertoire à créer
* 'mode' : mode pour le répertoire

Valeur de retour :

* 1 si le répertoire est créé, 0 en cas d'erreur

Exemple en C :

[source,C]
----
if (!weechat_mkdir ("/tmp/mydir", 0755))
{
    /* erreur */
}
----

Script (Python) :

[source,python]
----
# prototype
weechat.mkdir(directory, mode)

# exemple
weechat.mkdir("/tmp/mydir", 0755)
----

==== weechat_mkdir_parents

Créer un répertoire et ses parents si besoin.

Prototype :

[source,C]
----
int weechat_mkdir_parents (char *directory, int mode);
----

Paramètres :

* 'directory' : nom du répertoire à créer
* 'mode' : mode pour le répertoire

Valeur de retour :

* 1 si le répertoire est créé, 0 en cas d'erreur

Exemple en C :

[source,C]
----
if (!weechat_mkdir_parents ("/tmp/my/dir", 0755))
{
    /* erreur */
}
----

Script (Python) :

[source,python]
----
# prototype
weechat.mkdir_parents(directory, mode)

# exemple
weechat.mkdir_parents("/tmp/my/dir", 0755)
----

==== weechat_exec_on_files

Balayer les fichiers dans un répertoire et exécuter un "callback" pour chaque
fichier.

Prototype :

[source,C]
----
void weechat_exec_on_files (const char *directory,
                            int hidden_files,
                            void *data,
                            void (*callback)(void *data,
                                             const char *filename));
----

Paramètres :

* 'directory' : répertoire où chercher les fichiers
* 'hidden_files' : 1 pour inclure les fichiers cachés, sinon 0
* 'data' : pointeur donné au "callback" lorsqu'il est appelé par WeeChat
* 'callback' : fonction appelée pour chaque fichier trouvé, paramètres :
** 'void *data' : pointeur
** 'const char *filename' : nom de fichier trouvé

Exemple en C :

[source,C]
----
void callback (void *data, const char *filename)
{
    /* ... */
}
...
weechat_exec_on_files ("/tmp", 0, NULL, &callback);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_file_get_content

_WeeChat ≥ 0.3.1._

Lire le contenu d'un fichier texte dans une chaîne de caractères.

Prototype :

[source,C]
----
char *weechat_file_get_content (const char *filename);
----

Paramètres :

* 'filename' : chemin et nom du fichier

Valeur de retour :

* contenu du fichier sous forme de chaîne (doit être supprimé par un appel à
  "free" après utilisation)

Exemple en C :

[source,C]
----
char *contenu;

contenu = weechat_file_get_content ("/tmp/test.txt");
/* ... */
free (contenu);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

[[util]]
=== Util

Quelques fonctions utiles.

==== weechat_util_timeval_cmp

Comparer deux structures "timeval".

Prototype :

[source,C]
----
int weechat_util_timeval_cmp (struct timeval *tv1, struct timeval *tv2);
----

Paramètres :

* 'tv1' : première structure "timeval"
* 'tv2' : seconde structure "timeval"

Valeur de retour :

* -1 si tv1 < tv2
* zéro si tv1 == tv2
* +1 si tv1 > tv2

Exemple en C :

[source,C]
----
if (weechat_util_timeval_cmp (&tv1, &tv2) > 0)
{
    /* tv1 > tv2 */
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_util_timeval_diff

_Mis à jour dans la 1.1._

Retourner la différence (en microsecondes) entre deux structures "timeval".

Prototype :

[source,C]
----
long long weechat_util_timeval_diff (struct timeval *tv1, struct timeval *tv2);
----

Paramètres :

* 'tv1' : première structure "timeval"
* 'tv2' : seconde structure "timeval"

Valeur de retour :

* différence en microsecondes

[NOTE]
Avec WeeChat ≤ 1.0, la valeur retournée était en millisecondes.

Exemple en C :

[source,C]
----
long long diff = weechat_util_timeval_diff (&tv1, &tv2);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_util_timeval_add

_Mis à jour dans la 1.1._

Ajouter un intervalle (en microsecondes) à une structure "timeval".

Prototype :

[source,C]
----
void weechat_util_timeval_add (struct timeval *tv, long long interval);
----

Paramètres :

* 'tv' : structure "timeval"
* 'interval' : intervalle (en microsecondes)

[NOTE]
Avec WeeChat ≤ 1.0, l'intervalle était exprimé en millisecondes.

Exemple en C :

[source,C]
----
weechat_util_timeval_add (&tv, 2000000);  /* ajouter 2 secondes */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_util_get_time_string

_WeeChat ≥ 0.3.2._

Retourner la date/heure sous forme de chaîne construite avec "strftime".

Prototype :

[source,C]
----
char *weechat_util_get_time_string (const time_t *date);
----

Paramètres :

* 'date' : pointeur vers la date

Exemple en C :

[source,C]
----
time_t date = time (NULL);
weechat_printf (NULL, "date: %s",
                weechat_util_get_time_string (&date));
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_util_version_number

_WeeChat ≥ 0.3.9._

Convertir une chaîne avec la version WeeChat en nombre.

Prototype :

[source,C]
----
int weechat_util_version_number (const char *version);
----

Paramètres :

* 'version' : version WeeChat sous forme de chaîne (exemple : "0.3.9" ou
  "0.3.9-dev")

Exemple en C :

[source,C]
----
version_number = weechat_util_version_number ("0.3.8");      /* == 0x00030800 */
version_number = weechat_util_version_number ("0.3.9-dev");  /* == 0x00030900 */
version_number = weechat_util_version_number ("0.3.9-rc1");  /* == 0x00030900 */
version_number = weechat_util_version_number ("0.3.9");      /* == 0x00030900 */
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

[[sorted_lists]]
=== Listes triées

Fonctions pour les listes triées.

==== weechat_list_new

Créer une nouvelle liste.

Prototype :

[source,C]
----
struct t_weelist *weechat_list_new ();
----

Valeur de retour :

* pointeur vers la nouvelle liste

Exemple en C :

[source,C]
----
struct t_weelist *list = weechat_list_new ();
----

Script (Python) :

[source,python]
----
# prototype
list = weechat.list_new()

# exemple
list = weechat.list_new()
----

==== weechat_list_add

Ajouter un élément dans une liste.

Prototype :

[source,C]
----
struct t_weelist_item *weechat_list_add (struct t_weelist *weelist,
                                         const char *data,
                                         const char *where,
                                         void *user_data);
----

Paramètres :

* 'weelist' : pointeur vers la liste
* 'data' : donnée à insérer dans la liste
* 'where' : position dans la liste :
** 'WEECHAT_LIST_POS_SORT' : ajout dans la liste, en gardant la liste triée
** 'WEECHAT_LIST_POS_BEGINNING' : ajout en début de liste
** 'WEECHAT_LIST_POS_END' : ajout en fin de liste
* 'user_data' : un pointeur quelconque

Valeur de retour :

* pointeur vers le nouvel élément

Exemple en C :

[source,C]
----
struct t_weelist_item *my_item =
    weechat_list_add (list, "ma donnée", WEECHAT_LIST_POS_SORT, NULL);
----

Script (Python) :

[source,python]
----
# prototype
item = weechat.list_add(list, data, where, user_data)

# exemple
item = weechat.list_add(list, "ma donnée", weechat.WEECHAT_LIST_POS_SORT, "")
----

==== weechat_list_search

Rechercher un élément dans une liste.

Prototype :

[source,C]
----
struct t_weelist_item *weechat_list_search (struct t_weelist *weelist,
                                            const char *data);
----

Paramètres :

* 'weelist' : pointeur vers la liste
* 'data' : donnée à chercher dans la liste

Valeur de retour :

* pointeur vers l'élément trouvé, NULL si aucun élément n'a été trouvé

Exemple en C :

[source,C]
----
struct t_weelist_item *item = weechat_list_search (list, "ma donnée");
----

Script (Python) :

[source,python]
----
# prototype
item = weechat.list_search(list, data)

# exemple
item = weechat.list_search(list, "ma donnée")
----

==== weechat_list_search_pos

_WeeChat ≥ 0.3.4._

Rechercher la position d'un élément dans une liste.

Prototype :

[source,C]
----
int weechat_list_search_pos (struct t_weelist *weelist,
                             const char *data);
----

Paramètres :

* 'weelist' : pointeur vers la liste
* 'data' : donnée à chercher dans la liste

Valeur de retour :

* position de l'élément trouvé, -1 si aucun élément n'a été trouvé

Exemple en C :

[source,C]
----
int pos_item = weechat_list_search_pos (list, "ma donnée");
----

Script (Python) :

[source,python]
----
# prototype
pos_item = weechat.list_search_pos(list, data)

# exemple
pos_item = weechat.list_search_pos(list, "ma donnée")
----

==== weechat_list_casesearch

Rechercher un élément dans la liste, sans tenir compte de la casse.

Prototype :

[source,C]
----
struct t_weelist_item *weechat_list_casesearch (struct t_weelist *weelist,
                                                const char *data);
----

Paramètres :

* 'weelist' : pointeur vers la liste
* 'data' : données à chercher dans la liste

Valeur de retour :

* pointeur vers l'élément trouvé, NULL si aucun élément n'a été trouvé

Exemple en C :

[source,C]
----
struct t_weelist_item *item = weechat_list_casesearch (list, "ma donnée");
----

Script (Python) :

[source,python]
----
# prototype
item = weechat.list_casesearch(list, data)

# exemple
item = weechat.list_casesearch(list, "ma donnée")
----

==== weechat_list_casesearch_pos

_WeeChat ≥ 0.3.4._

Rechercher la position d'un élément dans la liste, sans tenir compte de la
casse.

Prototype :

[source,C]
----
int weechat_list_casesearch_pos (struct t_weelist *weelist,
                                 const char *data);
----

Paramètres :

* 'weelist' : pointeur vers la liste
* 'data' : données à chercher dans la liste

Valeur de retour :

* position l'élément trouvé, -1 si aucun élément n'a été trouvé

Exemple en C :

[source,C]
----
int pos_item = weechat_list_casesearch_pos (list, "ma donnée");
----

Script (Python) :

[source,python]
----
# prototype
pos_item = weechat.list_casesearch_pos(list, data)

# exemple
pos_item = weechat.list_casesearch_pos(list, "ma donnée")
----

==== weechat_list_get

Retourner un élément de la liste par sa position.

Prototype :

[source,C]
----
struct t_weelist_item *weechat_list_get (struct t_weelist *weelist,
                                         int position);
----

Paramètres :

* 'weelist' : pointeur vers la liste
* 'position' : position dans la liste (le premier élément est 0)

Valeur de retour :

* pointeur vers l'élément trouvé, NULL si aucun élément n'a été trouvé

Exemple en C :

[source,C]
----
struct t_weelist_item *item = weechat_list_get (list, 0);  /* premier élément */
----

Script (Python) :

[source,python]
----
# prototype
item = weechat.list_get(list, position)

# exemple
item = weechat.list_get(list, 0)
----

==== weechat_list_set

Affecter une nouvelle valeur pour un élément.

Prototype :

[source,C]
----
void weechat_list_set (struct t_weelist_item *item, const char *value);
----

Paramètres :

* 'item' : pointeur vers l'élément
* 'value' : nouvelle valeur pour l'élément

Exemple en C :

[source,C]
----
weechat_list_set (item, "nouvelle donnée");
----

Script (Python) :

[source,python]
----
# prototype
weechat.list_set(item, value)

# exemple
weechat.list_set(item, "nouvelle donnée")
----

==== weechat_list_next

Retourner l'élément suivant dans la liste.

Prototype :

[source,C]
----
struct t_weelist_item *weechat_list_next (struct t_weelist_item *item);
----

Paramètres :

* 'item' : pointeur vers l'élément

Valeur de retour :

* pointeur vers l'élément suivant, NULL si le pointeur était sur le dernier
  élément de la liste

Exemple en C :

[source,C]
----
struct t_weelist_item *next_item = weechat_list_next (item);
----

Script (Python) :

[source,python]
----
# prototype
item = weechat.list_next(item)

# exemple
item = weechat.list_next(item)
----

==== weechat_list_prev

Retourner l'élément précédent dans la liste.

Prototype :

[source,C]
----
struct t_weelist_item *weechat_list_prev (struct t_weelist_item *item);
----

Paramètres :

* 'item' : pointeur vers l'élément

Valeur de retour :

* pointeur vers l'élément précédent, NULL si le pointeur était sur le premier
  élément de la liste

Exemple en C :

[source,C]
----
struct t_weelist_item *prev_item = weechat_list_prev (item);
----

Script (Python) :

[source,python]
----
# prototype
item = weechat.list_prev(item)

# exemple
item = weechat.list_prev(item)
----

==== weechat_list_string

Retourner la valeur de l'élément sous forme de chaîne.

Prototype :

[source,C]
----
const char *weechat_list_string (struct t_weelist_item *item);
----

Paramètres :

* 'item' : pointeur vers l'élément

Valeur de retour :

* valeur de l'élément

Exemple en C :

[source,C]
----
weechat_printf (NULL, "valeur de l'item : %s", weechat_list_string (item));
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.list_string(item)

# exemple
weechat.prnt("", "valeur de l'item : %s" % weechat.list_string(item))
----

==== weechat_list_size

Retourner la taille de la liste (nombre d'éléments).

Prototype :

[source,C]
----
char *weechat_list_size (struct t_weelist *weelist);
----

Paramètres :

* 'weelist' : pointeur vers la liste

Valeur de retour :

* taille de la liste (nombre d'éléments), 0 si la liste est vide

Exemple en C :

[source,C]
----
weechat_printf (NULL, "taille de la liste : %d", weechat_list_size (list));
----

Script (Python) :

[source,python]
----
# prototype
size = weechat.list_size(list)

# exemple
weechat.prnt("", "taille de la liste : %d" % weechat.list_size(list))
----

==== weechat_list_remove

Supprimer un élément de la liste.

Prototype :

[source,C]
----
void weechat_list_remove (struct t_weelist *weelist,
                          struct t_weelist_item *item);
----

Paramètres :

* 'weelist' : pointeur vers la liste
* 'item' : pointeur vers l'élément

Exemple en C :

[source,C]
----
weechat_list_remove (list, item);
----

Script (Python) :

[source,python]
----
# prototype
weechat.list_remove(list, item)

# exemple
weechat.list_remove(list, item)
----

==== weechat_list_remove_all

Supprimer tous les éléments de la liste.

Prototype :

[source,C]
----
void weechat_list_remove_all (struct t_weelist *weelist);
----

Paramètres :

* 'weelist' : pointeur vers la liste

Exemple en C :

[source,C]
----
weechat_list_remove_all (list);
----

Script (Python) :

[source,python]
----
# prototype
weechat.list_remove_all(list)

# exemple
weechat.list_remove_all(list)
----

==== weechat_list_free

Supprimer une liste.

Prototype :

[source,C]
----
void weechat_list_free (struct t_weelist *weelist);
----

Paramètres :

* 'weelist' : pointeur vers la liste

Exemple en C :

[source,C]
----
weechat_list_free (list);
----

Script (Python) :

[source,python]
----
# prototype
weechat.list_free(list)

# exemple
weechat.list_free(list)
----

[[hashtables]]
=== Tables de hachage

Fonctions pour les tables de hachage.

==== weechat_hashtable_new

_WeeChat ≥ 0.3.3._

Créer une nouvelle table de hachage.

Prototype :

[source,C]
----
struct t_hashtable *weechat_hashtable_new (int size,
                                           const char *type_keys,
                                           const char *type_values,
                                           unsigned long long (*callback_hash_key)(struct t_hashtable *hashtable,
                                                                                   const void *key),
                                           int (*callback_keycmp)(struct t_hashtable *hashtable,
                                                                  const void *key1,
                                                                  const void *key2));
----

Paramètres :

* 'size' : taille du tableau interne pour stocker les clés sous forme de
  hachage, une grande valeur utilise plus de mémoire mais présente une meilleure
  performance (cela n'est *pas* une limite sur le nombre d'entrées de la table
  de hachage)
* 'type_keys' : type pour les clés dans la table de hachage :
** 'WEECHAT_HASHTABLE_INTEGER'
** 'WEECHAT_HASHTABLE_STRING'
** 'WEECHAT_HASHTABLE_POINTER'
** 'WEECHAT_HASHTABLE_BUFFER'
** 'WEECHAT_HASHTABLE_TIME'
* 'type_values' : type pour les valeurs dans la table de hachage :
** 'WEECHAT_HASHTABLE_INTEGER'
** 'WEECHAT_HASHTABLE_STRING'
** 'WEECHAT_HASHTABLE_POINTER'
** 'WEECHAT_HASHTABLE_BUFFER'
** 'WEECHAT_HASHTABLE_TIME'
* 'callback_hash_key' : fonction appelée pour rendre le hachage d'une clé (la
  clé sous forme de nombre entier), peut être NULL si le type de clé n'est pas
  "buffer" (une fonction de hachage par défaut est utilisée), paramètres et
  valeur de retour :
** 'struct t_hashtable *hashtable' : pointeur vers la table de hachage
** 'const void *key' : clé
** valeur de retour : hachage de la clé
* 'callback_keycmp' : fonction appelée pour comparer deux clés, peut être NULL
  si le type de clé n'est pas "buffer" (une fonction de comparaison par défaut
  est utilisée), paramètres et valeur de retour :
** 'struct t_hashtable *hashtable' : pointeur vers la table de hachage
** 'const void *key1' : première clé
** 'const void *key2' : seconde clé
** valeur de retour :
*** nombre négatif si 'key1' est inférieur à 'key2'
*** 0 si 'key1' est égal à 'key2'
*** nombre positif si 'key1' est supérieur à 'key2'

Valeur de retour :

* pointeur vers la nouvelle table de hachage, NULL en cas d'erreur

Exemple en C :

[source,C]
----
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_hashtable_set_with_size

_WeeChat ≥ 0.3.3, mis à jour dans la 0.4.2._

Ajouter ou mettre à jour une entrée dans une table de hachage avec une taille
pour la clé et la valeur.

Prototype :

[source,C]
----
struct t_hashtable_item *weechat_hashtable_set_with_size (struct t_hashtable *hashtable,
                                                          const void *key, int key_size,
                                                          const void *value, int value_size);
----

Paramètres :

* 'hashtable' : pointeur vers la table de hachage
* 'key' : pointeur vers la clé
* 'key_size' : taille de la clé (en octets), utilisée seulement si le type de
  clés dans la table de hachage est "buffer"
* 'value' : pointeur vers la valeur
* 'value_size' : taille de la valeur (en octets), utilisée seulement si le type
  de valeurs dans la table de hachage est "buffer"

Valeur de retour :

* pointeur vers l'item créé/mis à jour, NULL en cas d'erreur

Exemple en C :

[source,C]
----
weechat_hashtable_set_with_size (hashtable, "ma_cle", 0,
                                 my_buffer, sizeof (my_buffer_struct));
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_hashtable_set

_WeeChat ≥ 0.3.3, mis à jour dans la 0.4.2._

Ajouter ou mettre à jour une entrée dans la table de hachage.

Prototype :

[source,C]
----
struct t_hashtable_item *weechat_hashtable_set (struct t_hashtable *hashtable,
                                                const void *key, const void *value);
----

Paramètres :

* 'hashtable' : pointeur vers la table de hachage
* 'key' : pointeur vers la clé
* 'value' : pointeur vers la valeur

Valeur de retour :

* pointeur vers l'item créé/mis à jour, NULL en cas d'erreur

Exemple en C :

[source,C]
----
weechat_hashtable_set (hashtable, "ma_cle", "ma_valeur");
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_hashtable_get

_WeeChat ≥ 0.3.3._

Retourner la valeur associée à une clé dans une table de hachage.

Prototype :

[source,C]
----
void *weechat_hashtable_get (struct t_hashtable *hashtable, void *key);
----

Paramètres :

* 'hashtable' : pointeur vers la table de hachage
* 'key' : pointeur vers la clé

Valeur de retour :

* valeur pour la clé, NULL si la clé n'est pas trouvée

Exemple en C :

[source,C]
----
void *value = weechat_hashtable_get (hashtable, "ma_cle");
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_hashtable_has_key

_WeeChat ≥ 0.3.4._

Vérifier si une clé est présente dans la table de hachage.

Prototype :

[source,C]
----
int weechat_hashtable_has_key (struct t_hashtable *hashtable, void *key);
----

Paramètres :

* 'hashtable' : pointeur vers la table de hachage
* 'key' : pointeur vers la clé

Valeur de retour :

* 1 si la clé est dans la table de hachage, 0 si la clé n'est pas dans la table
  de hachage

Exemple en C :

[source,C]
----
if (weechat_hashtable_has_key (hashtable, "ma_cle"))
{
    /* la clé est dans la table de hachage */
    /* ... */
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_hashtable_map

_WeeChat ≥ 0.3.3._

Appeller une fonction pour chaque entrée d'une table de hachage.

Prototype :

[source,C]
----
void weechat_hashtable_map (struct t_hashtable *hashtable,
                            void (*callback_map)(void *data,
                                                 struct t_hashtable *hashtable,
                                                 const void *key,
                                                 const void *value),
                            void *callback_map_data);
----

Paramètres :

* 'hashtable' : pointeur vers la table de hachage
* 'callback_map' : fonction appelée pour chaque entrée de la table de hachage
* 'callback_map_data' : pointeur donné au "callback" lorsqu'il est appelé

Exemple en C :

[source,C]
----
void
map_cb (void *data, struct t_hashtable *hashtable,
        const void *key, const void *value)
{
    /* afficher la clé et la valeur (elles sont des chaînes ici) */
    weechat_printf (NULL, "clé: '%s', valeur: '%s'",
                    (const char *)key,
                    (const char *)value);
}
/* ... */
weechat_hashtable_map (hashtable, &map_cb, NULL);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_hashtable_map_string

_WeeChat ≥ 0.3.7._

Appeller une fonction pour chaque entrée d'une table de hachage, en envoyant les
clés et valeurs sous forme de chaînes.

Prototype :

[source,C]
----
void weechat_hashtable_map_string (struct t_hashtable *hashtable,
                                   void (*callback_map)(void *data,
                                                        struct t_hashtable *hashtable,
                                                        const char *key,
                                                        const char *value),
                                   void *callback_map_data);
----

Paramètres :

* 'hashtable' : pointeur vers la table de hachage
* 'callback_map' : fonction appelée pour chaque entrée de la table de hachage
* 'callback_map_data' : pointeur donné au "callback" lorsqu'il est appelé

[NOTE]
Les chaînes 'key' et 'value' envoyées au "callback" sont des chaînes
temporaires, elles sont supprimées après l'appel au "callback".

Exemple en C :

[source,C]
----
void
map_cb (void *data, struct t_hashtable *hashtable,
        const char *key, const char *value)
{
    /* afficher la clé et la valeur */
    weechat_printf (NULL, "clé: '%s', valeur: '%s'",
                    key, value);
}
/* ... */
weechat_hashtable_map_string (hashtable, &map_cb, NULL);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_hashtable_dup

_WeeChat ≥ 1.0._

Dupliquer une table de hachage.

Prototype :

[source,C]
----
struct t_hashtable *weechat_hashtable_dup (struct t_hashtable *hashtable);
----

Paramètres :

* 'hashtable' : pointeur vers la table de hachage

Valeur de retour :

* table de hachage dupliquée

Exemple en C :

[source,C]
----
struct t_hashtable *new_hashtable = weechat_hashtable_dup (hashtable);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_hashtable_get_integer

_WeeChat ≥ 0.3.3._

Retourner une valeur entière pour une propriété d'une table de hachage.

Prototype :

[source,C]
----
int weechat_hashtable_get_integer (struct t_hashtable *hashtable,
                                   void *property);
----

Paramètres :

* 'hashtable' : pointeur vers la table de hachage
* 'property' : nom de propriété :
** 'size' : taille du tableau interne "htable" dans la table de hachage
** 'items_count' : nombre d'éléments dans la table de hachage

Valeur de retour :

* valeur de la propriété sous forme d'entier

Exemple en C :

[source,C]
----
int items_count = weechat_hashtable_get_integer (hashtable, "items_count");
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_hashtable_get_string

_WeeChat ≥ 0.3.4._

Retourner une valeur pour une propriété d'une table de hachage sous forme de
chaîne.

Prototype :

[source,C]
----
const char *weechat_hashtable_get_string (struct t_hashtable *hashtable,
                                          const char *property);
----

Paramètres :

* 'hashtable' : pointeur vers la table de hachage
* 'property' : nom de la propriété :
** 'type_keys' : type pour les clés :
*** 'integer' : entier
*** 'string' : chaîne
*** 'pointer' : pointeur
*** 'buffer' : buffer
*** 'time' : heure
** 'type_values' : type pour les valeurs :
*** 'integer' : entier
*** 'string' : chaîne
*** 'pointer' : pointeur
*** 'buffer' : buffer
*** 'time' : heure
** 'keys' : chaîne avec la liste des clés (format : "clé1,clé2,clé3")
** 'keys_sorted' : chaîne avec la liste triée des clés (format :
   "clé1,clé2,clé3")
** 'values' : chaîne avec la liste des valeurs (format :
   "valeur1,valeur2,valeur3")
** 'keys_values' : chaîne avec la liste des clés et valeurs
   (format : "clé1:valeur1,clé2:valeur2,clé3:valeur3")
** 'keys_values_sorted' : chaîne avec la liste des clés et valeurs (triée sur
   les clés) (format : "clé1:valeur1,clé2:valeur2,clé3:valeur3")

Valeur de retour :

* valeur de la propriété sous forme de chaîne

Exemples en C :

[source,C]
----
weechat_printf (NULL, "les clés sont de type: %s",
                weechat_hashtable_get_string (hashtable, "type_keys"));
weechat_printf (NULL, "liste des clés: %s",
                weechat_hashtable_get_string (hashtable, "keys"));
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_hashtable_set_pointer

_WeeChat ≥ 0.3.4._

Affecter un pointeur à une propriété d'une table de hachage.

Prototype :

[source,C]
----
void weechat_hashtable_set_pointer (struct t_hashtable *hashtable,
                                    const char *property, void *pointer);
----

Paramètres :

* 'hashtable' : pointeur vers la table de hachage
* 'property' : nom de la propriété :
** 'callback_free_key' : définit la fonction "callback" pour supprimer les clés
   de la table de hachage _(WeeChat ≥ 0.4.2)_
** 'callback_free_value' : définit la fonction "callback" pour supprimer les
   valeurs de la table de hachage
* 'pointer' : nouvelle valeur de pointeur pour la propriété

Exemple en C :

[source,C]
----
void
my_free_value_cb (struct t_hashtable *hashtable, const void *key, void *value)
{
    /* ... */
}

void
my_free_key_cb (struct t_hashtable *hashtable, void *key)
{
    /* ... */
}

weechat_hashtable_set_pointer (hashtable, "callback_free_value", &my_free_value_cb);
weechat_hashtable_set_pointer (hashtable, "callback_free_key", &my_free_key_cb);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_hashtable_add_to_infolist

_WeeChat ≥ 0.3.3._

Ajouter les éléments d'une table de hachage dans un objet infolist.

Prototype :

[source,C]
----
int weechat_hashtable_add_to_infolist (struct t_hashtable *hashtable,
                                       struct t_infolist_item *infolist_item,
                                       const char *prefix);
----

Paramètres :

* 'hashtable' : pointeur vers la table de hachage
* 'infolist_item' : pointeur vers l'objet de l'infolist
* 'prefix' : chaîne utilisée comme préfixe pour les noms dans l'infolist

Valeur de retour :

* 1 si ok, 0 en cas d'erreur

Exemple en C :

[source,C]
----
weechat_hashtable_add_to_infolist (hashtable, infolist_item, "testhash");

/* si la table de hachage contient :
     "cle1" => "valeur 1"
     "cle2" => "valeur 2"
   alors les variables suivantes seront ajoutées dans l'objet de l'infolist :
     "testhash_name_00000"  = "cle1"
     "testhash_value_00000" = "valeur 1"
     "testhash_name_00001"  = "cle2"
     "testhash_value_00001" = "valeur 2"
*/
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_hashtable_remove

_WeeChat ≥ 0.3.3._

Supprimer un élément d'une table de hachage.

Prototype :

[source,C]
----
void weechat_hashtable_remove (struct t_hashtable *hashtable, const void *key);
----

Paramètres :

* 'hashtable' : pointeur vers la table de hachage
* 'key' : pointeur vers la clé

Exemple en C :

[source,C]
----
weechat_hashtable_remove (hashtable, "ma_cle");
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_hashtable_remove_all

_WeeChat ≥ 0.3.3._

Supprimer tous les éléments d'une table de hachage.

Prototype :

[source,C]
----
void weechat_hashtable_remove_all (struct t_hashtable *hashtable);
----

Paramètres :

* 'hashtable' : pointeur vers la table de hachage

Exemple en C :

[source,C]
----
weechat_hashtable_remove_all (hashtable);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_hashtable_free

_WeeChat ≥ 0.3.3._

Supprimer une table de hachage.

Prototype :

[source,C]
----
void weechat_hashtable_free (struct t_hashtable *hashtable);
----

Paramètres :

* 'hashtable' : pointeur vers la table de hachage

Exemple en C :

[source,C]
----
weechat_hashtable_free (hashtable);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

[[configuration_files]]
=== Fichiers de configuration

Fonctions pour les fichiers de configuration.

==== weechat_config_new

Créer un nouveau fichier de configuration.

Prototype :

[source,C]
----
struct t_config_file *weechat_config_new (const char *name,
                                          int (*callback_reload)(void *data,
                                                                 struct t_config_file *config_file),
                                          void *callback_reload_data);
----

Paramètres :

* 'name' : nom du nouveau fichier de configuration (sans chemin ou extension)
* 'callback_reload' : fonction appelée quand le fichier de configuration est
  rechargé avec `/reload` (optionnel, peut être NULL), paramètres et valeur de
  retour :
** 'void *data' : pointeur
** 'struct t_config_file *config_file' : pointeur vers le fichier de
   configuration
** valeur de retour :
*** 'WEECHAT_CONFIG_READ_OK'
*** 'WEECHAT_CONFIG_READ_MEMORY_ERROR'
*** 'WEECHAT_CONFIG_READ_FILE_NOT_FOUND'
* 'callback_reload_data' : pointeur donné au "callback" de rechargement
  lorsqu'il est appelé par WeeChat

Valeur de retour :

* pointeur vers le nouveau fichier de configuration, NULL en cas d'erreur

[NOTE]
Le fichier n'est PAS créé sur le disque par cette fonction. Il sera créé par
l'appel à la fonction <<_weechat_config_write,weechat_config_write>>.
Vous ne devriez appeler cette fonction qu'après avoir créé les sections (avec
<<_weechat_config_new_section,weechat_config_new_section>>) et les options (avec
<<_weechat_config_new_option,weechat_config_new_option>>).

Exemple en C :

[source,C]
----
int
my_config_reload_cb (void *data, struct t_config_file *config_file)
{
    /* ... */

    return WEECHAT_RC_OK;
}

struct t_config_file *config_file = weechat_config_new ("test",
                                                        &my_config_reload_cb,
                                                        NULL);
----

Script (Python) :

[source,python]
----
# prototype
config_file = weechat.config_new(name, calback_reload, callback_reload_data)

# exemple
def my_config_reload_cb(data, config_file):
    # ...
    return weechat.WEECHAT_RC_OK

config_file = weechat.config_new("test", "my_config_reload_cb", "")
----

==== weechat_config_new_section

Créer une nouvelle section dans un fichier de configuration.

Prototype :

[source,C]
----
struct t_config_section *weechat_config_new_section (
    struct t_config_file *config_file,
    const char *name,
    int user_can_add_options,
    int user_can_delete_options,
    int (*callback_read)(void *data,
                         struct t_config_file *config_file,
                         struct t_config_section *section,
                         const char *option_name,
                         const char *value),
    void *callback_read_data,
    int (*callback_write)(void *data,
                          struct t_config_file *config_file,
                          const char *section_name),
    void *callback_write_data,
    int (*callback_write_default)(void *data,
                                  struct t_config_file *config_file,
                                  const char *section_name);
    void *callback_write_default_data,
    int (*callback_create_option)(void *data,
                                  struct t_config_file *config_file,
                                  struct t_config_section *section,
                                  const char *option_name,
                                  const char *value),
    void *callback_create_option_data,
    int (*callback_delete_option)(void *data,
                                  struct t_config_file *config_file,
                                  struct t_config_section *section,
                                  struct t_config_option *option),
    void *callback_delete_option_data);
----

Paramètres :

* 'config_file' : pointeur vers le fichier de configuration
* 'name' : nom de la section
* 'user_can_add_options' : 1 si l'utilisateur peut créer de nouvelles options
  dans la section, ou 0 si c'est interdit
* 'user_can_delete_options' : 1 si l'utilisateur peut supprimer des options
  dans la section, ou 0 si c'est interdit
* 'callback_read' : fonction appelée quand une option de la section est lue
  depuis le disque (devrait être NULL dans la plupart des cas, sauf si des
  options de la section nécessitent une fonction personnalisée), paramètres et
  valeur de retour :
** 'void *data' : pointeur
** 'struct t_config_file *config_file' : pointeur vers le fichier de
   configuration
** 'struct t_config_section *section' : pointeur vers la section
** 'const char *option_name' : nom de l'option
** 'const char *value' : valeur
** valeur de retour :
*** 'WEECHAT_CONFIG_READ_OK'
*** 'WEECHAT_CONFIG_READ_MEMORY_ERROR'
*** 'WEECHAT_CONFIG_READ_FILE_NOT_FOUND'
* 'callback_read_data' : pointeur donné au "callback" quand il est appelé par
   WeeChat
* 'callback_write' : fonction appelée lorsque la section est écrite dans le
  fichier (devrait être NULL dans la plupart des cas, sauf si la section
  nécessite d'être écrite par une fonction personnalisée), paramètres et valeur
  de retour :
** 'void *data' : pointeur
** 'struct t_config_file *config_file' : pointeur vers le fichier de
   configuration
** 'struct t_config_section *section' : pointeur vers la section
** 'const char *option_name' : nom de l'option
** valeur de retour :
*** 'WEECHAT_CONFIG_WRITE_OK'
*** 'WEECHAT_CONFIG_WRITE_ERROR'
*** 'WEECHAT_CONFIG_WRITE_MEMORY_ERROR'
* callback_write_data : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat
* callback_write_default : fonction appelée lorsque les valeurs par défaut
  doivent être écrites dans le fichier, paramètres et valeur de retour :
** 'void *data' : pointeur
** 'struct t_config_file *config_file' : pointeur vers le fichier de
   configuration
** 'const char *section_name' : nom de la section
** valeur de retour :
*** 'WEECHAT_CONFIG_WRITE_OK'
*** 'WEECHAT_CONFIG_WRITE_ERROR'
*** 'WEECHAT_CONFIG_WRITE_MEMORY_ERROR'
* 'callback_write_default_data' : pointeur donné au "callback" lorsqu'il est
  appelé par WeeChat
* 'callback_create_option' : fonction appelée lorsqu'une nouvelle option est
  créée dans la section (NULL si la section n'autorise pas la création de
  nouvelles options), paramètres et valeur de retour :
** 'void *data' : pointeur
** 'struct t_config_file *config_file' : pointeur vers le fichier de
   configuration
** 'struct t_config_section *section' : pointeur vers la section
** 'const char *option_name' : nom de l'option
** 'const char *value' : valeur
* 'callback_create_option_data' : pointeur donné au "callback" lorsqu'il est
  appelé par WeeChat
* 'callback_delete_option' : fonction appelée lorsqu'une option est supprimée
  de la section (NULL si la section n'autorise pas la suppression d'options),
  paramètres et valeur de retour :
** 'void *data' : pointeur
** 'struct t_config_file *config_file' : pointeur vers le fichier de
   configuration
** 'struct t_config_section *section' : pointeur vers la section
** 'struct t_config_option *option' : pointeur vers l'option
** valeur de retour :
*** 'WEECHAT_CONFIG_OPTION_SET_OK_CHANGED'
*** 'WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE'
*** 'WEECHAT_CONFIG_OPTION_SET_ERROR'
*** 'WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND'
* 'callback_delete_option_data' : pointeur donné au "callback" lorsqu'il est
  appelé par WeeChat

Valeur de retour :

* pointeur vers la nouvelle section du fichier de configuration, NULL en cas
  d'erreur

Exemple en C :

[source,C]
----
int
my_section_read_cb (void *data, struct t_config_file *config_file,
                    struct t_config_section *section, const char *option_name,
                    const char *value)
{
    /* ... */

    return WEECHAT_CONFIG_OPTION_SET_OK_CHANGED;
    /* return WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE; */
    /* return WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND; */
    /* return WEECHAT_CONFIG_OPTION_SET_ERROR; */
}

int
my_section_write_cb (void *data, struct t_config_file *config_file,
                     const char *section_name)
{
    /* ... */

    return WEECHAT_CONFIG_WRITE_OK;
    /* return WEECHAT_CONFIG_WRITE_ERROR; */
}

int
my_section_write_default_cb (void *data, struct t_config_file *config_file,
                             const char *section_name)
{
    /* ... */

    return WEECHAT_CONFIG_WRITE_OK;
    /* return WEECHAT_CONFIG_WRITE_ERROR; */
}

int
my_section_create_option_cb (void *data, struct t_config_file *config_file,
                             struct t_config_section *section,
                             const char *option_name, const char *value)
{
    /* ... */

    return WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE;
    /* return WEECHAT_CONFIG_OPTION_SET_ERROR; */
}

int
my_section_delete_option_cb (void *data, struct t_config_file *config_file,
                             struct t_config_section *section,
                             struct t_config_option *option)
{
    /* ... */

    return WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED;
    /* return WEECHAT_CONFIG_OPTION_UNSET_ERROR; */
}

/* section standard, l'utilisateur ne peut pas ajouter/supprimer des options */
struct t_config_section *new_section1 =
    weechat_config_new_section (config_file, "section1", 0, 0,
                                NULL, NULL,  /* callback de lecture */
                                NULL, NULL,  /* callback d'écriture */
                                NULL, NULL,  /* callback d'écriture (valeurs par défaut) */
                                NULL, NULL,  /* callback de création d'option */
                                NULL, NULL);  /* callback de suppression d'option */

/* section spéciale, l'utilisateur peut ajouter/supprimer des options, et les
   options nécessitent un callback pour la lecture/écriture */
struct t_config_section *new_section2 =
    weechat_config_new_section (config_file, "section2", 1, 1,
                                &my_section_read_cb, NULL,
                                &my_section_write_cb, NULL,
                                &my_section_write_default_cb, NULL,
                                &my_section_create_option_cb, NULL,
                                &my_section_delete_option_cb, NULL);
----

Script (Python) :

[source,python]
----
# prototype
section = weechat.config_new_section(config_file, name,
    user_can_add_options, user_can_delete_options,
    callback_read, callback_read_data,
    callback_write, callback_write_data,
    callback_create_option, callback_create_option_data,
    callback_delete_option, callback_delete_option_data)

# exemple
def my_section_read_cb(data, config_file, section, option_name, value):
    # ...
    return weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED
    # return weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE
    # return weechat.WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND
    # return weechat.WEECHAT_CONFIG_OPTION_SET_ERROR

def my_section_write_cb(data, config_file, section_name):
    # ...
    return weechat.WEECHAT_CONFIG_WRITE_OK

def my_section_write_default_cb(data, config_file, section_name):
    # ...
    return weechat.WEECHAT_CONFIG_WRITE_OK

def my_section_create_option_cb(data, config_file, section, option_name, value):
    # ...
    return weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE

def my_section_delete_option_cb(data, config_file, section, option):
    # ...
    return weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED

section = weechat.config_new_section(config_file, "section1", 1, 1,
    "my_section_read_cb", "",
    "my_section_write_cb", "",
    "my_section_write_default_cb", "",
    "my_section_create_option_cb", "",
    "my_section_delete_option_cb", "")
----

==== weechat_config_search_section

Rechercher une section dans un fichier de configuration.

Prototype :

[source,C]
----
struct t_config_section *weechat_config_search_section (
    struct t_config_file *config_file,
    const char *section_name);
----

Paramètres :

* 'config_file' : pointeur vers le fichier de configuration
* 'section_name' : nom de la section à chercher

Valeur de retour :

* pointeur vers la section trouvée, ou NULL si la section n'a pas été trouvée

Exemple en C :

[source,C]
----
struct t_config_section *section = weechat_config_search_section (config_file,
                                                                  "section");
----

Script (Python) :

[source,python]
----
# prototype
section = weechat.config_search_section(config_file, section_name)

# exemple
section = weechat.config_search_section(config_file, "section")
----

==== weechat_config_new_option

Créer une nouvelle option dans une section d'un fichier de configuration.

Prototype :

[source,C]
----
struct t_config_option *weechat_config_new_option (
    struct t_config_file *config_file,
    struct t_config_section *section,
    const char *name,
    const char *type,
    const char *description,
    const char *string_values,
    int min,
    int max,
    const char *default_value,
    const char *value,
    int null_value_allowed,
    int (*callback_check_value)(void *data,
                                struct t_config_option *option,
                                const char *value),
    void *callback_check_value_data,
    void (*callback_change)(void *data,
                            struct t_config_option *option),
    void *callback_change_data,
    void (*callback_delete)(void *data,
                            struct t_config_option *option),
    void *callback_delete_data);
----

Paramètres :

* 'config_file' : pointeur vers le fichier de configuration
* 'section' : pointeur vers la section
* 'name' : nom de l'option
* 'type' : type de l'option :
** 'boolean' : valeur booléenne (on/off)
** 'integer' : valeur entière (avec en option une chaîne pour chaque valeur)
** 'string' : une chaîne de caractères
** 'color' : une couleur
* 'description' : description de l'option
* 'string_values' : valeurs sous forme de chaîne (séparées par "|"), utilisées
  pour le type 'integer' (optionnel)
* 'min' : valeur minimum (pour le type 'integer')
* 'max' : valeur maximum (pour le type 'integer')
* 'default_value' : valeur par défaut de l'option (utilisée quand l'option est
  réinitialisée)
* 'value' : valeur de l'option
* 'null_value_allowed' : 1 si 'null' (valeur non définie) est autorisé pour
  l'option, sinon 0
* 'callback_check_value' : fonction appelée pour vérifier la nouvelle valeur
  de l'option (optionnel), paramètres et valeur de retour :
** 'void *data' : pointeur
** 'struct t_config_option *option' : pointeur vers l'option
** 'const char *value' : nouvelle valeur pour l'option
** valeur de retour :
*** 1 si la valeur est ok
*** 0 si la valeur est invalide
* 'callback_check_value_data' : pointeur donné au "callback" lorsqu'il est
  appelé par WeeChat
* 'callback_change' : fonction appelée lorsque la valeur de l'option a changé
  (optionnel), paramètres :
** 'void *data' : pointeur
** 'struct t_config_option *option' : pointeur vers l'option
* 'callback_change_data' : pointeur donné au "callback" lorsqu'il est appelé
  par WeeChat
* 'callback_delete' : fonction appelée lorsque l'option est supprimée
  (optionnel), paramètres :
** 'void *data' : pointeur
** 'struct t_config_option *option' : pointeur vers l'option
* 'callback_delete_data' : pointeur donné au "callback" lorsqu'il est appelé
  par WeeChat

Valeur de retour :

* pointeur vers la nouvelle option de la section, NULL en cas d'erreur

Exemple en C :

[source,C]
----
/* booléen */
struct t_config_option *option1 =
    weechat_config_new_option (config_file, section, "option1", "boolean",
                               "Mon option, type booléen"
                               NULL,  /* valeurs sous forme de chaînes */
                               0, 0,  /* min, max */
                               "on",  /* défaut */
                               "on",  /* valeur */
                               0,  /* valeur null autorisée */
                               NULL, NULL,  /* callback de vérification */
                               NULL, NULL,  /* callback de changement de valeur */
                               NULL, NULL);  /* callback de suppression de l'option */

/* entier */
struct t_config_option *option2 =
    weechat_config_new_option (config_file, section, "option2", "integer",
                               "Mon option, type entier"
                               NULL,  /* valeurs sous forme de chaînes */
                               0, 100,  /* min, max */
                               "15",  /* défaut */
                               "15",  /* valeur */
                               0,  /* valeur null autorisée */
                               NULL, NULL,  /* callback de vérification */
                               NULL, NULL,  /* callback de changement de valeur */
                               NULL, NULL);  /* callback de suppression de l'option */

/* entier (avec valeurs sous forme de chaînes) */
struct t_config_option *option3 =
    weechat_config_new_option (config_file, section, "option3", "integer",
                               "Mon option, type entier "
                               "(avec valeurs sous forme de chaînes)"
                               "top|bottom|left|right",  /* valeurs sous forme de chaînes */
                               0, 0,  /* min, max */
                               "bottom",  /* défaut */
                               "bottom",  /* valeur */
                               0,  /* valeur null autorisée */
                               NULL, NULL,  /* callback de vérification */
                               NULL, NULL,  /* callback de changement de valeur */
                               NULL, NULL);  /* callback de suppression de l'option */

/* chaîne */
struct t_config_option *option4 =
    weechat_config_new_option (config_file, section, "option4", "string",
                               "Mon option, type chaîne"
                               NULL,  /* valeurs sous forme de chaînes */
                               0, 0,  /* min, max */
                               "test",  /* défaut */
                               "test",  /* valeur */
                               1,  /* valeur null autorisée */
                               NULL, NULL,  /* callback de vérification */
                               NULL, NULL,  /* callback de changement de valeur */
                               NULL, NULL);  /* callback de suppression de l'option */

/* couleur */
struct t_config_option *option5 =
    weechat_config_new_option (config_file, section, "option5", "color",
                               "Mon option, type couleur"
                               NULL,  /* valeurs sous forme de chaînes */
                               0, 0,  /* min, max */
                               "lightblue",  /* défaut */
                               "lightblue",  /* valeur */
                               0,  /* valeur null autorisée */
                               NULL, NULL,  /* callback de vérification */
                               NULL, NULL,  /* callback de changement de valeur */
                               NULL, NULL);  /* callback de suppression de l'option */
----

Script (Python) :

[source,python]
----
# prototype
option = weechat.config_new_option(config_file, section, name, type, description,
    string_values, min, max, default_value, value, null_value_allowed,
    callback_check_value, callback_check_value_data,
    callback_change, callback_change_data,
    callback_delete, callback_delete_data)

# exemple
def option4_check_value_cb(data, option, value):
    # ...
    return 1
    # return 0

def option4_change_cb(data, option):
    # ...

def option4_delete_cb(data, option):
    # ...

option1 = weechat.config_new_option(config_file, section, "option1", "boolean",
    "Mon option, type booléen",
    "", 0, 0, "on", "on", 0,
    "", "",
    "", "",
    "", "")

option2 = weechat.config_new_option(config_file, section, "option2", "integer",
    "Mon option, type entier",
    "", 0, 100, "15", "15", 0,
    "", "",
    "", "",
    "", "")

option3 = weechat.config_new_option(config_file, section, "option3", "integer",
    "Mon option, type entier (avec valeurs sous forme de chaînes)",
    "top|bottom|left|right",
    0, 0, "bottom", "bottom", 0,
    "", "",
    "", "",
    "", "")

option4 = weechat.config_new_option(config_file, section, "option4", "string",
    "Mon option, type chaîne",
    "", 0, 0, "test", "test", 1,
    "option4_check_value_cb", ""
    "option4_change_cb", "",
    "option4_delete_cb", "")

option5 = weechat.config_new_option(config_file, section, "option5", "color",
    "Mon option, type couleur",
    "", 0, 0, "lightblue", "lightblue", 0,
    "", "",
    "", "",
    "", "")
----

[NOTE]
En Ruby, les 3 "callbacks" + "data" (6 chaînes) doivent être données dans un
tableau de 6 chaînes de caractères (en raison d'une limitation de Ruby à 15
paramètres par fonction), voir le 'Guide pour Scripts WeeChat' pour plus d'infos
_(corrigé dans la version 0.4.1)_.

==== weechat_config_search_option

Rechercher une option dans une section d'un fichier de configuration.

Prototype :

[source,C]
----
struct t_config_option *weechat_config_search_option (
    struct t_config_file *config_file,
    struct t_config_section *section,
    const char *option_name);
----

Paramètres :

* 'config_file' : pointeur vers le fichier de configuration
* 'section' : pointeur vers la section
* 'name' : nom de l'option à rechercher

Valeur de retour :

* pointeur vers l'option trouvée, NULL si l'option n'a pas été trouvée

Exemple en C :

[source,C]
----
struct t_config_option *option =
    weechat_config_search_option (config_file, section, "option");
----

Script (Python) :

[source,python]
----
# prototype
option = weechat.config_search_option(config_file, section, option_name)

# exemple
option = weechat.config_search_option(config_file, section, "option")
----

==== weechat_config_search_section_option

Rechercher une section et une option dans un fichier de configuration ou une
section.

Prototype :

[source,C]
----
void weechat_config_search_section_option (struct t_config_file *config_file,
                                           struct t_config_section *section,
                                           const char *option_name,
                                           struct t_config_section **section_found,
                                           struct t_config_option **option_found);
----

Paramètres :

* 'config_file' : pointeur vers le fichier de configuration
* 'section' : pointeur vers la section
* 'option_name' : nom de l'option
* 'section' : pointeur vers un pointeur sur une section, sera alimenté avec le
  pointeur vers la section de l'option trouvée
* 'option' : pointeur vers un pointeur sur une option, sera alimenté avec le
  pointeur vers l'option trouvée

Exemple en C :

[source,C]
----
struct t_config_section *ptr_section;
struct t_config_option *ptr_option;

weechat_config_search_section_option (config_file,
                                      section,
                                      "option",
                                      &ptr_section,
                                      &ptr_option);
if (ptr_option)
{
    /* option trouvée */
}
else
{
    /* option non trouvée */
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_config_search_with_string

Retourner des infos sur fichier/section/option pour une option avec le nom
complet.

Prototype :

[source,C]
----
void weechat_config_search_with_string (const char *option_name,
                                        struct t_config_file **config_file,
                                        struct t_config_section **section,
                                        struct t_config_option **option,
                                        char **pos_option_name);
----

Paramètres :

* 'option_name' : nom complet de l'option (format : "fichier.section.option")
* 'config_file' : pointeur vers un pointeur sur un fichier de configuration,
  sera alimenté avec le pointeur vers le fichier de configuration de l'option
  trouvée
* 'section' : pointeur vers un pointeur sur une section, sera alimenté avec le
  pointeur vers la section de l'option trouvée
* 'option' : pointeur vers un pointeur sur une option, sera alimenté avec le
  pointeur vers l'option trouvée
* 'pos_option_name' : pointeur vers un pointeur sur une chaîne, sera alimenté
  avec le pointeur vers le nom de l'option trouvée

Exemple en C :

[source,C]
----
struct t_config_file *ptr_config_file;
struct t_config_section *ptr_section;
struct t_config_option *ptr_option;
char *option_name;

weechat_config_search_with_string ("fichier.section.option",
                                   &ptr_config_file,
                                   &ptr_section,
                                   &ptr_option,
                                   &option_name);
if (ptr_option)
{
    /* option trouvée */
}
else
{
    /* option non trouvée */
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_config_string_to_boolean

Vérifier si un texte est "vrai" ou "faux", au sens booléen.

Prototype :

[source,C]
----
int weechat_config_string_to_boolean (const char *text);
----

Paramètres :

* 'text' : texte à analyser

Valeur de retour :

* 1 si le texte est "vrai" ("on", "yes", "y", "true", "t", "1")
* 0 si le texte est "faux" ("off", "no", "n", "false", "f", "0")

Exemple en C :

[source,C]
----
if (weechat_config_string_to_boolean (option_value))
{
    /* la valeur est "vrai" */
}
else
{
    /* la valeur est "faux" */
}
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.config_string_to_boolean(text)

# exemple
if weechat.config_string_to_boolean(text):
    # ...
----

==== weechat_config_option_reset

Réinitialiser une option à sa valeur par défaut.

Prototype :

[source,C]
----
int weechat_config_option_reset (struct t_config_option *option,
                                 int run_callback);
----

Paramètres :

* 'option' : pointeur vers l'option
* 'run_callback' : 1 pour appeler le "callback" si la valeur de l'option est
  changée, sinon 0

Valeur de retour :

* 'WEECHAT_CONFIG_OPTION_SET_OK_CHANGED' si la valeur de l'option a été
  réinitialisée
* 'WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE' si la valeur n'a pas changé
* 'WEECHAT_CONFIG_OPTION_SET_ERROR' en cas d'erreur

Exemple en C :

[source,C]
----
switch (weechat_config_option_reset (option, 1))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* .... */
        break;
}
----

Script (Python) :

[source,python]
----
# prototype
rc = weechat.config_option_reset(option, run_callback)

# exemple
rc = weechat.config_option_reset(option, 1)
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----

==== weechat_config_option_set

Affecter une nouvelle valeur pour une option.

Prototype :

[source,C]
----
int weechat_config_option_set (struct t_config_option *option,
                               const char *value, int run_callback);
----

Paramètres :

* 'option' : pointeur vers l'option
* 'value' : nouvelle valeur pour l'option
* 'run_callback' : 1 pour appeler le "callback" si la valeur de l'option est
  changée, sinon 0

Valeur de retour :

* 'WEECHAT_CONFIG_OPTION_SET_OK_CHANGED' si la valeur de l'option a été changée
* 'WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE' si la valeur n'a pas changé
* 'WEECHAT_CONFIG_OPTION_SET_ERROR' en cas d'erreur

Exemple en C :

[source,C]
----
switch (weechat_config_option_set (option, "nouvelle_valeur", 1))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* .... */
        break;
}
----

Script (Python) :

[source,python]
----
# prototype
rc = weechat.config_option_set(option, value, run_callback)

# exemple
rc = weechat.config_option_set(option, "nouvelle_valeur", 1)
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----

==== weechat_config_option_set_null

Affecter "null" (valeur indéfinie) à une option.

Prototype :

[source,C]
----
int weechat_config_option_set_null (struct t_config_option *option,
                                    int run_callback);
----

Paramètres :

* 'option' : pointeur vers l'option
* 'run_callback' : 1 pour appeler le "callback" si la valeur de l'option est
  changée (elle n'était pas "null"), sinon 0

[NOTE]
Vous pouvez affecter "null" à une option seulement si c'est autorisé pour
l'option (voir <<_weechat_config_new_option,weechat_config_new_option>>).

Valeur de retour :

* 'WEECHAT_CONFIG_OPTION_SET_OK_CHANGED' si la valeur de l'option a été changée
* 'WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE' si la valeur n'a pas changé
* 'WEECHAT_CONFIG_OPTION_SET_ERROR' en cas d'erreur

Exemple en C :

[source,C]
----
switch (weechat_config_option_set_null (option, 1))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* .... */
        break;
}
----

Script (Python) :

[source,python]
----
# prototype
rc = weechat.config_option_set_null(option, run_callback)

# exemple
rc = weechat.config_option_set_null(option, 1)
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----

==== weechat_config_option_unset

Réinitialiser ou supprimer une option.

Prototype :

[source,C]
----
int weechat_config_option_unset (struct t_config_option *option);
----

Paramètres :

* 'option' : pointeur vers l'option

Valeur de retour :

* 'WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET' si la valeur de l'option n'a pas
  été réinitialisée
* 'WEECHAT_CONFIG_OPTION_UNSET_OK_RESET' si la valeur de l'option a été
  réinitialisée
* 'WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED' si l'option a été supprimée
* 'WEECHAT_CONFIG_OPTION_UNSET_ERROR' en cas d'erreur

Exemple en C :

[source,C]
----
switch (weechat_config_option_unset (option))
{
    case WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_ERROR:
        /* .... */
        break;
}
----

Script (Python) :

[source,python]
----
# prototype
rc = weechat.config_option_unset(option)

# exemple
rc = weechat.config_option_unset(option)
if rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_ERROR:
    # ...
----

==== weechat_config_option_rename

Renommer une option.

Prototype :

[source,C]
----
void weechat_config_option_rename (struct t_config_option *option,
                                   const char *new_name);
----

Paramètres :

* 'option' : pointeur vers l'option
* 'new_name' : nouveau nom pour l'option

Exemple en C :

[source,C]
----
weechat_config_option_rename (option, "nouveau_nom");
----

Script (Python) :

[source,python]
----
# prototype
weechat.config_option_rename(option, new_name)

# exemple
weechat.config_option_rename(option, "nouveau_nom")
----

==== weechat_config_option_get_pointer

Retourner un pointeur vers une propriété de l'option.

Prototype :

[source,C]
----
void *weechat_config_option_get_pointer (struct t_config_option *option,
                                         const char *property);
----

Paramètres :

* 'option' : pointeur vers l'option
* 'property' : nom de la propriété :
** 'config_file' : pointeur vers le fichier de configuration
   ('struct t_config_file *')
** 'section' : pointeur vers la section ('struct t_config_section *')
** 'name' : nom de l'option ('char *')
** 'type' : type de l'option ('int *')
** 'description' : description de l'option ('char *')
** 'string_values' : valeurs sous forme de chaîne ('char *')
** 'min' : valeur minimum ('int *')
** 'max' : valeur maximum ('int *')
** 'default_value' : valeur par défaut (dépend du type)
** 'value' : valeur courante (dépend du type)
** 'prev_option' : pointeur vers l'option précédente
   ('struct t_config_option *')
** 'next_option' : pointeur vers l'option suivante
   ('struct t_config_option *')

Valeur de retour :

* pointeur vers la propriété demandée

Exemple en C :

[source,C]
----
char *description = weechat_config_option_get_pointer (option, "description");
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_config_option_is_null

Vérifier si une option est "null" (valeur non définie).

Prototype :

[source,C]
----
int weechat_config_option_is_null (struct t_config_option *option);
----

Paramètres :

* 'option' : pointeur vers l'option

Valeur de retour :

* 1 si la valeur de l'option est "null"
* 0 si la valeur de l'option n'est pas "null"

Exemple en C :

[source,C]
----
if (weechat_config_option_is_null (option))
{
    /* la valeur est "null" */
}
else
{
    /* la valeur n'est pas "null" */
}
----

Script (Python) :

[source,python]
----
# prototype
is_null = weechat.config_option_is_null(option)

# exemple
if weechat.config_option_is_null(option):
    # ...
----

==== weechat_config_option_default_is_null

Vérifier si la valeur par défaut d'une option est "null" (valeur non définie).

Prototype :

[source,C]
----
int weechat_config_option_default_is_null (struct t_config_option *option);
----

Paramètres :

* 'option' : pointeur vers l'option

Valeur de retour :

* 1 si la valeur par défaut de l'option est "null"
* 0 si la valeur par défaut de l'option n'est pas "null"

Exemple en C :

[source,C]
----
if (weechat_config_option_default_is_null (option))
{
    /* la valeur par défaut est "null" */
}
else
{
    /* la valeur par défaut n'est pas "null" */
}
----

Script (Python) :

[source,python]
----
# prototype
is_null = weechat.config_option_default_is_null(option)

# exemple
if weechat.config_option_default_is_null(option):
    # ...
----

==== weechat_config_boolean

Retourner la valeur booléenne de l'option.

Prototype :

[source,C]
----
int weechat_config_boolean (struct t_config_option *option);
----

Paramètres :

* 'option' : pointeur vers l'option

Valeur de retour :

* valeur booléenne de l'option (0 ou 1)

Exemple en C :

[source,C]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
if (weechat_config_boolean (option))
{
    /* la valeur est "vrai" */
}
else
{
    /* la valeur est "faux" */
}
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.config_boolean(option)

# exemple
option = weechat.config_get("plugin.section.option")
if weechat.config_boolean(option):
    # ...
----

==== weechat_config_boolean_default

Retourner la valeur booléenne par défaut de l'option.

Prototype :

[source,C]
----
int weechat_config_boolean_default (struct t_config_option *option);
----

Paramètres :

* 'option' : pointeur vers l'option

Valeur de retour :

* valeur booléenne par défaut de l'option (0 ou 1)

Exemple en C :

[source,C]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
if (weechat_config_boolean_default (option))
{
    /* la valeur est "vrai" */
}
else
{
    /* la valeur est "faux" */
}
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.config_boolean_default(option)

# exemple
option = weechat.config_get("plugin.section.option")
if weechat.config_boolean_default(option):
    # ...
----

==== weechat_config_integer

Retourner la valeur entière de l'option.

Prototype :

[source,C]
----
int weechat_config_integer (struct t_config_option *option);
----

Paramètres :

* 'option' : pointeur vers l'option

Valeur de retour :

* valeur entière de l'option

Exemple en C :

[source,C]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
int value = weechat_config_integer (option);
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.config_integer(option)

# exemple
option = weechat.config_get("plugin.section.option")
value = weechat.config_integer(option)
----

==== weechat_config_integer_default

Retourner la valeur entière par défaut de l'option.

Prototype :

[source,C]
----
int weechat_config_integer_default (struct t_config_option *option);
----

Paramètres :

* 'option' : pointeur vers l'option

Valeur de retour :

* valeur entière par défaut de l'option

Exemple en C :

[source,C]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
int value = weechat_config_integer_default (option);
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.config_integer_default(option)

# exemple
option = weechat.config_get("plugin.section.option")
value = weechat.config_integer_default(option)
----

==== weechat_config_string

Retourner la valeur de l'option, sous forme de chaîne.

Prototype :

[source,C]
----
const char *weechat_config_string (struct t_config_option *option);
----

Paramètres :

* 'option' : pointeur vers l'option

Valeur de retour :

* valeur de l'option, sous forme de chaîne

Exemple en C :

[source,C]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
const char *value = weechat_config_string (option);
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.config_string(option)

# exemple
option = weechat.config_get("plugin.section.option")
value = weechat.config_string(option)
----

==== weechat_config_string_default

Retourner la valeur par défaut de l'option, sous forme de chaîne.

Prototype :

[source,C]
----
const char *weechat_config_string_default (struct t_config_option *option);
----

Paramètres :

* 'option' : pointeur vers l'option

Valeur de retour :

* valeur par défaut de l'option, sous forme de chaîne

Exemple en C :

[source,C]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
const char *value = weechat_config_string_default (option);
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.config_string_default(option)

# exemple
option = weechat.config_get("plugin.section.option")
value = weechat.config_string_default(option)
----

==== weechat_config_color

Retourner la valeur de l'option, sous forme de couleur.

Prototype :

[source,C]
----
const char *weechat_config_color (struct t_config_option *option);
----

Paramètres :

* 'option' : pointeur vers l'option

Valeur de retour :

* valeur de l'option sous forme de couleur (chaîne avec le nom de la couleur)

Exemple en C :

[source,C]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
const char *color = weechat_config_color (option);
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.config_color(option)

# exemple
option = weechat.config_get("plugin.section.option")
value = weechat.config_color(option)
----

==== weechat_config_color_default

Retourner la valeur par défaut de l'option, sous forme de couleur.

Prototype :

[source,C]
----
const char *weechat_config_color_default (struct t_config_option *option);
----

Paramètres :

* 'option' : pointeur vers l'option

Valeur de retour :

* valeur par défaut de l'option sous forme de couleur (chaîne avec le nom de la
  couleur)

Exemple en C :

[source,C]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
const char *color = weechat_config_color_default (option);
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.config_color_default(option)

# exemple
option = weechat.config_get("plugin.section.option")
value = weechat.config_color_default(option)
----

==== weechat_config_write_option

Écrire une ligne dans le fichier de configuration avec l'option et sa valeur
(cette fonction doit être appelée uniquement dans un "callback" "write" ou
"write_default" pour une section).

Prototype :

[source,C]
----
void weechat_config_write_option (struct t_config_file *config_file,
                                  struct t_config_option *option);
----

Paramètres :

* 'config_file' : pointeur vers le fichier de configuration
* 'option' : pointeur vers l'option

Exemple en C :

[source,C]
----
int
my_section_write_cb (void *data, struct t_config_file *config_file,
                     const char *section_name)
{
    weechat_config_write_line (config_file, "ma_section", NULL);

    weechat_config_write_option (config_file, option);

    return WEECHAT_RC_OK;
}
----

Script (Python) :

[source,python]
----
# prototype
weechat.config_write_option(config_file, option)

# exemple
def my_section_write_cb(data, config_file, section_name):
    weechat.config_write_line(config_file, "ma_section", "")
    weechat.config_write_option(config_file, option)
    return weechat.WEECHAT_RC_OK
----

==== weechat_config_write_line

Écrire une ligne dans un fichier de configuration (cette fonction doit être
appelée uniquement dans un "callback" "write" ou "write_default" pour une
section).

Prototype :

[source,C]
----
void weechat_config_write_line (struct t_config_file *config_file,
                                const char *option_name,
                                const char *value, ...);
----

Paramètres :

* 'config_file' : pointeur vers le fichier de configuration
* 'option_name' : nom de l'option
* 'value' : valeur (si NULL, alors la ligne est écrite avec le nom de la
  section, par exemple : "[section]")

Exemple en C :

[source,C]
----
int
my_section_write_cb (void *data, struct t_config_file *config_file,
                     const char *section_name)
{
    weechat_config_write_line (config_file, "ma_section", NULL);

    weechat_config_write_line (config_file, "option", "%s;%d",
                               "valeur", 123);

    return WEECHAT_RC_OK;
}
----

Script (Python) :

[source,python]
----
# prototype
weechat.config_write_line(config_file, option_name, value)

# exemple
def my_section_write_cb(data, config_file, section_name):
    weechat.config_write_line(config_file, "ma_section", "")
    weechat.config_write_line(config_file, "option", "valeur")
    return weechat.WEECHAT_RC_OK
----

==== weechat_config_write

Écrire un fichier de configuration sur le disque.

Prototype :

[source,C]
----
int weechat_config_write (struct t_config_file *config_file);
----

Paramètres :

* 'config_file' : pointeur vers le fichier de configuration.

Valeur de retour :

* 'WEECHAT_CONFIG_WRITE_OK' si la configuration a été écrite
* 'WEECHAT_CONFIG_WRITE_MEMORY_ERROR' s'il n'y a pas eu suffisamment de mémoire
* 'WEECHAT_CONFIG_WRITE_ERROR' si une autre erreur s'est produite

Exemple en C :

[source,C]
----
switch (weechat_config_write (config_file))
{
    case WEECHAT_CONFIG_WRITE_OK:
        /* ... */
        break;
    case WEECHAT_CONFIG_WRITE_MEMORY_ERROR:
        /* ... */
        break;
    case WEECHAT_CONFIG_WRITE_ERROR:
        /* ... */
        break;
}
----

Script (Python) :

[source,python]
----
# prototype
rc = weechat.config_write(config_file)

# exemple
rc = weechat.config_write(config_file)
if rc == weechat.WEECHAT_CONFIG_WRITE_OK:
    # ...
elif rc == weechat.WEECHAT_CONFIG_WRITE_MEMORY_ERROR:
    # ...
elif rc == weechat.WEECHAT_CONFIG_WRITE_ERROR:
    # ...
----

==== weechat_config_read

Lire un fichier de configuration depuis le disque.

Prototype :

[source,C]
----
int weechat_config_read (struct t_config_file *config_file);
----

Paramètres :

* 'config_file' : pointeur vers le fichier de configuration

Valeur de retour :

* 'WEECHAT_CONFIG_READ_OK' si la configuration a été chargée
* 'WEECHAT_CONFIG_READ_MEMORY_ERROR' s'il n'y a pas eu suffisamment de mémoire
* 'WEECHAT_CONFIG_READ_FILE_NOT_FOUND' si le fichier n'a pas été trouvé

Exemple en C :

[source,C]
----
switch (weechat_config_read (config_file))
{
    case WEECHAT_CONFIG_READ_OK:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_MEMORY_ERROR:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
        /* ... */
        break;
}
----

Script (Python) :

[source,python]
----
# prototype
rc = weechat.config_read(config_file)

# exemple
rc = weechat.config_read(config_file)
if rc == weechat.WEECHAT_CONFIG_READ_OK:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_MEMORY_ERROR:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
    # ...
----

==== weechat_config_reload

Relire un fichier de configuration depuis le disque.

Prototype :

[source,C]
----
int weechat_config_reload (struct t_config_file *config_file);
----

Paramètres :

* 'config_file' : pointeur vers le fichier de configuration

Valeur de retour :

* 'WEECHAT_CONFIG_READ_OK' si la configuration a été rechargée
* 'WEECHAT_CONFIG_READ_MEMORY_ERROR' s'il n'y a pas eu suffisamment de mémoire
* 'WEECHAT_CONFIG_READ_FILE_NOT_FOUND' si le fichier n'a pas été trouvé

Exemple en C :

[source,C]
----
switch (weechat_config_reload (config_file))
{
    case WEECHAT_CONFIG_READ_OK:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_MEMORY_ERROR:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
        /* ... */
        break;
}
----

Script (Python) :

[source,python]
----
# prototype
rc = weechat.config_reload(config_file)

# exemple
rc = weechat.config_reload(config_file)
if rc == weechat.WEECHAT_CONFIG_READ_OK:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_MEMORY_ERROR:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
    # ...
----

==== weechat_config_option_free

Supprimer une option.

Prototype :

[source,C]
----
void weechat_config_option_free (struct t_config_option *option);
----

Paramètres :

* 'option' : pointeur vers l'option

Exemple en C :

[source,C]
----
weechat_config_option_free (option);
----

Script (Python) :

[source,python]
----
# prototype
weechat.config_option_free(option)

# exemple
weechat.config_option_free(option)
----

==== weechat_config_section_free_options

Supprimer toutes les options dans une section.

Prototype :

[source,C]
----
void weechat_config_section_free_options (struct t_config_section *section);
----

Paramètres :

* 'section' : pointeur vers la section

Exemple en C :

[source,C]
----
weechat_config_section_free_options (section);
----

Script (Python) :

[source,python]
----
# prototype
weechat.config_section_free_options(section)

# exemple
weechat.config_section_free_options(section)
----

==== weechat_config_section_free

Supprimer une section.

Prototype :

[source,C]
----
void weechat_config_section_free (struct t_config_section *section);
----

Paramètres :

* 'section' : pointeur vers la section

Exemple en C :

[source,C]
----
weechat_config_section_free (section);
----

Script (Python) :

[source,python]
----
# prototype
weechat.config_section_free(section)

# exemple
weechat.config_section_free(section)
----

==== weechat_config_free

Supprimer un fichier de configuration.

Prototype :

[source,C]
----
void weechat_config_free (struct t_config_file *config_file);
----

Paramètres :

* 'config_file' : pointeur vers le fichier de configuration

Exemple en C :

[source,C]
----
weechat_config_free (config_file);
----

Script (Python) :

[source,python]
----
# prototype
weechat.config_free(config_file)

# exemple
weechat.config_free(config_file)
----

==== weechat_config_get

Rechercher une option avec le nom complet.

Prototype :

[source,C]
----
struct t_config_option *weechat_config_get (const char *option_name);
----

Paramètres :

* 'option_name' : nom complet de l'option (format : "fichier.section.option")

Valeur de retour :

* pointeur vers l'option trouvée, NULL si l'option n'a pas été trouvée

Exemple en C :

[source,C]
----
struct t_config_option *option = weechat_config_get ("weechat.look.item_time_format");
----

Script (Python) :

[source,python]
----
# prototype
option = weechat.config_get(option_name)

# exemple
option = weechat.config_get("weechat.look.item_time_format")
----

==== weechat_config_get_plugin

Rechercher une option dans le fichier de configuration des extensions
(plugins.conf).

Prototype :

[source,C]
----
const char *weechat_config_get_plugin (const char *option_name);
----

Paramètres :

* 'option_name' : nom de l'option, WeeChat ajoutera le préfixe
  "plugins.var.xxx." (où "xxx" est le nom de l'extension courante)

Valeur de retour :

* valeur de l'option trouvée, NULL si l'option n'a pas été trouvée

Exemple en C :

[source,C]
----
/* si l'extension courante est "test", alors on cherche la valeur de l'option
   "plugins.var.test.option" dans le fichier plugins.conf */
char *value = weechat_config_get_plugin ("option");
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.config_get_plugin(option_name)

# exemple
value = weechat.config_get_plugin("option")
----

==== weechat_config_is_set_plugin

Vérifier si une option existe dans le fichier de configuration des extensions
(plugins.conf).

Prototype :

[source,C]
----
int weechat_config_is_set_plugin (const char *option_name);
----

Paramètres :

* 'option_name' : nom de l'option, WeeChat ajoutera le préfixe
  "plugins.var.xxx." (où "xxx" est le nom de l'extension courante)

Valeur de retour :

* 1 si l'option est définie, 0 si l'option n'existe pas

Exemple en C :

[source,C]
----
if (weechat_config_is_set_plugin ("option"))
{
    /* l'option existe */
}
else
{
    /* l'option n'existe pas */
}
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.config_is_set_plugin(option_name)

# exemple
if weechat.config_is_set_plugin("option"):
    # l'option existe
    # ...
else:
    # l'option n'existe pas
    # ...
----

==== weechat_config_set_plugin

Affecter une nouvelle valeur pour une option dans le fichier de configuration
des extensions (plugins.conf).

Prototype :

[source,C]
----
int weechat_config_set_plugin (const char *option_name, const char *value);
----

Paramètres :

* 'option_name' : nom de l'option, WeeChat ajoutera le préfixe
  "plugins.var.xxx." (où "xxx" est le nom de l'extension courante)
* 'value' : nouvelle valeur pour l'option

Valeur de retour :

* 'WEECHAT_CONFIG_OPTION_SET_OK_CHANGED' si la valeur de l'option a été changée
* 'WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE' si la valeur n'a pas changé
* 'WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND' si l'option n'a pas été trouvée
* 'WEECHAT_CONFIG_OPTION_SET_ERROR' en cas d'erreur

Exemple en C :

[source,C]
----
switch (weechat_config_set_plugin ("option", "valeur_test"))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* ... */
        break;
}
----

Script (Python) :

[source,python]
----
# prototype
rc = weechat.config_set_plugin(option_name, value)

# exemple
rc = weechat.config_set_plugin("option", "valeur_test")
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----

==== weechat_config_set_desc_plugin

_WeeChat ≥ 0.3.5._

Affecter une description pour une option dans le fichier de configuration des
extensions (plugins.conf).

Prototype :

[source,C]
----
void weechat_config_set_desc_plugin (const char *option_name,
                                     const char *description);
----

Paramètres :

* 'option_name' : nom de l'option, WeeChat ajoutera le préfixe
  "plugins.desc.xxx." (où "xxx" est le nom de l'extension courante)
* 'description' : description pour l'option

[NOTE]
Ce n'est pas un problème si l'option (plugins.var.xxx.option_name) n'existe pas.
Une création future de cette option utilisera cette description.

Exemple en C :

[source,C]
----
weechat_config_set_desc_plugin ("option", "description de l'option");
----

Script (Python) :

[source,python]
----
# prototype
weechat.config_set_desc_plugin(option_name, description)

# exemple
version = weechat.info_get("version_number", "") or 0
if int(version) >= 0x00030500:
    weechat.config_set_desc_plugin("option", "description de l'option")
----

==== weechat_config_unset_plugin

Supprimer une option du fichier de configuration des extensions (plugins.conf).

Prototype :

[source,C]
----
int weechat_config_unset_plugin (const char *option_name);
----

Paramètres :

* 'option_name' : nom de l'option, WeeChat ajoutera le préfixe
  "plugins.var.xxx." (où "xxx" est le nom de l'extension courante)

Valeur de retour :

* 'WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET' si la valeur de l'option n'a pas
  été réinitialisée
* 'WEECHAT_CONFIG_OPTION_UNSET_OK_RESET' si la valeur de l'option a été
  réinitialisée
* 'WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED' si l'option a été supprimée
* 'WEECHAT_CONFIG_OPTION_UNSET_ERROR' en cas d'erreur

Exemple en C :

[source,C]
----
switch (weechat_config_unset_plugin ("option"))
{
    case WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_ERROR:
        /* ... */
        break;
}
----

Script (Python) :

[source,python]
----
# prototype
rc = weechat.config_unset_plugin(option_name)

# exemple
rc = weechat.config_unset_plugin("option")
if rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_ERROR:
    # ...
----

[[key_bindings]]
=== Associations de touches

Fonctions pour les associations de touches.

==== weechat_key_bind

_WeeChat ≥ 0.3.6._

Ajouter de nouvelles associations de touches.

[NOTE]
Contrairement à la commande `/key bind`, cette fonction ne changera jamais
une association de touche existante, seulement des nouvelles touches seront
créées. Pour supprimer une association de touche, utilisez
<<_weechat_key_unbind,weechat_key_unbind>>.

Prototype :

[source,C]
----
int weechat_key_bind (const char *context, struct t_hashtable *keys);
----

Paramètres :

* 'context' : contexte pour les touches :
** 'default' : contexte par défaut (actions courantes)
** 'search' : contexte de recherche (lors de la recherche de texte dans le
   tampon)
** 'cursor' : mouvement libre du curseur à l'écran
** 'mouse' : touches pour les évènements de souris
* 'keys' : table de hachage avec les associations de touches

Valeur de retour :

* nombre d'associations de touches ajoutées

Exemple en C :

[source,C]
----
struct t_hashtable *keys = weechat_hashtable_new (8,
                                                  WEECHAT_HASHTABLE_STRING,
                                                  WEECHAT_HASHTABLE_STRING,
                                                  NULL,
                                                  NULL);
if (keys)
{
    weechat_hashtable_set (keys, "@chat(plugin.buffer):button1", "hsignal:test_mouse");
    weechat_hashtable_set (keys, "@chat(plugin.buffer):wheelup", "/mycommand up");
    weechat_hashtable_set (keys, "@chat(plugin.buffer):wheeldown", "/mycommand down");
    weechat_key_bind ("mouse", keys);
    weechat_hashtable_free (keys);
}
----

Script (Python) :

[source,python]
----
# prototype
num_keys = weechat.key_bind(context, keys)

# exemple
keys = {"@chat(python.test):button1": "hsignal:test_mouse",
        "@chat(python.test):wheelup": "/mycommand up",
        "@chat(python.test):wheeldown": "/mycommand down"}
weechat.key_bind("mouse", keys)
----

==== weechat_key_unbind

_WeeChat ≥ 0.3.6._

Supprimer une/des association(s) de touche(s).

[WARNING]
Lors de l'appel à cette fonction, assurez-vous que vous n'allez pas supprimer
une touche définie par l'utilisateur.

Prototype :

[source,C]
----
int weechat_key_unbind (const char *context, const char *key);
----

Paramètres :

* 'context' : contexte pour les touches (voir
   <<_weechat_key_bind,weechat_key_bind>>)
* 'key' : touche à supprimer ou la valeur spéciale "area:XXX" pour supprimer
  toutes les touches ayant 'XXX' comme première ou deuxième zone

Valeur de retour :

* nombre d'associations de touches supprimées

Exemples en C :

[source,C]
----
/* supprimer une seule touche */
weechat_key_unbind ("mouse", "@chat(plugin.buffer):button1");

/* supprimer toutes les touches avec la zone "chat(plugin.buffer)" */
weechat_key_unbind ("mouse", "area:chat(plugin.buffer)");
----

Script (Python) :

[source,python]
----
# prototype
num_keys = weechat.key_unbind(context, key)

# exemples

# supprimer une seule touche
weechat.key_unbind("mouse", "@chat(plugin.buffer):button1")

# supprimer toutes les touches avec la zone "chat(python.test)"
weechat.key_unbind("mouse", "area:chat(python.test)")
----

[[display]]
=== Affichage

Fonctions pour afficher du texte dans les tampons.

==== weechat_prefix

Retourner un préfixe.

Prototype :

[source,C]
----
const char *weechat_prefix (const char *prefix);
----

Paramètres :

* 'prefix' : nom du préfixe (voir le tableau ci-dessous)

Valeur de retour :

* valeur du préfixe (chaîne avec le préfixe et des codes couleur), chaîne vide
  si le préfixe n'a pas été trouvé

Liste des préfixes :

[width="70%",cols="^2e,^1,^3,5",options="header"]
|===
| Préfixe | Valeur | Couleur                   | Description
| error   | `=!=`  | jaune ("yellow")          | Message d'erreur
| network | `--`   | violet ("magenta")        | Message du réseau
| action  | `*`    | blanc ("white")           | Action personnelle
| join    | `-->`  | vert clair ("lightgreen") | Quelqu'un a rejoint la discussion
| quit    | `<--`  | rouge clair ("lightred")  | Quelqu'un a quitté la discussion
|===

[NOTE]
Les valeurs et couleurs peuvent être configurées avec la commande `/set`.

Exemple en C :

[source,C]
----
weechat_printf (NULL, "%sCeci est une erreur...", weechat_prefix ("error"));
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.prefix(prefix)

# exemple
weechat.prnt("", "%sCeci est une erreur..." % weechat.prefix("error"))
----

==== weechat_color

Retourner une chaîne avec un code couleur pour affichage.

Prototype :

[source,C]
----
const char *weechat_color (const char *color_name);
----

Paramètres :

* 'color_name' : nom de la couleur, parmi :
** une option WeeChat (de weechat.color.xxx), par exemple 'chat_delimiters'
** une couleur avec des attributs/fond optionnels (voir ci-dessous)
** un attribut :
*** 'bold' : activer le gras
*** '-bold' : désactiver le gras
*** 'reverse' : activer la vidéo inverse
*** '-reverse' : désactiver la vidéo inverse
*** 'italic' : activer l'italique
*** '-italic' : désactiver l'italique
*** 'underline' : activer le souligné
*** '-underline' : désactiver le souligné
*** 'emphasis' : activer/désactiver la mise en valeur du texte (note : cela ne
    devrait être utilisé que dans les barres, car WeeChat utilise la mise en
    valeur du texte lors de la recherche de texte dans le tampon)
    _(WeeChat ≥ 0.4.2)_
** nom d'une couleur de barre :
*** 'bar_fg' : couleur de texte pour la barre
*** 'bar_delim' : couleur des délimiteurs pour la barre
*** 'bar_bg' : couleur de fond pour la barre
** réinitialisation :
*** 'reset' : réinitialiser la couleur et les attributs
*** 'resetcolor' : réinitialiser la couleur (garder les attributs)
    _(WeeChat ≥ 0.3.6)_

Le format de la couleur est : attributs (optionnel) + nom de couleur + ",fond"
(optionnel). Les attributs possibles sont :

* `*` : texte gras
* `!` : mode vidéo inverse
* `/` : italique
* `_` : texte souligné
* `|` : garder les attributs : ne pas réinitialiser
  gras/inverse/italique/souligné lors du changement de couleur
  _(WeeChat ≥ 0.3.6)_

Exemples :

* `yellow` : jaune
* `_green` : vert souligné
* `*214` : orange gras
* `yellow,red` : jaune sur rouge
* `|cyan` : cyan (et garder tout attribut définit précédemment)

Valeur de retour :

* chaîne avec le code couleur, ou une chaîne vide si la couleur n'a pas été
  trouvée

Exemple en C :

[source,C]
----
weechat_printf (NULL, "Couleur : %sbleu %scouleur par défaut %sjaune sur rouge",
                weechat_color ("blue"),
                weechat_color ("chat"),
                weechat_color ("yellow,red"));
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.color(color_name)

# exemple
weechat.prnt("", "Couleur : %sbleu %scouleur par défaut %sjaune sur rouge"
    % (weechat.color("blue"), weechat.color("chat"), weechat.color("yellow,red")))
----

==== weechat_printf

Afficher un message sur un tampon.

Prototype :

[source,C]
----
void weechat_printf (struct t_gui_buffer *buffer, const char *message, ...);
----

Paramètres :

* 'buffer' : pointeur vers le tampon, si NULL, le message est affiché sur le
  tampon WeeChat
* 'message' : message à afficher

[NOTE]
La première tabulation dans le message ("\t") est utilisée pour séparer le
préfixe du message. +
Si votre message contient des tabulations et si vous ne voulez pas de préfixe,
utilisez un espace, une tabulation, puis le message : cela désactivera le
préfixe (l'espace avant la tabulation ne sera pas affiché).

[NOTE]
Avec deux tabulations ("\t") au début du message, l'heure ne sera pas affichée
et le message n'aura pas d'alignement. De plus, la date dans le message sera
positionnée à 0.

Exemple en C :

[source,C]
----
weechat_printf (NULL, "Bonjour sur le tampon WeeChat");
weechat_printf (buffer, "Bonjour sur ce tampon");
weechat_printf (buffer, "%sCeci est une erreur !", weechat_prefix ("error"));
weechat_printf (buffer, " \tMessage sans préfixe mais avec \t quelques \t tabulations");
weechat_printf (buffer, "\t\tMessage sans heure/alignement");
weechat_printf (buffer, "\t\t");  /* ligne vide (sans heure) */
----

Script (Python) :

[source,python]
----
# prototype
weechat.prnt(buffer, message)

# exemple
weechat.prnt("", "Bonjour sur le tampon WeeChat")
weechat.prnt(buffer, "Bonjour sur ce tampon")
weechat.prnt(buffer, "%sCeci est une erreur !" % weechat.prefix("error"))
weechat.prnt(buffer, " \tMessage sans préfixe mais avec \t quelques \t tabulations")
weechat.prnt(buffer, "\t\tMessage sans heure/alignement")
weechat.prnt(buffer, "\t\t")  # ligne vide (sans heure)
----

[NOTE]
La fonction s'appelle "print" dans les scripts ("prnt" en Python).

==== weechat_printf_date

Afficher un message sur un tampon, en utilisant une date personnalisée.

Prototype :

[source,C]
----
void weechat_printf_date (struct t_gui_buffer *buffer, time_t date,
                          const char *message, ...);
----

Paramètres :

* 'buffer' : pointeur vers le tampon, si NULL, le message est affiché sur le
  tampon Weechat
* 'date' : date pour le message (0 signifie la date/heure courante)
* 'message' : message à afficher

Exemple en C :

[source,C]
----
weechat_printf_date (NULL, time (NULL) - 120, "Bonjour, il y a 2 minutes");
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_printf_tags

Afficher un message sur un tampon, avec des étiquettes personnalisées.

Prototype :

[source,C]
----
void weechat_printf_tags (struct t_gui_buffer *buffer, const char *tags,
                          const char *message, ...);
----

Paramètres :

* 'buffer' : pointeur vers le tampon, si NULL, le message est affiché sur le
  tampon Weechat
* 'tags' : liste d'étiquettes séparées par des virgules
* 'message' : message à afficher

Exemple en C :

[source,C]
----
weechat_printf_tags (NULL, "notify_message",
                     "Message avec une étiquette 'notify_message'");
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_printf_date_tags

Afficher un message sur un tampon, en utilisant une date et des étiquettes
personnalisées.

Prototype :

[source,C]
----
void weechat_printf_date_tags (struct t_gui_buffer *buffer, time_t date,
                               const char *tags, const char *message, ...);
----

Paramètres :

* 'buffer' : pointeur vers le tampon, si NULL, le message est affiché sur le
  tampon Weechat
* 'date' : date pour le message (0 signifie la date/heure courante)
* 'tags' : liste d'étiquettes séparées par des virgules
* 'message' : message à afficher

Tags couramment utilisés (liste non exhaustive) :

[width="70%",cols="1m,4",options="header"]
|===
| Tag              | Description
| no_filter        | La ligne ne peut pas être filtrée
| no_highlight     | Aucun highlight n'est possible sur cette ligne
| no_log           | La ligne n'est pas écrite dans le fichier de log
| log0 ... log9    | Niveau de log pour la ligne (voir `/help logger`)
| notify_none      | Le tampon avec la ligne ne sera pas ajouté à la "hotlist"
| notify_message   | Le tampon avec la ligne sera ajouté à la "hotlist" avec le niveau "message"
| notify_private   | Le tampon avec la ligne sera ajouté à la "hotlist" avec le niveau "private"
| notify_highlight | Le tampon avec la ligne sera ajouté à la "hotlist" avec le niveau "highlight"
| nick_xxx         | Le message vient du pseudo "xxx"
| prefix_nick_ccc  | Le préfixe est un pseudo avec la couleur "ccc"
| host_xxx         | Nom d'utilisateur et hôte dans le message
| irc_xxx          | Message IRC "xxx" (peut-être une commande ou un numérique sur 3 chiffres)
| irc_numeric      | Message IRC numérique
| irc_error        | Erreur du serveur IRC
| irc_action       | Action d'un pseudo (commande `/me`)
| irc_ctcp         | Message CTCP
| irc_ctcp_reply   | Réponse à un message CTCP
| irc_smart_filter | Message IRC qui peut être filtré avec le "smart filter" (filtre intelligent)
| away_info        | Message avec une info d'absence
|===

Exemple en C :

[source,C]
----
weechat_printf_date_tags (NULL, time (NULL) - 120, "notify_message",
                          "Message il y a 2 minutes avec une étiquette 'notify_message'");
----

Script (Python) :

[source,python]
----
# prototype
weechat.prnt_date_tags(buffer, date, tags, message)

# exemple
time = int(time.time())
weechat.prnt_date_tags("", time - 120, "notify_message",
    "Message il y a 2 minutes avec une étiquette 'notify_message'")
----

[NOTE]
La fonction s'appelle "print_date_tags" dans les scripts ("prnt_date_tags" en
Python).

==== weechat_printf_y

Afficher un message sur une ligne d'un tampon avec contenu libre.

Prototype :

[source,C]
----
void weechat_printf_y (struct t_gui_buffer *buffer, int y,
                       const char *message, ...);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'y' : numéro de ligne (la première ligne est 0); une valeur négative affiche
  une ligne après la dernière ligne affichée: la valeur absolue de 'y' est le
  nombre de lignes après la dernière ligne (par exemple -1 est immédiatement
  après la dernière ligne, -2 est 2 lignes après la dernière ligne)
  _(WeeChat ≥ 1.0)_
* 'message' : message à afficher

Exemple en C :

[source,C]
----
weechat_printf_y (buffer, 2, "Mon message sur la 3ème ligne");
----

Script (Python) :

[source,python]
----
# prototype
weechat.prnt_y(buffer, y, message)

# exemple
weechat.prnt_y("", 2, "Mon message sur la 3ème ligne")
----

[NOTE]
La fonction s'appelle "print_y" dans les scripts ("prnt_y" en Python).

==== weechat_log_printf

Écrire un message dans le fichier de log WeeChat (weechat.log).

Prototype :

[source,C]
----
void weechat_log_printf (const char *message, ...);
----

Paramètres :

* 'message' : message à écrire

Exemple en C :

[source,C]
----
weechat_log_printf ("Mon message dans le fichier log");
----

Script (Python) :

[source,python]
----
# prototype
weechat.log_print(message)

# exemple
weechat.log_print("Mon message dans le fichier log")
----

[NOTE]
La fonction s'appelle "log_print" dans les scripts.

[[hooks]]
=== Hooks

[[hook_priority]]
[float]
==== Priorité de hook

_WeeChat ≥ 0.3.4._

Pour certains "hooks", vous pouvez définir une priorité. Un "hook" avec une
priorité plus élevée sera au début de la liste des "hooks", et donc il sera
trouvé et exécuté avant les autres "hooks". Cela est pratique pour les
modificateurs, car l'ordre d'exécution est important.

Pour définir une priorité, vous devez utiliser cette syntaxe, pour un paramètre
où la priorité est autorisée : "nnn|nom" où "nnn" est un entier positif ou nul
avec la priorité et "nom" le nom pour le paramètre (la priorité n'apparaît pas
dans le nom, elle est automatiquement retirée de la chaîne).

La priorité par défaut est 1000.

Exemple en C :

[source,C]
----
/* accroche un modificateur avec priorité = 2000 */
weechat_hook_modifier ("2000|input_text_display", &modifier_cb, NULL);
----

Les types de "hooks" suivants autorisent une priorité : command, command_run,
signal, hsignal, config, completion, modifier, info, info_hashtable, infolist,
hdata, focus.

==== weechat_hook_command

Accrocher une commande.

Prototype :

[source,C]
----
struct t_hook *weechat_hook_command (const char *command,
                                     const char *description,
                                     const char *args,
                                     const char *args_description,
                                     const char *completion,
                                     int (*callback)(void *data,
                                                     struct t_gui_buffer *buffer,
                                                     int argc,
                                                     char **argv,
                                                     char **argv_eol),
                                     void *callback_data);
----

Paramètres :

* 'command' : nom de la commande
  (priorité autorisée, voir la note sur la <<hook_priority,priorité>>)
* 'description' : description de la commande (affiché avec `/help command`)
* 'args' : paramètres pour la commande (affichés avec `/help command`)
* 'args_description' : description des paramètres (affichée avec
  `/help command`)
* 'completion' : modèle pour la complétion de la commande : liste des
  complétions pour chaque paramètre, séparés par des espaces. Plusieurs
  complétions sont possibles pour un paramètre, séparées par "|". Plusieurs
  modèles de complétions sont possibles pour une même commande, séparés par
  "||".
* 'callback' : fonction appelée lorsque la commande est utilisée, paramètres et
  valeur de retour :
** 'void *data' : pointeur
** 'struct t_gui_buffer *buffer' : tampon où la commande est exécutée
** 'int argc' : nombre de paramètres passés à la commande
** 'char **argv' : paramètres pour la commande
** 'char **argv_eol' : paramètres pour la commande (jusqu'à fin de ligne pour
   chaque paramètre)
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Les codes complétions par défaut sont :

include::autogen/plugin_api/completions.asciidoc[]

Codes spéciaux :

* '%%command' : réutiliser le modèle de complétion de la commande 'command'
* '%-' : arrêter la complétion
* '%*' : répéter la dernière complétion

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----
int
my_command_cb (void *data, struct t_gui_buffer *buffer, int argc,
               char **argv, char **argv_eol)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* cet exemple s'inspire de la commande /filter */
struct t_hook *my_command_hook =
    weechat_hook_command (/* nom de la commande */
                          "monfiltre",
                          /* description */
                          "description de monfiltre",
                          /* paramètres */
                          "[list] | [enable|disable|toggle [nom]] | "
                          "[add nom extension.tampon tags regex] | "
                          "[del nom|-all]",
                          /* description des paramètres */
                          "description des paramètres...",
                          /* complétion */
                          "list"
                          " || enable %(filters_names)"
                          " || disable %(filters_names)"
                          " || toggle %(filters_names)"
                          " || add %(filters_names) %(buffers_plugins_names)|*"
                          " || del %(filters_names)|-all",
                          /* callback */
                          &my_command_cb,
                          /* callback_data */
                          NULL);
----

Par exemple, si la commande appelée est `/command abc def ghi`, alors 'argv' et
'argv_eol' ont les valeurs suivantes :

* 'argv' :
** 'argv[0]' == "/command"
** 'argv[1]' == "abc"
** 'argv[2]' == "def"
** 'argv[3]' == "ghi"
* 'argv_eol' :
** 'argv_eol[0]' == "/command abc def ghi"
** 'argv_eol[1]' == "abc def ghi"
** 'argv_eol[2]' == "def ghi"
** 'argv_eol[3]' == "ghi"

Pour les scripts, 'args' a la valeur "abc def ghi".

Script (Python) :

[source,python]
----
# prototype
hook = weechat.hook_command(command, description, args, args_description,
    completion, callback, callback_data)

# exemple
def my_command_cb(data, buffer, args):
    # ...
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_command("monfiltre", "description de monfiltre",
    "[list] | [enable|disable|toggle [name]] | [add name plugin.buffer tags regex] | [del name|-all]",
    "description des paramètres...",
    "list"
    " || enable %(filters_names)"
    " || disable %(filters_names)"
    " || toggle %(filters_names)"
    " || add %(filters_names) %(buffers_plugins_names)|*"
    " || del %(filters_names)|-all",
    "my_command_cb", "")
----

==== weechat_hook_command_run

Intercepter une commande lorsqu'elle est exécutée par WeeChat.

Prototype :

[source,C]
----
struct t_hook *weechat_hook_command_run (const char *command,
                                         int (*callback)(void *data,
                                                         struct t_gui_buffer *buffer,
                                                         const char *command),
                                         void *callback_data);
----

Paramètres :

* 'command' : commande à intercepter (le caractère joker "*" est autorisé)
  (priorité autorisée, voir la note sur la <<hook_priority,priorité>>)
* 'callback' : fonction appelée lorsque la commande est exécutée, paramètres et
  valeur de retour :
** 'void *data' : pointeur
** 'struct t_gui_buffer *buffer' : tampon où la commande est exécutée
** 'const char *command' : la commande exécutée, avec ses paramètres
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_OK_EAT'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

[NOTE]
Le "callback" peut retourner 'WEECHAT_RC_OK' ou 'WEECHAT_RC_OK_EAT' (la
commande ne sera pas exécutée par WeeChat après le "callback").

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----
int
my_command_run_cb (void *data, struct t_gui_buffer *buffer, const char *command)
{
    weechat_printf (NULL,
                    "Vous voulez compléter ? Je mange la commande, ahah !");
    return WEECHAT_RC_OK_EAT;
}

struct t_hook *my_command_run_hook =
    weechat_hook_command_run ("/input complete*",
                              &my_command_run_cb, NULL);
----

Script (Python) :

[source,python]
----
# prototype
hook = weechat.hook_command_run(command, callback, callback_data)

# exemple
def my_command_run_cb(data, buffer, command):
    weechat.prnt("", "Vous voulez compléter ? Je mange la commande, ahah !")
    return weechat.WEECHAT_RC_OK_EAT

hook = weechat.hook_command_run("/input complete*", "my_command_run_cb", "")
----

==== weechat_hook_timer

Accrocher un minuteur (fonction appelée à intervalles réguliers).

Prototype :

[source,C]
----
struct t_hook *weechat_hook_timer (long interval,
                                   int align_second,
                                   int max_calls,
                                   int (*callback)(void *data,
                                                   int remaining_calls),
                                   void *callback_data);
----

Paramètres :

* 'interval' : intervalle entre deux appels (en millisecondes, donc 1000 = 1
  seconde)
* 'align_second' : alignement sur la seconde. Par exemple, si la date courante
  est 09:00, si l'intervalle est 60000 (60 secondes), et que align_second = 60,
  alors le minuteur sera appelé chaque minute quand la seconde sera 0
* 'max_calls' : nombre maximum d'appels au minuteur (si 0, le minuteur n'a pas
  de fin)
* 'callback' : fonction appelée quand le délai est atteint, paramètres et valeur
  de retour :
** 'void *data' : pointeur
** 'int remaining_calls' : nombre d'appels restants (-1 si le minuteur n'a pas
   de fin)
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----
int
my_timer_cb (void *data, int remaining_calls)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* minuteur appelé toutes les 20 secondes */
struct t_hook *my_timer_hook =
    weechat_hook_timer (20 * 1000, 0, 0, &my_timer_cb, NULL);
----

Script (Python) :

[source,python]
----
# prototype
hook = weechat.hook_timer(interval, align_second, max_calls, callback, callback_data)

# exemple
def my_timer_cb(data, remaining_calls):
    # ...
    return weechat.WEECHAT_RC_OK

# minuteur appelé toutes les 20 secondes
hook = weechat.hook_timer(20 * 1000, 0, 0, "my_timer_cb", "")
----

==== weechat_hook_fd

Accrocher un descripteur de fichier (fichier ou socket).

Prototype :

[source,C]
----
struct t_hook *weechat_hook_fd (int fd,
                                int flag_read,
                                int flag_write,
                                int flag_exception,
                                int (*callback)(void *data,
                                                int fd),
                                void *callback_data);
----

Paramètres :

* 'fd' : descripteur de fichier
* 'flag_read' : 1 = intercepter un évènement de lecture, 0 = ignorer
* 'flag_write' : 1 = intercepter un évènement d'écriture, 0 = ignorer
* 'flag_exception' : 1 = intercepter un évènement d'exception, 0 = ignorer
* 'callback' : fonction appelée lorsqu'un des évènements sélectionnés se
  produit pour le fichier (ou le socket), paramètres et valeur de retour :
** 'void *data' : pointeur
** 'int fd' : descripteur de fichier
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----
int
my_fd_cb (void *data, int fd)
{
    /* ... */
    return WEECHAT_RC_OK;
}

int sock = socket (AF_INET, SOCK_STREAM, 0);
/* définir les options du socket */
/* ... */
struct t_hook *my_fd_hook = weechat_hook_fd (sock, 1, 0, 0, &my_fd_cb, NULL);
----

Script (Python) :

[source,python]
----
# prototype
hook = weechat.hook_fd(fd, flag_read, flag_write, flag_exception, callback, callback_data)

# exemple
def my_fd_cb(data, fd):
    # ...
    return weechat.WEECHAT_RC_OK

sock = ...
hook = weechat.hook_fd(sock, 1, 0, 0, "my_fd_cb", "")
----

==== weechat_hook_process

Accrocher un processus (lancé par un fork), et intercepter sa sortie.

[NOTE]
Depuis la version 0.3.9.2, le shell n'est plus utilisé pour exécuter la
commande. WeeChat effectue un découpage automatique de la commande et de ses
paramètres (comme le fait le shell). +
Si le découpage n'est pas correct (selon les guillemets utilisés dans votre
commande), ou si vous souhaitez utiliser le shell, vous pouvez utiliser la
fonction <<_weechat_hook_process_hashtable,weechat_hook_process_hashtable>> avec
les paramètres dans la table de hachage 'options' _(WeeChat ≥ 0.4.0)_.

Prototype :

[source,C]
----
struct t_hook *weechat_hook_process (const char *command,
                                     int timeout,
                                     int (*callback)(void *data,
                                                     const char *command,
                                                     int return_code,
                                                     const char *out,
                                                     const char *err),
                                     void *callback_data);
----


Paramètres :

* 'command' : commande à lancer dans le processus fils ou URL
  _(WeeChat ≥ 0.3.7)_ (voir ci-dessous)
* 'timeout' : timeout pour la commande (en millisecondes) : après ce délai, le
  processus fils est tué (0 signifie pas de limite)
* 'callback' : fonction appelée quand des données du fils sont disponibles, or
  ou quand le fils s'est terminé, paramètres et valeur de retour :
** 'void *data' : pointeur
** 'const char *command' : commande exécutée par le fils
** 'int return_code' : code retour :
*** '>= 0' : code retour du fils pour une commande, et pour l'URL, les valeurs
    possibles sont :
**** '0' : transfert ok
**** '1' : URL invalide
**** '2' : erreur de transfert
**** '3' : pas assez de mémoire
**** '4' : erreur avec un fichier
*** '< 0' : 'WEECHAT_HOOK_PROCESS_RUNNING' (données disponibles, mais le
    fils tourne toujours) ou 'WEECHAT_HOOK_PROCESS_ERROR' (erreur en lançant
    la commande)
** 'out' : sortie standard de la commande (stdout)
** 'err' : erreurs de la commande (stderr)
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Lorsque la commande est terminée, ou si le timeout est atteint, WeeChat
supprimera automatiquement le "hook" (et tuera le processus s'il tourne
toujours).

La commande peut être une URL avec le format : "url:http://www.example.com",
pour télécharger le contenu de l'URL _(WeeChat ≥ 0.3.7)_.
Des options pour l'URL sont possibles avec la fonction
<<_weechat_hook_process_hashtable,weechat_hook_process_hashtable>>.

[TIP]
Si vous souhaitez récupérer des infos à propos de WeeChat (comme la version
stable actuelle, le dernier commit git, etc...), vous pouvez utiliser les URLs
sur la page https://weechat.org/dev/info

[NOTE]
La taille du tampon pour l'envoi des données au "callback" est de 64 Ko (il y a
2 tampons : un pour stdout et un pour stderr).
Si la sortie du processus fils (stdout ou stderr) est plus longue que 64 Ko, le
"callback" sera appelé plusieurs fois.

[IMPORTANT]
Même si la plupart du temps le "callback" n'est appelé qu'une seule fois, vous
devez vous assurer que plusieurs appels au "callback" sont ok dans votre code :
vous devez concaténer les données issues de plusieurs appels et n'utiliser les
données que lorsque le code retour est positif ou nul.

Exemple en C :

[source,C]
----
int
my_process_cb (void *data, const char *command, int return_code,
               const char *out, const char *err)
{
    if (return_code == WEECHAT_HOOK_PROCESS_ERROR)
    {
        weechat_printf (NULL, "Erreur avec la commande '%s'", command);
        return WEECHAT_RC_OK;
    }

    if (return_code >= 0)
    {
        weechat_printf (NULL, "return_code = %d", return_code);
    }

    if (out)
    {
        weechat_printf (NULL, "stdout : %s", out);
    }

    if (err)
    {
        weechat_printf (NULL, "stderr : %s", err);
    }

    return WEECHAT_RC_OK;
}

struct t_hook *my_process_hook = weechat_hook_process ("ls", 5000,
                                                       &my_process_cb, NULL);
----

Script (Python) :

[source,python]
----
# prototype
hook = weechat.hook_process(command, timeout, callback, callback_data)

# exemple
def my_process_cb(data, command, return_code, out, err):
    if return_code == weechat.WEECHAT_HOOK_PROCESS_ERROR:
        weechat.prnt("", "Erreur avec la commande '%s'" % command)
        return weechat.WEECHAT_RC_OK
    if return_code >= 0:
        weechat.prnt("", "return_code = %d" % return_code)
    if out != "":
        weechat.prnt("", "stdout: %s" % out)
    if err != "":
        weechat.prnt("", "stderr: %s" % err)
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_process("ls", 5000, "my_process_cb", "")
----

==== weechat_hook_process_hashtable

_WeeChat ≥ 0.3.7._

Accrocher un processus (lancé par un fork) en utilisant des options dans une
table de hachage, et intercepter sa sortie.

Prototype :

[source,C]
----
struct t_hook *weechat_hook_process_hashtable (const char *command,
                                               struct t_hashtable *options,
                                               int timeout,
                                               int (*callback)(void *data,
                                                               const char *command,
                                                               int return_code,
                                                               const char *out,
                                                               const char *err),
                                               void *callback_data);
----

Les paramètres sont les mêmes que ceux de la fonction
<<_weechat_hook_process,weechat_hook_process>>, avec un paramètre
supplémentaire :

* 'options' : options pour la commande exécutée; la table de hachage est
  dupliquée dans la fonction, donc il est possible de la supprimer après cet
  appel

Pour une commande standard (ne commençant pas par "url:"), les options suivantes
sont disponibles :

[width="100%",cols="^1,1,3",options="header"]
|===
| Option | Valeur | Description

| argN (N ≥ 1) +
  _(WeeChat ≥ 0.4.0)_ |
  toute chaîne |
  Paramètres pour la commande ; si aucun paramètre n'est donné avec ces options,
  la commande sera automatiquement découpée comme le fait le shell (et donc les
  paramètres de la commande sont lus dans le paramètre 'command')

| stdin +
  _(WeeChat ≥ 0.4.3)_ |
  (non utilisée) |
  Créer un tuyau pour écrire sur l'entrée standard (stdin) du processus fils
  (voir la fonction <<_weechat_hook_set,weechat_hook_set>>)

| buffer_flush +
  _(WeeChat ≥ 1.0)_ |
  nombre d'octets |
  Nombre minimum d'octets pour vider stdout/stderr (pour envoyer la sortie au
  "callback"), entre 1 et 65536 (par défaut); 1 = envoyer toute sortie
  immédiatement au "callback"

| detached +
  _(WeeChat ≥ 1.0)_ |
  (non utilisée) |
  Lancer le process dans un mode détaché : stdout et stderr sont redirigés vers
  '/dev/null'
|===

Pour la commande "url:...", les options suivantes sont disponibles (voir
`man curl_easy_setopt` pour une description de chaque option) :

include::autogen/plugin_api/url_options.asciidoc[]

[NOTE]
^(1)^ Lorsque des constantes sont disponibles, elles doivent être utilisées
comme valeur pour l'option. Pour les options avec le type "mask", le format
est : "valeur1+valeur2+valeur3".

Pour l'URL, deux options supplémentaires (chaînes) sont autorisées, pour le
fichier en entrée/sortie :

* 'file_in' : fichier à lire pour envoyer avec l'URL (envoi de fichier "post")
* 'file_out' : écrire l'URL/fichier dans ce fichier (au lieu de la sortie
  standard)

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----
int
my_process_cb (void *data, const char *command, int return_code,
               const char *out, const char *err)
{
    if (return_code == WEECHAT_HOOK_PROCESS_ERROR)
    {
        weechat_printf (NULL, "Erreur avec la commande '%s'", command);
        return WEECHAT_RC_OK;
    }

    if (return_code >= 0)
    {
        weechat_printf (NULL, "return_code = %d", return_code);
    }

    if (out)
    {
        weechat_printf (NULL, "stdout : %s", out);
    }

    if (err)
    {
        weechat_printf (NULL, "stderr : %s", err);
    }

    return WEECHAT_RC_OK;
}

/* exemple 1 : téléchargement d'une URL */
struct t_hashtable *options = weechat_hashtable_new (8,
                                                     WEECHAT_HASHTABLE_STRING,
                                                     WEECHAT_HASHTABLE_STRING,
                                                     NULL,
                                                     NULL);
if (options)
{
    weechat_hashtable_set (options, "file_out", "/tmp/weechat.org.html");
    struct t_hook *my_process_hook = weechat_hook_process_hashtable ("url:https://weechat.org/",
                                                                     options,
                                                                     20000,
                                                                     &my_process_cb, NULL);
    weechat_hashtable_free (options);
}

/* exemple 2 : exécution d'un programme de notification avec le message de quelqu'un */
struct t_hashtable *options_cmd1 = weechat_hashtable_new (8,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          NULL,
                                                          NULL);
if (options_cmd1)
{
    weechat_hashtable_set (options_cmd1, "arg1", "-from");
    weechat_hashtable_set (options_cmd1, "arg2", nick);
    weechat_hashtable_set (options_cmd1, "arg3", "-msg");
    weechat_hashtable_set (options_cmd1, "arg4", message);  /* paramètre non sûr */
    struct t_hook *my_process_hook = weechat_hook_process_hashtable ("my-notify-command",
                                                                     options_cmd1,
                                                                     20000,
                                                                     &my_process_cb, NULL);
    weechat_hashtable_free (options_cmd1);
}

/* exemple 3 : appeler le shell pour exécuter la commande (la commande doit être SURE) */
struct t_hashtable *options_cmd2 = weechat_hashtable_new (8,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          NULL,
                                                          NULL);
if (options_cmd2)
{
    weechat_hashtable_set (options_cmd2, "arg1", "-c");
    weechat_hashtable_set (options_cmd2, "arg2", "ls -l /tmp | grep something");
    struct t_hook *my_process_hook = weechat_hook_process_hashtable ("sh",
                                                                     options_cmd2,
                                                                     20000,
                                                                     &my_process_cb, NULL);
    weechat_hashtable_free (options_cmd2);
}
----

Script (Python) :

[source,python]
----
# prototype
hook = weechat.hook_process_hashtable(command, options, timeout, callback, callback_data)

# exemple
def my_process_cb(data, command, return_code, out, err):
    if return_code == weechat.WEECHAT_HOOK_PROCESS_ERROR:
        weechat.prnt("", "Erreur avec la commande '%s'" % command)
        return weechat.WEECHAT_RC_OK
    if return_code >= 0:
        weechat.prnt("", "return_code = %d" % return_code)
    if out != "":
        weechat.prnt("", "stdout: %s" % out)
    if err != "":
        weechat.prnt("", "stderr: %s" % err)
    return weechat.WEECHAT_RC_OK

# exemple 1 : téléchargement d'une URL
hook1 = weechat.hook_process_hashtable("url:https://weechat.org/",
                                       {"file_out": "/tmp/weechat.org.html"},
                                       20000, "my_process_cb", "")

# exemple 2 : exécution d'un programme de notification avec le message de quelqu'un
hook2 = weechat.hook_process_hashtable("my-notify-command",
                                       {"arg1": "-from",
                                        "arg2": nick,
                                        "arg3": "-msg",
                                        "arg4": message},  # paramètre non sûr
                                       20000, "my_process_cb", "")

# exemple 3 : appeler le shell pour exécuter la commande (la commande doit être SURE)
hook3 = weechat.hook_process_hashtable("sh",
                                       {"arg1": "-c",
                                        "arg2": "ls -l /tmp | grep something"},
                                       20000, "my_process_cb", "")
----

==== weechat_hook_connect

Accrocher une connexion (connexion à une machine distante en tâche de fond).

Prototype :

[source,C]
----
struct t_hook *weechat_hook_connect (const char *proxy,
                                     const char *address,
                                     int port,
                                     int ipv6,
                                     int retry,
                                     void *gnutls_sess,
                                     void *gnutls_cb,
                                     int gnutls_dhkey_size,
                                     const char *gnutls_priorities,
                                     const char *local_hostname,
                                     int (*callback)(void *data,
                                                     int status,
                                                     int gnutls_rc,
                                                     int sock,
                                                     const char *error,
                                                     const char *ip_address),
                                     void *callback_data);
----

Paramètres :

* 'proxy' : nom du proxy à utiliser pour la connexion (optionnel, NULL signifie
  une connexion sans proxy)
* 'address' : nom ou adresse IP de la machine à laquelle se connecter
* 'port' : numéro de port
* 'ipv6' : 1 pour utiliser IPv6 (avec repli sur IPv4), 0 pour utiliser seulement
  IPv4
* 'retry' : numéro de nouvelle tentative, utilisé pour se rabattre sur les
  adresses IPv4 si la connexion IPv6 échoue
* 'gnutls_sess' : session GnuTLS (optionnel)
* 'gnutls_cb' : callback pour GnuTLS (optionnel)
* 'gnutls_dhkey_size' : taille de clé utilisée pour l'échange de clé
  Diffie-Hellman (GnuTLS)
* 'gnutls_priorities' : priorités pour gnutls (pour la syntaxe, voir la
  documentation de la fonction 'gnutls_priority_init' dans le manuel gnutls),
  les valeurs de base sont :
** 'PERFORMANCE'
** 'NORMAL' (défaut)
** 'SECURE128'
** 'SECURE256'
** 'EXPORT'
** 'NONE'
* 'local_hostname' : nom de machine local à utiliser pour la connexion
  (optionnel)
* 'callback' : fonction appelée lorsque la connexion est ok ou a échoué,
  paramètres et valeur de retour :
** 'void *data' : pointeur
** 'int status' : statut de connexion :
*** 'WEECHAT_HOOK_CONNECT_OK' : connexion ok
*** 'WEECHAT_HOOK_CONNECT_ADDRESS_NOT_FOUND' : adresse non trouvée
*** 'WEECHAT_HOOK_CONNECT_IP_ADDRESS_NOT_FOUND' : adresse IP non trouvée
*** 'WEECHAT_HOOK_CONNECT_CONNECTION_REFUSED' : connexion refusée
*** 'WEECHAT_HOOK_CONNECT_PROXY_ERROR' : erreur avec le proxy
*** 'WEECHAT_HOOK_CONNECT_LOCAL_HOSTNAME_ERROR' : erreur avec le nom local
*** 'WEECHAT_HOOK_CONNECT_GNUTLS_INIT_ERROR' : erreur d'initialisation GnuTLS
*** 'WEECHAT_HOOK_CONNECT_GNUTLS_HANDSHAKE_ERROR' : erreur avec la
    "poignée de main" GnuTLS
*** 'WEECHAT_HOOK_CONNECT_MEMORY_ERROR' : mémoire insuffisante
*** 'WEECHAT_HOOK_CONNECT_TIMEOUT' : temps maximum dépassé
*** 'WEECHAT_HOOK_CONNECT_SOCKET_ERROR' : erreur de création socket
** 'gnutls_rc' : valeur retour de 'gnutls_handshake()'
** 'sock' : socket utilisé pour la connexion
** 'const char *error' : valeur retour de 'gnutls_strerror(gnutls_rc)'
** 'const char *ip_address' : adresse IP trouvée
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----
int
my_connect_cb (void *data, int status, int gnutls_rc, int sock,
               const char *error, const char *ip_address)
{
    switch (status)
    {
        case WEECHAT_HOOK_CONNECT_OK:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_ADDRESS_NOT_FOUND:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_IP_ADDRESS_NOT_FOUND:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_CONNECTION_REFUSED:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_PROXY_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_LOCAL_HOSTNAME_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_GNUTLS_INIT_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_GNUTLS_HANDSHAKE_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_MEMORY_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_TIMEOUT:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_SOCKET_ERROR:
            /* ... */
            break;
    }
    return WEECHAT_RC_OK;
}

struct t_hook *my_connect_hook = weechat_hook_connect (NULL,
                                                       "my.server.org", 1234,
                                                       1, 0,
                                                       NULL, NULL, 0,  /* GnuTLS */
                                                       NULL,
                                                       &my_connect_cb, NULL);
----

Script (Python) :

[source,python]
----
# prototype
hook = weechat.hook_connect(proxy, address, port, ipv6, retry, local_hostname,
    callback, callback_data)

# exemple
def my_connect_cb(data, status, gnutls_rc, sock, error, ip_address):
    if status == WEECHAT_HOOK_CONNECT_OK:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_ADDRESS_NOT_FOUND:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_IP_ADDRESS_NOT_FOUND:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_CONNECTION_REFUSED:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_PROXY_ERROR:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_LOCAL_HOSTNAME_ERROR:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_GNUTLS_INIT_ERROR:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_GNUTLS_HANDSHAKE_ERROR:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_MEMORY_ERROR:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_TIMEOUT:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_SOCKET_ERROR:
        # ...
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_connect("", "my.server.org", 1234, 1, 0, "",
                            "my_connect_cb", "")
----

==== weechat_hook_print

_Mis à jour dans la 0.4.3 et 1.0._

Intercepter un message affiché.

Prototype :

[source,C]
----
struct t_hook *weechat_hook_print (struct t_gui_buffer *buffer,
                                   const char *tags,
                                   const char *message,
                                   int strip_colors,
                                   int (*callback)(void *data,
                                                   struct t_gui_buffer *buffer,
                                                   time_t date,
                                                   int tags_count,
                                                   const char **tags,
                                                   int displayed,
                                                   int highlight,
                                                   const char *prefix,
                                                   const char *message),
                                   void *callback_data);
----

Paramètres :

* 'buffer' : pointeur vers le tampon, si NULL, les messages de tous les tampons
  sont interceptés
* 'tags' : intercepter seulement les messages avec ces étiquettes (optionnel) :
** avec WeeChat ≥ 0.4.3 : liste d'étiquettes (séparées par des virgules) qui
   doivent être dans le message ("ou" logique); il est possible de combiner
   plusieurs étiquettes sous forme d'un "et" logique avec le séparateur "+";
   le caractère joker "*" est autorisé dans les étiquettes
** avec WeeChat ≤ 0.4.2 : liste d'étiquettes (séparées par des virgules) qui
   doivent toutes être dans le message ("et" logique)
* 'message' : seulement les messages contenant cette chaîne seront interceptés
  (optionnel, insensible à la casse)
* 'strip_colors' : si 1, les couleurs seront supprimées du message affiché,
  avant d'appeler le "callback"
* 'callback' : fonction appelée lorsqu'un message est affiché, paramètres et
  valeur de retour :
** 'void *data' : pointeur
** 'struct t_gui_buffer *buffer' : pointeur vers le tampon
** 'time_t date' : date
** 'int tags_count' : nombre d'étiquettes de la ligne
** 'const char **tags' : tableau avec les étiquettes de la ligne
** 'int displayed' : 1 si la ligne est affichée, 0 si elle est filtrée (cachée)
** 'int highlight' : 1 si la ligne contient un highlight, sinon 0
** 'const char *prefix' : préfixe
** 'const char *message' : message
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

[IMPORTANT]
Dans les scripts, avec WeeChat ≥ 1.0, les paramètres du callback 'displayed' et
'highlight' sont des entiers (avec WeeChat ≤ 0.4.3, ils étaient des chaînes). +
Pour être compatible avec toutes les versions, il est recommandé de convertir
le paramètre en entier avant de le tester, par exemple en Python :
"`if int(highlight):`".

Exemple en C :

[source,C]
----
int
my_print_cb (void *data, struct t_gui_buffer *buffer, time_t date,
             int tags_count, const char **tags,
             int displayed, int highlight,
             const char *prefix, const char *message)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* intercepter tous les messages, de tous les tampons, sans couleur */
struct t_hook *my_print_hook =
    weechat_hook_print (NULL, NULL, NULL, 1, &my_print_cb, NULL);
----

Script (Python) :

[source,python]
----
# prototype
hook = weechat.hook_print(buffer, tags, message, strip_colors, callback, callback_data)

# exemple
def my_print_cb(data, buffer, date, tags, displayed, highlight, prefix, message):
    if int(highlight):
        # ...
    return weechat.WEECHAT_RC_OK

# intercepter tous les messages, de tous les tampons, sans couleur
hook = weechat.hook_print("", "", "", 1, "my_print_cb", "")
----

==== weechat_hook_signal

S'accrocher à un signal.

Prototype :

[source,C]
----
struct t_hook *weechat_hook_signal (const char *signal,
                                    int (*callback)(void *data,
                                                    const char *signal,
                                                    const char *type_data,
                                                    void *signal_data),
                                    void *callback_data);
----

Paramètres :

* 'signal' : signal à intercepter, le caractère joker "*" est autorisé
  (priorité autorisée, voir la note sur la <<hook_priority,priorité>>)
  (voir le tableau ci-dessous)
* 'callback' : fonction appelée quand le signal est reçu, paramètres et valeur
  de retour :
** 'void *data' : pointeur
** 'const char *signal' : signal reçu
** 'const char *type_data' : type de donnée reçu avec le signal :
*** 'WEECHAT_HOOK_SIGNAL_STRING' : chaîne de caractères
*** 'WEECHAT_HOOK_SIGNAL_INT' : nombre entier
*** 'WEECHAT_HOOK_SIGNAL_POINTER' : pointeur
** 'void *signal_data' : données envoyées avec le signal
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_OK_EAT' (arrêter l'envoi du signal immédiatement)
    _(WeeChat ≥ 0.4.0)_
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Liste des signaux envoyés par WeeChat et les extensions :

[width="100%",cols="^1,^3,^4,5",options="header"]
|===
| Extension | Signal | Paramètres | Description

| aspell | aspell_suggest +
  _(WeeChat ≥ 0.4.0)_ |
  Pointeur : tampon |
  Nouvelles suggestions pour un mot mal orthographié

| guile | guile_script_loaded +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : chemin vers le script |
  Script scheme chargé

| guile | guile_script_unloaded +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : chemin vers le script |
  Script scheme déchargé

| guile | guile_script_installed +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : liste de chemins vers scripts installés (séparés par des virgules) |
  Script(s) scheme installé(s)

| guile | guile_script_removed +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : liste de scripts supprimés (séparés par des virgules) |
  Script(s) scheme supprimé(s)

| irc | xxx,irc_in_yyy ^(1)^ |
  Chaîne : message |
  Message IRC du serveur (avant utilisation par l'extension irc,
  signal envoyé uniquement si le message n'est *pas* ignoré)

| irc | xxx,irc_in2_yyy ^(1)^ |
  Chaîne : message |
  Message IRC du serveur (après utilisation par l'extension irc,
  signal envoyé uniquement si le message n'est *pas* ignoré)

| irc | xxx,irc_raw_in_yyy ^(1)^ +
  _(WeeChat ≥ 0.3.2)_ |
  Chaîne : message |
  Message IRC du serveur (avant utilisation par l'extension irc,
  signal envoyé même si le message est ignoré)

| irc | xxx,irc_raw_in2_yyy ^(1)^ +
  _(WeeChat ≥ 0.3.2)_ |
  Chaîne : message |
  Message IRC du serveur (après utilisation par l'extension irc,
  signal envoyé même si le message est ignoré)

| irc | xxx,irc_out1_yyy ^(1)^ +
  _(WeeChat ≥ 0.3.7)_ |
  Chaîne : message |
  Message IRC envoyé au serveur (avant découpage automatique pour tenir dans les
  512 octets)

| irc | xxx,irc_out_yyy ^(1)^ |
  Chaîne : message |
  Message IRC envoyé au serveur (après découpage automatique pour tenir dans les
  512 octets)

| irc | xxx,irc_outtags_yyy ^(1)^ +
  _(WeeChat ≥ 0.3.4)_ |
  Chaîne : étiquettes + ";" + message |
  Étiquettes + message IRC envoyé au serveur

| irc | irc_ctcp |
  Chaîne : message |
  CTCP reçu

| irc | irc_dcc |
  Chaîne : message |
  Nouveau DCC

| irc | irc_pv |
  Chaîne : message |
  Message privé reçu

| irc | irc_channel_opened |
  Pointeur : tampon |
  Canal ouvert

| irc | irc_pv_opened |
  Pointeur : tampon |
  Discussion privée ouverte

| irc | irc_server_opened +
  _(WeeChat ≥ 0.3.7)_ |
  Pointeur : tampon |
  Tampon du serveur ouvert

| irc | irc_server_connecting |
  Chaîne : nom du serveur |
  Connexion en cours au serveur

| irc | irc_server_connected |
  Chaîne : nom du serveur |
  Connecté au serveur

| irc | irc_server_disconnected |
  Chaîne : nom du serveur |
  Déconnecté du serveur

| irc | irc_ignore_removing |
  Pointeur : ignore |
  Suppression d'un ignore en cours

| irc | irc_ignore_removed |
  - |
  Ignore supprimé

| irc | irc_notify_join +
  _(WeeChat ≥ 0.3.8)_ |
  Chaîne : nom du serveur + "," + pseudo |
  Un pseudo dans la liste de notifications a rejoint le serveur

| irc | irc_notify_quit +
  _(WeeChat ≥ 0.3.8)_ |
  Chaîne : nom du serveur + "," + pseudo |
  Un pseudo dans la liste de notifications a quitté le serveur

| irc | irc_notify_away +
  _(WeeChat ≥ 0.3.8)_ |
  Chaîne : nom du serveur + "," + pseudo + "," + message d'absence |
  Un pseudo dans la liste de notifications est maintenant absent sur le serveur

| irc | irc_notify_still_away +
  _(WeeChat ≥ 0.3.8)_ |
  Chaîne : nom du serveur + "," + pseudo + "," + message d'absence |
  Un pseudo dans la liste de notifications est toujours absent sur le serveur
  (le message d'absence a changé)

| irc | irc_notify_back +
  _(WeeChat ≥ 0.3.8)_ |
  Chaîne : nom du serveur + "," + pseudo |
  Un pseudo dans la liste de notifications est de retour (statut d'absence
  supprimé)

| logger | logger_start |
  Pointeur : tampon |
  Démarrage de l'enregistrement sur disque pour le tampon

| logger | logger_stop |
  Pointeur : tampon |
  Fin de l'enregistrement sur disque pour le tampon

| logger | logger_backlog |
  Pointeur : tampon |
  Affichage du backlog pour le tampon

| lua | lua_script_loaded +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : chemin vers le script |
  Script lua chargé

| lua | lua_script_unloaded +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : chemin vers le script |
  Script lua déchargé

| lua | lua_script_installed +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : liste de chemins vers scripts installés (séparés par des virgules) |
  Script(s) lua installé(s)

| lua | lua_script_removed +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : liste de scripts supprimés (séparés par des virgules) |
  Script(s) lua supprimé(s)

| perl | perl_script_loaded +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : chemin vers le script |
  Script perl chargé

| perl | perl_script_unloaded +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : chemin vers le script |
  Script perl déchargé

| perl | perl_script_installed +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : liste de chemins vers scripts installés (séparés par des virgules) |
  Script(s) perl installé(s)

| perl | perl_script_removed +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : liste de scripts supprimés (séparés par des virgules) |
  Script(s) perl supprimé(s)

| python | python_script_loaded +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : chemin vers le script |
  Script python chargé

| python | python_script_unloaded +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : chemin vers le script |
  Script python déchargé

| python | python_script_installed +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : liste de chemins vers scripts installés (séparés par des virgules) |
  Script(s) python installé(s)

| python | python_script_removed +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : liste de scripts supprimés (séparés par des virgules) |
  Script(s) python supprimé(s)

| relay | relay_client_connecting +
  _(WeeChat ≥ 1.0)_ |
  Pointeur : client relay |
  Un client relay est en train de se connecter

| relay | relay_client_waiting_auth +
  _(WeeChat ≥ 1.0)_ |
  Pointeur : client relay |
  Attente de l'authentification d'un client relay

| relay | relay_client_auth_ok +
  _(WeeChat ≥ 1.0)_ |
  Pointeur : client relay |
  Authentification réussie d'un client relay

| relay | relay_client_connected +
  _(WeeChat ≥ 1.0)_ |
  Pointeur : client relay |
  Un client relay est connecté

| relay | relay_client_auth_failed +
  _(WeeChat ≥ 1.0)_ |
  Pointeur : client relay |
  L'authentification d'un client relay a échoué

| relay | relay_client_disconnected +
  _(WeeChat ≥ 1.0)_ |
  Pointeur : client relay |
  Un client relay est déconnecté

| ruby | ruby_script_loaded +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : chemin vers le script |
  Script ruby chargé

| ruby | ruby_script_unloaded +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : chemin vers le script |
  Script ruby déchargé

| ruby | ruby_script_installed +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : liste de chemins vers scripts installés (séparés par des virgules) |
  Script(s) ruby installé(s)

| ruby | ruby_script_removed +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : liste de scripts supprimés (séparés par des virgules) |
  Script(s) ruby supprimé(s)

| tcl | tcl_script_loaded +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : chemin vers le script |
  Script tcl chargé

| tcl | tcl_script_unloaded +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : chemin vers le script |
  Script tcl déchargé

| tcl | tcl_script_installed +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : liste de chemins vers scripts installés (séparés par des virgules) |
  Script(s) tcl installé(s)

| tcl | tcl_script_removed +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : liste de scripts supprimés (séparés par des virgules) |
  Script(s) tcl supprimé(s)

| weechat | buffer_opened |
  Pointeur : tampon |
  Tampon ouvert

| weechat | buffer_closing |
  Pointeur : tampon |
  Fermeture du tampon en cours

| weechat | buffer_closed |
  Pointeur : tampon |
  Tampon fermé

| weechat | buffer_cleared |
  Pointeur : tampon |
  Tampon vidé

| weechat | buffer_hidden |
  Pointeur : tampon |
  Tampon masqué

| weechat | buffer_unhidden |
  Pointeur : tampon |
  Tampon démasqué

| weechat | buffer_line_added +
  _(WeeChat ≥ 0.3.7)_ |
  Pointeur : ligne |
  Ligne ajoutée dans un tampon

| weechat | buffer_lines_hidden |
  Pointeur : tampon |
  Lignes cachées dans le tampon

| weechat | buffer_localvar_added |
  Pointeur : tampon |
  Variable locale ajoutée

| weechat | buffer_localvar_changed |
  Pointeur : tampon |
  Variable locale modifiée

| weechat | buffer_localvar_removed |
  Pointeur : tampon |
  Variable locale supprimée

| weechat | buffer_merged |
  Pointeur : tampon |
  Tampon mélangé

| weechat | buffer_unmerged |
  Pointeur : tampon |
  Le tampon n'est plus mélangé

| weechat | buffer_moved |
  Pointeur : tampon |
  Tampon déplacé

| weechat | buffer_renamed |
  Pointeur : tampon |
  Tampon renommé

| weechat | buffer_switch |
  Pointeur : tampon |
  Basculement vers un autre tampon

| weechat | buffer_title_changed |
  Pointeur : tampon |
  Titre du tampon changé

| weechat | buffer_type_changed |
  Pointeur : tampon |
  Type de tampon changé

| weechat | buffer_zoomed +
  _(WeeChat ≥ 0.4.3)_ |
  Pointeur : tampon |
  Zoom sur un tampon mélangé

| weechat | buffer_unzoomed +
  _(WeeChat ≥ 0.4.3)_ |
  Pointeur : tampon |
  Fin du zoom sur un tampon mélangé

| weechat | day_changed +
  _(WeeChat ≥ 0.3.2)_ |
  Chaîne : nouvelle date, format : "2010-01-31" |
  Le jour de la date système a changé

| weechat | debug_dump |
  Chaîne : nom d'extension |
  Requête de "dump"

| weechat | debug_libs |
  - |
  Affichage des bibliothèques externes utilisées

| weechat | filter_added |
  Pointeur : filtre |
  Filtre ajouté

| weechat | filter_removing |
  Pointeur : filtre |
  Suppression de filtre en cours

| weechat | filter_removed |
  - |
  Filtre supprimé

| weechat | filters_enabled |
  - |
  Filtres activés

| weechat | filters_disabled |
  - |
  Filtres désactivés

| weechat | hotlist_changed |
  - |
  La hotlist a changé

| weechat | input_paste_pending |
  - |
  Coller de lignes en cours

| weechat | input_search |
  Pointeur : tampon |
  Recherche de texte dans le tampon

| weechat | input_text_changed |
  Pointeur : tampon |
  Texte modifié dans la barre "input"

| weechat | input_text_cursor_moved |
  Pointeur : tampon |
  Curseur déplacé dans la barre "input"

| weechat | key_bind |
  Chaîne : touche |
  Touche ajoutée

| weechat | key_unbind |
  Chaîne : touche |
  Touche supprimée

| weechat | key_pressed |
  Chaîne : touche appuyée |
  Touche appuyée

| weechat | key_combo_default +
  _(WeeChat ≥ 1.0)_ |
  Chaîne : combinaison de touches |
  Combinaison de touches dans le contexte 'default'

| weechat | key_combo_search +
  _(WeeChat ≥ 1.0)_ |
  Chaîne : combinaison de touches |
  Combinaison de touches dans le contexte 'search'

| weechat | key_combo_cursor +
  _(WeeChat ≥ 1.0)_ |
  Chaîne : combinaison de touches |
  Combinaison de touches dans le contexte 'cursor'

| weechat | mouse_enabled +
  _(WeeChat ≥ 1.1)_ |
  - |
  Souris activée

| weechat | mouse_disabled +
  _(WeeChat ≥ 1.1)_ |
  - |
  Souris désactivée

| weechat | nicklist_group_added +
  _(WeeChat ≥ 0.3.2)_ |
  Chaîne : pointeur tampon + "," + nom du groupe |
  Groupe ajouté dans la liste des pseudos

| weechat | nicklist_group_changed +
  _(WeeChat ≥ 0.3.4)_ |
  Chaîne : pointeur tampon + "," + nom du groupe |
  Groupe modifié dans la liste des pseudos

| weechat | nicklist_group_removing +
  _(WeeChat ≥ 0.4.1)_ |
  Chaîne : pointeur tampon + "," + nom du groupe |
  Suppression du groupe de la liste des pseudos

| weechat | nicklist_group_removed +
  _(WeeChat ≥ 0.3.2)_ |
  Chaîne : pointeur tampon + "," + nom du groupe |
  Groupe supprimé de la liste des pseudos

| weechat | nicklist_nick_added +
  _(WeeChat ≥ 0.3.2)_ |
  Chaîne : pointeur tampon + "," + pseudo |
  Pseudo ajouté dans la liste des pseudos

| weechat | nicklist_nick_changed +
  _(WeeChat ≥ 0.3.4)_ |
  Chaîne : pointeur tampon + "," + pseudo |
  Pseudo modifié dans la liste des pseudos

| weechat | nicklist_nick_removing +
  _(WeeChat ≥ 0.4.1)_ |
  Chaîne : pointeur tampon + "," + pseudo |
  Suppression du pseudo de la liste des pseudos

| weechat | nicklist_nick_removed +
  _(WeeChat ≥ 0.3.2)_ |
  Chaîne : pointeur tampon + "," + pseudo |
  Pseudo supprimé de la liste des pseudos

| weechat | partial_completion |
  - |
  Une complétion partielle a été faite

| weechat | plugin_loaded +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : chemin vers l'extension chargée |
  Extension chargée

| weechat | plugin_unloaded +
  _(WeeChat ≥ 0.3.9)_ |
  Chaîne : nom de l'extension déchargée (exemple : "irc") |
  Extension déchargée

| weechat | quit |
  Chaîne : paramètres pour le /quit |
  La commande `/quit` a été exécutée par l'utilisateur

| weechat | signal_sigwinch +
  _(WeeChat ≥ 0.4.3)_ |
  - |
  Signal SIGWINCH reçu (le terminal a été redimensionné)

| weechat | upgrade |
  Chaîne : "quit" si le paramètre "-quit" a été donné pour /upgrade, sinon NULL |
  La commande `/upgrade` a été exécutée par l'utilisateur

| weechat | upgrade_ended +
  _(WeeChat ≥ 0.3.4)_ |
  - |
  Fin du processus de mise à jour (commande `/upgrade`)

| weechat | weechat_highlight |
  Chaîne : message avec le préfixe |
  Un highlight est survenu

| weechat | weechat_pv |
  Chaîne : message avec le préfixe |
  Un message privé a été affiché

| weechat | window_closing +
  _(WeeChat ≥ 0.3.6)_ |
  Pointeur : fenêtre |
  Fermeture de la fenêtre en cours

| weechat | window_closed +
  _(WeeChat ≥ 0.3.6)_ |
  Pointeur : fenêtre |
  Fenêtre fermée

| weechat | window_opened +
  _(WeeChat ≥ 0.4.1)_ |
  Pointeur : fenêtre |
  Fenêtre ouverte

| weechat | window_scrolled |
  Pointeur : fenêtre |
  Défilement dans la fenêtre

| weechat | window_switch +
  _(WeeChat ≥ 0.3.7)_ |
  Pointeur : fenêtre |
  Basculement vers une autre fenêtre

| weechat | window_zoom |
  Pointeur : fenêtre courante |
  Zoom en cours sur la fenêtre

| weechat | window_zoomed |
  Pointeur : fenêtre courante |
  Zoom effectué sur la fenêtre

| weechat | window_unzoom |
  Pointeur : fenêtre courante |
  Fin du zoom en cours sur la fenêtre

| weechat | window_unzoomed |
  Pointeur : fenêtre courante |
  Fin du zoom effectué sur la fenêtre

| xfer | xfer_add |
  Pointeur : infolist avec l'info xfer |
  Nouveau xfer

| xfer | xfer_send_ready |
  Pointeur : infolist avec l'info xfer |
  Xfer prêt

| xfer | xfer_accept_resume |
  Pointeur : infolist avec l'info xfer |
  Accepter la reprise xfer

| xfer | xfer_send_accept_resume |
  Pointeur : infolist avec l'info xfer |
  Reprise xfer acceptée

| xfer | xfer_start_resume |
  Pointeur : infolist avec l'info xfer |
  Redémarrage

| xfer | xfer_resume_ready |
  Pointer : infolist avec l'info xfer |
  Redémarrage prêt

| xfer | xfer_ended +
  _(WeeChat ≥ 0.3.2)_ |
  Pointer : infolist avec l'info xfer |
  Le xfer s'est terminé
|===

[NOTE]
^(1)^ 'xxx' est le nom du serveur IRC, 'yyy' est le nom d'une commande IRC.

Exemple en C :

[source,C]
----
int
my_signal_cb (void *data, const char *signal, const char *type_data,
              void *signal_data)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* intercepter le signal "quit" */
struct t_hook *my_signal_hook = weechat_hook_signal ("quit",
                                                     &my_signal_cb, NULL);
----

Script (Python) :

[source,python]
----
# prototype
hook = weechat.hook_signal(signal, callback, callback_data)

# exemple
def my_signal_cb(data, signal, signal_data):
    # ...
    return weechat.WEECHAT_RC_OK

# intercepter le signal "quit"
hook = weechat.hook_signal("quit", "my_signal_cb", "")
----

==== weechat_hook_signal_send

_Mis à jour dans la 1.0._

Envoyer un signal.

Prototype :

[source,C]
----
int weechat_hook_signal_send (const char *signal, const char *type_data,
                              void *signal_data);
----

Paramètres :

* 'signal' : signal à envoyer
* 'type_data' : type de données à envoyer avec le signal (voir
  <<_weechat_hook_signal,weechat_hook_signal>>)
* 'signal_data' : données envoyées avec le signal

Valeur de retour _(WeeChat ≥ 1.0)_ :

* code retour du dernier "callback" exécuté ('WEECHAT_RC_OK' si aucun "callback"
  n'a été exécuté) :
** 'WEECHAT_RC_OK'
** 'WEECHAT_RC_OK_EAT'
** 'WEECHAT_RC_ERROR'

Exemple en C :

[source,C]
----
int rc = weechat_hook_signal_send ("mon_signal", WEECHAT_HOOK_SIGNAL_STRING, ma_chaine);
----

Script (Python) :

[source,python]
----
# prototype
rc = weechat.hook_signal_send(signal, type_data, signal_data)

# exemple
rc = weechat.hook_signal_send("mon_signal", weechat.WEECHAT_HOOK_SIGNAL_STRING, ma_chaine)
----

[[signal_logger_backlog]]
===== Signal logger_backlog

Le signal "logger_backlog" peut être envoyé pour afficher l'historique de
discussion dans le tampon (par exemple si vous ouvrez votre propre tampon dans
votre extension/script).

Le paramètre est un pointeur vers le tampon.

Exemple en C :

[source,C]
----
weechat_hook_signal_send ("logger_backlog", WEECHAT_HOOK_SIGNAL_POINTER, buffer);
----

Script (Python) :

[source,python]
----
weechat.hook_signal_send("logger_backlog", weechat.WEECHAT_HOOK_SIGNAL_POINTER, buffer)
----

[[signals_xxx_script_install]]
===== Signaux xxx_script_install

Cinq signaux peuvent être envoyés pour installer un script, selon le langage :

* 'perl_script_install'
* 'python_script_install'
* 'ruby_script_install'
* 'lua_script_install'
* 'tcl_script_install'

Le "callback" effectuera les actions suivantes lorsqu'il recevra le signal :

. déchargement et suppression du script installé
. déplacement du nouveau script vers le répertoire '~/.weechat/xxx/' (où 'xxx'
  est le langage)
. création d'un lien vers le nouveau script dans le répertoire
  '~/.weechat/xxx/autoload/'
. chargement du nouveau script

Ces signaux sont utilisés par l'extension 'script' pour installer des scripts.

Le paramètre est une chaîne avec le chemin vers le script à installer.

Exemple en C :

[source,C]
----
weechat_hook_signal_send ("python_script_install", WEECHAT_HOOK_SIGNAL_STRING,
                          "/home/xxx/.weechat/test.py");
----

Script (Python) :

[source,python]
----
weechat.hook_signal_send("python_script_install", WEECHAT_HOOK_SIGNAL_STRING,
                         "/home/xxx/.weechat/test.py")
----

[[signals_xxx_script_remove]]
===== Signaux xxx_script_remove

Cinq signaux peuvent être envoyés pour supprimer une liste de scripts, selon le
langage :

* 'perl_script_remove'
* 'python_script_remove'
* 'ruby_script_remove'
* 'lua_script_remove'
* 'tcl_script_remove'

Pour chaque script dans la liste, le "callback" déchargera et supprimera le
script.

Ces signaux sont utilisés par l'extension 'script' pour supprimer des scripts.

Le paramètre est une chaîne avec une liste de scripts à supprimer (séparés par
des virgules, nom du script sans le chemin, par exemple 'script.py').

Exemple en C :

[source,C]
----
/* décharge et supprime les scripts test.py et script.py */
weechat_hook_signal_send ("python_script_remove", WEECHAT_HOOK_SIGNAL_STRING,
                          "test.py,script.py");
----

Script (Python) :

[source,python]
----
# décharge et supprime les scripts test.py et script.py
weechat.hook_signal_send("python_script_remove", WEECHAT_HOOK_SIGNAL_STRING,
                         "test.py,script.py")
----

[[signal_irc_input_send]]
===== Signal irc_input_send

_WeeChat ≥ 0.3.4._

Le signal "irc_input_send" peut être envoyé pour simuler une entrée de texte
dans un tampon irc (serveur, canal ou privé).

Le paramètre est une chaîne avec le format suivant :

* nom interne du serveur (requis)
* point-virgule
* nom de canal (optionnel)
* point-virgule
* drapeaux utilisés lors de l'envoi du message (optionnel, 1 par
  défaut) :
** '1' : file d'attente avec haute priorité (comme les messages utilisateur)
** '2' : file d'attente avec basse priorité (comme les messages envoyés
   automatiquement par WeeChat)
* point-virgule
* liste d'étiquettes (séparées par des virgules) utilisées lors de l'envoi du
  message (optionnel)
* point-virgule
* texte ou commande (requis)

Exemples en C :

[source,C]
----
/* dis "Bonjour !" sur le serveur freenode, canal #weechat */
weechat_hook_signal_send ("irc_input_send", WEECHAT_HOOK_SIGNAL_STRING,
                          "freenode;#weechat;1;;Bonjour !");

/* envoie la commande "/whois FlashCode" sur le canal freenode, en basse priorité */
weechat_hook_signal_send ("irc_input_send", WEECHAT_HOOK_SIGNAL_STRING,
                          "freenode;;2;;/whois FlashCode");
----

Script (Python) :

[source,python]
----
# dis "Bonjour !" sur le serveur freenode, canal #weechat
weechat.hook_signal_send("irc_input_send", weechat.WEECHAT_HOOK_SIGNAL_STRING,
                         "freenode;#weechat;1;;Bonjour !")

# envoie la commande "/whois FlashCode" sur le canal freenode, en basse priorité
weechat.hook_signal_send("irc_input_send", weechat.WEECHAT_HOOK_SIGNAL_STRING,
                         "freenode;;2;;/whois FlashCode")
----

==== weechat_hook_hsignal

_WeeChat ≥ 0.3.4._

S'accrocher à un hsignal (signal avec une table de hachage).

Prototype :

[source,C]
----
struct t_hook *weechat_hook_hsignal (const char *signal,
                                     int (*callback)(void *data,
                                                     const char *signal,
                                                     struct t_hashtable *hashtable),
                                     void *callback_data);
----

Paramètres :

* 'signal' : signal à intercepter, le caractère joker "*" est autorisé
  (priorité autorisée, voir la note sur la <<hook_priority,priorité>>)
  (voir le tableau ci-dessous)
* 'callback' : fonction appelée quand le signal est reçu, paramètres et valeur
  de retour :
** 'void *data' : pointeur
** 'const char *signal' : signal reçu
** 'struct t_hashtable *hashtable' : table de hachage
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_OK_EAT' (arrêter l'envoi du signal immédiatement)
    _(WeeChat ≥ 0.4.0)_
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Liste des hsignaux envoyés par WeeChat et les extensions :

[width="100%",cols="^1,^3,5,5",options="header"]
|===
| Extension | Signal | Paramètres | Description

| irc | irc_redirection_xxx_yyy ^(1)^ +
  _(WeeChat ≥ 0.3.4)_ |
  Voir <<hsignal_irc_redirect_command,hsignal_irc_redirect_command>> |
  Sortie de la redirection

| weechat | nicklist_group_added +
  _(WeeChat ≥ 0.4.1)_ |
  'buffer' ('struct t_gui_buffer *') : tampon +
  'parent_group' ('struct t_gui_nick_group *') : groupe parent +
  'group' ('struct t_gui_nick_group *') : groupe |
  Groupe ajouté dans la liste de pseudos

| weechat | nicklist_nick_added +
  _(WeeChat ≥ 0.4.1)_ |
  'buffer' ('struct t_gui_buffer *') : tampon +
  'parent_group' ('struct t_gui_nick_group *') : groupe parent +
  'nick' ('struct t_gui_nick *') : pseudo |
  Pseudo ajouté dans la liste de pseudos

| weechat | nicklist_group_removing +
  _(WeeChat ≥ 0.4.1)_ |
  'buffer' ('struct t_gui_buffer *') : tampon +
  'parent_group' ('struct t_gui_nick_group *') : groupe parent +
  'group' ('struct t_gui_nick_group *') : groupe |
  Suppression d'un groupe de la liste de pseudos

| weechat | nicklist_nick_removing +
  _(WeeChat ≥ 0.4.1)_ |
  'buffer' ('struct t_gui_buffer *') : tampon +
  'parent_group' ('struct t_gui_nick_group *') : groupe parent +
  'nick' ('struct t_gui_nick *') : pseudo |
  Suppression d'un pseudo de la liste de pseudos

| weechat | nicklist_group_changed +
  _(WeeChat ≥ 0.4.1)_ |
  'buffer' ('struct t_gui_buffer *') : tampon +
  'parent_group' ('struct t_gui_nick_group *') : groupe parent +
  'group' ('struct t_gui_nick_group *') : groupe |
  Groupe changé dans la liste de pseudos

| weechat | nicklist_nick_changed +
  _(WeeChat ≥ 0.4.1)_ |
  'buffer' ('struct t_gui_buffer *') : tampon +
  'parent_group' ('struct t_gui_nick_group *') : parent +
  'nick' ('struct t_gui_nick *') : pseudo |
  Pseudo changé dans la liste de pseudos
|===

[NOTE]
^(1)^ 'xxx' est l'argument "signal" utilisé dans la redirection, 'yyy' est le
modèle de redirection ("pattern").

Exemple en C :

[source,C]
----
int
my_hsignal_cb (void *data, const char *signal, struct t_hashtable *hashtable)
{
    /* ... */
    return WEECHAT_RC_OK;
}

struct t_hook *my_hsignal_hook = weechat_hook_hsignal ("test",
                                                       &my_hsignal_cb, NULL);
----

Script (Python) :

[source,python]
----
# prototype
hook = weechat.hook_hsignal(signal, callback, callback_data)

# exemple
def my_hsignal_cb(data, signal, hashtable):
    # ...
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_hsignal("test", "my_hsignal_cb", "")
----

==== weechat_hook_hsignal_send

_WeeChat ≥ 0.3.4, mis à jour dans la 1.0._

Envoyer un hsignal (signal avec table de hachage).

Prototype :

[source,C]
----
int weechat_hook_hsignal_send (const char *signal, struct t_hashtable *hashtable);
----

Paramètres :

* 'signal' : signal à envoyer
* 'hashtable' : table de hachage

Valeur de retour _(WeeChat ≥ 1.0)_ :

* code retour du dernier "callback" exécuté ('WEECHAT_RC_OK' si aucun "callback"
  n'a été exécuté) :
** 'WEECHAT_RC_OK'
** 'WEECHAT_RC_OK_EAT'
** 'WEECHAT_RC_ERROR'

Exemple en C :

[source,C]
----
int rc;
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
if (hashtable)
{
    weechat_hashtable_set (hashtable, "clé", "valeur");
    rc = weechat_hook_hsignal_send ("my_hsignal", hashtable);
    weechat_hashtable_free (hashtable);
}
----

Script (Python) :

[source,python]
----
# prototype
rc = weechat.hook_hsignal_send(signal, hashtable)

# exemple
rc = weechat.hook_hsignal_send("my_hsignal", {"clé": "valeur"})
----

[[hsignal_irc_redirect_command]]
===== Hsignal irc_redirect_command

_WeeChat ≥ 0.3.4._

Le hsignal "irc_redirect_command" peut être envoyé pour rediriger la sortie
d'une commande irc vers un "callback".

Le paramètre est une table de hachage avec les entrées suivantes (les clés et
valeurs sont des chaînes) :

* 'server' : nom interne du serveur (requis)
* 'pattern' : modèle de redirection à utiliser (requis), soit un par défaut
  (défini par l'extension irc), ou un modèle utilisateur (voir
  <<hsignal_irc_redirect_pattern>>), les modèles par défaut sont :
** 'ison'
** 'list'
** 'mode_channel'
** 'mode_channel_ban' ("mode #channel b")
** 'mode_channel_ban_exception' ("mode #channel e")
** 'mode_channel_invite' ("mode #channel I")
** 'mode_user'
** 'monitor'
** 'names'
** 'ping'
** 'time'
** 'topic'
** 'userhost'
** 'who'
** 'whois'
** 'whowas'
* 'signal' : nom du signal (requis)
* 'count' : nombre de fois que la redirection sera exécutée (optionnel, 1 par
  défaut)
* 'string' : chaîne qui doit être dans les messages irc reçus (optionnel, mais
  recommandé, si une chaîne peut être utilisée pour identifier les messages)
* 'timeout' : temps d'attente maximum pour la redirection, en secondes
  (optionnel, 60 par défaut)
* 'cmd_filter' : liste de commandes irc (séparées par des virgules) à filtrer
  (seules ces commandes seront transmises au "callback", les autres seront
  ignorées) (optionnel)

Immédiatement après l'envoi de ce hsignal, vous devez envoyer la commande au
serveur irc, et la redirection sera utilisée pour cette commande.

Lorsque la réponse complète à votre commande a été reçue, un hsignal est envoyé.
Ce hsignal a le nom 'irc_redirection_xxx_yyy' où 'xxx' est le 'signal' et 'yyy'
le 'pattern' utilisé.

La table de hachage envoyée dans le hsignal a le contenu suivant (les clés et
valeurs sont des chaînes) :

* 'output' : sortie de la commande (les messages sont séparés par "\n")
* 'output_size' : nombre d'octets dans 'output' (sous forme de chaîne)
* 'error' : chaîne d'erreur (si une erreur s'est produite) :
** 'timeout' : redirection stoppée après le délai maximum dépassé
* 'server' : nom interne du serveur
* 'pattern' : modèle de redirection
* 'signal' : nom du signal
* 'command' : commande redirigée

Exemple en C :

[source,C]
----
int
test_whois_cb (void *data, const char *signal, struct t_hashtable *hashtable)
{
    weechat_printf (NULL, "erreur = %s", weechat_hashtable_get (hashtable, "error"));
    weechat_printf (NULL, "sortie = %s", weechat_hashtable_get (hashtable, "output"));
    return WEECHAT_RC_OK;
}

weechat_hook_hsignal ("irc_redirection_test_whois", &test_whois_cb, NULL);
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
if (hashtable)
{
    weechat_hashtable_set (hashtable, "server", "freenode");
    weechat_hashtable_set (hashtable, "pattern", "whois");
    weechat_hashtable_set (hashtable, "signal", "test");
    weechat_hashtable_set (hashtable, "string", "FlashCode");
    weechat_hook_hsignal_send ("irc_redirect_command", hashtable);
    weechat_hook_signal_send ("irc_input_send", WEECHAT_HOOK_SIGNAL_STRING,
                              "freenode;;2;;/whois FlashCode");
    weechat_hashtable_free (hashtable);
}
----

Script (Python) :

[source,python]
----
def test_whois_cb(data, signal, hashtable):
    weechat.prnt("", "erreur = %s" % hashtable["error"])
    weechat.prnt("", "sortie = %s" % hashtable["output"])
    return weechat.WEECHAT_RC_OK

weechat.hook_hsignal ("irc_redirection_test_whois", "test_whois_cb", "")
weechat.hook_hsignal_send("irc_redirect_command",
                          {"server": "freenode", "pattern": "whois", "signal": "test",
                           "string": "FlashCode"})
weechat.hook_signal_send("irc_input_send", weechat.WEECHAT_HOOK_SIGNAL_STRING,
                         "freenode;;2;;/whois FlashCode")
----

[[hsignal_irc_redirect_pattern]]
===== Hsignal irc_redirect_pattern

_WeeChat ≥ 0.3.4._

Le hsignal "irc_redirect_pattern" peut être envoyé pour créer un modèle de
redirection irc (voir <<hsignal_irc_redirect_command>>).

Le paramètre est une table de hachage avec les entrées suivantes (les clés et
valeurs sont des chaînes) :

* 'pattern' : nom du modèle (requis)
* 'timeout' : temps d'attente maximum pour le modèle, en secondes (optionnel, 60
  par défaut)
* 'cmd_start' : liste de commandes (séparées par des virgules) démarrant la
  redirection (optionnel)
* 'cmd_stop' : liste de commandes (séparées par des virgules) stoppant la
  redirection (requis)
* 'cmd_extra' : liste de commandes (séparées par des virgules) pouvant être
  reçues après les commandes de stop (optionnel)

Pour chaque commande dans 'cmd_start', 'cmd_stop' et 'cmd_extra', il est
possible de donner un entier avec la position de la chaîne "string" qui doit
être trouvée dans le message reçu, par exemple :

----
352:1,354,401:1
----

Pour les commandes 352 et 401, la chaîne "string" doit être trouvée dans le
message reçu, comme premier paramètre.

[IMPORTANT]
Le modèle est détruit dès qu'il est utilisé dans une redirection. Si vous avez
besoin du modèle pour plusieurs redirections, vous devez créer un modèle pour
chaque redirection.

Exemple en C :

[source,C]
----
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
if (hashtable)
{
    weechat_hashtable_set (hashtable, "pattern", "my_whois");
    weechat_hashtable_set (hashtable, "timeout", "30");
    weechat_hashtable_set (hashtable, "cmd_start", "311:1");
    weechat_hashtable_set (hashtable, "cmd_stop", "318:1,401:1,402:1,431:1,461");
    weechat_hashtable_set (hashtable, "cmd_extra", "318:1");
    weechat_hook_hsignal_send ("irc_redirect_pattern", hashtable);
    /*
     * rediriger maintenant la commande irc whois avec le hsignal irc_redirect_command,
     * en utilisant le modèle "my_whois"
     */
    /* ... */
    weechat_hashtable_free (hashtable);
}
----

Script (Python) :

[source,python]
----
weechat.hook_hsignal_send("irc_redirect_pattern",
                          {"pattern": "my_whois", "timeout": "30",
                           "cmd_start": "311:1",
                           "cmd_stop": "318:1,401:1,402:1,431:1,461",
                           "cmd_extra": "318:1"})
# rediriger maintenant la commande irc whois avec le hsignal irc_redirect_command,
# en utilisant le modèle "my_whois"
# ...
----

==== weechat_hook_config

S'accrocher à une option de configuration.

Prototype :

[source,C]
----
struct t_hook *weechat_hook_config (const char *option,
                                    int (*callback)(void *data,
                                                    const char *option,
                                                    const char *value),
                                    void *callback_data);
----

Paramètres :

* 'option' : option, le format est le nom complet, celui utilisé avec la
  commande `/set` (par exemple : `weechat.look.item_time_format`), le caractère
  joker "*" est autorisé (priorité autorisée, voir la note sur la
  <<hook_priority,priorité>>)
* 'callback' : fonction appelée lorsque l'option de configuration est modifiée,
  paramètres et valeur de retour :
** 'void *data' : pointeur
** 'const char *option' : nom de l'option
** 'const char *value' : nouvelle valeur pour l'option
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----
int
my_config_cb (void *data, const char *option, const char *value)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* intercepter les changements de l'option "weechat.look.item_time_format" */
struct t_hook *my_config_hook = weechat_hook_config ("weechat.look.item_time_format",
                                                     &my_config_cb, NULL);
----

Script (Python) :

[source,python]
----
# prototype
hook = weechat.hook_config(option, callback, callback_data)

# exemple
def my_config_cb(data, option, value):
    # ...
    return weechat.WEECHAT_RC_OK

# intercepter les changements de l'option "weechat.look.item_time_format"
hook = weechat.hook_config("weechat.look.item_time_format", "my_config_cb", "")
----

==== weechat_hook_completion

Accrocher une complétion.

Prototype :

[source,C]
----
struct t_hook *weechat_hook_completion (const char *completion_item,
                                        const char *description,
                                        int (*callback)(void *data,
                                                        const char *completion_item,
                                                        struct t_gui_buffer *buffer,
                                                        struct t_gui_completion *completion),
                                        void *callback_data);
----

Paramètres :

* 'completion_item' : nom de l'objet de complétion, après vous pouvez utiliser
  '%(nom)' dans une commande (paramètre 'completion')
  (priorité autorisée, voir la note sur la <<hook_priority,priorité>>)
* 'description' : description de la complétion
* 'callback' : fonction appelée lorsque la complétion est utilisée
  (l'utilisateur est en train de compléter quelque chose qui fait appel à cette
  complétion), paramètres et valeur de retour :
** 'void *data' : pointeur
** 'const char *completion_item' : nom de la complétion
** 'struct t_gui_buffer *buffer' : tampon où la complétion est effectuée
** 'struct t_gui_completion *completion' : structure utilisée pour ajouter
   les mots pour la complétion (voir
   <<_weechat_hook_completion_list_add,weechat_hook_completion_list_add>>)
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

[NOTE]
Les noms de complétion sont globaux (partagés entre WeeChat et les extensions).
Il est donc recommandé de choisir un nom avec un préfixe unique, comme
"monextension_xxx" (où "xxx" est le nom de votre complétion).

[IMPORTANT]
Le "callback" doit seulement appeler la fonction
<<_weechat_hook_completion_list_add,weechat_hook_completion_list_add>>
et ne doit *PAS* mettre à jour la ligne de commande. +
Pour mettre à jour la ligne de commande quand key[Tab] est pressé, vous pouvez
utiliser la fonction <<_weechat_hook_command_run,weechat_hook_command_run>>
avec la commande : "/input complete_next" (et vous devez retourner
'WEECHAT_RC_OK_EAT' si votre "callback" a mis à jour la ligne de commande, de
sorte que WeeChat n'exécute pas la complétion).

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----
int
my_completion_cb (void *data, const char *completion_item,
                  struct t_gui_buffer *buffer,
                  struct t_gui_completion *completion)
{
    weechat_hook_completion_list_add (completion, "mot1",
                                      0, WEECHAT_LIST_POS_SORT);
    weechat_hook_completion_list_add (completion, "test_mot2",
                                      0, WEECHAT_LIST_POS_SORT);
    return WEECHAT_RC_OK;
}

struct t_hook *my_completion_hook = weechat_hook_completion ("extension_item",
                                                             "ma complétion !",
                                                             &my_completion_cb, NULL);
----

Script (Python) :

[source,python]
----
# prototype
hook = weechat.hook_completion(completion_item, description, callback, callback_data)

# exemple
def my_completion_cb(data, completion_item, buffer, completion):
    weechat.hook_completion_list_add(completion, "mot1", 0, weechat.WEECHAT_LIST_POS_SORT)
    weechat.hook_completion_list_add(completion, "test_mot2", 0, weechat.WEECHAT_LIST_POS_SORT)
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_completion("extension_item", "ma complétion !",
                               "my_completion_cb", "")
----

==== weechat_hook_completion_get_string

_WeeChat ≥ 0.3.4._

Retourner la valeur d'une propriété de la complétion sous forme de chaîne.

Prototype :

[source,C]
----
const char *weechat_hook_completion_get_string (struct t_gui_completion *completion,
                                                const char *property);
----

Paramètres :

* 'completion' : pointeur vers la complétion
* 'property' : nom de la propriété :
** 'base_command' : commande utilisée pour la complétion
** 'base_word' : le mot qui va être complété
** 'args' : paramètres de la commande (incluant le mot de base "base_word")

Exemple en C :

[source,C]
----
int
my_completion_cb (void *data, const char *completion_item,
                  struct t_gui_buffer *buffer,
                  struct t_gui_completion *completion)
{
    /* récupère les paramètres de la commande */
    const char *args = weechat_hook_completion_get_string (completion, "args");

    /* complétion selon les paramètres */
    /* ... */

    return WEECHAT_RC_OK;
}
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.hook_completion_get_string(completion, property)

# exemple
def my_completion_cb(data, completion_item, buffer, completion):
    # récupère les paramètres de la commande
    args = weechat.hook_completion_get_string(completion, "args")
    # complétion selon les paramètres
    # ...
    return weechat.WEECHAT_RC_OK
----

==== weechat_hook_completion_list_add

Ajouter un mot pour une complétion.

Prototype :

[source,C]
----
void weechat_hook_completion_list_add (struct t_gui_completion *completion,
                                       const char *word,
                                       int nick_completion,
                                       const char *where);
----

Paramètres :

* 'completion' : pointeur vers la complétion
* 'word' : mot à ajouter
* 'nick_completion' : 1 si le mot est un pseudo, sinon 0
* 'where' : position où sera inséré le mot dans la liste :
** 'WEECHAT_LIST_POS_SORT' : n'importe où, pour maintenir la liste triée
** 'WEECHAT_LIST_POS_BEGINNING' : au début de la liste
** 'WEECHAT_LIST_POS_END' : à la fin de la liste

Exemple en C : voir <<_weechat_hook_completion,weechat_hook_completion>>.

Script (Python) :

[source,python]
----
# prototype
weechat.hook_completion_list_add(completion, word, nick_completion, where)

# exemple : voir la fonction hook_completion ci-dessus
----

==== weechat_hook_modifier

Accrocher un modificateur.

Prototype :

[source,C]
----
struct t_hook *weechat_hook_modifier (const char *modifier,
                                      char *(*callback)(void *data,
                                                        const char *modifier,
                                                        const char *modifier_data,
                                                        const char *string),
                                      void *callback_data);
----

Paramètres :

* 'modifier' : nom du modificateur, liste des modificateurs utilisés par WeeChat
  ou des extensions
  (priorité autorisée, voir la note sur la <<hook_priority,priorité>>)
  (voir le tableau ci-dessous)
* 'callback' : fonction appelée lorsque le modificateur est utilisé, paramètres
  et valeur de retour :
** 'void *data' : pointeur
** 'const char *modifier' : nom du modificateur
** 'const char *modifier_data' : données pour le modificateur
** 'const char *string' : chaîne à modifier
** valeur de retour : nouvelle chaîne
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Liste des modificateurs utilisés par WeeChat et les extensions :

[width="100%",cols="^2,3,4,4",options="header"]
|===
| Modificateur | Données du modificateur | Chaîne | Sortie

| charset_decode |
  extension.nom_tampon |
  Toute chaîne |
  Chaîne décodée depuis le jeu de caractères trouvé pour l'extension/tampon
  vers UTF-8

| charset_encode |
  extension.nom_tampon |
  Toute chaîne |
  Chaîne encodée depuis UTF-8 vers le jeu de caractères trouvé pour
  l'extension/tampon

| irc_color_decode |
  "1" pour garder les couleurs, "0" pour les supprimer |
  Toute chaîne |
  Chaîne avec les couleurs IRC converties en couleurs WeeChat (ou avec les
  couleurs IRC supprimées)

| irc_color_encode |
  "1" pour garder les couleurs, "0" pour les supprimer |
  Toute chaîne |
  Chaîne avec les couleurs IRC (ou avec les couleurs IRC supprimées)

| irc_color_decode_ansi +
  _(WeeChat ≥ 1.0)_ |
  "1" pour garder les couleurs, "0" pour les supprimer |
  Toute chaîne |
  Chaîne avec les couleurs ANSI converties en couleurs IRC (ou avec les couleurs
  ANSI supprimées)

| irc_command_auth +
  _(WeeChat ≥ 0.4.1)_ |
  Nom du serveur |
  Commande d'authentification (par exemple : `/msg nickserv identify password`) |
  Commande avec le mot de passe caché (par exemple : `/msg nickserv identify ********`)

| irc_message_auth +
  _(WeeChat ≥ 0.4.1)_ |
  Nom du serveur |
  Message affiché après `msg` envoyé à nickserv |
  Message avec le mot de passe caché

| irc_in_xxx ^(1)^ |
  Nom de serveur |
  Contenu du message reçu du serveur IRC (avant décodage du jeu de caractères) |
  Nouveau contenu du message

| irc_in2_xxx ^(1)^ +
  _(WeeChat ≥ 0.3.5)_ |
  Nom de serveur |
  Contenu du message reçu du serveur IRC (après décodage du jeu de caractères) |
  Nouveau contenu du message

| irc_out1_xxx ^(1)^ +
  _(WeeChat ≥ 0.3.7)_ |
  Nom de serveur |
  Contenu du message qui va être envoyé au serveur IRC (avant découpage
  automatique pour tenir dans les 512 octets) |
  Nouveau contenu du message

| irc_out_xxx ^(1)^ |
  Nom de serveur |
  Contenu du message qui va être envoyé au serveur IRC (après découpage
  automatique pour tenir dans les 512 octets) |
  Nouveau contenu du message

| color_decode_ansi +
  _(WeeChat ≥ 1.0)_ |
  "1" pour garder les couleurs, "0" pour les supprimer |
  Toute chaîne |
  Chaîne avec les couleurs ANSI converties en couleurs WeeChat (ou avec les
  couleurs ANSI supprimées)

| bar_condition_yyy ^(2)^ |
  Chaîne avec un pointeur vers la fenêtre ("0x123..") |
  Chaîne vide |
  "1" pour afficher la barre, "0" pour la cacher

| history_add +
  _(WeeChat ≥ 0.3.2)_ |
  Chaîne avec un pointeur vers le tampon ("0x123..") |
  Contenu de la ligne de commande à ajouter à l'historique des commandes
  (tampon et global) |
  Chaîne ajoutée à l'historique des commandes

| input_text_content |
  Chaîne avec un pointeur vers le tampon ("0x123..") |
  Contenu de la ligne de commande |
  Nouvelle chaîne pour la ligne de commande

| input_text_display |
  Chaîne avec un pointeur vers le tampon ("0x123..") |
  Contenu de la ligne de commande, sans le code du curseur dedans |
  Nouvelle chaîne, pour affichage seulement (la ligne de commande n'est pas
  modifiée)

| input_text_display_with_cursor |
  Chaîne avec un pointeur vers le tampon ("0x123..") |
  Contenu de la ligne de commande, avec le code du curseur dedans |
  Nouvelle chaîne, pour affichage seulement (la ligne de commande n'est pas
  modifiée)

| input_text_for_buffer +
  _(WeeChat ≥ 0.3.7)_ |
  Chaîne avec un pointeur vers le tampon ("0x123..") |
  Contenu de la ligne de commande envoyée au tampon (texte ou commande) |
  Nouveau contenu de la ligne de commande envoyée au tampon

| weechat_print |
  extension + ";" + nom_tampon + ";" + étiquettes |
  Message affiché |
  Nouveau message affiché
|===

[NOTE]
^(1)^ 'xxx' est un nom de commande IRC. +
^(2)^ 'yyy' est le nom de la barre.

Exemple en C :

[source,C]
----
char *
my_modifier_cb (void *data, const char *modifier,
                const char *modifier_data,
                const char *string)
{
    char *result;
    int length;

    if (!string)
        return NULL;

    length = strlen (string) + 5;
    result = malloc (length);
    if (result)
    {
        /* ajouter "xxx" à chaque message affiché */
        snprintf (result, length, "%s xxx", string);
    }

    return result;
}

struct t_hook *my_modifier_hook = weechat_hook_modifier ("weechat_print",
                                                         &my_modifier_cb, NULL);
----

Script (Python) :

[source,python]
----
# prototype
hook = weechat.hook_modifier(modifier, callback, callback_data)

# exemple
def my_modifier_cb(data, modifier, modifier_data, string):
    return "%s xxx" % string

hook = weechat.hook_modifier("weechat_print", "my_modifier_cb", "")
----

==== weechat_hook_modifier_exec

Exécuter un ou plusieurs modificateurs.

Prototype :

[source,C]
----
char *weechat_hook_modifier_exec (const char *modifier,
                                  const char *modifier_data,
                                  const char *string);
----

Paramètres :

* 'modifier' : nom du modificateur
* 'modifier_data' : données du modificateur
* 'string' : chaîne à modifier

Valeur de retour :

* chaîne modifiée, NULL en cas d'erreur

Exemple en C :

[source,C]
----
char *new_string = weechat_hook_modifier_exec ("mon_modifier",
                                               mes_donnees, ma_chaine);
----

Script (Python) :

[source,python]
----
# prototype
weechat.hook_modifier_exec(modifier, modifier_data, string)

# exemple
weechat.hook_modifier_exec("mon_modifier", mes_donnees, ma_chaine)
----

==== weechat_hook_info

Accrocher une information (le "callback" prend et retourne une chaîne).

Prototype :

[source,C]
----
struct t_hook *weechat_hook_info (const char *info_name,
                                  const char *description,
                                  const char *args_description,
                                  const char *(*callback)(void *data,
                                                          const char *info_name,
                                                          const char *arguments),
                                  void *callback_data);
----

Paramètres :

* 'info_name' : nom de l'information
  (priorité autorisée, voir la note sur la <<hook_priority,priorité>>)
* 'description' : description
* 'args_description' : description des paramètres (optionnel, peut être NULL)
* 'callback' : fonction appelée quand l'information est demandée, paramètres et
  valeur de retour :
** 'void *data' : pointeur
** 'const char *info_name' : nom de l'information
** 'const char *arguments' : paramètres additionnels, dépendant de
   l'information
** valeur de retour : valeur de l'information demandée
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----
const char *
my_info_cb (void *data, const char *info_name, const char *arguments)
{
    /* ... */
    return pointeur_vers_chaine;
}

/* ajoute l'information "mon_info" */
struct t_hook *my_info_hook = weechat_hook_info ("mon_info",
                                                 "Une information",
                                                 "Info sur les paramètres",
                                                 &my_info_cb, NULL);
----

Script (Python) :

[source,python]
----
# prototype
hook = weechat.hook_info(info_name, description, args_description,
                         callback, callback_data)

# exemple
def my_info_cb(data, info_name, arguments):
    return "some_info"

hook = weechat.hook_info("mon_info", "Une information", "Info sur les paramètres",
                         "my_info_cb", "")
----

==== weechat_hook_info_hashtable

_WeeChat ≥ 0.3.4._

Accrocher une information (le "callback" prend et retourne une table de
hachage).

Prototype :

[source,C]
----
struct t_hook *weechat_hook_info_hashtable (const char *info_name,
                                            const char *description,
                                            const char *args_description,
                                            const char *output_description,
                                            struct t_hashtable *(*callback)(void *data,
                                                                            const char *info_name,
                                                                            struct t_hashtable *hashtable),
                                            void *callback_data);
----

Paramètres :

* 'info_name' : nom de l'information
  (priorité autorisée, voir la note sur la <<hook_priority,priorité>>)
* 'description' : description
* 'args_description' : description de la table de hachage attendue
  (optionnel, peut être NULL)
* 'output_description' : description de la table de hachage retournée par le
  "callback" (optionnel, peut être NULL)
* 'callback' : fonction appelée quand l'information est demandée, paramètres et
  valeur de retour :
** 'void *data' : pointeur
** 'const char *info_name' : nom de l'information
** 'struct t_hashtable *hashtable' : table de hachage, dépendant de
   l'information
** valeur de retour : table de hachage demandée
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----
struct t_hashtable *
my_info_hashtable_cb (void *data, const char *info_name, struct t_hashtable *hashtable)
{
    /* ... */
    return pointer_vers_nouvelle_table_de_hachage;
}

/* ajoute l'information "mon_info_hashtable" */
struct t_hook *my_info_hook = weechat_hook_info_hashtable ("mon_info_hashtable",
                                                           "Une information",
                                                           "Info sur la table de hachage en entrée",
                                                           "Info sur la table de hachage en sortie",
                                                           &my_info_hashtable_cb, NULL);
----

Script (Python) :

[source,python]
----
# prototype
hook = weechat.hook_info_hashtable(info_name, description, args_description,
                                   output_description, callback, callback_data)

# exemple
def my_info_hashtable_cb(data, info_name, hashtable):
    return {"test_cle": "test_valeur"}

hook = weechat.hook_info_hashtable("mon_info_hashtable", "Une information",
                                   "Info sur la table de hachage en entrée",
                                   "Info sur la table de hachage en sortie",
                                   "my_info_hashtable_cb", "")
----

==== weechat_hook_infolist

Accrocher une infolist : le "callback" retournera un pointeur vers l'infolist
demandée.

Prototype :

[source,C]
----
struct t_hook *weechat_hook_infolist (const char *infolist_name,
                                      const char *description,
                                      const char *pointer_description,
                                      const char *args_description,
                                      struct t_infolist *(*callback)(void *data,
                                                                     const char *infolist_name,
                                                                     void *pointer,
                                                                     const char *arguments),
                                      void *callback_data);
----

Paramètres :

* 'infolist_name' : nom de l'infolist
  (priorité autorisée, voir la note sur la <<hook_priority,priorité>>)
* 'description' : description
* 'pointer_description' : description du pointeur (optionnel, peut être NULL)
* 'args_description' : description des paramètres (optionnel, peut être NULL)
* 'callback' : fonction appelée quand l'infolist est demandée, paramètres et
  valeur de retour :
** 'void *data' : pointeur
** 'const char *infolist_name' : nom de l'infolist
** 'void *pointer' : pointeur vers un objet que l'infolist doit retourner (pour
   obtenir uniquement cet objet dans l'infolist)
** 'const char *arguments' : paramètres additionnels, dépendant de l'infolist
** valeur de retour : infolist demandée
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----
struct t_infolist *
my_infolist_cb (void *data, const char *infolist_name, void *pointer,
                const char *arguments)
{
    struct t_infolist *mon_infolist;

    /* construction de l'infolist */
    /* ... */

    return mon_infolist;
}

/* ajoute l'infolist "mon_infolist" */
struct t_hook *my_infolist = weechat_hook_infolist ("mon_infolist",
                                                    "Mon infolist",
                                                    "Info sur le pointeur",
                                                    "Info sur les paramètres",
                                                    &my_infolist_cb, NULL);
----

Script (Python) :

[source,python]
----
# prototype
hook = weechat.hook_infolist(infolist_name, description, pointer_description,
                             args_description, callback, callback_data)

# exemple
def my_infolist_cb(data, infolist_name, pointer, arguments):
    # construction de l'infolist
    # ...
    return my_infolist

hook = weechat.hook_infolist("mon_infolist", "Mon infolist",
                             "Info sur le pointeur", "Info sur les paramètres",
                             "my_infolist_cb", "")
----

==== weechat_hook_hdata

Accrocher un hdata : le "callback" retournera un pointeur vers le hdata demandé.

Prototype :

[source,C]
----
struct t_hook *weechat_hook_hdata (const char *hdata_name,
                                   const char *description,
                                   struct t_hdata *(*callback)(void *data,
                                                               const char *hdata_name),
                                   void *callback_data);
----

Paramètres :

* 'hdata_name' : nom du hdata
  (priorité autorisée, voir la note sur la <<hook_priority,priorité>>)
* 'description' : description
* 'callback' : fonction appelée quand le hdata est demandé, paramètres et valeur
  de retour :
** 'void *data' : pointeur
** 'const char *hdata_name' : nom du hdata
** valeur de retour : hdata demandé
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----
struct t_hdata *
my_hdata_cb (void *data, const char *hdata_name)
{
    struct t_hdata *mon_hdata;

    /* construction du hdata */
    /* ... */

    return mon_hdata;
}

/* ajoute le hdata "mon_hdata" */
struct t_hook *my_hdata = weechat_hook_hdata ("mon_hdata",
                                              "Hdata pour ma structure",
                                              &my_hdata_cb, NULL);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_hook_focus

Accrocher un focus : évènement souris ou touche du clavier pressée dans le mode
"curseur" (mouvement libre du curseur).

Prototype :

[source,C]
----
struct t_hook *weechat_hook_focus (const char *area,
                                   struct t_hashtable *(*callback)(void *data,
                                                                   struct t_hashtable *info),
                                   void *callback_data);
----

Paramètres :

* 'area' : "chat" pour la zone de discussion, ou un nom d'objet de barre
  (priorité autorisée, voir la note sur la <<hook_priority,priorité>>)
* 'callback' : fonction appelée quand le focus est fait, paramètres et valeur de
  retour :
** 'void *data' : pointeur
** 'struct t_hashtable *info' : table de hachage avec les informations sur le
   focus et les chaînes retournées par les autres appels aux "callbacks" de
   focus (avec plus haute priorité) (voir le tableau ci-dessous)
** valeur de retour : soit le pointeur vers la table de hachage "info" (avec la
   table de hachage complétée), ou un pointeur vers une nouvelle table de
   hachage (créée par le "callback", avec clés et valeurs de type "string"), le
   contenu de cette nouvelle table de hachage sera ajouté à 'info' pour les
   autres appels aux "callbacks" focus
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
   WeeChat

[IMPORTANT]
Pour un geste de souris, votre "callback" sera appelé deux fois : la première
lorsque le bouton est pressé (ici la zone correspond à vôtre zone), la seconde
fois lorsque le bouton est relâché, et la zone peut ne pas correspondre à la
vôtre : donc vous devez *toujours* tester dans le "callback" si la zone
correspond avant d'utiliser les informations de la table de hachage.

Contenu de la table de hachage envoyée au "callback" (les clés et valeurs sont
de type "string") :

[width="100%",cols="5m,5,8,3",options="header"]
|===
| Clé ^(1)^                  | Description                   | Exemples de valeur                           | Valeur si non applicable
| _x                         | Colonne sur l'écran         2+| "0" ... "n"
| _y                         | Ligne sur l'écran           2+| "0" ... "n"
| _key                       | Touche ou évènement souris  2+| "button1", "button2-gesture-left", ...
| _window                    | Pointeur vers la fenêtre      | "0x12345678"                                 | ""
| _window_number             | Numéro de la fenêtre          | "1" ... "n"                                  | "*"
| _buffer                    | Pointeur vers le tampon       | "0x12345678"                                 | ""
| _buffer_number             | Numéro du tampon              | "1" ... "n"                                  | "-1"
| _buffer_plugin             | Nom d'extension du tampon     | "core", "irc", ...                           | ""
| _buffer_name               | Nom du tampon                 | "weechat", "freenode.#weechat", ...          | ""
| _buffer_full_name          | Nom complet du tampon         | "core.weechat", "irc.freenode.#weechat", ... | ""
| _buffer_localvar_XXX ^(2)^ | Variables locales du tampon   | toute chaîne                                 | non défini
| _chat                      | Indicateur zone "chat"        | "0" ou "1"                                   | "0"
| _chat_line_x               | Colonne de la ligne ^(3)^     | "0" ... "n"                                  | "-1"
| _chat_line_y               | Numéro de ligne ^(3)^         | "0" ... "n"                                  | "-1"
| _chat_line_date            | Date/heure de la ligne        | "1313237175"                                 | "0"
| _chat_line_date_printed    | Date/heure de la ligne ^(4)^  | "1313237175"                                 | "0"
| _chat_line_time            | Heure affichée                | "14:06:15"                                   | ""
| _chat_line_tags            | Étiquettes de la ligne        | "irc_privmsg,nick_flashy,log1"               | ""
| _chat_line_nick            | Pseudo de la ligne            | "FlashCode"                                  | ""
| _chat_line_prefix          | Préfixe de la ligne           | "@FlashCode"                                 | ""
| _chat_line_message         | Message de la ligne           | "Hello world!"                               | ""
| _chat_word                 | Mot à la position (x,y)       | "Hello"                                      | ""
| _chat_bol                  | Début de ligne ⇒ (x-1,y)      | "He"                                         | ""
| _chat_eol                  | (x,y) ⇒ fin de ligne          | "llo world!"                                 | ""
| _bar_name                  | Nom de la barre               | "title", "nicklist", ...                     | ""
| _bar_filling               | Remplissage de la barre       | "horizontal", "vertical", ...                | ""
| _bar_item_name             | Nom de l'objet de barre       | "buffer_nicklist", "hotlist", ...            | ""
| _bar_item_line             | Ligne dans l'objet de barre   | "0" ... "n"                                  | "-1"
| _bar_item_col              | Colonne dans l'objet de barre | "0" ... "n"                                  | "-1"
|===

[NOTE]
^(1)^ Il y a les mêmes clés suffixées par "2" (c'est-à-dire : "_x2", "_y2",
"_window2", ...) avec l'information sur le second point (pratique seulement
pour les gestes de souris, pour savoir où le bouton de la souris a été
relâché). +
^(2)^ `XXX` est le nom d'une variable locale du tampon. +
^(3)^ Renseigné seulement pour les tampons avec contenu libre. +
^(4)^ Il s'agit de la date lorsque WeeChat ajoute la ligne dans le tampon
(supérieure ou égale à "_chat_line_date").

Informations additionnelles pour l'objet de barre "buffer_nicklist" :

[width="70%",cols="3m,3,8",options="header"]
|===
| Clé            | Extension ^(1)^ | Description
| nick           | core            | Pseudonyme
| prefix         | core            | Préfixe du pseudonyme
| group          | core            | Nom du groupe
| irc_host       | irc             | Nom d'hôte pour le pseudonyme (si connu)
|===

[NOTE]
^(1)^ Le nom de l'extension qui définit un hook_focus pour retourner des infos
pour cet objet de barre (donc par exemple si l'extension est "irc", ces infos
ne seront disponibles que sur les tampons irc).

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----
struct t_hashtable *
my_focus_nicklist_cb (void *data, struct t_hashtable *info)
{
    /* ajout de chaînes dans la table de hachage */
    /* ... */

    return info;
}

/* ajoute le focus sur la liste des pseudos */
struct t_hook *my_focus = weechat_hook_focus ("buffer_nicklist",
                                              &my_focus_nicklist_cb, NULL);
----

Script (Python) :

[source,python]
----
# prototype
hook = weechat.hook_focus(area, callback, callback_data)

# exemple
def my_focus_nicklist_cb(data, info):
    # construction du dict
    # ...
    return my_dict

hook = weechat.hook_focus("buffer_nicklist", "my_focus_nicklist_cb", "")
----

==== weechat_hook_set

_WeeChat ≥ 0.3.9 (script : WeeChat ≥ 0.4.3)._

Affecter une valeur à une propriété d'un hook.

Prototype :

[source,C]
----
void weechat_hook_set (struct t_hook *hook, const char *property,
                       const char *value);
----

Paramètres :

* 'hook' : quelque chose d'accroché avec "weechat_hook_xxx()"
* 'property' : nom de la propriété (voir le tableau ci-dessous)
* 'value' : nouvelle valeur pour la propriété

Propriétés :

[width="100%",cols="^2,2,2,5",options="header"]
|===
| Nom | Type de hook | Valeur | Description

| subplugin | tout type | toute chaîne |
  Nom de la sous-extension (couramment un nom de script, qui est affiché dans
  `/help commande` pour un hook de type 'command')

| stdin +
  _(WeeChat ≥ 0.4.3)_ |
  'process', 'process_hashtable' | toute chaîne |
  Envoyer les données sur l'entrée standard ('stdin') du processus fils

| stdin_close +
  _(WeeChat ≥ 0.4.3)_ |
  'process', 'process_hashtable' | (non utilisée) |
  Fermer le tuyau utilisé pour envoyer les données sur l'entrée standard
  ('stdin') du processus fils

| signal +
  _(WeeChat ≥ 1.0)_ |
  'process', 'process_hashtable' |
  numéro de signal ou un de ces noms : `hup`, `int`, `quit`, `kill`, `term`,
  `usr1`, `usr2` |
  Envoyer un signal au processus fils
|===

Exemple en C :

[source,C]
----
struct t_hook *my_command_hook =
    weechat_hook_command ("abcd", "description",
                          "args", "description args",
                          "", &my_command_cb, NULL);
weechat_hook_set (my_command_hook, "subplugin", "test");
----

Script (Python) :

[source,python]
----
# prototype
weechat.hook_set(hook, property, value)

# exemple
def my_process_cb(data, command, return_code, out, err):
    # ...
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_process_hashtable("/chemin/vers/commande", {"stdin": "1"},
                                      20000, "my_process_cb", "")
weechat.hook_set(hook, "stdin", "données envoyées sur le stdin du processus fils")
weechat.hook_set(hook, "stdin_close", "")  # facultatif
----

==== weechat_unhook

Décrocher quelque chose qui est a été accroché.

Prototype :

[source,C]
----
void weechat_unhook (struct t_hook *hook);
----

Paramètres :

* 'hook' : quelque chose accroché avec "weechat_hook_xxx()"

Exemple en C :

[source,C]
----
struct t_hook *my_hook = weechat_hook_command ( /* ... */ );
/* ... */
weechat_unhook (my_hook);
----

Script (Python) :

[source,python]
----
# prototype
weechat.unhook(hook)

# exemple
weechat.unhook(my_hook)
----

==== weechat_unhook_all

Décrocher tout ce qui a été accroché par l'extension courante.

Prototype :

[source,C]
----
void weechat_unhook_all ();
----

Exemple en C :

[source,C]
----
weechat_unhook_all ();
----

Script (Python) :

[source,python]
----
# prototype
weechat.unhook_all()

# exemple
weechat.unhook_all()
----

[[buffers]]
=== Tampons

Fonctions pour créer/interroger/fermer les tampons.

==== weechat_buffer_new

Ouvrir un nouveau tampon.

Prototype :

[source,C]
----
struct t_gui_buffer *weechat_buffer_new (const char *name,
                                         int (*input_callback)(void *data,
                                                               struct t_gui_buffer *buffer,
                                                               const char *input_data),
                                         void *input_callback_data,
                                         int (*close_callback)(void *data,
                                                               struct t_gui_buffer *buffer),
                                         void *close_callback_data);
----

Paramètres :

* 'name' : nom du tampon (doit être unique pour l'extension)
* 'input_callback' : fonction appelée lorsque du texte saisi est envoyé au
  tampon, paramètres et valeur de retour :
** 'void *data' : pointeur
** 'struct t_gui_buffer *buffer' : pointeur vers le tampon
** 'const char *input_data' : données en entrée
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat
* 'close_callback' : fonction appelée lorsque le tampon est fermé, paramètres et
  valeur de retour :
** 'void *data' : pointeur
** 'struct t_gui_buffer *buffer' : pointeur vers le tampon
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau tampon, NULL en cas d'erreur

Exemple en C :

[source,C]
----
int
my_input_cb (void *data, struct t_gui_buffer *buffer, const char *input_data)
{
    weechat_printf (buffer, "Texte : %s", input_data);
    return WEECHAT_RC_OK;
}

int
my_close_cb (void *data, struct t_gui_buffer *buffer)
{
    weechat_printf (NULL, "Le tampon '%s' va être fermé !",
                    weechat_buffer_get_string (buffer, "name"));
    return WEECHAT_RC_OK;
}

struct t_gui_buffer *my_buffer = weechat_buffer_new ("mon_buffer",
                                                     &my_input_cb, NULL,
                                                     &my_close_cb, NULL);
----

Script (Python) :

[source,python]
----
# prototype
buffer = weechat.buffer_new(name, input_callback, input_callback_data,
    close_callback, close_callback_data)

# exemple
def my_input_cb(data, buffer, input_data):
    weechat.prnt(buffer, "Texte : %s" % input_data)
    return weechat.WEECHAT_RC_OK

def my_close_cb(data, buffer):
    weechat.prnt("", "Le tampon '%s' va être fermé !" % weechat.buffer_get_string(buffer, "name"))
    return weechat.WEECHAT_RC_OK

buffer = weechat.buffer_new("mon_buffer", "my_input_cb", "", "my_close_cb", "")
----

==== weechat_current_buffer

Retourner un pointeur vers le tampon courant (le tampon affiché par la fenêtre
courante).

Prototype :

[source,C]
----
struct t_gui_buffer *weechat_current_buffer ();
----

Valeur de retour :

* pointeur vers le tampon courant

Exemple en C :

[source,C]
----
weechat_printf (weechat_current_buffer (), "Texte sur le tampon courant");
----

Script (Python) :

[source,python]
----
# prototype
buffer = weechat.current_buffer()

# exemple
weechat.prnt(weechat.current_buffer(), "Texte sur le tampon courant")
----

==== weechat_buffer_search

_Mis à jour dans la 1.0._

Rechercher un tampon par l'extension et/ou le nom.

Prototype :

[source,C]
----
struct t_gui_buffer *weechat_buffer_search (const char *plugin,
                                            const char *name);
----

Paramètres :

* 'plugin' : nom de l'extension, la valeur spéciale suivante est autorisée :
** `==` : le nom utilisé est le nom complet du tampon (par exemple :
   `irc.freenode.#weechat` au lieu de `freenode.#weechat`)
   _(WeeChat ≥ 1.0)_
* 'name' : nom du tampon, si c'est NULL ou une chaîne vide, le tampon courant
  est retourné (tampon affiché par la fenêtre courante); si le nom commence par
  `(?i)`, la recherche est insensible à la casse _(WeeChat ≥ 1.0)_

Valeur de retour :

* pointeur vers le tampon trouvé, NULL s'il n'a pas été trouvé

Exemples en C :

[source,C]
----
struct t_gui_buffer *buffer1 = weechat_buffer_search ("irc", "freenode.#weechat");
struct t_gui_buffer *buffer2 = weechat_buffer_search ("==", "irc.freenode.#test");  /* WeeChat ≥ 1.0 */
----

Script (Python) :

[source,python]
----
# prototype
buffer = weechat.buffer_search(plugin, name)

# exemple
buffer = weechat.buffer_search("mon_extension", "mon_tampon")
----

==== weechat_buffer_search_main

Rechercher le tampon principal de WeeChat (tampon 'core', premier tampon
affiché lorsque WeeChat démarre).

Prototype :

[source,C]
----
struct t_gui_buffer *weechat_buffer_search_main ();
----

Valeur de retour :

* pointeur vers le tampon principal WeeChat (tampon 'core')

Exemple en C :

[source,C]
----
struct t_gui_buffer *weechat_buffer = weechat_buffer_search_main ();
----

Script (Python) :

[source,python]
----
# prototype
buffer = weechat.buffer_search_main()

# exemple
buffer = weechat.buffer_search_main()
----

==== weechat_buffer_clear

Effacer le contenu d'un tampon.

Prototype :

[source,C]
----
void weechat_buffer_clear (struct t_gui_buffer *buffer);
----

Paramètres :

* 'buffer' : pointeur vers le tampon

Exemple en C :

[source,C]
----
struct t_gui_buffer *my_buffer = weechat_buffer_search ("mon_extension",
                                                        "mon_tampon");
if (my_buffer)
{
    weechat_buffer_clear (my_buffer);
}
----

Script (Python) :

[source,python]
----
# prototype
weechat.buffer_clear(buffer)

# exemple
buffer = weechat.buffer_search("mon_extension", "mon_tampon")
if buffer != "":
    weechat.buffer_clear(buffer)
----

==== weechat_buffer_close

Fermer un tampon.

Prototype :

[source,C]
----
void weechat_buffer_close (struct t_gui_buffer *buffer);
----

Paramètres :

* 'buffer' : pointeur vers le tampon

Exemple en C :

[source,C]
----
struct t_gui_buffer *my_buffer = weechat_buffer_new ("mon_tampon",
                                                     &my_input_cb, NULL,
                                                     &my_close_cb, NULL);
/* ... */
weechat_buffer_close (my_buffer);
----

Script (Python) :

[source,python]
----
# prototype
weechat.buffer_close(buffer)

# exemple
buffer = weechat.buffer_new("mon_tampon", "my_input_cb", "", "my_close_cb", "")
# ...
weechat.buffer_close(buffer)
----

==== weechat_buffer_merge

Mélanger le tampon avec un autre tampon : les deux tampons continueront
d'exister chacun de leur côté, mais avec le même numéro, et WeeChat affichera
les lignes des deux tampons (lignes mélangées).

Prototype :

[source,C]
----
void weechat_buffer_merge (struct t_gui_buffer *buffer,
                           struct t_gui_buffer *target_buffer);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'target_buffer' : tampon cible avec lequel on doit mélanger

Exemple en C :

[source,C]
----
/* mélanger le tampon courant avec le tampon "core" */
weechat_buffer_merge (weechat_current_buffer (),
                      weechat_buffer_search_main ());
----

Script (Python) :

[source,python]
----
# prototype
weechat.buffer_merge(buffer, target_buffer)

# exemple
# mélanger le tampon courant avec le tampon "core"
weechat.buffer_merge(weechat.current_buffer(), weechat.buffer_search_main())
----

==== weechat_buffer_unmerge

Supprimer le mélange d'un tampon.

Prototype :

[source,C]
----
void weechat_buffer_unmerge (struct t_gui_buffer *buffer,
                             int number);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'number' : numéro cible pour le tampon détaché, s'il est < 1, alors le tampon
  sera déplacé vers le numéro du tampon + 1

Exemple en C :

[source,C]
----
weechat_buffer_unmerge (weechat_current_buffer (), 1);
----

Script (Python) :

[source,python]
----
# prototype
weechat.buffer_unmerge(buffer, number)

# exemple
weechat.buffer_unmerge(weechat.current_buffer(), 1)
----

==== weechat_buffer_get_integer

Retourner une valeur entière pour une propriété du tampon.

Prototype :

[source,C]
----
int weechat_buffer_get_integer (struct t_gui_buffer *buffer,
                                const char *property);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'property' : nom de la propriété :
** 'number' : numéro du tampon (commence à 1)
** 'layout_number' : numéro du tampon sauvegardé dans le "layout"
** 'layout_number_merge_order' : ordre du tampon mélangé pour le "layout"
** 'short_name_is_set' : 1 si le nom court est défini, 0 si non défini
** 'type' : type de tampon (0 : formaté, 1 : contenu libre)
** 'notify' : niveau de notification du tampon
** 'num_displayed' : nombre de fenêtres affichant ce tampon
** 'active' : 2 si le tampon est le seul actif (mélangé), 1 si le tampon est
   actif, 0 si le tampon est mélangé et n'est pas sélectionné
** 'hidden' : 1 si le tampon est caché, sinon 0
   _(WeeChat ≥ 1.0)_
** 'zoomed' : 1 si le tampon est mélangé et zoomé, sinon 0
   _(WeeChat ≥ 1.0)_
** 'print_hooks_enabled' : 1 si les hooks "print" sont activés, sinon 0
** 'day_change' : 1 si les messages de changement de jour sont affichés, sinon 0
   _(WeeChat ≥ 0.4.3)_
** 'clear' : 1 si le tampon peut être effacé avec la commande `/buffer clear`,
   sinon 0 _(WeeChat ≥ 1.0)_
** 'filter' : 1 si les filtres sont activés sur le tampon, sinon 0
   _(WeeChat ≥ 1.0)_
** 'lines_hidden' : 1 si au moins une ligne est cachée dans le tampon
   (filtrée), ou 0 si toutes les lignes sont affichées
** 'prefix_max_length' : longueur maximale du préfixe dans ce tampon
** 'time_for_each_line' : 1 si l'heure est affichée pour chaque ligne du tampon
   (par défaut), sinon 0
** 'nicklist' : 1 si la liste de pseudos est activée, sinon 0
** 'nicklist_case_sensitive' : 1 si les pseudos sont sensibles à la casse,
   sinon 0
** 'nicklist_max_length' : longueur maximale d'un pseudo
** 'nicklist_display_groups' : 1 si les groupes sont affichés, sinon 0
** 'nicklist_count' : nombre de pseudos et groupes dans la liste de pseudos
** 'nicklist_groups_count' : nombre de groupes dans la liste de pseudos
** 'nicklist_nicks_count' : nombre de pseudos dans la liste de pseudos
** 'nicklist_visible_count' : nombre de pseudos/groupes affichés
** 'input' : 1 si la zone de saisie est activée, sinon 0
** 'input_get_unknown_commands' : 1 si les commandes inconnues sont envoyées
   au "callback input", sinon 0
** 'input_size' : taille de la zone de saisie (en octets)
** 'input_length' : longueur de la zone de saisie (nombre de caractères)
** 'input_pos' : position du curseur dans la zone de saisie
** 'input_1st_display' : premier caractère affiché à l'écran
** 'num_history' : nombre de commandes dans l'historique
** 'text_search' : type de recherche de texte :
*** 0 : pas de recherche en cours
*** 1 : recherche arrière (vers les messages les plus anciens)
*** 2 : recherche avant (vers les messages les plus récents)
** 'text_search_exact' : 1 si la recherche de texte est sensible à la casse
** 'text_search_found' : 1 si du texte a été trouvé, sinon 0

Valeur de retour :

* valeur entière de la propriété

Exemple en C :

[source,C]
----
weechat_printf (NULL, "mon numéro de tampon est : %d",
                weechat_buffer_get_integer (mon_tampon, "number"));
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.buffer_get_integer(buffer, property)

# exemple
weechat.prnt("", "mon numéro de tampon est : %d" % weechat.buffer_get_integer(my_buffer, "number"))
----

==== weechat_buffer_get_string

Retourner la valeur d'une propriété du tampon sous forme de chaîne.

Prototype :

[source,C]
----
const char *weechat_buffer_get_string (struct t_gui_buffer *buffer,
                                       const char *property);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'property' : nom de la propriété :
** 'plugin' : nom de l'extension qui a créé ce tampon ("core" pour le tampon
   principal WeeChat)
** 'name' : nom du tampon
** 'full_name' : nom complet du tampon ("extension.nom") _(WeeChat ≥ 0.3.7)_
** 'short_name' : nom court du tampon (note: utilisé pour l'affichage seulement
   et peut être changé par l'utilisateur, il ne doit pas être utilisé pour
   trouver le nom du tampon, utilisez à la place 'name', 'full_name' ou bien la
   variable locale 'channel')
** 'title' : titre du tampon
** 'input' : texte saisi
** 'text_search_input' : texte saisi sauvegardé avant la recherche de texte
** 'highlight_words' : liste des mots pour le highlight
** 'highlight_regex' : expression régulière POSIX étendue pour le highlight
** 'highlight_tags_restrict' : restreindre les highlights aux messages
   comportant ces étiquettes
** 'highlight_tags' : forcer le highlight pour les messages avec ces étiquettes
** 'hotlist_max_level_nicks' : niveau maximum pour la hotlist pour certains
   pseudos
** 'localvar_xxx' : contenu de la variable locale "xxx" (remplacer "xxx" par le
   nom de la variable locale à lire)

Valeur de retour :

* valeur de la propriété, sous forme de chaîne

Exemple en C :

[source,C]
----
weechat_printf (NULL, "nom / nom court du tampon sont : %s / %s",
                weechat_buffer_get_string (my_buffer, "name"),
                weechat_buffer_get_string (my_buffer, "short_name"));
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.buffer_get_string(buffer, property)

# exemple
weechat.prnt("", "nom / nom court du tampon sont : %s / %s"
    % (weechat.buffer_get_string(my_buffer, "name"),
    weechat.buffer_get_string(my_buffer, "short_name")))
----

==== weechat_buffer_get_pointer

Retourner la valeur d'une propriété sous forme d'un pointeur.

Prototype :

[source,C]
----
void *weechat_buffer_pointer (struct t_gui_buffer *buffer,
                              const char *property);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'property' : nom de la propriété :
** 'plugin' : pointeur vers l'extension qui a créé le tampon (NULL pour le
   tampon principal WeeChat)
** 'highlight_regex_compiled' : expression régulière 'highlight_regex' compilée

Valeur de retour :

* valeur de la propriété, sous forme de pointeur

Exemple en C :

[source,C]
----
weechat_printf (NULL, "pointeur vers l'extension de mon tampon : %lx",
                weechat_buffer_get_pointer (mon_tampon, "plugin"));
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.buffer_get_pointer(buffer, property)

# exemple
weechat.prnt("", "pointeur vers l'extension de mon tampon : %s" % weechat.buffer_get_pointer(my_buffer, "plugin"))
----

==== weechat_buffer_set

Affecter une valeur à une propriété d'un tampon.

Prototype :

[source,C]
----
void weechat_buffer_set (struct t_gui_buffer *buffer, const char *property,
                         const char *value);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'property' : nom de la propriété (voir le tableau ci-dessous)
* 'value' : nouvelle valeur pour la propriété

Propriétés :

[width="100%",cols="^2,4,8",options="header"]
|===
| Nom | Valeur | Description

| hotlist | "+", "-", WEECHAT_HOTLIST_LOW, WEECHAT_HOTLIST_MESSAGE,
  WEECHAT_HOTLIST_PRIVATE, WEECHAT_HOTLIST_HIGHLIGHT, "-1" |
  "+" : active la hotlist (option globale, le pointeur vers le tampon n'est pas
  utilisé) +
  "-" : désactive la hotlist (option globale, le pointeur vers le tampon n'est
  pas utilisé) +
  priorité : ajouter ce tampon dans la hotlist avec cette priorité +
  "-1" : supprimer ce tampon de la hotlist _(WeeChat ≥ 1.0)_

| completion_freeze | "0" ou "1" |
  "0" : pas de gel de la complétion (valeur par défaut)
  (option globale, le pointeur vers le tampon n'est pas utilisé) +
  "1" : ne pas arrêter la complétion lorsque la ligne de commande est mise à
  jour (option globale, le pointeur vers le tampon n'est pas utilisé)

| unread | - |
  Définit le marqueur de données non lues après la dernière ligne du tampon

| display | "1" ou "auto" |
  "1" : basculer vers ce tampon dans la fenêtre active +
  "auto" : basculer vers ce tampon dans la fenêtre active, le marqueur de
  données non lues n'est pas réinitialisé

| hidden +
  _(WeeChat ≥ 1.0)_ | "0" ou "1" |
  "0" : démasquer le tampon +
  "1" : masquer le tampon

| number | numéro |
  Déplace le tampon vers ce numéro

| name | toute chaîne |
  Change le nom du tampon

| short_name | toute chaîne |
  Change le nom court du tampon

| type | "formatted" ou "free" |
  Définit le type de tampon : "formatted" (pour afficher les messages d'une
  discussion), ou "free" (pour du contenu libre); lorsque la valeur est "free",
  la propriété 'clear' est forcée à "0" _(WeeChat ≥ 1.0)_

| notify | "0", "1", "2", "3" |
  Définit le niveau de notification du tampon : "0" = ne jamais ajouter à la
  hotlist, "1" = ajouter pour les highlights seulement, "2" = ajouter pour les
  highlights et les messages, "3" = ajouter pour tous les messages

| print_hooks_enabled | "0" ou "1" |
  "0" pour désactiver les hooks "print", "1" pour les activer
  (par défaut pour un nouveau tampon)

| day_change +
  _(WeeChat ≥ 0.4.3)_ | "0" ou "1" |
  "0" pour cacher les messages de changement de jour, "1" pour les voir
  (par défaut pour un nouveau tampon)

| clear +
  _(WeeChat ≥ 1.0)_ | "0" ou "1" |
  "0" pour empêcher l'utilisateur d'effacer le tampon avec la commande
  `/buffer clear`, "1" pour autoriser l'utilisateur à effacer le tampon (par
   défaut pour un nouveau tampon) (note : même lorsque la valeur est "0", le
   tampon peut toujours être effacé avec la fonction
   <<_weechat_buffer_clear,weechat_buffer_clear>>)

| filter +
  _(WeeChat ≥ 1.0)_ | "0" or "1" |
  "0" : désactiver les filtres sur le tampon +
  "1" : activer les filtres sur le tampon

| title | toute chaîne |
  Change le titre du tampon

| time_for_each_line | "0" ou "1" |
  "0" pour cacher l'heure sur toutes les lignes du tampon, "1" pour afficher
  l'heure sur toutes les lignes (par défaut pour un nouveau tampon)

| nicklist | "0" ou "1" |
  "0" pour supprimer la liste des pseudos du tampon, "1" pour ajouter la liste
  des pseudos du tampon

| nicklist_case_sensitive | "0" ou "1" |
  "0" pour avoir la liste des pseudos insensible à la casse, "1" pour avoir
  la liste des pseudos sensible à la casse

| nicklist_display_groups | "0" ou "1" |
  "0" pour cacher les groupes de la liste des pseudos, "1" pour afficher les
  groupes de la liste des pseudos

| highlight_words | "-" ou une liste de mots séparés par des virgules |
  "-" est une valeur spéciale pour désactiver tout highlight sur ce tampon, ou
  une liste de mots à mettre en valeur dans ce tampon, par exemple :
  "abc,def,ghi"

| highlight_words_add | liste de mots séparés par des virgules |
  Liste de mots à mettre en valeur dans ce tampon, ces mots sont ajoutés aux
  mots existants pour le tampon

| highlight_words_del | liste de mots séparés par des virgules |
  Liste de mots à supprimer de la liste des mots à mettre en valeur dans ce
  tampon

| highlight_regex | toute chaîne |
  Expression régulière POSIX étendue pour le highlight

| highlight_tags_restrict | liste d'étiquettes séparées par des virgules |
  Restreindre les highlights aux messages avec ces étiquettes dans ce tampon
  (il est possible de combiner plusieurs étiquettes sous forme d'un "et" logique
  avec le séparateur "+", par exemple : "nick_toto+irc_action")

| highlight_tags | liste d'étiquettes séparées par des virgules |
  Forcer le highlight pour les messages avec ces étiquettes dans ce tampon
  (il est possible de combiner plusieurs étiquettes sous forme d'un "et" logique
  avec le séparateur "+", par exemple : "nick_toto+irc_action")

| hotlist_max_level_nicks | liste de "pseudo:niveau" séparés par des virgules |
  Liste de pseudos avec niveau max pour la hotlist sur ce tampon (le niveau peut
  être : -1: jamais dans la hotlist, 0: faible, 1: message, 2: privé,
  3: highlight), par exemple : "joe:2,mike:-1,robert:-1" (joe ne produira
  jamais de highlight sur le tampon, mike et robert ne changeront jamais la
  hotlist)

| hotlist_max_level_nicks_add | liste de "pseudo:niveau" séparés par des virgules" |
  Liste de pseudos avec niveau pour la hotlist, ces pseudos sont ajoutés aux
  pseudos existant dans le tampon

| hotlist_max_level_nicks_del | liste de pseudos séparés par des virgules |
  Liste de pseudos à supprimer des niveaux max de hotlist

| key_bind_xxx | toute chaîne |
  Associe la nouvelle touche 'xxx', spécifique à ce tampon, la valeur est la
  commande à exécuter pour cette touche

| key_unbind_xxx | - |
  Supprime la touche 'xxx' pour ce tampon

| input | toute chaîne |
  Change le contenu de la zone de saisie

| input_pos | position |
  Change la position du curseur dans la zone de saisie

| input_get_unknown_commands | "0" ou "1" |
  "0" pour désactiver les commandes inconnues sur ce tampon (comportement par
  défaut), "1" pour recevoir les commandes inconnues, par exemple si
  l'utilisateur tape "/commandeinconnue", le tampon le recevra (pas d'erreur
  sur la commande inconnue)

| localvar_set_xxx | toute chaîne |
  Change la valeur de la variable locale 'xxx' (la variable est créée si elle
  n'existe pas)

| localvar_del_xxx | - |
  Supprime la variable locale 'xxx'
|===

Exemple en C :

[source,C]
----
/* désactiver la hotlist (pour tous les tampons) */
weechat_buffer_set (NULL, "hotlist", "-");

/* activer à nouveau la hotlist */
weechat_buffer_set (NULL, "hotlist", "+");

/* changer le nom du tampon */
weechat_buffer_set (mon_tampon, "name", "nouveau_nom");

/* ajouter une variable locale "toto" avec la valeur "abc" */
weechat_buffer_set (mon_tampon, "localvar_set_toto", "abc");

/* supprimer la variable locale "toto" */
weechat_buffer_set (mon_tampon, "localvar_del_toto", NULL);
----

Script (Python) :

[source,python]
----
# prototype
weechat.buffer_set(buffer, property, value)

# exemples

# désactiver la hotlist (pour tous les tampons)
weechat.buffer_set("", "hotlist", "-")

# activer à nouveau la hotlist
weechat.buffer_set("", "hotlist", "+")

# changer le nom du tampon
weechat.buffer_set(my_buffer, "name", "my_new_name")

# ajouter une variable locale "toto" avec la valeur "abc"
weechat.buffer_set(my_buffer, "localvar_set_toto", "abc")

# supprimer la variable locale "toto"
weechat.buffer_set(my_buffer, "localvar_del_toto", "")
----

==== weechat_buffer_set_pointer

Affecter un pointeur à une propriété d'un tampon.

Prototype :

[source,C]
----
void weechat_buffer_set_pointer (struct t_gui_buffer *buffer, const char *property,
                                 void *pointer);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'property' : nom de la propriété :
** 'close_callback' : définit la fonction "callback" de fermeture du tampon
** 'close_callback_data' : définit les données pour le "callback" de fermeture
   du tampon
** 'input_callback' : définit la fonction de "callback" pour les données en
   entrée
** 'input_callback_data' : définit les données pour le "callback" des données
   en entrée
** 'nickcmp_callback' : définit la fonction "callback" de comparaison de pseudos
   (ce "callback" est appelé lors de la recherche d'un pseudo dans la liste des
   pseudos) _(WeeChat ≥ 0.3.9)_
** 'nickcmp_callback_data' : définit les données pour le "callback" de
   comparaison de pseudos _(WeeChat ≥ 0.3.9)_
* 'pointer' : nouvelle valeur de pointeur pour la propriété

Prototypes pour les "callbacks" :

[source,C]
----
int close_callback (void *data, struct t_gui_buffer *buffer);

int input_callback (void *data, struct t_gui_buffer *buffer, const char *input_data);

int nickcmp_callback (void *data, struct t_gui_buffer *buffer, const char *nick1, const char *nick2);
----

Exemple en C :

[source,C]
----
int
my_close_cb (void *data, struct t_gui_buffer *buffer)
{
    /* ... */
    return WEECHAT_RC_OK;
}

weechat_buffer_set_pointer (mon_tampon, "close_callback", &my_close_cb);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_buffer_string_replace_local_var

Remplacer les variables locales dans une chaîne par leurs valeurs, en utilisant
les variables locales du tampon.

Prototype :

[source,C]
----
char *weechat_buffer_string_replace_local_var (struct t_gui_buffer *buffer,
                                               const char *string);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'string' : chaîne avec du texte et des variables locales, au format "$var"

Valeur de retour :

* chaîne avec les valeurs des variables locales

Exemple en C :

[source,C]
----
weechat_buffer_set (mon_tampon, "localvar_set_toto", "abc");

char *str = weechat_buffer_string_replace_local_var (mon_tampon,
                                                     "test avec $toto");
/* str contient "test avec abc" */
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.buffer_string_replace_local_var(buffer, string)

# exemple
weechat.buffer_set(my_buffer, "localvar_set_toto", "abc")
str = weechat.buffer_string_replace_local_var(my_buffer, "test avec $toto")
# str contient "test avec abc"
----

==== weechat_buffer_match_list

_WeeChat ≥ 0.3.5._

Vérifier si le tampon correspond à la liste de tampons.

Prototype :

[source,C]
----
int weechat_buffer_match_list (struct t_gui_buffer *buffer, const char *string);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'string' : liste de tampons, séparés par des virgules :
** "*" signifie tous les tampons
** un nom commençant par "!" est exclu
** le caractère joker "*" est autorisé dans le nom

Valeur de retour :

* 1 si le tampon correspond à la liste de tampons, 0 sinon

Exemple en C :

[source,C]
----
struct t_gui_buffer *buffer = weechat_buffer_search ("irc", "freenode.#weechat");
if (buffer)
{
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "*"));                    /* 1 */
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "*,!*#weechat*"));        /* 0 */
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "irc.freenode.*"));       /* 1 */
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "irc.oftc.*,python.*"));  /* 0 */
}
----

Script (Python) :

[source,python]
----
# prototype
match = weechat.buffer_match_list(buffer, string)

# exemple
buffer = weechat.buffer_search("irc", "freenode.#weechat")
if buffer:
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "*"))                    # 1
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "*,!*#weechat*"))        # 0
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "irc.freenode.*"))       # 1
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "irc.oftc.*,python.*"))  # 0
----

[[windows]]
=== Fenêtres

Fonctions pour interroger les fenêtres.

==== weechat_current_window

Retourner le pointeur vers la fenêtre courante.

Prototype :

[source,C]
----
struct t_gui_window *weechat_current_window ();
----

Valeur de retour :

* pointeur vers la fenêtre courante

Exemple en C :

[source,C]
----
struct t_gui_window *current_window = weechat_current_window ();
----

Script (Python) :

[source,python]
----
# prototype
window = weechat.current_window()

# exemple
current_window = weechat.current_window()
----

==== weechat_window_search_with_buffer

_WeeChat ≥ 0.3.5._

Retourner le pointeur vers la fenêtre affichant un tampon.

Prototype :

[source,C]
----
struct t_gui_window *weechat_window_search_with_buffer (struct t_gui_buffer *buffer);
----

Paramètre :

* 'buffer' : pointeur vers le tampon

Valeur de retour :

* pointeur vers la fenêtre affichant un tampon (NULL si aucune fenêtre n'affiche
  ce tampon)

Exemple en C :

[source,C]
----
weechat_printf (NULL,
                "fenêtre affichant le tampon core: %lx",
                weechat_window_search_with_buffer (weechat_buffer_search_main ()));
----

Script (Python) :

[source,python]
----
# prototype
window = weechat.window_search_with_buffer(buffer)

# exemple
weechat.prnt("", "fenêtre affichant le tampon core: %s"
    % weechat.window_search_with_buffer(weechat.buffer_search_main()))
----

==== weechat_window_get_integer

Retourner la valeur entière d'une propriété de la fenêtre.

Prototype :

[source,C]
----
int weechat_window_get_integer (struct t_gui_window *window,
                                const char *property);
----

Paramètres :

* 'window' : pointeur vers la fenêtre
* 'property' : nom de la propriété :
** 'number' : numéro de la fenêtre (commence à 1)
** 'win_x' : position X de la fenêtre dans le terminal (la première colonne est
   0)
** 'win_y' : position Y de la fenêtre dans le terminal (la première ligne est
   0)
** 'win_width' : largeur de la fenêtre, en caractères
** 'win_height' : hauteur de la fenêtre, en caractères
** 'win_width_pct' : taille en pourcentage, en comparaison avec la fenêtre
   parente (par exemple 50 indique une largeur de moitié)
** 'win_height_pct' : taille en pourcentage, en comparaison avec la fenêtre
   parente (par exemple 50 indique une hauteur de moitié)
** 'win_chat_x' : position X de la fenêtre de discussion ("chat") dans le
   terminal (la première colonne est 0)
** 'win_chat_y' : position Y de la fenêtre de discussion ("chat") dans le
   terminal (la première ligne est 0)
** 'win_chat_width' : largeur de la fenêtre de discussion ("chat"), en
   caractères
** 'win_chat_height' : hauteur de la fenêtre de discussion ("chat"), en
   caractères
** 'first_line_displayed' : 1 si la première du tampon est affichée à l'écran,
   sinon 0
** 'scrolling' : 1 s'il y a un défilement en cours dans la fenêtre (la dernière
   ligne n'est pas affichée)
** 'lines_after' : nombre de lignes non affichées après la dernière ligne
   affichée (lors d'un défilement)

Valeur de retour :

* valeur entière de la propriété

Exemple en C :

[source,C]
----
weechat_printf (NULL, "la fenêtre courante est en position (x,y) : (%d,%d)",
                weechat_window_get_integer (weechat_current_window (), "win_x"),
                weechat_window_get_integer (weechat_current_window (), "win_y"));
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.window_get_integer(window, property)

# exemple
weechat.prnt("", "la fenêtre courante est en position (x,y) : (%d,%d)"
    % (weechat.window_get_integer(weechat.current_window(), "win_x"),
    weechat.window_get_integer(weechat.current_window(), "win_y")))
----

==== weechat_window_get_string

Retourner la valeur d'une propriété de la fenêtre sous forme d'une chaîne.

[NOTE]
Cette fonction n'est pas utilisée aujourd'hui, elle est réservée pour une
version future.

Prototype :

[source,C]
----
int weechat_window_get_string (struct t_gui_window *window,
                               const char *property);
----

Paramètres :

* 'window' : pointeur vers la fenêtre
* 'property' : nom de la propriété

Valeur de retour :

* valeur de la propriété, sous forme de chaîne

==== weechat_window_get_pointer

Retourner la valeur d'une propriété, sous forme d'un pointeur.

Prototype :

[source,C]
----
void *weechat_window_get_pointer (struct t_gui_window *window,
                                  const char *property);
----

Paramètres :

* 'window' : pointeur vers la fenêtre
* 'property' : nom de la propriété :
** 'current' : pointeur vers la fenêtre courante
** 'buffer' : pointeur vers le tampon affiché par la fenêtre

Valeur de retour :

* valeur de la propriété, sous forme de pointeur

Exemple en C :

[source,C]
----
weechat_printf (NULL,
                "tampon affiché dans la fenêtre courante : %lx",
                weechat_window_get_pointer (weechat_current_window (), "buffer"));
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.window_get_pointer(window, property)

# exemple
weechat.prnt("", "tampon affiché dans la fenêtre courante : %s"
    % weechat.window_get_pointer(weechat.current_window(), "buffer"))
----

==== weechat_window_set_title

Définir le titre du terminal.

Prototype :

[source,C]
----
void weechat_window_set_title (const char *title);
----

Paramètres :

* 'title' : nouveau titre pour le terminal (NULL pour réinitialiser le titre)

Exemple en C :

[source,C]
----
weechat_window_set_title ("nouveau titre ici");
----

Script (Python) :

[source,python]
----
# prototype
weechat.window_set_title(window, title)

# exemple
weechat.window_set_title("nouveau titre ici")
----

[[nicklist]]
=== Nicklist

Fonctions pour la liste des pseudos.

==== weechat_nicklist_add_group

Ajouter un groupe dans la liste des pseudos.

Prototype :

[source,C]
----
struct t_gui_nick_group *weechat_nicklist_add_group (struct t_gui_buffer *buffer,
                                                     struct t_gui_nick_group *parent_group,
                                                     const char *name,
                                                     const char *color,
                                                     int visible);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'parent_group' : pointeur vers le parent du groupe, NULL si le groupe n'a pas
  de parent (racine de la liste des pseudos)
* 'name' : nom du groupe
* 'color' : nom de l'option contenant la couleur :
** une option WeeChat, par exemple 'weechat.color.nicklist_group'
** une couleur avec un fond optionnel, par exemple 'yellow' ou 'yellow,red'
** nom d'une couleur de barre :
*** 'bar_fg' : couleur de texte pour la barre
*** 'bar_delim' : couleur des délimiteurs pour la barre
*** 'bar_bg' : couleur de fond pour la barre
* 'visible' :
** '1' : le groupe et ses sous-groupes/pseudos sont visibles
** '0' : le groupe et ses sous-groupes/pseudos sont cachés

[NOTE]
Le nom du groupe peut commencer par un ou plusieurs chiffres, suivis d'un pipe
("|"), puis du nom du groupe. Quand une telle chaîne est trouvée au début, elle
est utilisée pour trier les groupes dans la liste des pseudos. Par exemple les
groupes "1|test" et "2|abc" seront affichés dans cet ordre : "test" en premier,
puis "abc" en second.

Valeur de retour :

* pointeur vers le nouveau groupe, NULL en cas d'erreur

Exemple en C :

[source,C]
----
struct t_gui_nick_group *my_group =
    weechat_nicklist_add_group (my_buffer,
                                my_parent_group,
                                "groupe_test",
                                "weechat.color.nicklist_group",
                                1);
----

Script (Python) :

[source,python]
----
# prototype
group = weechat.nicklist_add_group(buffer, parent_group, name, color, visible)

# exemple
group = weechat.nicklist_add_group(my_buffer, my_parent_group, "groupe_test",
    "weechat.color.nicklist_group", 1)
----

==== weechat_nicklist_search_group

Rechercher un groupe dans la liste des pseudos.

Prototype :

[source,C]
----
struct t_gui_nick_group *weechat_nicklist_search_group (struct t_gui_buffer *buffer,
                                                        struct t_gui_nick_group *from_group,
                                                        const char *name);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'from_group' : recherche depuis ce groupe seulement, si NULL, alors recherche
  dans toute la liste des pseudos
* 'name' : nom du groupes à rechercher

Valeur de retour :

* pointeur vers le groupe trouvé, NULL s'il n'est pas trouvé

Exemple en C :

[source,C]
----
struct t_gui_nick_group *ptr_group = weechat_nicklist_search_group (my_buffer,
                                                                    NULL, "groupe_test");
----

Script (Python) :

[source,python]
----
# prototype
group = weechat.nicklist_search_group(buffer, from_group, name)

# exemple
group = weechat.nicklist_search_group(my_buffer, "", "groupe_test")
----

==== weechat_nicklist_add_nick

Ajouter un pseudo dans un groupe.

Prototype :

[source,C]
----
struct t_gui_nick_group *weechat_nicklist_add_nick (struct t_gui_buffer *buffer,
                                                    struct t_gui_nick_group *group,
                                                    const char *name,
                                                    const char *color,
                                                    const char *prefix,
                                                    const char *prefix_color,
                                                    int visible);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'group' : pointeur vers le groupe
* 'name' : nom du pseudo
* 'color' : nom de l'option contenant la couleur pour le pseudo :
** une option WeeChat, par exemple 'weechat.color.nicklist_group'
** une couleur avec un fond optionnel, par exemple 'yellow' ou 'yellow,red'
** nom d'une couleur de barre :
*** 'bar_fg' : couleur de texte pour la barre
*** 'bar_delim' : couleur des délimiteurs pour la barre
*** 'bar_bg' : couleur de fond pour la barre
* 'prefix' : préfixe affiché avant le pseudo
* 'prefix_color' : nom de l'option contenant la couleur pour le préfixe :
** une option WeeChat, par exemple 'weechat.color.nicklist_group'
** une couleur avec un fond optionnel, par exemple 'yellow' ou 'yellow,red'
** nom d'une couleur de barre :
*** 'bar_fg' : couleur de texte pour la barre
*** 'bar_delim' : couleur des délimiteurs pour la barre
*** 'bar_bg' : couleur de fond pour la barre
* 'visible' :
** '1' : le pseudo est visible
** '0' : le pseudo est caché

Valeur de retour :

* pointeur vers le nouveau pseudo, NULL en cas d'erreur

Exemple en C :

[source,C]
----
struct t_gui_nick *my_nick =
    weechat_nicklist_add_nick (my_buffer, my_group,
                               "test_nick",
                               (nick_away) ? "weechat.color.nicklist_away" : "bar_fg",
                               "@", "lightgreen",
                               1);
----

Script (Python) :

[source,python]
----
# prototype
nick = weechat.nicklist_add_nick(buffer, group, name, color, prefix, prefix_color, visible)

# exemple
if nick_away:
    color = "weechat.color.nicklist_away"
else:
    color = "bar_fg"
nick = weechat.nicklist_add_nick(my_buffer, my_group, "test_nick", color, "@", "lightgreen", 1)
----

==== weechat_nicklist_search_nick

Rechercher un pseudo dans la liste des pseudos.

Prototype :

[source,C]
----
struct t_gui_nick *weechat_nicklist_search_nick (struct t_gui_buffer *buffer,
                                                 struct t_gui_nick_group *from_group,
                                                 const char *name);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'from_group' : recherche depuis ce groupe seulement, si NULL, alors recherche
  dans toute la liste des pseudos
* 'name' : nom du pseudo à rechercher

Valeur de retour :

* pointeur vers le pseudo trouvé, NULL s'il n'est pas trouvé

Exemple en C :

[source,C]
----
struct t_gui_nick *ptr_nick = weechat_nicklist_search_nick (my_buffer,
                                                            NULL, "test_nick");
----

Script (Python) :

[source,python]
----
# prototype
nick = weechat.nicklist_search_nick(buffer, from_group, name)

# exemple
nick = weechat.nicklist_search_nick(my_buffer, "", "test_nick")
----

==== weechat_nicklist_remove_group

Supprimer un groupe de la liste des pseudos.

Prototype :

[source,C]
----
void weechat_nicklist_remove_group (struct t_gui_buffer *buffer,
                                    struct t_gui_nick_group *group);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'group' : pointeur vers le groupe à supprimer (tous les sous-groupes/pseudos
  seront supprimés également)

Exemple en C :

[source,C]
----
weechat_nicklist_remove_group (my_buffer, my_group);
----

Script (Python) :

[source,python]
----
# prototype
weechat.nicklist_remove_group(buffer, group)

# exemple
weechat.nicklist_remove_group(my_buffer, my_group)
----

==== weechat_nicklist_remove_nick

Supprimer un pseudo de la liste des pseudos.

Prototype :

[source,C]
----
void weechat_nicklist_remove_nick (struct t_gui_buffer *buffer,
                                   struct t_gui_nick *nick);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'nick' : pointeur vers le pseudo à supprimer

Exemple en C :

[source,C]
----
weechat_nicklist_remove_nick (my_buffer, my_nick);
----

Script (Python) :

[source,python]
----
# prototype
weechat.nicklist_remove_nick(buffer, nick)

# exemple
weechat.nicklist_remove_nick(my_buffer, my_nick)
----

==== weechat_nicklist_remove_all

Supprimer tous les groupes/pseudos de la liste des pseudos.

Prototype :

[source,C]
----
void weechat_nicklist_remove_all (struct t_gui_buffer *buffer);
----

Paramètres :

* 'buffer' : pointeur vers le tampon

Exemple en C :

[source,C]
----
weechat_nicklist_remove_all (my_buffer);
----

Script (Python) :

[source,python]
----
# prototype
weechat.nicklist_remove_all(buffer)

# exemple
weechat.nicklist_remove_all(my_buffer)
----

==== weechat_nicklist_get_next_item

_WeeChat ≥ 0.3.7._

Retourner le prochain groupe ou pseudo de la liste des pseudos (utilisé
principalement pour afficher la liste des pseudos).

Prototype :

[source,C]
----
void weechat_nicklist_get_next_item (struct t_gui_buffer *buffer,
                                     struct t_gui_nick_group **group,
                                     struct t_gui_nick **nick);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'group' : pointeur vers un pointeur sur le groupe
* 'nick' : pointeur vers un pointeur sur le pseudo

Exemple en C :

[source,C]
----
struct t_gui_nick_group *ptr_group;
struct t_gui_nick *ptr_nick;

ptr_group = NULL;
ptr_nick = NULL;
weechat_nicklist_get_next_item (buffer, &ptr_group, &ptr_nick);
while (ptr_group || ptr_nick)
{
    if (ptr_nick)
    {
        /* pseudo */
        /* ... */
    }
    else
    {
        /* groupe */
        /* ... */
    }
    weechat_nicklist_get_next_item (buffer, &ptr_group, &ptr_nick);
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_nicklist_group_get_integer

_WeeChat ≥ 0.3.4._

Retourner une valeur entière pour une propriété du groupe.

Prototype :

[source,C]
----
int weechat_nicklist_group_get_integer (struct t_gui_buffer *buffer,
                                        struct t_gui_nick_group *group,
                                        const char *property);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'group' : pointeur vers le groupe
* 'property' : nom de la propriété :
** 'visible' : 1 si le groupe est visible, sinon 0
** 'level' : niveau du groupe (la racine est 0)

Valeur de retour :

* valeur entière de la propriété

Exemple en C :

[source,C]
----
int visible = weechat_nicklist_group_get_integer (buffer, group, "visible");
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.nicklist_group_get_integer(buffer, group, property)

# exemple
visible = weechat.nicklist_group_get_integer(buffer, group, "visible")
----

==== weechat_nicklist_group_get_string

_WeeChat ≥ 0.3.4._

Retourner la valeur d'une propriété du groupe sous forme de chaîne.

Prototype :

[source,C]
----
const char *weechat_nicklist_group_get_string (struct t_gui_buffer *buffer,
                                               struct t_gui_nick_group *group,
                                               const char *property);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'group' : pointeur vers le groupe
* 'property' : nom de la propriété :
** 'name' : nom du groupe
** 'color' : couleur du groupe dans la liste des pseudos

Valeur de retour :

* valeur de la propriété, sous forme de chaîne

Exemple en C :

[source,C]
----
const char *color = weechat_nicklist_group_get_string (buffer, group, "color");
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.nicklist_group_get_string(buffer, group, property)

# exemple
color = weechat.nicklist_group_get_string(buffer, group, "color")
----

==== weechat_nicklist_group_get_pointer

_WeeChat ≥ 0.3.4._

Retourner la valeur d'une propriété du groupe sous forme d'un pointeur.

Prototype :

[source,C]
----
void *weechat_nicklist_group_get_pointer (struct t_gui_buffer *buffer,
                                          struct t_gui_nick_group *group,
                                          const char *property);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'group' : pointeur vers le groupe
* 'property' : nom de la propriété :
** 'parent' : pointeur vers le groupe parent

Valeur de retour :

* valeur de la propriété, sous forme de pointeur

Exemple en C :

[source,C]
----
struct t_gui_nick_group *parent = weechat_nicklist_group_get_pointer (buffer, group, "parent");
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.nicklist_group_get_pointer(buffer, group, property)

# exemple
parent = weechat.nicklist_group_get_pointer(buffer, group, "parent")
----

==== weechat_nicklist_group_set

_WeeChat ≥ 0.3.4._

Affecter une valeur à une propriété d'un groupe.

Prototype :

[source,C]
----
void weechat_nicklist_group_set (struct t_gui_buffer *buffer,
                                 struct t_gui_nick_group *group,
                                 const char *property,
                                 const char *value);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'group' : pointeur vers le groupe
* 'property' : nom de la propriété (voir le tableau ci-dessous)
* 'value' : nouvelle valeur pour la propriété

Propriétés :

[width="100%",cols="^2,4,8",options="header"]
|===
| Nom | Valeur | Description

| color | nom d'option de couleur WeeChat |
  Voir le paramètre "color" de la fonction
  <<_weechat_nicklist_add_group,weechat_nicklist_add_group>>

| visible | "0", "1" |
  "0" = groupe caché, "1" = groupe visible
|===

Exemples en C :

[source,C]
----
/* changer la couleur du groupe en "bar_fg" */
weechat_nicklist_group_set (buffer, group, "color", "bar_fg");

/* changer la couleur du groupe en jaune */
weechat_nicklist_group_set (buffer, group, "color", "yellow");

/* cacher le groupe dans la liste des pseudos */
weechat_nicklist_group_set (buffer, group, "visible", "0");
----

Script (Python) :

[source,python]
----
# prototype
weechat.nicklist_group_set(buffer, group, property, value)

# exemples

# changer la couleur du groupe en "bar_fg"
weechat.nicklist_group_set(buffer, group, "color", "bar_fg")

# changer la couleur du groupe en jaune
weechat.nicklist_group_set(buffer, group, "color", "yellow")

# cacher le groupe dans la liste des pseudos
weechat.nicklist_group_set(buffer, group, "visible", "0")
----

==== weechat_nicklist_nick_get_integer

_WeeChat ≥ 0.3.4._

Retourner une valeur entière pour une propriété du pseudo.

Prototype :

[source,C]
----
int weechat_nicklist_nick_get_integer (struct t_gui_buffer *buffer,
                                       struct t_gui_nick *nick,
                                       const char *property);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'nick' : pointeur vers le pseudo
* 'property' : nom de la propriété :
** 'visible' : 1 si le pseudo est visible, sinon 0

Valeur de retour :

* valeur entière de la propriété

Exemple en C :

[source,C]
----
int visible = weechat_nicklist_nick_get_integer (buffer, nick, "visible");
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.nicklist_nick_get_integer(buffer, nick, property)

# exemple
visible = weechat.nicklist_nick_get_integer(buffer, nick, "visible")
----

==== weechat_nicklist_nick_get_string

_WeeChat ≥ 0.3.4._

Retourner la valeur d'une propriété du pseudo sous forme de chaîne.

Prototype :

[source,C]
----
const char *weechat_nicklist_nick_get_string (struct t_gui_buffer *buffer,
                                              struct t_gui_nick *nick,
                                              const char *property);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'nick' : pointeur vers le pseudo
* 'property' : nom de la propriété :
** 'name' : nom du pseudo
** 'color' : couleur du pseudo dans la liste des pseudos
** 'prefix' : préfixe du pseudo
** 'prefix_color' : couleur du préfixe dans la liste des pseudos

Valeur de retour :

* valeur de la propriété, sous forme de chaîne

Exemple en C :

[source,C]
----
const char *color = weechat_nicklist_nick_get_string (buffer, nick, "color");
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.nicklist_nick_get_string(buffer, nick, property)

# exemple
color = weechat.nicklist_nick_get_string(buffer, nick, "color")
----

==== weechat_nicklist_nick_get_pointer

_WeeChat ≥ 0.3.4._

Retourner la valeur d'une propriété du pseudo sous forme d'un pointeur.

Prototype :

[source,C]
----
void *weechat_nicklist_nick_get_pointer (struct t_gui_buffer *buffer,
                                         struct t_gui_nick *nick,
                                         const char *property);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'nick' : pointeur vers le pseudo
* 'property' : nom de la propriété :
** 'group' : pointeur vers le groupe contenant ce pseudo

Valeur de retour :

* valeur de la propriété, sous forme de pointeur

Exemple en C :

[source,C]
----
struct t_gui_nick_group *group = weechat_nicklist_nick_get_pointer (buffer, nick, "group");
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.nicklist_nick_get_pointer(buffer, nick, property)

# exemple
group = weechat.nicklist_nick_get_pointer(buffer, nick, "group")
----

==== weechat_nicklist_nick_set

_WeeChat ≥ 0.3.4._

Affecter une valeur à une propriété d'un pseudo.

Prototype :

[source,C]
----
void weechat_nicklist_nick_set (struct t_gui_buffer *buffer,
                                struct t_gui_nick *nick,
                                const char *property,
                                const char *value);
----

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'nick' : pointeur vers le pseudo
* 'property' : nom de la propriété (voir le tableau ci-dessous)
* 'value' : nouvelle valeur pour la propriété

Propriétés :

[width="100%",cols="^2,4,8",options="header"]
|===
| Nom | Valeur | Description

| color | nom d'option de couleur WeeChat |
  Voir le paramètre "color" de la fonction
  <<_weechat_nicklist_add_nick,weechat_nicklist_add_nick>>

| prefix | toute chaîne |
  Préfixe du pseudo

| prefix_color | nom d'option de couleur WeeChat |
  Voir le paramètre "prefix_color" de la fonction
  <<_weechat_nicklist_add_nick,weechat_nicklist_add_nick>>

| visible | "0", "1" |
  "0" = pseudo caché, "1" = pseudo visible
|===

Exemples en C :

[source,C]
----
/* changer la couleur du pseudo en cyan */
weechat_nicklist_nick_set (buffer, nick, "color", "cyan");

/* changer le préfixe en "+" */
weechat_nicklist_nick_set (buffer, nick, "prefix", "+");

/* changer la couleur du préfixe en jaune */
weechat_nicklist_nick_set (buffer, nick, "prefix_color", "yellow");

/* cacher le pseudo dans la liste des pseudos */
weechat_nicklist_nick_set (buffer, nick, "visible", "0");
----

Script (Python) :

[source,python]
----
# prototype
weechat.nicklist_nick_set(buffer, nick, property, value)

# exemples

# changer la couleur du pseudo en cyan
weechat.nicklist_nick_set(buffer, nick, "color", "cyan")

# changer le préfixe en "+"
weechat.nicklist_nick_set(buffer, nick, "prefix", "+")

# changer la couleur du préfixe en jaune
weechat.nicklist_nick_set(buffer, nick, "prefix_color", "yellow")

# cacher le pseudo dans la liste des pseudos
weechat.nicklist_nick_set(buffer, nick, "visible", "0")
----

[[bars]]
=== Barres

Fonctions pour les barres.

==== weechat_bar_item_search

Rechercher un objet de barre.

Prototype :

[source,C]
----
struct t_gui_bar_item *weechat_bar_item_search (const char *name);
----

Paramètres :

* 'name' : nom de l'objet de barre

Valeur de retour :

* pointeur vers l'objet de barre trouvé, NULL s'il n'a pas été trouvé

Exemple en C :

[source,C]
----
struct t_gui_bar_item *bar_item = weechat_bar_item_search ("myitem");
----

Script (Python) :

[source,python]
----
# prototype
bar_item = weechat.bar_item_search(name)

# exemple
bar_item = weechat.bar_item_search("myitem")
----

==== weechat_bar_item_new

_Mis à jour dans la 0.4.2._

Créer un nouvel objet de barre.

Prototype :

[source,C]
----
struct t_gui_bar_item *weechat_bar_item_new (const char *name,
                                             char *(*build_callback)(void *data,
                                                                     struct t_gui_bar_item *item,
                                                                     struct t_gui_window *window,
                                                                     struct t_gui_buffer *buffer,
                                                                     struct t_hashtable *extra_info),
                                             void *build_callback_data);
----

Paramètres :

* 'name' : nom de l'objet de barre
* 'build_callback' : fonction appelée lorsque l'objet est construit, paramètres
  et valeur de retour :
** 'void *data' : pointeur
** 'struct t_gui_bar_item *item' : pointeur vers l'objet de barre
** 'struct t_gui_window *window' : pointeur vers la fenêtre (NULL lors d'un
   appel pour une barre "root")
** 'struct t_gui_buffer *buffer' : tampon affiché dans la fenêtre (si la fenêtre
   est NULL alors c'est le tampon courant) ou tampon passé dans l'objet de
   barre avec la syntaxe : "@buffer:item" _(WeeChat ≥ 0.4.2)_
** 'struct t_hashtable *extra_info' : toujours NULL (le paramètre est réservé
   pour une version future) _(WeeChat ≥ 0.4.2)_
** valeur de retour : contenu de l'objet de barre
* 'build_callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouvel objet de barre, NULL en cas d'erreur

Exemple en C :

[source,C]
----
char *
my_build_callback (void *data,
                   struct t_gui_bar_item *item,
                   struct t_gui_window *window,
                   struct t_gui_buffer *buffer,
                   struct t_hashtable *extra_info)
{
    return strdup ("mon contenu");
}

struct t_gui_bar_item *my_item = weechat_bar_item_new ("myitem",
                                                       &my_build_callback,
                                                       NULL);
----

Script (Python) :

[IMPORTANT]
Pour la compatibilité avec les versions ≤ 0.4.1, le "callback" par défaut a
seulement 3 paramètres : 'data', 'item' et 'window' (pas de 'buffer' et
'extra_info'). +
Pour utiliser le callback avec tous les paramètres, vous devez ajouter "(extra)"
avant le nom, voir l'exemple ci-dessous (supporté seulement dans
WeeChat ≥ 0.4.2).

[source,python]
----
# prototype
bar_item = weechat.bar_item_new(name, build_callback, build_callback_data)

# exemple (callback sans "buffer" et "extra_info")
def my_build_callback(data, item, window):
    return "mon contenu"

bar_item = weechat.bar_item_new("myitem", "my_build_callback", "")

# example (callback avec tous les paramètres, pour WeeChat ≥ 0.4.2)
def my_build_callback2(data, item, window, buffer, extra_info):
    return "mon contenu"

bar_item2 = weechat.bar_item_new("(extra)myitem2", "my_build_callback2", "")  # WeeChat ≥ 0.4.2
----

==== weechat_bar_item_update

Mettre à jour le contenu d'un objet de barre, en appelant son "callback" de
construction.

Prototype :

[source,C]
----
void weechat_bar_item_update (const char *name);
----

Paramètres :

* 'name' : nom de l'objet de barre

Exemple en C :

[source,C]
----
weechat_bar_item_update ("myobjet");
----

Script (Python) :

[source,python]
----
# prototype
weechat.bar_item_update(name)

# exemple
weechat.bar_item_update("myitem")
----

==== weechat_bar_item_remove

Supprimer un objet de barre.

Prototype :

[source,C]
----
void weechat_bar_item_remove (struct t_gui_bar_item *item);
----

Paramètres :

* 'item' : bar item pointer

Exemple en C :

[source,C]
----
weechat_bar_item_remove (&my_item);
----

Script (Python) :

[source,python]
----
# prototype
weechat.bar_item_remove(item)

# exemple
weechat.bar_item_remove(myitem)
----

==== weechat_bar_search

Rechercher une barre.

Prototype :

[source,C]
----
struct t_gui_bar *weechat_bar_search (const char *name);
----

Paramètres :

* 'name' : nom de la barre

Valeur de retour :

* pointeur vers la barre trouvée, NULL si elle n'est pas trouvée

Exemple en C :

[source,C]
----
struct t_gui_bar *bar = weechat_bar_search ("my_barre");
----

Script (Python) :

[source,python]
----
# prototype
bar = weechat.bar_search(name)

# exemple
bar = weechat.bar_search("mybar")
----

==== weechat_bar_new

Créer une nouvelle barre.

Prototype :

[source,C]
----
struct t_gui_bar *weechat_bar_new (const char *name,
                                   const char *hidden,
                                   const char *priority,
                                   const char *type,
                                   const char *condition,
                                   const char *position,
                                   const char *filling_top_bottom,
                                   const char *filling_left_right,
                                   const char *size,
                                   const char *size_max,
                                   const char *color_fg,
                                   const char *color_delim,
                                   const char *color_bg,
                                   const char *separator,
                                   const char *items);
----

Paramètres :

* 'name' : nom de la barre
* 'hidden' :
** 'on' : la barre est cachée
** 'off' : la barre est visible
* 'priority' : priorité de la barre (nombre entier)
* 'type' :
** 'root' : la barre est affichée une seule fois, hors des fenêtres
** 'window' : la barre est affichée dans chaque fenêtre
* 'condition' : condition pour afficher la barre :
** 'active' : la barre est affichée dans la fenêtre active seulement
** 'inactive' : la barre est affichée dans les fenêtres inactives seulement
** 'nicklist' : la barre est affichée dans les fenêtres possédant une liste des
   pseudos
** expression évaluée : voir le chapitre sur les barres dans le
   'Guide utilisateur WeeChat'
* 'position' : 'top' (en haut), 'bottom' (en bas), 'left' (à gauche) ou 'right'
  (à droite)
* 'filling_top_bottom' :
** 'horizontal' : les objets sont remplis horizontalement (avec un espace
   entre chaque objet)
** 'vertical' : les objets sont remplis verticalement (avec une nouvelle ligne
   entre chaque objet)
** 'columns_horizontal' : les objets sont remplis horizontalement, affichés
   sous forme de colonnes
** 'columns_vertical' : les objets sont remplis verticalement, affichés sous
   forme de colonnes
* 'filling_left_right' :
** 'horizontal' : les objets sont remplis horizontalement (avec un espace
   entre chaque objet)
** 'vertical' : les objets sont remplis verticalement (avec une nouvelle ligne
   entre chaque objet)
** 'columns_horizontal' : les objets sont remplis horizontalement, affichés
   sous forme de colonnes
** 'columns_vertical' : les objets sont remplis verticalement, affichés sous
   forme de colonnes
* 'size' : taille de la barre en caractères (0 indique une taille automatique)
* 'size_max' : taille maximum de la barre (0 pour pas de maximum)
* 'color_fg' : couleur du texte dans la barre
* 'color_delim' : couleur pour les délimiteurs dans la barre
* 'color_bg' : couleur de fond pour la barre
* 'separator' :
** 'on' : la barre a un séparateur avec les autres fenêtres/barres
** 'off' : pas de séparateur
* 'items' : liste des objets dans la barre, séparés par une virgule (espace
  entre les objets), ou "+" (objets collés)

Valeur de retour :

* pointeur vers la nouvelle barre, NULL en cas d'erreur

Exemple en C :

[source,C]
----
struct t_gui_bar *my_bar = weechat_bar_new ("mybar",
                                            "off",
                                            "100",
                                            "window",
                                            "",
                                            "top",
                                            "horizontal",
                                            "vertical",
                                            "0",
                                            "5",
                                            "default",
                                            "cyan",
                                            "blue",
                                            "off",
                                            "time,buffer_number+buffer_name");
----

Script (Python) :

[source,python]
----
# prototype
bar = weechat.bar_new(name, hidden, priority, type, condition, position,
    filling_top_bottom, filling_left_right, size, size_max,
    color_fg, color_delim, color_bg, separator, items)

# exemple
bar = weechat.bar_new("mybar", "off", "100", "window", "", "top", "horizontal", "vertical",
    "0", "5", "default", "cyan", "blue", "off", "time,buffer_number+buffer_name")
----

==== weechat_bar_set

Affecter une nouvelle valeur pour une propriété de la barre.

Prototype :

[source,C]
----
int weechat_bar_set (struct t_gui_bar *bar, const char *property,
                     const char *value);
----

Paramètres :

* 'bar' : pointeur vers la barre
* 'property' : name, hidden, priority, conditions, position, filling_top_bottom,
  filling_left_right, size, size_max, color_fg, color_delim, color_bg,
  separator, items (voir <<_weechat_bar_new,weechat_bar_new>>)
* 'value' : nouvelle valeur pour la propriété

Valeur de retour :

* 1 si la valeur a été affectée, 0 en cas d'erreur

Exemple en C :

[source,C]
----
weechat_bar_set (my_bar, "position", "bottom");
----

Script (Python) :

[source,python]
----
# prototype
weechat.bar_set(bar, property, value)

# exemple
weechat.bar_set(my_bar, "position", "bottom")
----

==== weechat_bar_update

Mettre à jour le contenu d'une barre à l'écran.

Prototype :

[source,C]
----
void weechat_bar_update (const char *name);
----

Paramètres :

* 'name' : nom de la barre

Exemple en C :

[source,C]
----
weechat_bar_update ("mybar");
----

Script (Python) :

[source,python]
----
# prototype
weechat.bar_update(name)

# exemple
weechat.bar_update("mybar")
----

==== weechat_bar_remove

Supprimer une barre.

Prototype :

[source,C]
----
void weechat_bar_remove (struct t_gui_bar *bar);
----

Paramètres :

* 'bar' : pointeur vers la barre

Exemple en C :

[source,C]
----
weechat_bar_remove (my_bar);
----

Script (Python) :

[source,python]
----
# prototype
weechat.bar_remove(bar)

# exemple
weechat.bar_remove(my_bar)
----

[[commands]]
=== Commandes

Fonctions pour exécuter des commandes WeeChat.

==== weechat_command

_Mis à jour dans la 1.1._

Exécuter une commande.

Prototype :

[source,C]
----
int weechat_command (struct t_gui_buffer *buffer, const char *command);
----

Paramètres :

* 'buffer' : pointeur vers le tampon (la commande est exécutée sur ce tampon,
  NULL pour le tampon courant)
* 'command' : commande à exécuter (si elle commence par "/"), ou texte à
  envoyer au tampon

Valeur de retour : (_WeeChat ≥ 1.1_)

* 'WEECHAT_RC_OK' si ok
* 'WEECHAT_RC_ERROR' si erreur

Exemple en C :

[source,C]
----
int rc;
rc = weechat_command (weechat_buffer_search ("irc", "freenode.#weechat"),
                      "/whois FlashCode");
----

Script (Python) :

[source,python]
----
# prototype
weechat.command(buffer, command)

# exemple
rc = weechat.command(weechat.buffer_search("irc", "freenode.#weechat"), "/whois FlashCode")
----

[[network]]
=== Réseau

Fonctions pour le réseau.

==== weechat_network_pass_proxy

Établir une connexion/authentification avec un proxy.

[IMPORTANT]
Cette fonction est bloquante sur l'appel à connect(), donc elle doit être
appelée sans un processus issu d'un "fork", pour ne pas bloquer WeeChat.

Prototype :

[source,C]
----
int weechat_network_pass_proxy (const char *proxy,
                                int sock,
                                const char *address,
                                int port);
----

Paramètres :

* 'proxy' : nom du proxy à utiliser
* 'sock' : socket à utiliser
* 'address' : adresse (nom de machine ou adresse IP)
* 'port' : port

Valeur de retour :

* 1 si la connexion est ok, 0 en cas d'erreur

Exemple en C :

[source,C]
----
if (weechat_network_pass_proxy ("mon_proxy", sock, "chat.freenode.net", 6667))
{
    /* OK */
}
else
{
    /* erreur */
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_network_connect_to

_Mis à jour dans la 0.4.3._

Établir une connexion à une machine distante.

[IMPORTANT]
Cette fonction est bloquante sur l'appel à connect(), donc elle doit être
appelée sans un processus issu d'un "fork", pour ne pas bloquer WeeChat.

Prototype :

[source,C]
----
int weechat_network_connect_to (const char *proxy,
                                struct sockaddr *address,
                                socklen_t address_length);
----

Paramètres :

* 'proxy' : nom du proxy à utiliser
* 'address' : adresse où se connecter (avec le port)
* 'address_length' : longueur du paramètre 'address'

Valeur de retour :

* numéro de socket (>= 0) si la connexion est OK, -1 en cas d'erreur

Exemple en C :

[source,C]
----
struct sockaddr *addr;
socklen_t length;
int sock;

/* allouer/définir l'adresse et le port dans 'addr', définir 'length' */
/* ... */

sock = weechat_network_connect_to (NULL, addr, length);
if (sock >= 0)
{
    /* OK */
}
else
{
    /* erreur */
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

[[infos]]
=== Infos

Fonctions pour obtenir des informations.

==== weechat_info_get

Retourner une information, sous forme de chaîne, de WeeChat ou d'une extension.

Prototype :

[source,C]
----
const char *weechat_info_get (const char *info_name, const char *arguments);
----

Paramètres :

* 'info_name' : nom de l'information à lire (voir le tableau ci-dessous)
* 'arguments' : paramètres pour l'information demandée (optionnels, NULL si
  aucun paramètre n'est nécessaire)

Valeur de retour :

* chaîne avec l'information demandée, NULL en cas d'erreur

Infos :

include::autogen/plugin_api/infos.asciidoc[]

Exemple en C :

[source,C]
----
weechat_printf (NULL, "La version de WeeChat est : %s (compilée le %s)",
                weechat_info_get ("version", NULL),
                weechat_info_get ("date", NULL));
weechat_printf (NULL, "Le répertoire de WeeChat est : %s",
                weechat_info_get ("weechat_dir", NULL));
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.info_get(info_name, arguments)

# exemple
weechat.prnt("", "La version de WeeChat est : %s (compilée le %s)"
    % (weechat.info_get("version", ""), weechat.info_get("date", ""))
weechat.prnt("", "Le répertoire de WeeChat est : %s" % weechat.info_get("weechat_dir", ""))
----

==== weechat_info_get_hashtable

_WeeChat ≥ 0.3.4._

Retourner une information, sous forme de table de hachage, de WeeChat ou d'une
extension.

Prototype :

[source,C]
----
struct t_hashtable *weechat_info_get_hashtable (const char *info_name,
                                                struct t_hashtable *hashtable);
----

Paramètres :

* 'info_name' : nom de l'information à lire (voir le tableau ci-dessous)
* 'hashtable' : table de hachage avec les paramètres (dépendant de l'information
  demandée) (optionnel, NULL si aucun paramètre n'est nécessaire)

Valeur de retour :

* table de hachage avec l'information demandée, NULL en cas d'erreur

Infos :

include::autogen/plugin_api/infos_hashtable.asciidoc[]

Exemple en C :

[source,C]
----
struct t_hashtable *hashtable_in, *hashtable_out;

hashtable_in = weechat_hashtable_new (8,
                                      WEECHAT_HASHTABLE_STRING,
                                      WEECHAT_HASHTABLE_STRING,
                                      NULL,
                                      NULL);
if (hashtable_in)
{
    weechat_hashtable_set (hashtable_in, "message",
                           ":nick!user@host PRIVMSG #weechat :message ici");
    hashtable_out = weechat_info_get_hashtable ("irc_message_parse",
                                                hashtable_in);
    /*
     * maintenant hashtable_out a les clés/valeurs suivantes :
     *   "nick"     : "nick"
     *   "host"     : "nick!user@host"
     *   "command"  : "PRIVMSG"
     *   "channel"  : "#weechat"
     *   "arguments": "#weechat :message ici"
     */
    weechat_hashtable_free (hashtable_in);
    weechat_hashtable_free (hashtable_out);
}
----

Script (Python) :

[source,python]
----
# prototype
dict = weechat.info_get_hashtable(info_name, dict_in)

# exemple
dict_in = {"message": ":nick!user@host PRIVMSG #weechat :message ici"}
weechat.prnt("", "message analysé: %s"
             % weechat.info_get_hashtable("irc_message_parse", dict_in))
----

[[infolists]]
=== Infolists

Une "infolist" est une liste composée d'objets ("items"). Chaque objet contient
des variables.

Par exemple, l'infolist "irc_server" a N objets (N est le nombre de serveurs
IRC définis). Pour chaque objet, il y a des variables, comme "name", "buffer",
"is_connected", ...

Chaque variable a un type et une valeur. Les types possibles sont :

* 'integer' : nombre entier
* 'string' : chaîne de caractères
* 'pointer' : pointeur
* 'buffer' : tampon avec une taille fixe, peut contenir n'importe quel type de
  données
* 'time' : date/heure

==== weechat_infolist_new

Créer une "infolist".

Prototype :

[source,C]
----
struct t_infolist *weechat_infolist_new ();
----

Valeur de retour :

* pointeur vers la nouvelle "infolist"

Exemple en C :

[source,C]
----
struct t_infolist *infolist = weechat_infolist_new ();
----

Script (Python) :

[source,python]
----
# prototype
infolist = weechat.infolist_new()

# exemple
infolist = weechat.infolist_new()
----

==== weechat_infolist_new_item

Ajouter un objet dans l'infolist.

Prototype :

[source,C]
----
struct t_infolist_item *weechat_infolist_new_item (struct t_infolist *infolist);
----

Paramètres :

* 'infolist' : pointeur vers l'infolist

Valeur de retour :

* pointeur vers le nouvel objet

Exemple en C :

[source,C]
----
struct t_infolist_item *item = weechat_infolist_new_item (infolist);
----

Script (Python) :

[source,python]
----
# prototype
item = weechat.infolist_new_item(infolist)

# exemple
item = weechat.infolist_new_item(infolist)
----

==== weechat_infolist_new_var_integer

Ajouter une variable de type "integer" dans l'objet de l'infolist.

Prototype :

[source,C]
----
struct t_infolist_var *weechat_infolist_new_var_integer (struct t_infolist_item *item,
                                                         const char *name,
                                                         int value);
----

Paramètres :

* 'item' : pointeur vers l'objet de l'infolist
* 'name' : nom de la variable
* 'value' : valeur

Valeur de retour :

* pointeur vers la nouvelle variable

Exemple en C :

[source,C]
----
struct t_infolist_var *var = weechat_infolist_new_var_integer (item,
                                                               "mon_entier",
                                                               123);
----

Script (Python) :

[source,python]
----
# prototype
var = weechat.infolist_new_var_integer(item, name, value)

# exemple
var = weechat.infolist_new_var_integer(item, "mon_entier", 123)
----

==== weechat_infolist_new_var_string

Ajouter une variable de type "string" dans l'objet de l'infolist.

Prototype :

[source,C]
----
struct t_infolist_var *weechat_infolist_new_var_string (struct t_infolist_item *item,
                                                        const char *name,
                                                        const char *value);
----

Paramètres :

* 'item' : pointeur vers l'objet de l'infolist
* 'name' : nom de la variable
* 'value' : valeur

Valeur de retour :

* pointeur vers la nouvelle variable

Exemple en C :

[source,C]
----
struct t_infolist_var *var = weechat_infolist_new_var_string (item,
                                                              "ma_chaine",
                                                              "valeur");
----

Script (Python) :

[source,python]
----
# prototype
var = weechat.infolist_new_var_string(item, name, value)

# exemple
var = weechat.infolist_new_var_string(item, "ma_chaine", "valeur")
----

==== weechat_infolist_new_var_pointer

Ajouter une variable de type "pointer" dans l'objet de l'infolist.

Prototype :

[source,C]
----
struct t_infolist_var *weechat_infolist_new_var_pointer (struct t_infolist_item *item,
                                                         const char *name,
                                                         void *pointer);
----

Paramètres :

* 'item' : pointeur vers l'objet de l'infolist
* 'name' : nom de la variable
* 'pointer' : pointeur

Valeur de retour :

* pointeur vers la nouvelle variable

Exemple en C :

[source,C]
----
struct t_infolist_var *var = weechat_infolist_new_var_pointer (item,
                                                               "mon_pointeur",
                                                               &pointer);
----

Script (Python) :

[source,python]
----
# prototype
var = weechat.infolist_new_var_pointer(item, name, pointer)

# exemple
var = weechat.infolist_new_var_pointer(item, "mon_pointeur", pointer)
----

==== weechat_infolist_new_var_buffer

Ajouter une variable de type "buffer" dans l'objet de l'infolist.

Prototype :

[source,C]
----
struct t_infolist_var *weechat_infolist_new_var_buffer (struct t_infolist_item *item,
                                                        const char *name,
                                                        void *pointer,
                                                        int size);
----

Paramètres :

* 'item' : pointeur vers l'objet de l'infolist
* 'name' : nom de la variable
* 'pointer' : pointeur
* 'size' : taille du tampon

Valeur de retour :

* pointeur vers la nouvelle variable

Exemple en C :

[source,C]
----
char buffer[256];
/* ... */
struct t_infolist_var *var = weechat_infolist_new_var_buffer (item,
                                                              "mon_buffer",
                                                              buffer,
                                                              sizeof (buffer));
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_infolist_new_var_time

Ajouter une variable de type "time" dans l'objet de l'infolist.

Prototype :

[source,C]
----
struct t_infolist_var *weechat_infolist_new_var_time (struct t_infolist_item *item,
                                                      const char *name,
                                                      time_t time);
----

Paramètres :

* 'item' : pointeur vers l'objet de l'infolist
* 'name' : nom de la variable
* 'time' : valeur

Valeur de retour :

* pointeur vers la nouvelle variable

Exemple en C :

[source,C]
----
struct t_infolist_var *var = weechat_infolist_new_var_time (item,
                                                            "mon_time",
                                                            time (NULL));
----

Script (Python) :

[source,python]
----
# prototype
var = weechat.infolist_new_var_time(item, name, time)

# exemple
var = weechat.infolist_new_var_time(item, "mon_time", int(time.time()))
----

==== weechat_infolist_get

Retourner une "infolist" de WeeChat ou d'une extension.

[IMPORTANT]
Le contenu d'une infolist est une duplication des données réelles. Donc si vous
demandez une infolist avec beaucoup de données (comme "buffer_lines"), WeeChat
allouera de la mémoire pour dupliquer toutes les données, et cela peut prendre
du temps. +
Au lieu d'utiliser une grosse infolist, il est préférable d'utiliser un hdata
(mais l'infolist peut contenir plus de données que le hdata, qui contient des
données brutes), voir <<hdata,hdata>>.

Prototype :

[source,C]
----
struct t_infolist *weechat_infolist_get (const char *infolist_name,
                                         void *pointer,
                                         const char *arguments);
----

Paramètres :

* 'infolist_name' : nom de l'infolist à lire (voir le tableau ci-dessous)
* 'pointer' : pointeur vers un objet, pour n'obtenir que celui-ci dans
  l'infolist (optionnel, peut être NULL)
* 'arguments' : paramètres pour l'infolist demandée (optionnels, NULL si aucun
  paramètre n'est nécessaire)

Valeur de retour :

* pointeur vers l'infolist, NULL en cas d'erreur

Infolists :

include::autogen/plugin_api/infolists.asciidoc[]

Exemple en C :

[source,C]
----
struct t_infolist *infolist = weechat_infolist_get ("irc_server", NULL, NULL);
----

Script (Python) :

[source,python]
----
# prototype
infolist = weechat.infolist_get(infolist_name, pointer, arguments)

# exemple
infolist = weechat.infolist_get("irc_server", "", "")
----

==== weechat_infolist_next

Déplacer le "curseur" vers l'objet suivant dans l'infolist. Le premier appel à
cette fonction sur une infolist déplace le curseur sur le premier objet de
l'infolist.

Prototype :

[source,C]
----
int weechat_infolist_next (struct t_infolist *infolist);
----

Paramètres :

* 'infolist' : pointeur vers l'infolist

Valeur de retour :

* 1 si le curseur a été déplacé sur l'objet suivant, 0 si la fin de la liste a
  été atteinte

Exemple en C :

[source,C]
----
if (weechat_infolist_next (infolist))
{
    /* lecture des variables dans l'objet... */
}
else
{
    /* pas d'autre objet disponible */
}
----

Script (Python) :

[source,python]
----
# prototype
rc = weechat.infolist_next(infolist)

# exemple
rc = weechat.infolist_next(infolist)
if rc:
    # lecture des variables dans l'objet...
else:
    # pas d'autre objet disponible
----

==== weechat_infolist_prev

Déplacer le "curseur" vers l'objet précédent dans l'infolist. Le premier appel à
cette fonction sur une infolist déplace le curseur sur le dernier objet de
l'infolist.

Prototype :

[source,C]
----
int weechat_infolist_prev (struct t_infolist *infolist);
----

Paramètres :

* 'infolist' : pointeur vers l'infolist

Valeur de retour :

* 1 si le curseur a été déplacé sur l'objet précédent, 0 si le début de liste a
  été atteint

Exemple en C :

[source,C]
----
if (weechat_infolist_prev (infolist))
{
    /* lecture des variables dans l'objet... */
}
else
{
    /* pas d'autre objet disponible */
}
----

Script (Python) :

[source,python]
----
# prototype
rc = weechat.infolist_prev(infolist)

# exemple
rc = weechat.infolist_prev(infolist)
if rc:
    # lecture des variables dans l'objet
else:
    # pas d'autre objet disponible
----

==== weechat_infolist_reset_item_cursor

Réinitialiser le "curseur" de l'infolist.

Prototype :

[source,C]
----
void weechat_infolist_reset_item_cursor (struct t_infolist *infolist);
----

Paramètres :

* 'infolist' : pointeur vers l'infolist

Exemple en C :

[source,C]
----
weechat_infolist_reset_item_cursor (infolist);
----

Script (Python) :

[source,python]
----
# prototype
weechat.infolist_reset_item_cursor(infolist)

# exemple
weechat.infolist_reset_item_cursor(infolist)
----

==== weechat_infolist_search_var

_WeeChat ≥ 0.4.3._

Chercher une variable dans l'objet courant de l'infolist.

Prototype :

[source,C]
----
struct t_infolist_var *weechat_infolist_search_var (struct t_infolist *infolist,
                                                    const char *name);
----

Paramètres :

* 'infolist' : pointeur vers l'infolist
* 'name' : nom de la variable

Valeur de retour :

* pointeur vers la variable trouvée, NULL si la variable n'est pas trouvée

Exemple en C :

[source,C]
----
if (weechat_infolist_search_var (infolist, "name"))
{
    /* la variable "name" existe */
    /* ... */
}
----

Script (Python) :

[source,python]
----
# prototype
var = weechat.infolist_search_var(infolist, name)

# exemple
if weechat.infolist_search_var(infolist, "name"):
    # la variable "name" existe
    # ...
----

==== weechat_infolist_fields

Retourner la liste des champs pour l'objet courant de l'infolist.

Prototype :

[source,C]
----
const char *weechat_infolist_fields (struct t_infolist *infolist);
----

Paramètres :

* 'infolist' : pointeur vers l'infolist

Valeur de retour :

* chaîne avec la liste des champs pour l'objet courant de l'infolist. La liste,
  séparée par des virgules, contient la lettre pour le type, suivi du nom de la
  variable. Les types sont : "i" (nombre entier), "s" (chaîne), "p" (pointeur),
  "b" (buffer), "t" (date/heure).

Exemple en C :

[source,C]
----
const char *fields = weechat_infolist_fields (infolist);
/* fields contient quelque chose comme :
   "i:mon_entier,s:ma_chaine,p:mon_pointeur,b:mon_buffer,t:ma_date" */
----

Script (Python) :

[source,python]
----
# prototype
fields = weechat.infolist_fields(infolist)

# exemple
fields = weechat.infolist_fields(infolist)
# fields contient quelque chose comme :
# "i:mon_entier,s:ma_chaine,p:mon_pointeur,b:mon_buffer,t:ma_date"
----

==== weechat_infolist_integer

Retourner la valeur de la variable de l'objet courant de l'infolist, sous forme
d'entier.

Prototype :

[source,C]
----
int weechat_infolist_integer (struct t_infolist *infolist, const char *var);
----

Paramètres :

* 'infolist' : pointeur vers l'infolist
* 'var' : nom de la variable (doit être de type "integer")

Valeur de retour :

* valeur de la variable, sous forme d'entier

Exemple en C :

[source,C]
----
weechat_printf (NULL, "entier = %d",
                weechat_infolist_integer (infolist, "mon_entier"));
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.infolist_integer(infolist, var)

# exemple
weechat.prnt("", "entier = %d" % weechat.infolist_integer(infolist, "mon_entier"))
----

==== weechat_infolist_string

Retourner la valeur de la variable de l'objet courant de l'infolist, sous forme
de chaîne de caractères.

Prototype :

[source,C]
----
const char *weechat_infolist_string (struct t_infolist *infolist, const char *var);
----

Paramètres :

* 'infolist' : pointeur vers l'infolist
* 'var' : nom de la variable (doit être de type "string")

Valeur de retour :

* valeur de la variable, sous forme de chaîne

Exemple en C :

[source,C]
----
weechat_printf (NULL, "chaîne = %s",
                weechat_infolist_string (infolist, "ma_chaine"));
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.infolist_string(infolist, var)

# exemple
weechat.prnt("", "chaîne = %s" % weechat.infolist_string(infolist, "ma_chaine"))
----

==== weechat_infolist_pointer

Retourner la valeur de la variable de l'objet courant de l'infolist, sous forme
de pointeur.

Prototype :

[source,C]
----
void *weechat_infolist_pointer (struct t_infolist *infolist, const char *var);
----

Paramètres :

* 'infolist' : pointeur vers l'infolist
* 'var' : nom de la variable (doit être de type "pointer")

Valeur de retour :

* valeur de la variable, sous forme de pointeur

Exemple en C :

[source,C]
----
weechat_printf (NULL, "pointeur = 0x%lx",
                weechat_infolist_pointer (infolist, "mon_pointeur"));
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.infolist_pointer(infolist, var)

# exemple
weechat.prnt("", "pointeur = 0x%s" % weechat.infolist_pointer(infolist, "mon_pointeur"))
----

==== weechat_infolist_buffer

Retourner la valeur de la variable de l'objet courant de l'infolist, sous forme
de tampon de données.

Prototype :

[source,C]
----
void *weechat_infolist_buffer (struct t_infolist *infolist, const char *var,
                               int *size);
----

Paramètres :

* 'infolist' : pointeur vers l'infolist
* 'var' : nom de la variable (doit être de type "buffer")
* 'size' : pointeur vers une variable entière, qui sera alimenté avec la taille
  de la zone

Valeur de retour :

* pointeur vers le tampon de données

Exemple en C :

[source,C]
----
int size;
void *pointer = weechat_infolist_buffer (infolist, "mon_buffer", &size);
weechat_printf (NULL, "buffer = 0x%lx, taille = %d",
                pointer, size);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_infolist_time

Retourner la valeur de la variable de l'objet courant de l'infolist, sous forme
de date/heure.

Prototype :

[source,C]
----
time_t weechat_infolist_time (struct t_infolist *infolist, const char *var);
----

Paramètres :

* 'infolist' : pointeur vers l'infolist
* 'var' : nom de la variable (doit être de type "time")

Valeur de retour :

* valeur de la variable, sous forme de date/heure

Exemple en C :

[source,C]
----
weechat_printf (NULL, "date/heure = %ld",
                weechat_infolist_time (infolist, "mon_time"));
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.infolist_time(infolist, var)

# exemple
weechat.prnt("", "date/heure = %ld" % weechat.infolist_time(infolist, "mon_time"))
----

==== weechat_infolist_free

Supprimer une infolist.

Prototype :

[source,C]
----
void weechat_infolist_free (struct t_infolist *infolist);
----

Paramètres :

* 'infolist' : pointeur vers l'infolist

Exemple en C :

[source,C]
----
weechat_infolist_free (infolist);
----

Script (Python) :

[source,python]
----
# prototype
weechat.infolist_free(infolist)

# exemple
weechat.infolist_free(infolist)
----

[[hdata]]
=== Hdata

Fonctions pour les hdata (accès brut aux données de WeeChat ou des extensions).

[IMPORTANT]
Le "hdata" fournit seulement un accès en lecture seule aux données. Il est
*STRICTEMENT INTERDIT* d'écrire quelque chose dans une zone mémoire pointée par
les variables du hdata. +
Le seul moyen pour mettre à jour des données est d'appeler la fonction
<<_weechat_hdata_update,weechat_hdata_update>>.

==== weechat_hdata_new

_WeeChat ≥ 0.3.6, mis à jour dans la 0.3.9 et 0.4.0._

Créer un "hdata".

[NOTE]
.hdata vs infolist
====
Le "hdata" est un moyen rapide de lire des données de WeeChat ou des extensions.
Il est similaire à l'infolist, mais il y a quelques différences :

* il est plus rapide et utilise moins de mémoire : accès direct aux données sans
  duplication
* il peut contenir des informations différentes de l'infolist : il contient
  seulement les données brutes des structures (l'infolist peut ajouter des
  données supplémentaires pour plus de commodité)
====

Prototype :

[source,C]
----
struct t_hdata *weechat_hdata_new (const char *hdata_name, const char *var_prev, const char *var_next,
                                   int create_allowed, int delete_allowed,
                                   int (*callback_update)(void *data,
                                                          struct t_hdata *hdata,
                                                          void *pointer,
                                                          struct t_hashtable *hashtable),
                                   void *callback_update_data);
----

Paramètres :

* 'hdata_name' : nom du hdata
* 'var_prev' : nom de la variable dans la structure qui est un pointeur vers
  l'élément précédent dans la liste (peut être NULL si une telle variable
  n'existe pas)
* 'var_next' : nom de la variable dans la structure qui est un pointeur vers
  l'élément suivant dans la liste (peut être NULL si une telle variable
  n'existe pas)
* 'create_allowed' : 1 si la création de structure est autorisée, sinon 0
  _(WeeChat ≥ 0.4.0)_
* 'delete_allowed' : 1 si la suppression de structure est autorisée, sinon 0
  _(WeeChat ≥ 0.3.9)_
* 'callback_update' : fonction appelée pour mettre à jour des données dans le
  hdata, peut être NULL si aucune mise à jour n'est autorisée
  _(WeeChat ≥ 0.3.9)_, paramètres et valeur de retour :
** 'void *data' : pointeur
** 'struct t_hdata *hdata' : pointeur vers le hdata
** 'struct t_hashtable *hashtable' : table de hachage avec les variables à
   mettre à jour (voir <<_weechat_hdata_update,weechat_hdata_update>>)
** valeur de retour : nombre de variables mises à jour
* 'callback_update_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat _(WeeChat ≥ 0.3.9)_

Valeur de retour :

* pointeur vers le nouveau "hdata"

Exemple en C :

[source,C]
----
struct t_hdata *hdata = weechat_hdata_new ("myplugin_list", "prev", "next", 0, 0, &callback_update, NULL);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_hdata_new_var

_WeeChat ≥ 0.3.6._

Créer une nouvelle variable dans le hdata.

Prototype :

[source,C]
----
void weechat_hdata_new_var (struct t_hdata *hdata, const char *name, int offset, int type,
                            int update_allowed, const char *array_size, const char *hdata_name);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'name' : nom de la variable
* 'offset' : position (offset) de la variable dans la structure
* 'type' : type de la variable, un parmi ceux-ci :
** WEECHAT_HDATA_CHAR
** WEECHAT_HDATA_INTEGER
** WEECHAT_HDATA_LONG
** WEECHAT_HDATA_STRING
** WEECHAT_HDATA_SHARED_STRING
** WEECHAT_HDATA_POINTER
** WEECHAT_HDATA_TIME
** WEECHAT_HDATA_HASHTABLE
** WEECHAT_HDATA_OTHER
* 'update_allowed' : 1 si la mise à jour de la variable est autorisée, sinon 0
  _(WeeChat ≥ 0.3.9)_
* 'array_size' : non NULL seulement si la variable est un tableau, et peut
  être : _(WeeChat ≥ 0.3.9)_
** nom d'une variable du hdata : cette variable sera utilisée comme taille de
   tableau (taille dynamique pour le tableau)
** entier (sous forme de chaîne) : taille fixe pour le tableau
** '*' : taille automatique : la taille est calculée en examinant les valeurs,
   lorsque le premier NULL est trouvé (seulement pour le type string, pointer ou
   hashtable)
* 'hdata_name' : nom d'un hdata (si c'est un pointeur vers une structure qui a
  un hdata)

Exemple en C :

[source,C]
----
struct t_myplugin_list
{
    char *name;
    struct t_gui_buffer *buffer;
    int tags_count;
    char **tags_array;
    char **string_split;
    struct t_myplugin_list *prev;
    struct t_myplugin_list *next;
};

/* ... */

struct t_hdata *hdata = weechat_hdata_new ("myplugin_list", "prev", "next");
weechat_hdata_new_var (hdata, "name", offsetof (struct t_myplugin_list, name), WEECHAT_HDATA_STRING, 0, NULL, NULL);
weechat_hdata_new_var (hdata, "buffer", offsetof (struct t_myplugin_list, buffer), WEECHAT_HDATA_POINTER, 0, NULL, NULL);
weechat_hdata_new_var (hdata, "tags_count", offsetof (struct t_myplugin_list, tags_count), WEECHAT_HDATA_INTEGER, 0, NULL, NULL);
weechat_hdata_new_var (hdata, "tags_array", offsetof (struct t_myplugin_list, tags_array), WEECHAT_HDATA_STRING, 0, "tags_count", NULL);
weechat_hdata_new_var (hdata, "string_split", offsetof (struct t_myplugin_list, string_split), WEECHAT_HDATA_STRING, 0, "*", NULL);
weechat_hdata_new_var (hdata, "prev", offsetof (struct t_myplugin_list, prev), WEECHAT_HDATA_POINTER, 0, NULL, "myplugin_list");
weechat_hdata_new_var (hdata, "next", offsetof (struct t_myplugin_list, next), WEECHAT_HDATA_POINTER, 0, NULL, "myplugin_list");
----

La macro "WEECHAT_HDATA_VAR" peut être utilisée pour raccourcir le code :

[source,C]
----
WEECHAT_HDATA_VAR(struct t_myplugin_list, name, STRING, 0, NULL, NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, buffer, POINTER, 0, NULL, NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, tags_count, INTEGER, 0, NULL, NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, tags_array, STRING, 0, "tags_count", NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, string_split, STRING, 0, "*", NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, prev, POINTER, 0, NULL, "myplugin_list");
WEECHAT_HDATA_VAR(struct t_myplugin_list, next, POINTER, 0, NULL, "myplugin_list");
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_hdata_new_list

_WeeChat ≥ 0.3.6, mis à jour dans la 1.0._

Créer un nouveau pointer vers une liste dans le hdata.

Prototype :

[source,C]
----
void weechat_hdata_new_list (struct t_hdata *hdata, const char *name, void *pointer, int flags);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'name' : nom de la variable
* 'pointer' : pointeur vers la liste
* 'flags' : combinaison des valeurs suivantes : _(WeeChat ≥ 1.0)_
** 'WEECHAT_HDATA_LIST_CHECK_POINTERS' : liste utilisée pour vérifier les
   pointeurs

Exemple en C :

[source,C]
----
struct t_myplugin_list
{
    char *name;
    struct t_gui_buffer *buffer;
    int tags_count;
    char **tags_array;
    char **string_split;
    struct t_myplugin_list *prev;
    struct t_myplugin_list *next;
};

/* ... */

struct t_hdata *hdata = weechat_hdata_new ("myplugin_list", "prev", "next");
weechat_hdata_new_var (hdata, "name", offsetof (struct t_myplugin_list, name), WEECHAT_HDATA_STRING, NULL, NULL);
weechat_hdata_new_var (hdata, "buffer", offsetof (struct t_myplugin_list, buffer), WEECHAT_HDATA_POINTER, NULL, NULL);
weechat_hdata_new_var (hdata, "tags_count", offsetof (struct t_myplugin_list, tags_count), WEECHAT_HDATA_INTEGER, NULL, NULL);
weechat_hdata_new_var (hdata, "tags_array", offsetof (struct t_myplugin_list, tags_array), WEECHAT_HDATA_STRING, "tags_count", NULL);
weechat_hdata_new_var (hdata, "string_split", offsetof (struct t_myplugin_list, string_split), WEECHAT_HDATA_STRING, "*", NULL);
weechat_hdata_new_var (hdata, "prev", offsetof (struct t_myplugin_list, prev), WEECHAT_HDATA_POINTER, NULL, "myplugin_list");
weechat_hdata_new_var (hdata, "next", offsetof (struct t_myplugin_list, next), WEECHAT_HDATA_POINTER, NULL, "myplugin_list");

weechat_hdata_new_list (hdata, "buffers", &buffers, WEECHAT_HDATA_LIST_CHECK_POINTERS);
weechat_hdata_new_list (hdata, "last_buffer", &last_buffer, 0);
----

La macro "WEECHAT_HDATA_LIST" peut être utilisée pour raccourcir le code :

[source,C]
----
WEECHAT_HDATA_LIST(buffers, WEECHAT_HDATA_LIST_CHECK_POINTERS);
WEECHAT_HDATA_LIST(last_buffer, 0);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_hdata_get

_WeeChat ≥ 0.3.6._

Retourner un "hdata" pour une structure de WeeChat ou d'une extension.

[NOTE]
Le "hdata" ne contient aucune donnée, il s'agit seulement d'une table de hachage
avec la position (offset) des variables dans la structure. Cela signifie que
vous aurez besoin de ce hdata et d'un pointeur vers un objet WeeChat ou d'une
extension pour lire des données.

Prototype :

[source,C]
----
struct t_hdata *weechat_hdata_get (const char *hdata_name);
----

Paramètres :

* 'hdata_name' : nom du hdata (voir la liste ci-dessous)

Valeur de retour :

* pointeur vers le hdata, NULL en cas d'erreur

Liste des hdata :

include::autogen/plugin_api/hdata.asciidoc[]

Exemple en C :

[source,C]
----
struct t_hdata *hdata = weechat_hdata_get ("irc_server");
----

Script (Python) :

[source,python]
----
# prototype
hdata = weechat.hdata_get(hdata_name)

# exemple
hdata = weechat.hdata_get("irc_server")
----

==== weechat_hdata_get_var_offset

_WeeChat ≥ 0.3.6._

Retourner la position (offset) de la variable dans le hdata.

Prototype :

[source,C]
----
int weechat_hdata_get_var_offset (struct t_hdata *hdata, const char *name);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'name' : nom de la variable

Valeur de retour :

* position (offset) de la variable, 0 en cas d'erreur

Exemple en C :

[source,C]
----
int offset = weechat_hdata_get_var_offset (hdata, "name");
----

Script (Python) :

[source,python]
----
# prototype
offset = weechat.hdata_get_var_offset(hdata, name)

# exemple
offset = weechat.hdata_get_var_offset(hdata, "name")
----

==== weechat_hdata_get_var_type

_WeeChat ≥ 0.3.6._

Retourner le type de la variable dans le hdata (sous forme d'entier).

Prototype :

[source,C]
----
int weechat_hdata_get_var_type (struct t_hdata *hdata, const char *name);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'name' : nom de la variable

Valeur de retour :

* type de la variable, -1 en cas d'erreur

Exemple en C :

[source,C]
----
int type = weechat_hdata_get_var_type (hdata, "name");
switch (type)
{
    case WEECHAT_HDATA_CHAR:
        /* ... */
        break;
    case WEECHAT_HDATA_INTEGER:
        /* ... */
        break;
    case WEECHAT_HDATA_LONG:
        /* ... */
        break;
    case WEECHAT_HDATA_STRING:
        /* ... */
        break;
    case WEECHAT_HDATA_SHARED_STRING:
        /* ... */
        break;
    case WEECHAT_HDATA_POINTER:
        /* ... */
        break;
    case WEECHAT_HDATA_TIME:
        /* ... */
        break;
    case WEECHAT_HDATA_HASHTABLE:
        /* ... */
        break;
    case WEECHAT_HDATA_OTHER:
        /* ... */
        break;
    default:
        /* variable non trouvée */
        break;
}
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_hdata_get_var_type_string

_WeeChat ≥ 0.3.6._

Retourner le type de la variable dans le hdata (sous forme de chaîne).

Prototype :

[source,C]
----
const char *weechat_hdata_get_var_type_string (struct t_hdata *hdata, const char *name);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'name' : nom de la variable

Valeur de retour :

* type de la variable, NULL en cas d'erreur

Exemple en C :

[source,C]
----
weechat_printf (NULL, "type = %s", weechat_hdata_get_var_type_string (hdata, "name"));
----

Script (Python) :

[source,python]
----
# prototype
type = weechat.hdata_get_var_type_string(hdata, name)

# exemple
weechat.prnt("", "type = %s" % weechat.hdata_get_var_type_string(hdata, "name"))
----

==== weechat_hdata_get_var_array_size

_WeeChat ≥ 0.3.9._

Retourner la taille du tableau pour la variable dans le hdata.

Prototype :

[source,C]
----
int weechat_hdata_get_var_array_size (struct t_hdata *hdata, void *pointer, const char *name);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'name' : nom de la variable

Valeur de retour :

* taille du tableau pour la variable, -1 si la variable n'est pas un tableau ou
  en cas d'erreur

Exemple en C :

[source,C]
----
int array_size = weechat_hdata_get_var_array_size (hdata, pointer, "name");
----

Script (Python) :

[source,python]
----
# prototype
array_size = weechat.hdata_get_var_array_size(hdata, pointer, name)

# exemple
array_size = weechat.hdata_get_var_array_size(hdata, pointer, "name")
----

==== weechat_hdata_get_var_array_size_string

_WeeChat ≥ 0.3.9._

Retourner la taille du tableau pour la variable dans le hdata (sous forme de
chaîne).

Prototype :

[source,C]
----
const char *weechat_hdata_get_var_count_array_size (struct t_hdata *hdata, void *pointer,
                                                    const char *name);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'name' : nom de la variable

Valeur de retour :

* taille du tableau pour la variable sous forme de chaîne, -1 si la variable
  n'est pas un tableau ou en cas d'erreur

Exemple en C :

[source,C]
----
const char *array_size = weechat_hdata_get_var_array_size_string (hdata, pointer, "name");
----

Script (Python) :

[source,python]
----
# prototype
array_size = weechat.hdata_get_var_array_size_string(hdata, pointer, name)

# exemple
array_size = weechat.hdata_get_var_array_size_string(hdata, pointer, "name")
----

==== weechat_hdata_get_var_hdata

_WeeChat ≥ 0.3.6._

Retourner le hdata pour la variable dans le hdata.

Prototype :

[source,C]
----
const char *weechat_hdata_get_var_hdata (struct t_hdata *hdata, const char *name);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'name' : nom de la variable

Valeur de retour :

* hdata pour la variable, NULL si pas de hdata ou en cas d'erreur

Exemple en C :

[source,C]
----
weechat_printf (NULL, "hdata = %s", weechat_hdata_get_var_hdata (hdata, "name"));
----

Script (Python) :

[source,python]
----
# prototype
hdata_name = weechat.hdata_get_var_hdata(hdata, name)

# exemple
weechat.prnt("", "hdata = %s" % weechat.hdata_get_var_hdata(hdata, "name"))
----

==== weechat_hdata_get_var

_WeeChat ≥ 0.3.6._

Retourner un pointeur vers le contenu de la variable dans le hdata.

Prototype :

[source,C]
----
void *weechat_hdata_get_var (struct t_hdata *hdata, void *pointer, const char *name);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'name' : nom de la variable

Valeur de retour :

* pointeur vers le contenu de la variable, NULL en cas d'erreur

Exemple en C :

[source,C]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
void *pointer = weechat_hdata_get_var (hdata, buffer, "name");
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_hdata_get_var_at_offset

_WeeChat ≥ 0.3.6._

Retourner un pointeur vers le contenu de la variable dans le hdata, en utilisant
une position (offset).

Prototype :

[source,C]
----
void *weechat_hdata_get_var_at_offset (struct t_hdata *hdata, void *pointer, int offset);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'offset' : position (offset) de la variable

Valeur de retour :

* pointeur vers le contenu de la variable, NULL en cas d'erreur

Exemple en C :

[source,C]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
int offset = weechat_hdata_get_var_offset (hdata, "name");
void *pointer = weechat_hdata_get_var_at_offset (hdata, buffer, offset);
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_hdata_get_list

_WeeChat ≥ 0.3.6._

Retourner un pointeur de liste du hdata.

Prototype :

[source,C]
----
void *weechat_hdata_get_list (struct t_hdata *hdata, const char *name);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'name' : nom de la liste

Valeur de retour :

* pointeur vers la liste, NULL en cas d'erreur

Exemple en C :

[source,C]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffers = weechat_hdata_get_list (hdata, "gui_buffers");
----

Script (Python) :

[source,python]
----
# prototype
list = weechat.hdata_get_list(hdata, name)

# exemple
hdata = weechat.hdata_get("buffer")
buffers = weechat.hdata_get_list(hdata, "gui_buffers")
----

==== weechat_hdata_check_pointer

_WeeChat ≥ 0.3.7, mis à jour dans la 1.0._

Vérifier si un pointeur est valide pour un hdata et un pointeur de liste.

Prototype :

[source,C]
----
int weechat_hdata_check_pointer (struct t_hdata *hdata, void *list, void *pointer);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'list' : pointeur vers une liste; si NULL _(WeeChat ≥ 1.0)_, le pointeur est
  vérifié avec les listes dans le hdata qui ont le drapeau
  "vérifier les pointeurs" (voir
  <<_weechat_hdata_new_list,weechat_hdata_new_list>>), et s'il n'y a pas de
  telle liste, le pointeur est considéré comme valide
* 'pointer' : pointeur à vérifier

Valeur de retour :

* 1 si le pointeur est dans la liste, 0 si non trouvé

Exemple en C :

[source,C]
----
/* vérifie si le pointeur vers le tampon est valide */
struct t_hdata *hdata = weechat_hdata_get ("buffer");
if (weechat_hdata_check_pointer (hdata,
                                 weechat_hdata_get_list (hdata, "gui_buffers"),
                                 ptr_buffer))
{
    /* pointeur valide */
}
else
{
    /* pointeur invalide */
}
----

Script (Python) :

[source,python]
----
# prototype
rc = weechat.hdata_check_pointer(hdata, list, pointer)

# exemple
hdata = weechat.hdata_get("buffer")
if weechat.hdata_check_pointer(hdata, weechat.hdata_get_list(hdata, "gui_buffers"), ptr_buffer):
    # pointeur valide
    # ...
else:
    # pointeur invalide
    # ...
----

==== weechat_hdata_move

_WeeChat ≥ 0.3.6._

Déplacer le pointeur vers un autre élément dans la liste.

Prototype :

[source,C]
----
void *weechat_hdata_move (struct t_hdata *hdata, void *pointer, int count);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'count' : nombre de saut(s) à exécuter (entier négatif ou positif, différent
  de 0)

Valeur de retour :

* pointeur vers l'élément atteint, NULL en cas d'erreur

Exemple en C :

[source,C]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();

/* se déplacer au tampon suivant, 2 fois */
buffer = weechat_hdata_move (hdata, buffer, 2);

/* se déplacer au tampon précédent */
if (buffer)
    buffer = weechat_hdata_move (hdata, buffer, -1);
----

Script (Python) :

[source,python]
----
# prototype
pointer = weechat.hdata_move(hdata, pointer, count)

# exemple
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()

# se déplacer au tampon suivant, 2 fois
buffer = weechat.hdata_move(hdata, buffer, 2)

# se déplacer au tampon précédent
if buffer:
    buffer = weechat.hdata_move(hdata, buffer, -1)
----

==== weechat_hdata_search

_WeeChat ≥ 0.4.1._

Chercher un élément dans la liste : l'expression 'search' est évaluée pour
chaque élément dans la liste, jusqu'à trouver l'élément (ou la fin de la liste).

Prototype :

[source,C]
----
void *weechat_hdata_search (struct t_hdata *hdata, void *pointer, const char *search, int move);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'search' : expression à évaluer, le pointeur par défaut dans l'expression est
  le nom du hdata (et ce pointeur change pour chaque élément dans la liste);
  pour l'aide sur l'expression, voir la commande `/eval` dans le
  'Guide utilisateur WeeChat'
* 'move' : nombre de saut(s) à exécuter après une recherche infructueuse (entier
  négatif ou positif, différent de 0)

Valeur de retour :

* pointeur vers l'élément trouvé, ou NULL si non trouvé

Exemple en C :

[source,C]
----
struct t_hdata *hdata = weechat_hdata_get ("irc_server");
void *servers = weechat_hdata_get (hdata, "irc_servers");

/* cherche un serveur irc avec le nom "freenode" */
void *server = weechat_hdata_search (hdata, servers, "${irc_server.name} == freenode", 1);
if (server)
{
    /* ... */
}
----

Script (Python) :

[source,python]
----
# prototype
pointer = weechat.hdata_search(hdata, pointer, search, count)

# exemple
hdata = weechat.hdata_get("irc_server")
servers = weechat.hdata_get_list(hdata, "irc_servers")

# cherche un serveur irc avec le nom "freenode"
server = weechat.hdata_search(hdata, servers, "${irc_server.name} == freenode", 1)
if server:
    # ...
----

==== weechat_hdata_char

_WeeChat ≥ 0.3.7._

Retourner la valeur de la variable dans la structure en utilisant le hdata, sous
forme de caractère.

Prototype :

[source,C]
----
char weechat_hdata_char (struct t_hdata *hdata, void *pointer, const char *name);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'name' : nom de la variable (doit être de type "char"); pour les tableaux,
  le nom peut être "N|name" où N est un index dans le tableau (démarrant à 0),
  par exemple : "2|name"

Valeur de retour :

* valeur de la variable, sous forme de caractère

Exemple en C :

[source,C]
----
weechat_printf (NULL, "letter = %c", weechat_hdata_char (hdata, pointer, "letter"));
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.hdata_char(hdata, pointer, name)

# exemple
weechat.prnt("", "letter = %c" % weechat.hdata_char(hdata, pointer, "letter"))
----

==== weechat_hdata_integer

_WeeChat ≥ 0.3.6._

Retourner la valeur de la variable dans la structure en utilisant le hdata, sous
forme d'entier.

Prototype :

[source,C]
----
int weechat_hdata_integer (struct t_hdata *hdata, void *pointer, const char *name);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'name' : nom de la variable (doit être de type "integer"); pour les tableaux,
  le nom peut être "N|name" où N est un index dans le tableau (démarrant à 0),
  par exemple : "2|name"

Valeur de retour :

* valeur de la variable, sous forme d'entier

Exemple en C :

[source,C]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
weechat_printf (NULL, "number = %d", weechat_hdata_integer (hdata, buffer, "number"));
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.hdata_integer(hdata, pointer, name)

# exemple
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
weechat.prnt("", "number = %d" % weechat.hdata_integer(hdata, buffer, "number"))
----

==== weechat_hdata_long

_WeeChat ≥ 0.3.6._

Retourner la valeur de la variable dans la structure en utilisant le hdata, sous
forme d'entier long.

Prototype :

[source,C]
----
long weechat_hdata_long (struct t_hdata *hdata, void *pointer, const char *name);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'name' : nom de la variable (doit être de type "long"); pour les tableaux,
  le nom peut être "N|name" où N est un index dans le tableau (démarrant à 0),
  par exemple : "2|name"

Valeur de retour :

* valeur de la variable, sous forme d'entier long

Exemple en C :

[source,C]
----
weechat_printf (NULL, "longvar = %ld", weechat_hdata_long (hdata, pointer, "longvar"));
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.hdata_long(hdata, pointer, name)

# exemple
weechat.prnt("", "longvar = %ld" % weechat.hdata_long(hdata, pointer, "longvar"))
----

==== weechat_hdata_string

_WeeChat ≥ 0.3.6._

Retourner la valeur de la variable dans la structure en utilisant le hdata, sous
forme de chaîne.

Prototype :

[source,C]
----
const char *weechat_hdata_string (struct t_hdata *hdata, void *pointer, const char *name);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'name' : nom de la variable (doit être de type "string"); pour les tableaux,
  le nom peut être "N|name" où N est un index dans le tableau (démarrant à 0),
  par exemple : "2|name"

Valeur de retour :

* valeur de la variable, sous forme de chaîne

Exemple en C :

[source,C]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
weechat_printf (NULL, "name = %s", weechat_hdata_string (hdata, buffer, "name"));
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.hdata_string(hdata, pointer, name)

# exemple
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
weechat.prnt("", "name = %s" % weechat.hdata_string(hdata, buffer, "name"))
----

==== weechat_hdata_pointer

_WeeChat ≥ 0.3.6._

Retourner la valeur de la variable dans la structure en utilisant le hdata, sous
forme de pointeur.

Prototype :

[source,C]
----
void *weechat_hdata_pointer (struct t_hdata *hdata, void *pointer, const char *name);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'name' : nom de la variable (doit être de type "pointeur"); pour les tableaux,
  le nom peut être "N|name" où N est un index dans le tableau (démarrant à 0),
  par exemple : "2|name"

Valeur de retour :

* valeur de la variable, sous forme de pointeur

Exemple en C :

[source,C]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
weechat_printf (NULL, "lines = %lx", weechat_hdata_pointer (hdata, buffer, "lines"));
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.hdata_pointer(hdata, pointer, name)

# exemple
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
weechat.prnt("", "lines = %lx" % weechat.hdata_pointer(hdata, buffer, "lines"))
----

==== weechat_hdata_time

_WeeChat ≥ 0.3.6._

Retourner la valeur de la variable dans la structure en utilisant le hdata, sous
forme de date/heure.

Prototype :

[source,C]
----
time_t weechat_hdata_time (struct t_hdata *hdata, void *pointer, const char *name);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'name' : nom de la variable (doit être de type "time"); pour les tableaux,
  le nom peut être "N|name" où N est un index dans le tableau (démarrant à 0),
  par exemple : "2|name"

Valeur de retour :

* valeur de la variable, sous forme de date/heure

Exemple en C :

[source,C]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *ptr = weechat_buffer_search_main ();
ptr = weechat_hdata_pointer (hdata, ptr, "lines");
if (ptr)
{
    hdata = weechat_hdata_get ("lines");
    ptr = weechat_hdata_pointer (hdata, ptr, "first_line");
    if (ptr)
    {
        hdata = weechat_hdata_get ("line");
        ptr = weechat_hdata_pointer (hdata, ptr, "data");
        if (ptr)
        {
            hdata = weechat_hdata_get ("line_data");
            time_t date = weechat_hdata_time (hdata, hdata, "date");
            weechat_printf (NULL, "heure de la première ligne affichée = %s", ctime (&date));
        }
    }
}
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.hdata_time(hdata, pointer, name)

# exemple
buf = weechat.buffer_search_main()
ptr = weechat.hdata_pointer(weechat.hdata_get("buffer"), buf, "lines")
if ptr:
    ptr = weechat.hdata_pointer(weechat.hdata_get("lines"), ptr, "first_line")
    if ptr:
        ptr = weechat.hdata_pointer(weechat.hdata_get("line"), ptr, "data")
        if ptr:
            date = weechat.hdata_time(weechat.hdata_get("line_data"), ptr, "date")
            weechat.prnt("", "heure de la première ligne affichée = %s" % time.strftime("%F %T", time.localtime(int(date))))
----

==== weechat_hdata_hashtable

_WeeChat ≥ 0.3.7._

Retourner la valeur de la variable dans la structure en utilisant le hdata, sous
forme de table de hachage.

Prototype :

[source,C]
----
struct t_hashtable *weechat_hdata_hashtable (struct t_hdata *hdata, void *pointer, const char *name);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'name' : nom de la variable (doit être de type "hashtable"); pour les
  tableaux, le nom peut être "N|name" où N est un index dans le tableau
  (démarrant à 0), par exemple : "2|name"

Valeur de retour :

* valeur de la variable, sous forme de pointeur vers la table de hachage

Exemple en C :

[source,C]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
struct t_hashtable *hashtable = weechat_hdata_hashtable (hdata, buffer, "local_variables");
weechat_printf (NULL, "%d variables locales dans le tampon principal",
                weechat_hashtable_get_integer (hashtable, "items_count"));
----

Script (Python) :

[source,python]
----
# prototype
hashtable = weechat.hdata_hashtable(hdata, pointer, name)

# exemple
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
hash = weechat.hdata_hashtable(hdata, buffer, "local_variables")
weechat.prnt("", "variables locales dans le tampon principal :")
for key in hash:
    weechat.prnt("", "  %s == %s" % (key, hash[key]))
----

==== weechat_hdata_set

_WeeChat ≥ 0.3.9._

Définir une nouvelle valeur pour une variable dans un hdata.

[NOTE]
Cette fonction ne peut être appelée que dans un "callback" de mise à jour
(voir <<_weechat_hdata_new,weechat_hdata_new>> et
<<_weechat_hdata_update,weechat_hdata_update>>), si la variable peut être mise à
jour.

Prototype :

[source,C]
----
int weechat_hdata_set (struct t_hdata *hdata, void *pointer, const char *name, const char *value);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'name' : nom de la variable (types autorisés : char, integer, long, string,
  pointer, time)
* 'value' : nouvelle valeur pour la variable

Valeur de retour :

* 1 si ok, 0 en cas d'erreur

Exemple en C :

[source,C]
----
weechat_hdata_set (hdata, pointer, "message", "test");
----

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

==== weechat_hdata_update

_WeeChat ≥ 0.3.9._

Mettre à jour des données dans le hdata.

Prototype :

[source,C]
----
int weechat_hdata_update (struct t_hdata *hdata, void *pointer, struct t_hashtable *hashtable);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'hashtable' : variables à mettre à jour : les clés sont les noms des
  variables, les valeurs sont les nouvelles valeurs pour les variables (clés et
  valeurs sont des chaînes de caractères), quelques clés spéciales sont
  acceptées :
** clé `__create_allowed` (avec n'importe quelle valeur) : retourne 1 si la
   création est autorisée pour la structure, sinon 0
   _(WeeChat ≥ 0.4.0)_
** clé `__delete_allowed` (avec n'importe quelle valeur) : retourne 1 si la
   suppression est autorisée pour la structure, sinon 0
** clé `__update_allowed`, la valeur est le nom d'une variable : retourne 1 si
   la mise à jour est autorisée pour la variable, sinon 0
** clé `__delete` (avec n'importe quelle valeur) : supprime la structure
   (si autorisé)

Valeur de retour :

* nombre de variables mises à jour

Exemple en C :

[source,C]
----
/* soustrait une heure sur le dernier message affiché dans le tampon courant */

struct t_gui_lines *own_lines;
struct t_gui_line *line;
struct t_gui_line_data  *line_data;
struct t_hdata *hdata;
struct t_hashtable *hashtable;
char str_date[64];

own_lines = weechat_hdata_pointer (weechat_hdata_get ("buffer"), weechat_current_buffer (), "own_lines");
if (own_lines)
{
    line = weechat_hdata_pointer (weechat_hdata_get ("lines"), own_lines, "last_line");
    if (line)
    {
        line_data = weechat_hdata_pointer (weechat_hdata_get ("line"), line, "data");
        hdata = weechat_hdata_get ("line_data");
        hashtable = weechat_hashtable_new (8,
                                           WEECHAT_HASHTABLE_STRING,
                                           WEECHAT_HASHTABLE_STRING,
                                           NULL,
                                           NULL);
        if (hashtable)
        {
            snprintf (str_date, sizeof (str_date), "%ld", ((long int)weechat_hdata_time (hdata, line_data, "date")) - 3600);
            weechat_hashtable_set (hashtable, "date", str_date);
            weechat_hdata_update (hdata, line_data, hashtable);
            weechat_hashtable_free (hashtable);
        }
    }
}
----

Script (Python) :

[source,python]
----
# prototype
count = weechat.hdata_update(hdata, pointer, hashtable)

# exemple : soustrait une heure sur le dernier message affiché dans le tampon courant
own_lines = weechat.hdata_pointer(weechat.hdata_get("buffer"), weechat.current_buffer(), "own_lines")
if own_lines:
    line = weechat.hdata_pointer(weechat.hdata_get("lines"), own_lines, "last_line")
    if line:
        line_data = weechat.hdata_pointer(weechat.hdata_get("line"), line, "data")
        hdata = weechat.hdata_get("line_data")
        weechat.hdata_update(hdata, line_data, {"date": str(weechat.hdata_time(hdata, line_data, "date") - 3600)})
----

==== weechat_hdata_get_string

_WeeChat ≥ 0.3.6._

Retourner une valeur pour une propriété d'un hdata sous forme de chaîne.

Prototype :

[source,C]
----
const char *weechat_hdata_get_string (struct t_hdata *hdata, const char *property);
----

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'property' : nom de la propriété :
** 'var_keys' : chaîne avec la liste des clés pour les variables du hdata
   (format : "key1,key2,key3")
** 'var_values' : chaîne avec la liste des valeurs pour les variables du hdata
   (format : "value1,value2,value3")
** 'var_keys_values' : chaîne avec la liste des clés et valeurs pour les
   variables du hdata (format : "key1:value1,key2:value2,key3:value3")
** 'var_prev' : nom de la variable dans la structure qui est un pointeur vers
   l'élément précédent dans la liste
** 'var_next' : nom de la variable dans la structure qui est un pointeur vers
   l'élément suivant dans la liste
** 'list_keys' : chaîne avec la liste des clés pour les listes du hdata
   (format : "key1,key2,key3")
** 'list_values' : chaîne avec la liste des valeurs pour les listes du hdata
   (format : "value1,value2,value3")
** 'list_keys_values' : chaîne avec la liste des clés et valeurs pour les listes
   du hdata (format : "key1:value1,key2:value2,key3:value3")

Valeur de retour :

* valeur de la propriété sous forme de chaîne

Exemple en C :

[source,C]
----
weechat_printf (NULL, "variables dans le hdata: %s", weechat_hdata_get_string (hdata, "var_keys"));
weechat_printf (NULL, "listes dans le hdata: %s", weechat_hdata_get_string (hdata, "list_keys"));
----

Script (Python) :

[source,python]
----
# prototype
value = weechat.hdata_get_string(hdata, property)

# exemple
weechat.prnt("", "variables dans le hdata: %s" % weechat.hdata_get_string(hdata, "var_keys"))
weechat.prnt("", "listes dans le hdata: %s" % weechat.hdata_get_string(hdata, "list_keys"))
----

[[upgrade]]
=== Mise à jour

Fonctions pour la mise à jour de WeeChat (commande "/upgrade").

==== weechat_upgrade_new

Créer ou lire un fichier pour la mise à jour.

Prototype :

[source,C]
----
struct t_upgrade_file *weechat_upgrade_new (const char *filename, int write);
----

Paramètres :

* 'filename' : nom du fichier (l'extension ".upgrade" sera ajoutée
  automatiquement par WeeChat)
* 'write' :
** '1' : création du fichier (mode écriture, avant la mise à jour)
** '0' : lecture du fichier (après la mise à jour)

Valeur de retour :

* pointeur vers le fichier de mise à jour

Exemple en C :

[source,C]
----
struct t_upgrade_file *upgrade_file = weechat_upgrade_new ("mon_fichier", 1);
----

Script (Python) :

[source,python]
----
# prototype
upgrade_file = weechat.upgrade_new(filename, write)

# exemple
upgrade_file = weechat.upgrade_new("mon_fichier", 1)
----

==== weechat_upgrade_write_object

Écrire un objet dans le fichier de mise à jour.

Prototype :

[source,C]
----
int weechat_upgrade_write_object (struct t_upgrade_file *upgrade_file,
                                  int object_id,
                                  struct t_infolist *infolist);
----

Paramètres :

* 'upgrade_file' : pointeur vers le fichier de mise à jour
* 'object_id' : identifiant de l'objet
* 'infolist' : infolist à écrire dans le fichier

Valeur de retour :

* 1 si ok, 0 en cas d'erreur

Exemple en C :

[source,C]
----
if (weechat_upgrade_write_object (upgrade_file, 1, &infolist))
{
    /* ok */
}
else
{
    /* erreur */
}
----

Script (Python) :

[source,python]
----
# prototype
rc = weechat.upgrade_write_object(upgrade_file, object_id, infolist)

# exemple
weechat.upgrade_write_object(upgrade_file, 1, infolist)
----

==== weechat_upgrade_read

Lire un fichier de mise à jour.

Prototype :

[source,C]
----
int weechat_upgrade_read (struct t_upgrade_file *upgrade_file,
                          int (*callback_read)(void *data,
                                               struct t_upgrade_file *upgrade_file,
                                               int object_id,
                                               struct t_infolist *infolist),
                          void *callback_read_data);
----

Paramètres :

* 'upgrade_file' : pointeur vers le fichier de mise à jour
* 'callback_read' : fonction appelée pour chaque objet lu dans le fichier de
  mise à jour, paramètres et valeur de retour :
** 'void *data' : pointeur
** 'struct t_upgrade_file *upgrade_file' : pointeur vers le fichier de mise à
   jour
** 'int object_id' : identifiant de l'objet
** 'struct t_infolist *infolist' : infolist avec le contenu de l'objet
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_read_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* 1 si ok, 0 en cas d'erreur

Exemple en C :

[source,C]
----
int
my_upgrade_read_cb (struct t_upgrade_file *upgrade_file,
                    int object_id,
                    struct t_infolist *infolist)
{
    /* lecture des variables... */
    return WEECHAT_RC_OK;
}

weechat_upgrade_read (upgrade_file, &my_upgrade_read_cb, NULL);
----

Script (Python) :

[source,python]
----
# prototype
rc = weechat.upgrade_read(upgrade_file, callback_read, callback_read_data)

# exemple
def my_upgrade_read_cb(upgrade_file, object_id, infolist):
    # read variables...
    return weechat.WEECHAT_RC_OK

weechat.upgrade_read(upgrade_file, "my_upgrade_read_cb", ""))
----

==== weechat_upgrade_close

Fermer un fichier de mise à jour.

Prototype :

[source,C]
----
void weechat_upgrade_close (struct t_upgrade_file *upgrade_file);
----

Paramètres :

* 'upgrade_file' : pointeur vers le fichier de mise à jour

Exemple en C :

[source,C]
----
weechat_upgrade_close (upgrade_file);
----

Script (Python) :

[source,python]
----
# prototype
weechat.upgrade_close(upgrade_file)

# exemple
weechat.upgrade_close(upgrade_file)
----
