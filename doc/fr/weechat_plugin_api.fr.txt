Référence API Extension WeeChat
===============================
Sébastien Helleu <flashcode@flashtux.org>


Ce manuel documente le client de messagerie instantanée WeeChat, il fait
partie de WeeChat.

La dernière version de ce document peut être téléchargée sur cette page :
http://www.weechat.org/doc


[[introduction]]
Introduction
------------

WeeChat (Wee Enhanced Environment for Chat) est un client de discussion libre,
rapide et léger, conçu pour différents systèmes d'exploitation.

Ce manuel documente l'API WeeChat des extensions, utilisée par les extensions
en C pour interagir avec le coeur de WeeChat.

[[plugins_in_weechat]]
Extensions dans WeeChat
-----------------------

Une extension est un programme C qui peut appeler des fonctions WeeChat
définies dans une interface.

Ce programme C n'a pas besoin des sources WeeChat pour être compilé et peut
être dynamiquement chargé dans WeeChat avec la commande `/plugin`.

Cette extension doit être une bibliothèque dynamique, pour un chargement
dynamique par le système d'exploitation.
Sous GNU/Linux, le fichier a une extension ".so" et ".dll" sous Windows.

L'extension doit inclure le fichier "weechat-plugin.h" (disponible dans le code
source WeeChat).
Ce fichier définit les structures et types utilisés pour communiquer avec
WeeChat.

[[macros]]
Macros
~~~~~~

L'extension doit utiliser des macros (pour définir quelques variables) :

WEECHAT_PLUGIN_NAME("name")::
    nom de l'extension

WEECHAT_PLUGIN_DESCRIPTION("description")::
    description courte de l'extension

WEECHAT_PLUGIN_VERSION("1.0")::
    version de l'extension

WEECHAT_PLUGIN_LICENSE("GPL3")::
    licence de l'extension

[[main_functions]]
Fonctions principales
~~~~~~~~~~~~~~~~~~~~~

L'extension doit utiliser deux fonctions :

* weechat_plugin_init
* weechat_plugin_end

weechat_plugin_init
^^^^^^^^^^^^^^^^^^^

Cette fonction est appelée quand l'extension est chargée par WeeChat.

Prototype :

[source,C]
----------------------------------------
int weechat_plugin_init (struct t_weechat_plugin *plugin,
                         int argc, char *argv[]);
----------------------------------------

Paramètres :

* 'plugin' : pointeur vers la structure d'extension WeeChat
* 'argc' : nombre de paramètres pour l'extension (donnés sur la ligne de
  commande par l'utilisateur)
* 'argv' : paramètres pour l'extension

Valeur de retour :

* 'WEECHAT_RC_OK' si ok (l'extension sera chargée)
* 'WEECHAT_RC_ERROR' si erreur (l'extension ne sera PAS chargée)

weechat_plugin_end
^^^^^^^^^^^^^^^^^^

Cette fonction est appelée quand l'extension est déchargée par WeeChat.

Prototype :

[source,C]
----------------------------------------
int weechat_plugin_end (struct t_weechat_plugin *plugin);
----------------------------------------

Paramètres :

* 'plugin' : pointeur vers la structure d'extension WeeChat

Valeur de retour :

* 'WEECHAT_RC_OK' si ok
* 'WEECHAT_RC_ERROR' si erreur

[[compile_plugin]]
Compilation de l'extension
~~~~~~~~~~~~~~~~~~~~~~~~~~

La compilation ne nécessite pas les sources de WeeChat, seul le fichier
 'weechat-plugin.h' est requis.

Pour compiler l'extension qui n'a qu'un fichier "toto.c" (sous GNU/Linux) :

----------------------------------------
$ gcc -fPIC -Wall -c toto.c
$ gcc -shared -fPIC -o libtoto.so toto.o
----------------------------------------

[[load_plugin]]
Chargement de l'extension
~~~~~~~~~~~~~~~~~~~~~~~~~

Copiez le fichier 'libtoto.so' dans le répertoire système des extensions (par
exemple '/usr/local/lib/weechat/plugins') ou dans le répertoire utilisateur des
extensions (par exemple '/home/xxx/.weechat/plugins').

Sous WeeChat :

----------------------------------------
/plugin load toto
----------------------------------------

[[plugin_example]]
Exemple d'extension
~~~~~~~~~~~~~~~~~~~

Exemple complet d'extension, qui ajoute une commande '/double' : affiche deux
fois les paramètres sur le tampon courant, ou exécute deux fois une commande
(ok ce n'est pas très utile, mais c'est juste un exemple !) :

[source,C]
----------------------------------------
#include <stdlib.h>

#include "weechat-plugin.h"

WEECHAT_PLUGIN_NAME("double");
WEECHAT_PLUGIN_DESCRIPTION("Extension de test pour WeeChat");
WEECHAT_PLUGIN_AUTHOR("Sebastien Helleu <flashcode@flashtux.org>");
WEECHAT_PLUGIN_VERSION("0.1");
WEECHAT_PLUGIN_LICENSE("GPL3");

struct t_weechat_plugin *weechat_plugin = NULL;


/* callback pour la commande "/double" */

int
commande_double_cb (void *data, struct t_gui_buffer *buffer, int argc,
                    char **argv, char **argv_eol)
{
    /* pour que le compilateur C soit content */
    (void) data;
    (void) buffer;
    (void) argv;

    if (argc > 1)
    {
        weechat_command (NULL, argv_eol[1]);
        weechat_command (NULL, argv_eol[1]);
    }

    return WEECHAT_RC_OK;
}

int
weechat_plugin_init (struct t_weechat_plugin *plugin,
                     int argc, char *argv[])
{
    weechat_plugin = plugin;

    weechat_hook_command ("double",
                          "Affiche deux fois un message "
                          "ou exécute deux fois une commande",
                          "message | commande",
                          "message : message à afficher deux fois\n"
                          "commande : commande à exécuter deux fois",
                          NULL,
                          &commande_double_cb, NULL);

    return WEECHAT_RC_OK;
}

int
weechat_plugin_end (struct t_weechat_plugin *plugin)
{
    /* pour que le compilateur C soit content */
    (void) plugin;

    return WEECHAT_RC_OK;
}
----------------------------------------

[[plugin_api]]
API extension
-------------

Les chapîtres ci-dessous décrivent les fonctions de l'API, classées par
catégorie.

Pour chaque fonction, on donne :

* une description de la fonction,
* le prototype en C,
* le détail des paramètres,
* la valeur de retour,
* un exemple en C,
* un exemple en script Python (la syntaxe pour les autres langages de script est
  similaire).

[[plugins]]
Extensions
~~~~~~~~~~

Fonctions pour obtenir des informations sur les extensions.

weechat_plugin_get_name
^^^^^^^^^^^^^^^^^^^^^^^

Retourne le nom d'une extension.

Prototype :

[source,C]
----------------------------------------
const char *weechat_plugin_get_name (struct t_weechat_plugin *plugin);
----------------------------------------

Paramètres :

* 'plugin' : pointeur vers la structure d'extension WeeChat (peut être NULL)

Valeur de retour :

* nom de l'extension, "core" pour le coeur de WeeChat (si le pointeur vers
  l'extension est NULL)

Exemple en C :

[source,C]
----------------------------------------
const char *name = weechat_plugin_get_name (plugin);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
name = weechat.plugin_get_name(plugin)

# exemple
plugin = weechat.buffer_get_pointer(weechat.current_buffer(), "plugin")
name = weechat.plugin_get_name(plugin)
----------------------------------------

[[strings]]
Chaînes de caractères
~~~~~~~~~~~~~~~~~~~~~

Plusieurs fonctions sur les chaînes de caractères sont déjà disponibles via
les fonctions standard du C, mais il est recommandé d'utiliser celles de l'API
car elles sont ok avec UTF-8 et la locale.

weechat_charset_set
^^^^^^^^^^^^^^^^^^^

Définit le nouveau jeu de caractères (le jeu de caractères par défaut est
'UTF-8', donc si votre extension utilise 'UTF-8', vous n'avez pas besoin
d'appeler cette fonction).

Prototype :

[source,C]
----------------------------------------
void weechat_charset_set (const char *charset);
----------------------------------------

Paramètres :

* 'charset' : nouveau jeu de caractères à utiliser

Exemple en C :

[source,C]
----------------------------------------
weechat_charset_set (plugin, "iso-8859-1");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.charset_set(charset)

# exemple
weechat.charset_set("iso-8859-1")
----------------------------------------

weechat_iconv_to_internal
^^^^^^^^^^^^^^^^^^^^^^^^^

Convertit une chaîne vers le jeu de caractères interne (UTF-8).

Prototype :

[source,C]
----------------------------------------
char *weechat_iconv_to_internal (const char *charset, const char *string);
----------------------------------------

Paramètres :

* 'charset' : jeu de caractères à convertir
* 'string' : chaîne à convertir

Valeur de retour :

* chaîne convertie (doit être libérée par un appel à "free" après utilisation)

Exemple en C :

[source,C]
----------------------------------------
char *str = weechat_iconv_to_internal (plugin, "iso-8859-1", "chaîne iso : é à");
/* ... */
free (str);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
str = weechat.iconv_to_internal(charset, string)

# exemple
str = weechat.iconv_to_internal("iso-8859-1", "chaîne iso : é à")
----------------------------------------

weechat_iconv_from_internal
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Convertie une chaîne du jeu de caractères interne (UTF-8) vers un autre.

Prototype :

[source,C]
----------------------------------------
char *weechat_iconv_from_internal (const char *charset, const char *string);
----------------------------------------

Paramètres :

* 'charset' : jeu de caractères cible
* 'string' : chaîne à convertir

Valeur de retour :

* chaîne convertie (doit être libérée par un appel à "free" après utilisation)

Exemple en C :

[source,C]
----------------------------------------
char *str = weechat_iconv_from_internal ("iso-8859-1", "chaîne utf-8 : é à");
/* ... */
free (str);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
str = weechat.iconv_from_internal(charset, string)

# exemple
str = weechat.iconv_from_internal("iso-8859-1", "chaîne utf-8 : é à")
----------------------------------------

weechat_gettext
^^^^^^^^^^^^^^^

Retourne la chaîne traduite (dépend de la langue locale).

Prototype :

[source,C]
----------------------------------------
const char *weechat_gettext (const char *string);
----------------------------------------

Paramètres :

* 'string' : chaîne à traduire

Valeur de retour :

* chaîne traduite

Exemple en C :

[source,C]
----------------------------------------
char *str = weechat_gettext ("hello");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
str = weechat.gettext(string)

# exemple
str = weechat.gettext("hello")
----------------------------------------

weechat_ngettext
^^^^^^^^^^^^^^^^

Retourne la chaîne traduite, en utilisant le singulier ou le pluriel, selon
le paramètre 'count'.

Prototype :

[source,C]
----------------------------------------
const char *weechat_ngettext (const char *string, const char *plural,
                              int count);
----------------------------------------

Paramètres :

* 'string' : chaîne à traduire, au singulier
* 'plural' : chaîne à traduire, au pluriel
* 'count' : utilisé pour choisir entre le singulier et le pluriel (le choix est
  fonction de la langue utilisée)

Valeur de retour :

* chaîne traduite

Exemple en C :

[source,C]
----------------------------------------
char *str = weechat_ngettext ("file", "files", num_files);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
str = weechat.ngettext(string, plural, count)

# exemple
num_files = 2
str = weechat.ngettext("file", "files", num_files)
----------------------------------------

weechat_strndup
^^^^^^^^^^^^^^^

Retourne la chaîne dupliquée, avec au plus 'length' caractères.

Prototype :

[source,C]
----------------------------------------
char *weechat_strndup (const char *string, int length);
----------------------------------------

Paramètres :

* 'string' : chaîne à dupliquer
* 'length' : nombre maximum de caractères à dupliquer

Valeur de retour :

* chaîne dupliquée (doit être libérée par un appel à "free" après utilisation)

Exemple en C :

[source,C]
----------------------------------------
char *str = weechat_strndup ("abcdef", 3); /* résultat : "abc" */
/* ... */
free (str);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_string_tolower
^^^^^^^^^^^^^^^^^^^^^^

Convertit une chaîne UTF-8 en minuscules.

Prototype :

[source,C]
----------------------------------------
void weechat_string_tolower (const char *string);
----------------------------------------

Paramètres :

* 'string' : chaîne à convertir

Exemple en C :

[source,C]
----------------------------------------
char *str = "AbCdé";
weechat_string_tolower (str); /* str vaut maintenant : "abcdé" */
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_string_toupper
^^^^^^^^^^^^^^^^^^^^^^

Convertir une chaîne UTF-8 en majuscules.

Prototype :

[source,C]
----------------------------------------
void weechat_string_toupper (const char *string);
----------------------------------------

Paramètres :

* 'string' : chaîne à convertir

Exemple en C :

[source,C]
----------------------------------------
char *str = "AbCdé";
weechat_string_toupper (str); /* str vaut maintenant : "ABCDé" */
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_strcasecmp
^^^^^^^^^^^^^^^^^^

Comparaison de chaînes indépendante de la locale et de la casse.

Prototype :

[source,C]
----------------------------------------
int weechat_strcasecmp (const char *string1, const char *string2);
----------------------------------------

Paramètres :

* 'string1' : première chaîne à comparer
* 'string2' : seconde chaîne à comparer

Valeur de retour :

* différence entre les deux chaînes :
** négative si string1 < string2
** zéro si string1 == string2
** positive si string1 > string2

Exemple en C :

[source,C]
----------------------------------------
int diff = weechat_strcasecmp ("aaa", "CCC"); /* == -2 */
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_strcasecmp_range
^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.7._

Comparaison de chaînes indépendante de la locale et de la casse, avec un
intervalle pour comparer la casse.

Prototype :

[source,C]
----------------------------------------
int weechat_strcasecmp_range (const char *string1, const char *string2, int range);
----------------------------------------

Paramètres :

* 'string1' : première chaîne à comparer
* 'string2' : seconde chaîne à comparer
* 'range' : nombre de caractères pour la comparaison de casse, par exemple :
** 26 : "A-Z" deviennent en minuscules "a-z"
** 29 : "A-Z [ \ ]" deviennent minuscules "a-z { | }"
** 30 : "A-Z [ \ ] ^" deviennent minuscules "a-z { | } ~"

[NOTE]
Les valeurs 29 et 30 sont utilisés par quelques protocoles comme IRC.

Valeur de retour :

* différence entre les deux chaînes :
** négative si string1 < string2
** zéro si string1 == string2
** positive si string1 > string2

Exemple en C :

[source,C]
----------------------------------------
int diff = weechat_strcasecmp_range ("nick{away}", "NICK[away]", 29); /* == 0 */
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_strncasecmp
^^^^^^^^^^^^^^^^^^^

Comparaison de chaînes indépendante de la locale et de la casse, pour 'max'
caractères.

Prototype :

[source,C]
----------------------------------------
int weechat_strncasecmp (const char *string1, const char *string2, int max);
----------------------------------------

Paramètres :

* 'string1' : première chaîne à comparer
* 'string2' : seconde chaîne à comparer
* 'max' : nombre maximum de caractères à comparer

Valeur de retour :

* différence entre les deux chaînes :
** négative si string1 < string2
** zéro si string1 == string2
** positive si string1 > string2

Exemple en C :

[source,C]
----------------------------------------
int diff = weechat_strncasecmp ("aabb", "aacc", 2); /* == 0 */
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_strncasecmp_range
^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.7._

Comparaison de chaînes indépendante de la locale et de la casse, pour 'max'
caractères, avec un intervalle pour comparer la casse.

Prototype :

[source,C]
----------------------------------------
int weechat_strncasecmp_range (const char *string1, const char *string2, int max, int range);
----------------------------------------

Paramètres :

* 'string1' : première chaîne à comparer
* 'string2' : seconde chaîne à comparer
* 'max' : nombre maximum de caractères à comparer
* 'range' : nombre de caractères pour la comparaison de casse, par exemple :
** 26 : "A-Z" deviennent en minuscules "a-z"
** 29 : "A-Z [ \ ]" deviennent minuscules "a-z { | }"
** 30 : "A-Z [ \ ] ^" deviennent minuscules "a-z { | } ~"

[NOTE]
Les valeurs 29 et 30 sont utilisés par quelques protocoles comme IRC.

Valeur de retour :

* différence entre les deux chaînes :
** négative si string1 < string2
** zéro si string1 == string2
** positive si string1 > string2

Exemple en C :

[source,C]
----------------------------------------
int diff = weechat_strncasecmp_range ("nick{away}", "NICK[away]", 6, 29); /* == 0 */
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_strcmp_ignore_chars
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Comparaison de chaînes indépendante de la locale (et en option de la casse), en
ignorant des caractères.

Prototype :

[source,C]
----------------------------------------
int weechat_strcmp_ignore_chars (const char *string1, const char *string2,
                                 const char *chars_ignored,
                                 int case_sensitive);
----------------------------------------

Paramètres :

* 'string1' : première chaîne à comparer
* 'string2' : seconde chaîne à comparer
* 'chars_ignored' : chaîne avec les caractères à ignorer
* 'case_sensitive' : 1 pour une comparaison tenant compte de la casse, sinon 0

Valeur de retour :

* différence entre les deux chaînes :
** négative si string1 < string2
** zéro si string1 == string2
** positive si string1 > string2

Exemple en C :

[source,C]
----------------------------------------
int diff = weechat_strcmp_ignore_chars ("a-b", "--a-e", "-", 1); /* == -3 */
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_strcasestr
^^^^^^^^^^^^^^^^^^

Recherche de chaîne indépendante de la locale et de la casse.

Prototype :

[source,C]
----------------------------------------
char *weechat_strcasestr (const char *string, const char *search);
----------------------------------------

Paramètres :

* 'string' : chaîne
* 'search' : chaîne à rechercher dans 'string'

Valeur de retour :

* pointeur vers la chaîne trouvée, ou NULL si non trouvée

Exemple en C :

[source,C]
----------------------------------------
char *pos = weechat_strcasestr ("aBcDeF", "de"); /* résultat : pointeur vers "DeF" */
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_string_match
^^^^^^^^^^^^^^^^^^^^

Vérifie si une chaîne correspond à un masque.

Prototype :

[source,C]
----------------------------------------
int weechat_string_match (const char *string, const char *mask,
                          int case_sensitive);
----------------------------------------

Paramètres :

* 'string' : chaîne
* 'mask' : masque, peut commencer ou se terminer par "`*`" (aucune autre "`*`"
  n'est autorisée dans le masque)
* 'case_sensitive' : 1 pour une comparaison tenant compte de la casse, sinon 0

Valeur de retour :

* 1 si la chaîne correspond au masque, sinon 0

Exemple en C :

[source,C]
----------------------------------------
int match1 = weechat_string_match ("abcdef", "abc*", 0); /* == 1 */
int match2 = weechat_string_match ("abcdef", "*dd*", 0); /* == 0 */
int match3 = weechat_string_match ("abcdef", "*def", 0); /* == 1 */
int match4 = weechat_string_match ("abcdef", "*de*", 0); /* == 1 */
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
match = weechat.string_match(string, mask, case_sensitive)

# exemples
match1 = weechat.string_match("abcdef", "abc*", 0) # 1
match2 = weechat.string_match("abcdef", "*dd*", 0) # 0
match3 = weechat.string_match("abcdef", "*def", 0) # 1
match4 = weechat.string_match("abcdef", "*de*", 0) # 1
----------------------------------------

weechat_string_replace
^^^^^^^^^^^^^^^^^^^^^^

Remplace toutes les occurrences d'une chaîne par une autre chaîne.

Prototype :

[source,C]
----------------------------------------
char *weechat_string_replace (const char *string, const char *search,
                              const char *replace);
----------------------------------------

Paramètres :

* 'string' : chaîne
* 'search' : chaîne à remplacer
* 'replace' : remplacement pour la chaîne 'search'

Valeur de retour :

* chaîne avec 'search' remplacée par 'replace' (doit être libérée par un appel
  à "free" après utilisation)

Exemple en C :

[source,C]
----------------------------------------
char *str = weechat_string_replace ("test, test", "s", "x"); /* résultat : "text" */
/* ... */
free (str);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_string_expand_home
^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.3._

Remplace le `~` en début de chaîne par le répertoire "home". Si la chaîne ne
débute pas par `~`, alors une chaîne identique est retournée.

Prototype :

[source,C]
----------------------------------------
char *weechat_string_expand_home (const char *path);
----------------------------------------

Paramètres :

* 'path' : chemin

Valeur de retour :

* chemin avec le `~` en début remplacé par le répertoire "home" (doit être
  libéré par un appel à "free" après utilisation)

Exemple en C :

[source,C]
----------------------------------------
char *str = weechat_string_expand_home ("~/fichier.txt");
/* résultat: "/home/xxx/fichier.txt" */
/* ... */
free (str);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_string_remove_quotes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Supprime les apostrophes/guillemets au début et à la fin d'une chaîne (ignore
les blancs s'ils sont avant la première apostrophe ou après la dernière).

Prototype :

[source,C]
----------------------------------------
char *weechat_string_remove_quotes (const char *string, const char *quotes);
----------------------------------------

Paramètres :

* 'string' : chaîne
* 'quotes' : chaîne avec la liste des apostrophes/guillemets à supprimer

Valeur de retour :

* chaîne sans les apostrophes/guillemets au début et à la fin (doit être
  libérée par un appel à "free" après utilisation)

Exemple en C :

[source,C]
----------------------------------------
char *str = weechat_string_remove_quotes (string, " 'aujourd'hui' ", "'");
/* résultat : "aujourd'hui" */
/* ... */
free (str);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_string_strip
^^^^^^^^^^^^^^^^^^^^

Supprime des caractères au début et/ou à la fin d'une chaîne.

Prototype :

[source,C]
----------------------------------------
char *weechat_string_strip (const char *string, int left, int right,
                            const char *chars);
----------------------------------------

Paramètres :

* 'string' : chaîne
* 'left' : supprime les caractères en début de chaîne si différent de 0
* 'right' : supprime les caractères en fin de chaîne si different de 0
* 'chars' : chaîne avec les caractères à supprimer

Valeur de retour :

* chaîne avec les caractères supprimés (doit être libérée par un appel à "free"
  après utilisation)

Exemple en C :

[source,C]
----------------------------------------
char *str = weechat_string_strip (".abc -", 0, 1, "- ."); /* résultat : ".abc" */
/* ... */
free (str);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_string_mask_to_regex
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Retourne une expression régulière ("regex"), construite avec un masque où le
seul caractère spécial est "`*`". Tous les autres caractères spéciaux
d'expression régulière sont échappés.

Prototype :

[source,C]
----------------------------------------
char *weechat_string_mask_to_regex (const char *mask);
----------------------------------------

Paramètres :

* 'mask' : masque

Valeur de retour :

* expression régulière, sous forme de chaîne (doit être libérée par un appel à
  "free" après utilisation)

Exemple en C :

[source,C]
----------------------------------------
char *str_regex = weechat_string_mask_to_regex ("test*mask");
/* résultat : "test.*mask" */
/* ... */
free (str_regex);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
regex = weechat.string_mask_to_regex(mask)

# exemple
regex = weechat.string_mask_to_regex("test*mask") # "test.*mask"
----------------------------------------

weechat_string_regex_flags
^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.7._

Retourne un pointeur dans la chaîne après les "flags" et retourne le masque avec
les "flags" pour compiler l'expression régulière.

Prototype :

[source,C]
----------------------------------------
const char *weechat_string_regex_flags (const char *regex, int default_flags, int *flags)
----------------------------------------

Paramètres :

* 'regex' : expression régulière
* 'default_flags' : combinaison des valeurs suivantes (voir `man regcomp`) :
** REG_EXTENDED
** REG_ICASE
** REG_NEWLINE
** REG_NOSUB
* 'flags' : la valeur du pointer est alimentée avec les "flags" utilisés dans
  l'expression régulière ("flags" par défaut + "flags" définis dans l'expression
  régulière)

Les "flags" doivent être au début de l'expression régulière. Le format est :
"(?eins-eins)chaîne".

Les "flags" autorisés sont :

* 'e' : expression régulière POSIX étendue ('REG_EXTENDED')
* 'i' : insensible à la casse ('REG_ICASE')
* 'n' : les opérateurs qui cherchent n'importe quel caractère ne trouvent pas
  les nouvelles lignes ('REG_NEWLINE')
* 's' : le support d'adressage des sous-chaînes de correspondance n'est pas
  requis ('REG_NOSUB')

Valeur de retour :

* pointeur dans la 'regex', après les "flags"

Exemple en C :

[source,C]
----------------------------------------
const char *regex = "(?i)test";
int flags;
const char *ptr_regex = weechat_string_regex_flags (regex, REG_EXTENDED, &flags);
/* ptr_regex == "test", flags == REG_EXTENDED | REG_ICASE */
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_string_regcomp
^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.7._

Compile une expression régulière avec des "flags" optionnels en début de chaîne
(pour le format des "flags", voir
<<_weechat_string_regex_flags,weechat_string_regex_flags>>).

Prototype :

[source,C]
----------------------------------------
int weechat_string_regcomp (void *preg, const char *regex, int default_flags)
----------------------------------------

Paramètres :

* 'preg' : pointeur vers la structure 'regex_t'
* 'regex' : expression régulière
* 'default_flags' : combinaison des valeurs suivantes (voir `man regcomp`) :
** REG_EXTENDED
** REG_ICASE
** REG_NEWLINE
** REG_NOSUB

Valeur de retour :

* même code retour que la fonction `regcomp` (0 si ok, autre valeur pour une
  erreur, voir `man regcomp`)

Exemple en C :

[source,C]
----------------------------------------
regex_t my_regex;
if (weechat_string_regcomp (&my_regex, "(?i)test", REG_EXTENDED) != 0)
{
    /* erreur */
}
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_string_has_highlight
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Vérifie si une chaîne a un ou plusieurs "highlights", en utilisant une liste
de mots "highlight".

Prototype :

[source,C]
----------------------------------------
int weechat_string_has_highlight (const char *string,
                                  const char highlight_words);
----------------------------------------

Paramètres :

* 'string' : chaîne
* 'highlight_words' : liste de mots "highlight", séparés par des virgules

Valeur de retour :

* 1 si la chaîne a un ou plusieurs "highlights", sinon 0

Exemple en C :

[source,C]
----------------------------------------
int hl = weechat_string_has_highlight ("my test string", "test,word2"); /* == 1 */
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
highlight = weechat.string_has_highlight(string, highlight_words)

# exemple
highlight = weechat.string_has_highlight("my test string", "test,word2") # 1
----------------------------------------

weechat_string_has_highlight_regex
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.4._

Vérifie si une chaîne a un ou plusieurs "highlights", en utilisant une
expression régulière.
Pour au moins une correspondance dans la chaîne, elle doit être entourée de
caractères de mot (caractère alpha-numérique, "-", "_" ou "|").

Prototype :

[source,C]
----------------------------------------
int weechat_string_has_highlight_regex (const char *string, const char *regex);
----------------------------------------

Paramètres :

* 'string' : chaîne
* 'regex' : expression régulière

Valeur de retour :

* 1 si la chaîne a un ou plusieurs "highlights", sinon 0

Exemple en C :

[source,C]
----------------------------------------
int hl = weechat_string_has_highlight_regex ("my test string", "test|word2"); /* == 1 */
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
highlight = weechat.string_has_highlight_regex(string, regex)

# exemple
highlight = weechat.string_has_highlight_regex("my test string", "test|word2") # 1
----------------------------------------

weechat_string_split
^^^^^^^^^^^^^^^^^^^^

Découpe une chaîne à l'aide de délimiteur(s).

Prototype :

[source,C]
----------------------------------------
char **weechat_string_split (const char *string, const char *separators,
                             int keep_eol, int num_items_max,
                             int *num_items);
----------------------------------------

Paramètres :

* 'string' : chaîne à découper
* 'separators' : délimiteurs utilisés pour le découpage
* 'keep_eol' : si différent de 0, alors chaque paramètre contiendra toutes les
  chaînes jusqu'à la fin de la ligne (voir exemple ci-dessous)
** 0 : chaque chaîne contiendra un mot
** 1 : chaque chaîne contiendra toute la chaîne jusqu'à la fin de la ligne (voir
   exemple ci-dessous)
** 2 : comme 1, mais ne supprime pas les séparateurs en fin de chaîne avant le
   découpage (_nouveau dans la version 0.3.6_)
* 'num_items_max' : nombre maximum de chaînes à créer (0 = pas de limite)
* 'num_items' : pointeur vers un entier qui contiendra le nombre de chaînes
  créées

Valeur de retour :

* tableau de chaînes, NULL en cas de problème (doit être libéré par un appel à
  <<_weechat_string_free_split,weechat_string_free_split>> après utilisation)

Exemples en C :

[source,C]
----------------------------------------
char **argv;
int argc;
argv = weechat_string_split ("abc de  fghi", " ", 0, 0, &argc);
/* résultat :  argv[0] == "abc"
               argv[1] == "de"
               argv[2] == "fghi"
               argv[3] == NULL
               argc == 3
*/
weechat_string_free_split (argv);

argv = weechat_string_split ("abc de  fghi", " ", 1, 0, &argc);
/* résultat : argv[0] == "abc de  fghi"
              argv[1] == "de  fghi"
              argv[2] == "fghi"
              argv[3] == NULL
              argc == 3
*/
weechat_string_free_split (argv);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_string_free_split
^^^^^^^^^^^^^^^^^^^^^^^^^

Libère la mémoire utilisée pour le découpage d'une chaîne.

Prototype :

[source,C]
----------------------------------------
void weechat_string_free_split (char **split_string);
----------------------------------------

Paramètres :

* 'split_string' : chaîne découpée par
  <<_weechat_string_split,weechat_string_split>>

Exemple en C :

[source,C]
----------------------------------------
char *argv;
int argc;
argv = weechat_string_split (string, " ", 0, 0, &argc);
/* ... */
weechat_string_free_split (argv);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_string_build_with_split_string
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Construit une chaîne à partir d'une chaîne découpée.

Prototype :

[source,C]
----------------------------------------
char *weechat_string_build_with_split_string (char **split_string
                                              const char *separator);
----------------------------------------

Paramètres :

* 'split_string' : chaîne découpée par la fonction
  <<_weechat_string_split,weechat_string_split>>
* 'separator' : chaîne utilisée pour séparer les différentes chaînes

Valeur de retour :

* chaîne construite avec la chaîne découpée (doit être libérée par un appel à
  "free" après utilisation)

Exemple en C :

[source,C]
----------------------------------------
char **argv;
int argc;
argv = weechat_string_split ("abc def ghi", " ", 0, 0, &argc);
char *str = weechat_string_build_with_split_string (argv, ";");
/* str == "abc;def;ghi" */
/* ... */
free (str);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_string_split_command
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Eclate une liste de commandes séparées par 'separator' (qui peut être échappé
par "\" dans la chaîne).

Prototype :

[source,C]
----------------------------------------
char **weechat_string_split_command (const char *command, char separator);
----------------------------------------

Paramètres :

* 'command' : commande à éclater
* 'separator' : séparateur

Valeur de retour :

* tableau de chaînes, NULL en cas de problème (doit être libéré par un appel à
  <<_weechat_free_split_command,weechat_free_split_command>> après utilisation)

Exemple en C :

[source,C]
----------------------------------------
char **argv = weechat_string_split_command ("/commande1 arg;/commande2", ';');
/* résultat : argv[0] == "/commande1 arg"
              argv[1] == "/commande2"
*/
weechat_free_split_command (argv);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_string_free_split_command
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Libère la mémoire utilisée par une commande éclatée.

Prototype :

[source,C]
----------------------------------------
void weechat_string_free_split_command (char **split_command);
----------------------------------------

Paramètres :

* 'split_command' : commande éclatée par
  <<_weechat_string_split_command,weechat_string_split_command>>

Exemple en C :

[source,C]
----------------------------------------
char **argv = weechat_string_split_command ("/commande1 arg;/commande2", ';');
/* ... */
weechat_free_split_command (argv);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_string_format_size
^^^^^^^^^^^^^^^^^^^^^^^^^^

Construit une chaîne avec une taille de fichier formatée et une unité traduite
dans la langue locale.

Prototype :

[source,C]
----------------------------------------
char *weechat_string_format_size (unsigned long long size);
----------------------------------------

Paramètres :

* 'size' : taille (en octets)

Valeur de retour :

* chaîne formatée (doit être libérée par un appel à "free" après utilisation)

Exemples en C :

[source,C]
----------------------------------------
/* exemples avec la langue française */

char *str = weechat_string_format_size (0); /* str == "0 octet" */
/* ... */
free (str);

char *str = weechat_string_format_size (200); /* str == "200 octets" */
/* ... */
free (str);

char *str = weechat_string_format_size (1536); /* str == "1.5 Ko" */
/* ... */
free (str);

char *str = weechat_string_format_size (2097152); /* str == "2 Mo" */
/* ... */
free (str);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_string_remove_color
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Supprime les couleurs WeeChat dans une chaîne.

Prototype :

[source,C]
----------------------------------------
char *weechat_string_remove_color (const char *string,
                                   const char *replacement);
----------------------------------------

Paramètres :

* 'string' : chaîne
* 'replacement' : si non NULL et non vide, les couleurs WeeChat sont remplacées
  par le premier caractère de cette chaine, sinon les codes couleurs WeeChat et
  les caractères suivants (rattachés à la couleur) sont supprimés de la chaîne

Valeur de retour :

* chaîne sans couleur (doit être libérée par un appel à "free" après
  utilisation)

Exemples en C :

[source,C]
----------------------------------------
/* supprime les codes couleur */
char *str = weechat_string_remove_color (ma_chaine1, NULL);
/* ... */
free (str);

/* remplace les codes couleur par "?" */
char *str = weechat_string_remove_color (ma_chaine2, "?");
/* ... */
free (str);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
str = weechat.string_remove_color(string, replacement)

# exemple
str = weechat.string_remove_color(ma_chaine, "?")
----------------------------------------

weechat_string_encode_base64
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.2._

Encode une chaîne en base64.

Prototype :

[source,C]
----------------------------------------
void weechat_string_encode_base64 (const char *from, int length, char *to);
----------------------------------------

Paramètres :

* 'from' : chaîne à encoder
* 'length' : longueur de chaîne à encoder (par exemple `strlen(from)`)
* 'to' : pointeur vers la chaîne pour stocker le résultat (doit être suffisamment
  long, le résultat est plus long que la chaîne initiale)

Exemple en C :

[source,C]
----------------------------------------
char *string = "abcdefgh", result[128];
weechat_string_encode_base64 (string, strlen (string), result);
/* result == "YWJjZGVmZ2g=" */
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_string_decode_base64
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.2._

Décode une chaîne base64.

Prototype :

[source,C]
----------------------------------------
int weechat_string_decode_base64 (const char *from, char *to);
----------------------------------------

Paramètres :

* 'from' : chaîne à décoder
* 'to' : pointeur vers la chaîne pour stocker le résultat (doit être suffisamment
  long, le résultat est plus court que la chaîne initiale)

Valeur de retour :

* longueur de la chaîne stockée dans *to (ne compte pas le '\0' final)

Exemple en C :

[source,C]
----------------------------------------
char *string = "YWJjZGVmZ2g=", result[128];
int length;
length = weechat_string_decode_base64 (string, result);
/* length == 8, result == "abcdefgh" */
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_string_is_command_char
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.2._

Vérifie si le premier caractère de la chaîne est un caractère de commande (le
caractère par défaut de commande est '/').

Prototype :

[source,C]
----------------------------------------
int weechat_string_is_command_char (const char *string);
----------------------------------------

Paramètres :

* 'string' : chaîne

Valeur de retour :

* 1 si le premier caractère de la chaîne est un caractère de commande, sinon 0

Exemples en C :

[source,C]
----------------------------------------
int command_char1 = weechat_string_is_command_char ("/test"); /* == 1 */
int command_char2 = weechat_string_is_command_char ("test");  /* == 0 */
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
is_cmdchar = weechat.string_is_command_char(string)

# exemples
command_char1 = weechat.string_is_command_char("/test") # == 1
command_char2 = weechat.string_is_command_char("test")  # == 0
----------------------------------------

weechat_string_input_for_buffer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.2._

Retourne un pointeur vers le texte envoyé vers le tampon (pointeur à
l'intérieur du paramètre "string"), ou NULL si c'est une commande.

Prototype :

[source,C]
----------------------------------------
const char *weechat_string_input_for_buffer (const char *string);
----------------------------------------

Paramètres :

* 'string' : chaîne

Valeur de retour :

* pointeur vers "string", ou NULL

Exemples en C :

[source,C]
----------------------------------------
const char *str1 = weechat_string_input_for_buffer ("test");   /* "test"  */
const char *str2 = weechat_string_input_for_buffer ("/test");  /* NULL    */
const char *str3 = weechat_string_input_for_buffer ("//test"); /* "/test" */
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
str = weechat.string_input_for_buffer(string)

# exemples
str1 = weechat.string_input_for_buffer("test")   # "test"
str2 = weechat.string_input_for_buffer("/test")  # ""
str3 = weechat.string_input_for_buffer("//test") # "/test"
----------------------------------------

[[utf-8]]
UTF-8
~~~~~

Fonctions pour les chaînes UTF-8.

weechat_utf8_has_8bits
^^^^^^^^^^^^^^^^^^^^^^

Vérifie si une chaîne a des caractères 8-bits.

Prototype :

[source,C]
----------------------------------------
int weechat_utf8_has_8bits (const char *string);
----------------------------------------

Paramètres :

* 'string' : chaîne

Valeur de retour :

* 1 si la chaîne a des caractères 8-bits, 0 s'il y a seulement des caractères
  7-bits

Exemple en C :

[source,C]
----------------------------------------
if (weechat_utf8_has_8bits (string))
{
    /* ... */
}
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_utf8_is_valid
^^^^^^^^^^^^^^^^^^^^^

Vérifie si une chaîne est valide UTF-8.

Prototype :

[source,C]
----------------------------------------
int weechat_utf8_is_valid (const char *string, char **error);
----------------------------------------

Paramètres :

* 'string' : chaîne
* 'error' : si non NULL, '*error' est alimenté avec le pointeur vers le premier
  caractère non valide dans la chaîne, s'il y en a

Valeur de retour :

* 1 si la chaîne UTF-8 est valide, sinon 0

Exemple en C :

[source,C]
----------------------------------------
char *error;
if (weechat_utf8_is_valid (string, &error))
{
    /* ... */
}
else
{
    /* "error" pointe vers le premier caractère invalide */
}
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_utf8_normalize
^^^^^^^^^^^^^^^^^^^^^^

Normalise une chaîne UTF-8 : supprime tous les caractères non valides UTF-8
en les remplaçant par un caractère.

Prototype :

[source,C]
----------------------------------------
void weechat_utf8_normalize (char *string, char replacement);
----------------------------------------

Paramètres :

* 'string' : chaîne
* 'replacement' : caractère de remplacement pour les caractères non valides

Exemple en C :

[source,C]
----------------------------------------
weechat_utf8_normalize (string, '?');
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_utf8_prev_char
^^^^^^^^^^^^^^^^^^^^^^

Retourne un pointeur vers le caractère UTF-8 précédent dans une chaîne.

Prototype :

[source,C]
----------------------------------------
char *weechat_utf8_prev_char (const char *string_start, const char *string);
----------------------------------------

Paramètres :

* 'string_start' : début de la chaîne (la fonction ne retournera pas un
  caractère situé avant ce pointeur)
* 'string' : pointeur vers la chaîne (doit être ≥ 'string_start')

Valeur de retour :

* pointeur vers le caractère UTF-8 précédent, NULL si non trouvé (début de
  chaîne atteint)

Exemple en C :

[source,C]
----------------------------------------
char *prev_char = weechat_utf8_prev_char (string, ptr_in_string);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_utf8_next_char
^^^^^^^^^^^^^^^^^^^^^^

Retourne un pointeur vers le caractère UTF-8 suivant dans une chaîne.

Prototype :

[source,C]
----------------------------------------
char *weechat_utf8_next_char (const char *string);
----------------------------------------

Paramètres :

* 'string' : chaîne

Valeur de retour :

* pointeur vers le caractère UTF-8 suivant, NULL si non trouvé (fin de la
  chaîne atteinte)

Exemple en C :

[source,C]
----------------------------------------
char *next_char = weechat_utf8_next_char (string);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_utf8_char_int
^^^^^^^^^^^^^^^^^^^^^

Retourne un caractère UTF-8 sous forme d'entier.

Prototype :

[source,C]
----------------------------------------
int weechat_utf8_char_int (const char *string);
----------------------------------------

Paramètres :

* 'string' : chaîne

Valeur de retour :

* caractère UTF-8 sous forme d'entier

Exemple en C :

[source,C]
----------------------------------------
int char_int = weechat_utf8_char_int ("être"); /* "ê" comme entier */
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_utf8_char_size
^^^^^^^^^^^^^^^^^^^^^^

Retourne la taille d'un caractère UTF-8 (en octets).

Prototype :

[source,C]
----------------------------------------
int weechat_utf8_char_size (const char *string);
----------------------------------------

Paramètres :

* 'string' : chaîne

Valeur de retour :

* taille du caractère UTF-8 (en octets)

Exemple en C :

[source,C]
----------------------------------------
int char_size = weechat_utf8_char_size ("être"); /* == 2 */
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_utf8_strlen
^^^^^^^^^^^^^^^^^^^

Retourne la taille d'une chaîne UTF-8 (en nombre de caractères UTF-8).

Prototype :

[source,C]
----------------------------------------
int weechat_utf8_strlen (const char *string);
----------------------------------------

Paramètres :

* 'string' : chaîne

Valeur de retour :

* longueur de la chaîne UTF-8 (nombre de caractères UTF-8)

Exemple en C :

[source,C]
----------------------------------------
int length = weechat_utf8_strlen ("chêne"); /* == 5 */
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_utf8_strnlen
^^^^^^^^^^^^^^^^^^^^

Retourne la taille d'une chaîne UTF-8 (en nombre de caractères UTF-8), pour au
maximum 'bytes' octets dans la chaîne.

Prototype :

[source,C]
----------------------------------------
int weechat_utf8_strnlen (const char *string, int bytes);
----------------------------------------

Paramètres :

* 'string' : chaîne
* 'bytes' : nombre maximum d'octets

Valeur de retour :

* longueur de la chaîne UTF-8 (nombre de caractères UTF-8)

Exemple en C :

[source,C]
----------------------------------------
int length = weechat_utf8_strnlen ("chêne", 4); /* == 3 */
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_utf8_strlen_screen
^^^^^^^^^^^^^^^^^^^^^^^^^^

Retourne le nombre de caractères nécessaires pour afficher la chaîne UTF-8
sur l'écran.

Prototype :

[source,C]
----------------------------------------
int weechat_utf8_strlen_screen (const char *string);
----------------------------------------

Paramètres :

* 'string' : chaîne

Valeur de retour :

* nombre de caractères nécessaires pour afficher la chaîne UTF-8 sur l'écran

Exemple en C :

[source,C]
----------------------------------------
int length_on_screen = weechat_utf8_strlen_screen ("é"); /* == 1 */
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_utf8_charcmp
^^^^^^^^^^^^^^^^^^^^

Compare deux caractères UTF-8.

Prototype :

[source,C]
----------------------------------------
int weechat_utf8_charcmp (const char *string1, const char *string2);
----------------------------------------

Paramètres :

* 'string1' : première chaîne pour la comparaison
* 'string2' : seconde chaîne pour la comparaison

Valeur de retour :

* différence entre le premier caractère de chaque chaîne :
** négative si char1 < char2
** zéro si char1 == char2
** positive si char1 > char2

Exemple en C :

[source,C]
----------------------------------------
int diff = weechat_utf8_charcmp ("aaa", "ccc"); /* == -2 */
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_utf8_charcasecmp
^^^^^^^^^^^^^^^^^^^^^^^^

Compare deux caractères UTF-8 en ignorant la casse.

Prototype :

[source,C]
----------------------------------------
int weechat_utf8_charcasecmp (const char *string1, const char *string2);
----------------------------------------

Paramètres :

* 'string1' : première chaîne pour la comparaison
* 'string2' : seconde chaîne pour la comparaison

Valeur de retour :

* différence entre le premier caractère de chaque chaîne :
** négative si char1 < char2
** zéro si char1 == char2
** positive si char1 > char2

Exemple en C :

[source,C]
----------------------------------------
int diff = weechat_utf8_charcasecmp ("aaa", "CCC"); /* == -2 */
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_utf8_char_size_screen
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Retourne le nombre de caractères nécessaires pour afficher le caractère UTF-8
sur l'écran.

Prototype :

[source,C]
----------------------------------------
int weechat_utf8_char_size_screen (const char *string);
----------------------------------------

Paramètres :

* 'string' : chaîne

Valeur de retour :

* nombre de caractères nécessaires pour afficher le caractère UTF-8 sur l'écran

Exemple en C :

[source,C]
----------------------------------------
int length_on_screen = weechat_utf8_char_size_screen ("é"); /* == 1 */
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_utf8_add_offset
^^^^^^^^^^^^^^^^^^^^^^^

Avancer de N caractères dans une chaîne UTF-8.

Prototype :

[source,C]
----------------------------------------
char *weechat_utf8_add_offset (const char *string, int offset);
----------------------------------------

Paramètres :

* 'string' : chaîne
* 'offset' : nombre de caractères

Valeur de retour :

* pointeur vers la chaîne, N caractères après (NULL s'il est impossible
  d'atteindre cette position dans la chaîne)

Exemple en C :

[source,C]
----------------------------------------
char *str = "chêne";
char *str2 = weechat_utf8_add_offset (str, 3); /* pointe vers "ne" */
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_utf8_real_pos
^^^^^^^^^^^^^^^^^^^^^

Retourne la position réelle dans une chaîne UTF-8.

Prototype :

[source,C]
----------------------------------------
int weechat_utf8_real_pos (const char *string, int pos);
----------------------------------------

Paramètres :

* 'string' : chaîne
* 'pos' : position (en nombre de caractères)

Valeur de retour :

* position réelle (en octets)

Exemple en C :

[source,C]
----------------------------------------
int pos = weechat_utf8_real_pos ("chêne", 3); /* == 4 */
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_utf8_pos
^^^^^^^^^^^^^^^^

Retourne la position dans une chaîne UTF-8.

Prototype :

[source,C]
----------------------------------------
int weechat_utf8_pos (const char *string, int real_pos);
----------------------------------------

Paramètres :

* 'string' : chaîne
* 'real_pos' : position (en octets)

Valeur de retour :

* position (en nombre de caractères)

Exemple en C :

[source,C]
----------------------------------------
int pos = weechat_utf8_pos ("chêne", 4); /* == 3 */
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_utf8_strndup
^^^^^^^^^^^^^^^^^^^^

Retourne une chaîne dupliquée, avec au plus 'length' caractères.

Prototype :

[source,C]
----------------------------------------
char *weechat_utf8_strndup (const char *string, int length);
----------------------------------------

Paramètres :

* 'string' : chaîne
* 'length' : nombre maximum de caractères à dupliquer

Valeur de retour :

* chaîne dupliquée (doit être libérée avec un appel à "free" après utilisation)

Exemple en C :

[source,C]
----------------------------------------
char *string = weechat_utf8_strndup ("chêne", 3); /* retourne "chê" */
/* ... */
free (str);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

[[directories]]
Répertoires
~~~~~~~~~~~

Fonctions liées aux répertoires.

weechat_mkdir_home
^^^^^^^^^^^^^^^^^^

Crée un répertoire dans le répertoire de WeeChat.

Prototype :

[source,C]
----------------------------------------
int weechat_mkdir_home (char *directory, int mode);
----------------------------------------

Paramètres :

* 'directory' : nom du répertoire à créer
* 'mode' : mode pour le répertoire

Valeur de retour :

* 1 si le répertoire est créé, 0 en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
if (!weechat_mkdir_home ("temp", 0755))
{
    /* erreur */
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.mkdir_home(directory, mode)

# exemple
weechat.mkdir_home("temp", 0755)
----------------------------------------

weechat_mkdir
^^^^^^^^^^^^^

Crée un répertoire.

Prototype :

[source,C]
----------------------------------------
int weechat_mkdir (char *directory, int mode);
----------------------------------------

Paramètres :

* 'directory' : nom du répertoire à créer
* 'mode' : mode pour le répertoire

Valeur de retour :

* 1 si le répertoire est créé, 0 en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
if (!weechat_mkdir ("/tmp/mydir", 0755))
{
    /* erreur */
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.mkdir(directory, mode)

# exemple
weechat.mkdir("/tmp/mydir", 0755)
----------------------------------------

weechat_mkdir_parents
^^^^^^^^^^^^^^^^^^^^^

Crée un répertoire et ses parents si besoin.

Prototype :

[source,C]
----------------------------------------
int weechat_mkdir_parents (char *directory, int mode);
----------------------------------------

Paramètres :

* 'directory' : nom du répertoire à créer
* 'mode' : mode pour le répertoire

Valeur de retour :

* 1 si le répertoire est créé, 0 en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
if (!weechat_mkdir_parents ("/tmp/my/dir", 0755))
{
    /* erreur */
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.mkdir_parents(directory, mode)

# exemple
weechat.mkdir_parents("/tmp/my/dir", 0755)
----------------------------------------

weechat_exec_on_files
^^^^^^^^^^^^^^^^^^^^^

Balaye les fichiers dans un répertoire et exécute un "callback" pour chaque
fichier.

Prototype :

[source,C]
----------------------------------------
void weechat_exec_on_files (const char *directory,
                            int hidden_files,
                            void *data,
                            void (*callback)(void *data,
                                             const char *filename));
----------------------------------------

Paramètres :

* 'directory' : répertoire où chercher les fichiers
* 'hidden_files' : 1 pour inclure les fichiers cachés, sinon 0
* 'data' : pointeur donné au "callback" lorsqu'il est appelé par WeeChat
* 'callback' : fonction appelée pour chaque fichier trouvé, paramètres :
** 'void *data' : pointeur
** 'const char *filename' : nom de fichier trouvé

Exemple en C :

[source,C]
----------------------------------------
void callback (void *data, const char *filename)
{
    /* ... */
}
...
weechat_exec_on_files ("/tmp", 0, NULL, &callback);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_file_get_content
^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.1._

Lit le contenu d'un fichier texte dans une chaîne de caractères.

Prototype :

[source,C]
----------------------------------------
char *weechat_file_get_content (const char *filename);
----------------------------------------

Paramètres :

* 'filename' : chemin et nom du fichier

Valeur de retour :

* contenu du fichier sous forme de chaîne (doit être libérée par un appel à
  "free" après utilisation)

Exemple en C :

[source,C]
----------------------------------------
char *contenu;

contenu = weechat_file_get_content ("/tmp/test.txt");
/* ... */
free (contenu);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

[[util]]
Util
~~~~

Quelques fonctions utiles.

weechat_util_timeval_cmp
^^^^^^^^^^^^^^^^^^^^^^^^

Compare deux structures "timeval".

Prototype :

[source,C]
----------------------------------------
int weechat_util_timeval_cmp (struct timeval *tv1, struct timeval *tv2);
----------------------------------------

Paramètres :

* 'tv1' : première structure "timeval"
* 'tv2' : seconde structure "timeval"

Valeur de retour :

* -1 si tv1 < tv2
* zéro si tv1 == tv2
* +1 si tv1 > tv2

Exemple en C :

[source,C]
----------------------------------------
if (weechat_util_timeval_cmp (&tv1, &tv2) > 0)
{
    /* tv1 > tv2 */
}
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_util_timeval_diff
^^^^^^^^^^^^^^^^^^^^^^^^^

Retourne la différence (en millisecondes) entre deux structures "timeval".

Prototype :

[source,C]
----------------------------------------
long weechat_util_timeval_diff (struct timeval *tv1, struct timeval *tv2);
----------------------------------------

Paramètres :

* 'tv1' : première structure "timeval"
* 'tv2' : seconde structure "timeval"

Valeur de retour :

* différence en millisecondes

Exemple en C :

[source,C]
----------------------------------------
long diff = weechat_util_timeval_diff (&tv1, &tv2);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_util_timeval_add
^^^^^^^^^^^^^^^^^^^^^^^^

Ajoute un intervalle (en millisecondes) à une structure "timeval".

Prototype :

[source,C]
----------------------------------------
void weechat_util_timeval_add (struct timeval *tv, long interval);
----------------------------------------

Paramètres :

* 'tv' : structure "timeval"
* 'interval' : intervalle (en millisecondes)

Exemple en C :

[source,C]
----------------------------------------
weechat_util_timeval_add (&tv, 2000); /* ajoute 2 secondes */
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_util_get_time_string
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.2._

Retourne la date/heure sous forme de chaîne construite avec "strftime".

Prototype :

[source,C]
----------------------------------------
char *weechat_util_get_time_string (const time_t *date);
----------------------------------------

Paramètres :

* 'date' : pointeur vers la date

Exemple en C :

[source,C]
----------------------------------------
time_t date = time (NULL);
weechat_printf (NULL, "date: %s",
                weechat_util_get_time_string (&date));
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

[[sorted_lists]]
Listes triées
~~~~~~~~~~~~~

Fonctions pour les listes triées.

weechat_list_new
^^^^^^^^^^^^^^^^

Crée une nouvelle liste.

Prototype :

[source,C]
----------------------------------------
struct t_weelist *weechat_list_new ();
----------------------------------------

Valeur de retour :

* pointeur vers la nouvelle liste

Exemple en C :

[source,C]
----------------------------------------
struct t_weelist *list = weechat_list_new ();
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
list = weechat.list_new()

# exemple
list = weechat.list_new()
----------------------------------------

weechat_list_add
^^^^^^^^^^^^^^^^

Ajoute un élément dans une liste.

Prototype :

[source,C]
----------------------------------------
struct t_weelist_item *weechat_list_add (struct t_weelist *weelist,
                                         const char *data,
                                         const char *where,
                                         void *user_data);
----------------------------------------

Paramètres :

* 'weelist' : pointeur vers la liste
* 'data' : donnée à insérer dans la liste
* 'where' : position dans la liste :
** 'WEECHAT_LIST_POS_SORT' : ajout dans la liste, en gardant la liste triée
** 'WEECHAT_LIST_POS_BEGINNING' : ajout en début de liste
** 'WEECHAT_LIST_POS_END' : ajout en fin de liste
* 'user_data' : un pointeur quelconque

Valeur de retour :

* pointeur vers le nouvel élément

Exemple en C :

[source,C]
----------------------------------------
struct t_weelist_item *my_item =
    weechat_list_add (list, "ma donnée", WEECHAT_LIST_POS_SORT, NULL);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
item = weechat.list_add(list, data, where, user_data)

# exemple
item = weechat.list_add(list, "ma donnée", weechat.WEECHAT_LIST_POS_SORT, "")
----------------------------------------

weechat_list_search
^^^^^^^^^^^^^^^^^^^

Recherche un élément dans une liste.

Prototype :

[source,C]
----------------------------------------
struct t_weelist_item *weechat_list_search (struct t_weelist *weelist,
                                            const char *data);
----------------------------------------

Paramètres :

* 'weelist' : pointeur vers la liste
* 'data' : donnée à chercher dans la liste

Valeur de retour :

* pointeur vers l'élément trouvé, NULL si aucun élément n'a été trouvé

Exemple en C :

[source,C]
----------------------------------------
struct t_weelist_item *item = weechat_list_search (list, "ma donnée");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
item = weechat.list_search(list, data)

# exemple
item = weechat.list_search(list, "ma donnée")
----------------------------------------

weechat_list_search_pos
^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.4._

Recherche la position d'un élément dans une liste.

Prototype :

[source,C]
----------------------------------------
int weechat_list_search_pos (struct t_weelist *weelist,
                             const char *data);
----------------------------------------

Paramètres :

* 'weelist' : pointeur vers la liste
* 'data' : donnée à chercher dans la liste

Valeur de retour :

* position de l'élément trouvé, -1 si aucun élément n'a été trouvé

Exemple en C :

[source,C]
----------------------------------------
int pos_item = weechat_list_search_pos (list, "ma donnée");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
pos_item = weechat.list_search_pos(list, data)

# exemple
pos_item = weechat.list_search_pos(list, "ma donnée")
----------------------------------------

weechat_list_casesearch
^^^^^^^^^^^^^^^^^^^^^^^

Recherche un élément dans la liste, sans tenir compte de la casse.

Prototype :

[source,C]
----------------------------------------
struct t_weelist_item *weechat_list_casesearch (struct t_weelist *weelist,
                                                const char *data);
----------------------------------------

Paramètres :

* 'weelist' : pointeur vers la liste
* 'data' : données à chercher dans la liste

Valeur de retour :

* pointeur vers l'élément trouvé, NULL si aucun élément n'a été trouvé

Exemple en C :

[source,C]
----------------------------------------
struct t_weelist_item *item = weechat_list_casesearch (list, "ma donnée");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
item = weechat.list_casesearch(list, data)

# exemple
item = weechat.list_casesearch(list, "ma donnée")
----------------------------------------

weechat_list_casesearch_pos
^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.4._

Recherche la position d'un élément dans la liste, sans tenir compte de la casse.

Prototype :

[source,C]
----------------------------------------
int weechat_list_casesearch_pos (struct t_weelist *weelist,
                                 const char *data);
----------------------------------------

Paramètres :

* 'weelist' : pointeur vers la liste
* 'data' : données à chercher dans la liste

Valeur de retour :

* position l'élément trouvé, -1 si aucun élément n'a été trouvé

Exemple en C :

[source,C]
----------------------------------------
int pos_item = weechat_list_casesearch_pos (list, "ma donnée");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
pos_item = weechat.list_casesearch_pos(list, data)

# exemple
pos_item = weechat.list_casesearch_pos(list, "ma donnée")
----------------------------------------

weechat_list_get
^^^^^^^^^^^^^^^^

Retourne un élément de la liste par sa position.

Prototype :

[source,C]
----------------------------------------
struct t_weelist_item *weechat_list_get (struct t_weelist *weelist,
                                         int position);
----------------------------------------

Paramètres :

* 'weelist' : pointeur vers la liste
* 'position' : position dans la liste (le premier élément est 0)

Valeur de retour :

* pointeur vers l'élément trouvé, NULL si aucun élément n'a été trouvé

Exemple en C :

[source,C]
----------------------------------------
struct t_weelist_item *item = weechat_list_get (list, 0); /* premier élément */
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
item = weechat.list_get(list, position)

# exemple
item = weechat.list_get(list, 0)
----------------------------------------

weechat_list_set
^^^^^^^^^^^^^^^^

Affecte une nouvelle valeur pour un élément.

Prototype :

[source,C]
----------------------------------------
void weechat_list_set (struct t_weelist_item *item, const char *value);
----------------------------------------

Paramètres :

* 'item' : pointeur vers l'élément
* 'value' : nouvelle valeur pour l'élément

Exemple en C :

[source,C]
----------------------------------------
weechat_list_set (item, "nouvelle donnée");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.list_set(item, value)

# exemple
weechat.list_set(item, "nouvelle donnée")
----------------------------------------

weechat_list_next
^^^^^^^^^^^^^^^^^

Retourne l'éléement suivant dans la liste.

Prototype :

[source,C]
----------------------------------------
struct t_weelist_item *weechat_list_next (struct t_weelist_item *item);
----------------------------------------

Paramètres :

* 'item' : pointeur vers l'élément

Valeur de retour :

* pointeur vers l'élément suivant, NULL si le pointeur était sur le dernier
  élément de la liste

Exemple en C :

[source,C]
----------------------------------------
struct t_weelist_item *next_item = weechat_list_next (item);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
item = weechat.list_next(item)

# exemple
item = weechat.list_next(item)
----------------------------------------

weechat_list_prev
^^^^^^^^^^^^^^^^^

Retourne l'élément précédent dans la liste.

Prototype :

[source,C]
----------------------------------------
struct t_weelist_item *weechat_list_prev (struct t_weelist_item *item);
----------------------------------------

Paramètres :

* 'item' : pointeur vers l'élément

Valeur de retour :

* pointeur vers l'élément précédent, NULL si le pointeur était sur le premier
  élément de la liste

Exemple en C :

[source,C]
----------------------------------------
struct t_weelist_item *prev_item = weechat_list_prev (item);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
item = weechat.list_prev(item)

# exemple
item = weechat.list_prev(item)
----------------------------------------

weechat_list_string
^^^^^^^^^^^^^^^^^^^

Retourne la valeur de l'élément sous forme de chaîne.

Prototype :

[source,C]
----------------------------------------
const char *weechat_list_string (struct t_weelist_item *item);
----------------------------------------

Paramètres :

* 'item' : pointeur vers l'élément

Valeur de retour :

* valeur de l'élément

Exemple en C :

[source,C]
----------------------------------------
weechat_printf (NULL, "valeur de l'item : %s", weechat_list_string (item));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.list_string(item)

# exemple
weechat.prnt("", "valeur de l'item : %s" % weechat.list_string(item))
----------------------------------------

weechat_list_size
^^^^^^^^^^^^^^^^^

Retourne la taille de la liste (nombre d'éléments).

Prototype :

[source,C]
----------------------------------------
char *weechat_list_size (struct t_weelist *weelist);
----------------------------------------

Paramètres :

* 'weelist' : pointeur vers la liste

Valeur de retour :

* taille de la liste (nombre d'éléments), 0 si la liste est vide

Exemple en C :

[source,C]
----------------------------------------
weechat_printf (NULL, "taille de la liste : %d", weechat_list_size (list));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
size = weechat.list_size(list)

# exemple
weechat.prnt("", "taille de la liste : %d" % weechat.list_size(list))
----------------------------------------

weechat_list_remove
^^^^^^^^^^^^^^^^^^^

Supprime un élément de la liste.

Prototype :

[source,C]
----------------------------------------
void weechat_list_remove (struct t_weelist *weelist,
                          struct t_weelist_item *item);
----------------------------------------

Paramètres :

* 'weelist' : pointeur vers la liste
* 'item' : pointeur vers l'élément

Exemple en C :

[source,C]
----------------------------------------
weechat_list_remove (list, item);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.list_remove(list, item)

# exemple
weechat.list_remove(list, item)
----------------------------------------

weechat_list_remove_all
^^^^^^^^^^^^^^^^^^^^^^^

Supprime tous les éléments de la liste.

Prototype :

[source,C]
----------------------------------------
void weechat_list_remove_all (struct t_weelist *weelist);
----------------------------------------

Paramètres :

* 'weelist' : pointeur vers la liste

Exemple en C :

[source,C]
----------------------------------------
weechat_list_remove_all (list);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.list_remove_all(list)

# exemple
weechat.list_remove_all(list)
----------------------------------------

weechat_list_free
^^^^^^^^^^^^^^^^^

Supprime une liste.

Prototype :

[source,C]
----------------------------------------
void weechat_list_free (struct t_weelist *weelist);
----------------------------------------

Paramètres :

* 'weelist' : pointeur vers la liste

Exemple en C :

[source,C]
----------------------------------------
weechat_list_free (list);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.list_free(list)

# exemple
weechat.list_free(list)
----------------------------------------

[[hashtables]]
Hashtables
~~~~~~~~~~

Fonctions pour les hashtables.

weechat_hashtable_new
^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.3._

Crée une nouvelle hashtable.

Prototype :

[source,C]
----------------------------------------
struct t_hashtable *weechat_hashtable_new (int size,
                                           const char *type_keys,
                                           const char *type_values,
                                           unsigned int (*callback_hash_key)(struct t_hashtable *hashtable,
                                                                             const void *key),
                                           int (*callback_keycmp)(struct t_hashtable *hashtable,
                                                                  const void *key1,
                                                                  const void *key2));
----------------------------------------

Paramètres :

* 'size' : taille du tableau interne pour stocker les clés sous forme de "hash",
  une grande valeur utilise plus de mémoire mais présente une meilleure
  performance (cela n'est *pas* une limite sur le nombre d'entrées de la
  hashtable)
* 'type_keys' : type pour les clés dans la hashtable :
** 'WEECHAT_HASHTABLE_INTEGER'
** 'WEECHAT_HASHTABLE_STRING'
** 'WEECHAT_HASHTABLE_POINTER'
** 'WEECHAT_HASHTABLE_BUFFER'
** 'WEECHAT_HASHTABLE_TIME'
* 'type_values' : type pour les valeurs dans la hashtable :
** 'WEECHAT_HASHTABLE_INTEGER'
** 'WEECHAT_HASHTABLE_STRING'
** 'WEECHAT_HASHTABLE_POINTER'
** 'WEECHAT_HASHTABLE_BUFFER'
** 'WEECHAT_HASHTABLE_TIME'
* 'callback_hash_key' : fonction appelée pour rendre le "hash" d'une clé (la clé
  sous forme de nombre entier), peut être NULL si le type de clé est "string"
  (une fonction par défaut est utilisée pour les chaînes, et seulement pour les
  chaînes). Paramètres et valeur de retour :
** 'struct t_hashtable *hashtable' : pointeur vers la hashtable
** 'const void *key' : clé
** valeur de retour : "hash" de la clé
* 'callback_keycmp' : fonction appelée pour comparer deux clés, peut être NULL
  si le type de valeur est "string" (une fonction par défaut est utilisée pour
  les chaînes, et seulement pour les chaînes). Paramètres et valeur de retour :
** 'struct t_hashtable *hashtable' : pointeur vers la hashtable
** 'const void *key1' : première clé
** 'const void *key2' : seconde clé
** valeur de retour :
*** nombre négatif si 'key1' est inférieur à 'key2'
*** 0 si 'key1' est égal à 'key2'
*** nombre positif si 'key1' est supérieur à 'key2'

Valeur de retour :

* pointeur vers la nouvelle hashtable, NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_hashtable_set_with_size
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.3._

Ajoute ou met à jour une entrée dans une hashtable avec une taille pour la clé
et la valeur.

Prototype :

[source,C]
----------------------------------------
int weechat_hashtable_set_with_size (struct t_hashtable *hashtable,
                                     const void *key, int key_size,
                                     const void *value, int value_size);
----------------------------------------

Paramètres :

* 'hashtable' : pointeur vers la hashtable
* 'key' : pointeur vers la clé
* 'key_size' : taille de la clé (en octets), utilisée seulement si le type de
  clés dans la hashtable est "buffer"
* 'value' : pointeur vers la valeur
* 'value_size' : taille de la valeur (en octets), utilisée seulement si le type
  de valeurs dans la hashtable est "buffer"

Valeur de retour :

* 1 si ok, 0 en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
weechat_hashtable_set_with_size (hashtable, "ma_cle", 0,
                                 my_buffer, sizeof (my_buffer_struct));
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_hashtable_set
^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.3._

Ajoute ou met à jour une entrée dans la hashtable.

Prototype :

[source,C]
----------------------------------------
int weechat_hashtable_set (struct t_hashtable *hashtable,
                           const void *key, const void *value);
----------------------------------------

Paramètres :

* 'hashtable' : pointeur vers la hashtable
* 'key' : pointeur vers la clé
* 'value' : pointeur vers la valeur

Valeur de retour :

* 1 si ok, 0 en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
weechat_hashtable_set (hashtable, "ma_cle", "ma_valeur");
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_hashtable_get
^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.3._

Retourne la valeur associée à une clé dans une hashtable.

Prototype :

[source,C]
----------------------------------------
void *weechat_hashtable_get (struct t_hashtable *hashtable, void *key);
----------------------------------------

Paramètres :

* 'hashtable' : pointeur vers la hashtable
* 'key' : pointeur vers la clé

Valeur en retour :

* valeur pour la clé, NULL si la clé n'est pas trouvée

Exemple en C :

[source,C]
----------------------------------------
void *value = weechat_hashtable_get (hashtable, "ma_cle");
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_hashtable_has_key
^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.4._

Retourne 1 si la clé est dans la hashtable, sinon 0.

Prototype :

[source,C]
----------------------------------------
int weechat_hashtable_has_key (struct t_hashtable *hashtable, void *key);
----------------------------------------

Paramètres :

* 'hashtable' : pointeur vers la hashtable
* 'key' : pointeur vers la clé

Valeur en retour :

* 1 si la clé est dans la hashtable, 0 si la clé n'est pas dans la hashtable

Exemple en C :

[source,C]
----------------------------------------
if (weechat_hashtable_has_key (hashtable, "ma_cle"))
{
    /* la clé est dans la hashtable */
    /* ... */
}
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_hashtable_map
^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.3._

Appelle une fonction pour chaque entrée d'une hashtable.

Prototype :

[source,C]
----------------------------------------
void hashtable_map (struct t_hashtable *hashtable,
                    void (*callback_map)(void *data,
                                         struct t_hashtable *hashtable,
                                         const void *key,
                                         const void *value),
                    void *callback_map_data);
----------------------------------------

Paramètres :

* 'hashtable' : pointeur vers la hashtable
* 'callback_map' : fonction appelée pour chaque entrée de la hashtable
* 'callback_map_data' : pointeur donné au "callback" lorsqu'il est appelé

Exemple en C :

[source,C]
----------------------------------------
void
map_cb (void *data, struct t_hashtable *hashtable,
        const void *key, const void *value)
{
    /* afficher la clé et la valeur (elles sont des chaînes ici) */
    weechat_printf (NULL, "clé: '%s', valeur: '%s'",
                    (const char *)key,
                    (const char *)value);
}
/* ... */
weechat_hashtable_map (hashtable, &map_cb, NULL);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_hashtable_map_string
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.7._

Appelle une fonction pour chaque entrée d'une hashtable, en envoyant les clés
et valeurs sous forme de chaînes.

Prototype :

[source,C]
----------------------------------------
void hashtable_map_string (struct t_hashtable *hashtable,
                           void (*callback_map)(void *data,
                                                struct t_hashtable *hashtable,
                                                const char *key,
                                                const char *value),
                           void *callback_map_data);
----------------------------------------

Paramètres :

* 'hashtable' : pointeur vers la hashtable
* 'callback_map' : fonction appelée pour chaque entrée de la hashtable
* 'callback_map_data' : pointeur donné au "callback" lorsqu'il est appelé

[NOTE]
Les chaînes 'key' et 'value' envoyées au "callback" sont des chaînes
temporaires, elles sont supprimées après l'appel au "callback".

Exemple en C :

[source,C]
----------------------------------------
void
map_cb (void *data, struct t_hashtable *hashtable,
        const char *key, const char *value)
{
    /* afficher la clé et la valeur */
    weechat_printf (NULL, "clé: '%s', valeur: '%s'",
                    key, value);
}
/* ... */
weechat_hashtable_map_string (hashtable, &map_cb, NULL);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_hashtable_get_integer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.3._

Retourne une valeur entière pour une propriété d'une hashtable.

Prototype :

[source,C]
----------------------------------------
int weechat_hashtable_get_integer (struct t_hashtable *hashtable,
                                   void *property);
----------------------------------------

Paramètres :

* 'hashtable' : pointeur vers la hashtable
* 'property' : nom de propriété :
** 'size' : taille du tableau interne "htable" dans la hashtable
** 'items_count' : nombre d'éléments dans la hashtable

Valeur en retour :

* valeur de la propriété sous forme d'entier

Exemple en C :

[source,C]
----------------------------------------
int items_count = weechat_hashtable_get_integer (hashtable, "items_count");
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_hashtable_get_string
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.4._

Retourne une valeur pour une propriété d'une hashtable sous forme de chaîne.

Prototype :

[source,C]
----------------------------------------
const char *weechat_hashtable_get_string (struct t_hashtable *hashtable,
                                          const char *property);
----------------------------------------

Paramètres :

* 'hashtable' : pointeur vers la hashtable
* 'property' : nom de la propriété :
** 'type_keys' : type pour les clés :
*** 'integer' : entier
*** 'string' : chaîne
*** 'pointer' : pointeur
*** 'buffer' : buffer
*** 'time' : heure
** 'type_values' : type pour les valeurs :
*** 'integer' : entier
*** 'string' : chaîne
*** 'pointer' : pointeur
*** 'buffer' : buffer
*** 'time' : heure
** 'keys' : chaîne avec la liste des clés (format : "clé1,clé2,clé3")
** 'keys_sorted' : chaîne avec la liste triée des clés (format :
   "clé1,clé2,clé3")
** 'values' : chaîne avec la liste des valeurs (format : "valeur1,valeur2,valeur3")
** 'keys_values' : chaîne avec la liste des clés et valeurs
   (format : "clé1:valeur1,clé2:valeur2,clé3:valeur3")
** 'keys_values_sorted' : chaîne avec la liste des clés et valeurs (triée sur
   les clés) (format : "clé1:valeur1,clé2:valeur2,clé3:valeur3")

Valeur en retour :

* valeur de la propriété sous forme de chaîne

Exemples en C :

[source,C]
----------------------------------------
weechat_printf (NULL, "les clés sont de type: %s",
                weechat_hashtable_get_string (hashtable, "type_keys"));
weechat_printf (NULL, "liste des clés: %s",
                weechat_hashtable_get_string (hashtable, "keys"));
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_hashtable_set_pointer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.4._

Affecte un pointeur à une propriété d'une hashtable.

Prototype :

[source,C]
----------------------------------------
void weechat_hashtable_set_pointer (struct t_hashtable *hashtable,
                                    const char *property, void *pointer);
----------------------------------------

Paramètres :

* 'hashtable' : pointeur vers la hashtable
* 'property' et 'value' : nom de la propriété, avec sa valeur :
** 'callback_free_value' : définit la fonction "callback" pour libérer les
   valeurs de la hashtable

Exemple en C :

[source,C]
----------------------------------------
void
my_free_value_cb (struct t_hashtable *hashtable, const void *key, void *value)
{
    /* ... */
}

weechat_hashtable_set_pointer (hashtable, "callback_free_value", &my_free_value_cb);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_hashtable_add_to_infolist
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.3._

Ajoute les éléments d'une hashtable dans un objet infolist.

Prototype :

[source,C]
----------------------------------------
int weechat_hashtable_add_to_infolist (struct t_hashtable *hashtable,
                                       struct t_infolist_item *infolist_item,
                                       const char *prefix);
----------------------------------------

Paramètres :

* 'hashtable' : pointeur vers la hashtable
* 'infolist_item' : pointeur vers l'objet de l'infolist
* 'prefix' : chaîne utilisée comme préfixe pour les noms dans l'infolist

Valeur en retour :

* 1 si ok, 0 en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
weechat_hashtable_add_to_infolist (hashtable, infolist_item, "testhash");

/* si la hashtable contient :
     "cle1" => "valeur 1"
     "cle2" => "valeur 2"
   alors les variables suivantes seront ajoutées dans l'objet de l'infolist :
     "testhash_name_00000"  = "cle1"
     "testhash_value_00000" = "valeur 1"
     "testhash_name_00001"  = "cle2"
     "testhash_value_00001" = "valeur 2"
*/
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_hashtable_remove
^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.3._

Supprime un élément d'une hashtable.

Prototype :

[source,C]
----------------------------------------
void weechat_hashtable_remove (struct t_hashtable *hashtable, const void *key);
----------------------------------------

Paramètres :

* 'hashtable' : pointeur vers la hashtable
* 'key' : pointeur vers la clé

Exemple en C :

[source,C]
----------------------------------------
weechat_hashtable_remove (hashtable, "ma_cle");
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_hashtable_remove_all
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.3._

Supprime tous les éléments d'une hashtable.

Prototype :

[source,C]
----------------------------------------
void weechat_hashtable_remove_all (struct t_hashtable *hashtable);
----------------------------------------

Paramètres :

* 'hashtable' : pointeur vers la hashtable

Exemple en C :

[source,C]
----------------------------------------
weechat_hashtable_remove_all (hashtable);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_hashtable_free
^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.3._

Supprime une hashtable.

Prototype :

[source,C]
----------------------------------------
void weechat_hashtable_free (struct t_hashtable *hashtable);
----------------------------------------

Paramètres :

* 'hashtable' : pointeur vers la hashtable

Exemple en C :

[source,C]
----------------------------------------
weechat_hashtable_free (hashtable);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

[[configuration_files]]
Fichiers de configuration
~~~~~~~~~~~~~~~~~~~~~~~~~

Fonctions pour les fichiers de configuration.

weechat_config_new
^^^^^^^^^^^^^^^^^^

Crée un nouveau fichier de configuration.

Prototype :

[source,C]
----------------------------------------
struct t_config_file *weechat_config_new (const char *name,
                                          int (*callback_reload)(void *data,
                                                                 struct t_config_file *config_file),
                                          void *callback_reload_data);
----------------------------------------

Paramètres :

* 'name' : nom du nouveau fichier de configuration (sans chemin ou extension)
* 'callback_reload' : fonction appelée quand le fichier de configuration est
  rechargé avec `/reload` (optionnel, peut être NULL), paramètres et valeur de
  retour :
** 'void *data' : pointeur
** 'struct t_config_file *config_file' : pointeur vers le fichier de
   configuration
** valeur de retour :
*** 'WEECHAT_CONFIG_READ_OK'
*** 'WEECHAT_CONFIG_READ_MEMORY_ERROR'
*** 'WEECHAT_CONFIG_READ_FILE_NOT_FOUND'
* 'callback_reload_data' : pointeur donné au "callback" de rechargement
  lorsqu'il est appelé par WeeChat

Valeur de retour :

* pointeur vers le nouveau fichier de configuration, NULL en cas d'erreur

[NOTE]
Le fichier n'est PAS créé sur le disque par cette fonction. Il sera créé par
l'appel à la fonction <<_weechat_write_config,weechat_write_config>>.
Vous ne devriez appeler cette fonction qu'après avoir créé les sections (avec
<<_weechat_config_new_section,weechat_config_new_section>>) et les options (avec
<<_weechat_config_new_option,weechat_config_new_option>>).

Exemple en C :

[source,C]
----------------------------------------
int
my_config_reload_cb (void *data, struct t_config_file *config_file)
{
    /* ... */

    return WEECHAT_RC_OK;
}

struct t_config_file *config_file = weechat_config_new ("test",
                                                        &my_config_reload_cb,
                                                        NULL);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
config_file = weechat.config_new(name, calback_reload, callback_reload_data)

# exemple
def my_config_reload_cb(data, config_file):
    # ...
    return weechat.WEECHAT_RC_OK

config_file = weechat.config_new("test", "my_config_reload_cb", "")
----------------------------------------

weechat_config_new_section
^^^^^^^^^^^^^^^^^^^^^^^^^^

Crée une nouvelle section dans un fichier de configuration.

Prototype :

[source,C]
----------------------------------------
struct t_config_section *weechat_config_new_section (
    struct t_config_file *config_file,
    const char *name,
    int user_can_add_options,
    int user_can_delete_options,
    int (*callback_read)(void *data,
                         struct t_config_file *config_file,
                         struct t_config_section *section,
                         const char *option_name,
                         const char *value),
    void *callback_read_data,
    int (*callback_write)(void *data,
                          struct t_config_file *config_file,
                          const char *section_name),
    void *callback_write_data,
    int (*callback_write_default)(void *data,
                                  struct t_config_file *config_file,
                                  const char *section_name);
    void *callback_write_default_data,
    int (*callback_create_option)(void *data,
                                  struct t_config_file *config_file,
                                  struct t_config_section *section,
                                  const char *option_name,
                                  const char *value),
    void *callback_create_option_data,
    int (*callback_delete_option)(void *data,
                                  struct t_config_file *config_file,
                                  struct t_config_section *section,
                                  struct t_config_option *option),
    void *callback_delete_option_data);
----------------------------------------

Paramètres :

* 'config_file' : pointeur vers le fichier de configuration
* 'name' : nom de la section
* 'user_can_add_options' : 1 si l'utilisateur peut créer de nouvelles options
  dans la section, ou 0 si c'est interdit
* 'user_can_delete_options' : 1 si l'utilisateur peut supprimer des options
  dans la section, ou 0 si c'est interdit
* 'callback_read' : fonction appelée quand une option de la section est lue
  depuis le disque (devrait être NULL dans la plupart des cas, sauf si des
  options de la section nécessitent une fonction personnalisée), paramètres et
  valeur de retour :
** 'void *data' : pointeur
** 'struct t_config_file *config_file' : pointeur vers le fichier de
   configuration
** 'struct t_config_section *section' : pointeur vers la section
** 'const char *option_name' : nom de l'option
** 'const char *value' : valeur
** valeur de retour :
*** 'WEECHAT_CONFIG_READ_OK'
*** 'WEECHAT_CONFIG_READ_MEMORY_ERROR'
*** 'WEECHAT_CONFIG_READ_FILE_NOT_FOUND'
* 'callback_read_data' : pointeur donné au "callback" quand il est appelé par
   WeeChat
* 'callback_write' : fonction appelée lorsque la section est écrite dans le
  fichier (devrait être NULL dans la plupart des cas, sauf si la section
  nécessite d'être écrite par une fonction personnalisée), paramètres et valeur
  de retour :
** 'void *data' : pointeur
** 'struct t_config_file *config_file' : pointeur vers le fichier de
   configuration
** 'struct t_config_section *section' : pointeur vers la section
** 'const char *option_name' : nom de l'option
** valeur de retour :
*** 'WEECHAT_CONFIG_WRITE_OK'
*** 'WEECHAT_CONFIG_WRITE_ERROR'
*** 'WEECHAT_CONFIG_WRITE_MEMORY_ERROR'
* callback_write_data : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat
* callback_write_default : fonction appelée lorsque les valeurs par défaut
  doivent être écrites dans le fichier, paramètres et valeur de retour :
** 'void *data' : pointeur
** 'struct t_config_file *config_file' : pointeur vers le fichier de
   configuration
** 'const char *section_name' : nom de la section
** valeur de retour :
*** 'WEECHAT_CONFIG_WRITE_OK'
*** 'WEECHAT_CONFIG_WRITE_ERROR'
*** 'WEECHAT_CONFIG_WRITE_MEMORY_ERROR'
* 'callback_write_default_data' : pointeur donné au "callback" lorsqu'il est
  appelé par WeeChat
* 'callback_create_option' : fonction appelée lorsqu'une nouvelle option est
  créée dans la section (NULL si la section n'autorise pas la création de
  nouvelles options), paramètres et valeur de retour :
** 'void *data' : pointeur
** 'struct t_config_file *config_file' : pointeur vers le fichier de
   configuration
** 'struct t_config_section *section' : pointeur vers la section
** 'const char *option_name' : nom de l'option
** 'const char *value' : valeur
* 'callback_create_option_data' : pointeur donné au "callback" lorsqu'il est
  appelé par WeeChat
* 'callback_delete_option' : fonction appelée lorsqu'une option est supprimée
  de la section (NULL si la section n'autorise pas la suppression d'options),
  paramètres et valeur de retour :
** 'void *data' : pointeur
** 'struct t_config_file *config_file' : pointeur vers le fichier de
   configuration
** 'struct t_config_section *section' : pointeur vers la section
** 'struct t_config_option *option' : pointeur vers l'option
** valeur de retour :
*** 'WEECHAT_CONFIG_OPTION_SET_OK_CHANGED'
*** 'WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE'
*** 'WEECHAT_CONFIG_OPTION_SET_ERROR'
*** 'WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND'
* 'callback_delete_option_data' : pointeur donné au "callback" lorsqu'il est
  appelé par WeeChat

Valeur de retour :

* pointeur vers la nouvelle section du fichier de configuration, NULL en cas
  d'erreur

Exemple en C :

[source,C]
----------------------------------------
int
my_section_read_cb (void *data, struct t_config_file *config_file,
                    struct t_config_section *section, const char *option_name,
                    const char *value)
{
    /* ... */

    return WEECHAT_CONFIG_OPTION_SET_OK_CHANGED;
    /* return WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE; */
    /* return WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND; */
    /* return WEECHAT_CONFIG_OPTION_SET_ERROR; */
}

int
my_section_write_cb (void *data, struct t_config_file *config_file,
                     const char *section_name)
{
    /* ... */

    return WEECHAT_CONFIG_WRITE_OK;
    /* return WEECHAT_CONFIG_WRITE_ERROR; */
}

int
my_section_write_default_cb (void *data, struct t_config_file *config_file,
                             const char *section_name)
{
    /* ... */

    return WEECHAT_CONFIG_WRITE_OK;
    /* return WEECHAT_CONFIG_WRITE_ERROR; */
}

int
my_section_create_option_cb (void *data, struct t_config_file *config_file,
                             struct t_config_section *section,
                             const char *option_name, const char *value)
{
    /* ... */

    return WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE;
    /* return WEECHAT_CONFIG_OPTION_SET_ERROR; */
}

int
my_section_delete_option_cb (void *data, struct t_config_file *config_file,
                             struct t_config_section *section,
                             struct t_config_option *option)
{
    /* ... */

    return WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED;
    /* return WEECHAT_CONFIG_OPTION_UNSET_ERROR; */
}

/* section standard, l'utilisateur ne peut pas ajouter/supprimer des options */
struct t_config_section *new_section1 =
    weechat_config_new_section (config_file, "section1", 0, 0,
                                NULL, NULL, /* callback de lecture */
                                NULL, NULL, /* callback d'écriture */
                                NULL, NULL, /* callback d'écriture (valeurs par défaut) */
                                NULL, NULL, /* callback de création d'option */
                                NULL, NULL); /* callback de suppression d'option */

/* section spéciale, l'utilisateur peut ajouter/supprimer des options, et les
   options nécessitent un callback pour la lecture/écriture */
struct t_config_section *new_section2 =
    weechat_config_new_section (config_file, "section2", 1, 1,
                                &my_section_read_cb, NULL,
                                &my_section_write_cb, NULL,
                                &my_section_write_default_cb, NULL,
                                &my_section_create_option_cb, NULL,
                                &my_section_delete_option_cb, NULL);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
section = weechat.config_new_section(config_file, name,
    user_can_add_options, user_can_delete_options,
    callback_read, callback_read_data,
    callback_write, callback_write_data,
    callback_create_option, callback_create_option_data,
    callback_delete_option, callback_delete_option_data)

# exemple
def my_section_read_cb(data, config_file, section, option_name, value):
    # ...
    return weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED
    # return weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE
    # return weechat.WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND
    # return weechat.WEECHAT_CONFIG_OPTION_SET_ERROR

def my_section_write_cb(data, config_file, section_name):
    # ...
    return weechat.WEECHAT_CONFIG_WRITE_OK

def my_section_write_default_cb(data, config_file, section_name):
    # ...
    return weechat.WEECHAT_CONFIG_WRITE_OK

def my_section_create_option_cb(data, config_file, section, option_name, value):
    # ...
    return weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE

def my_section_delete_option_cb(data, config_file, section, option):
    # ...
    return weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED

section = weechat.config_new_section(config_file, "section1", 1, 1,
    "my_section_read_cb", "",
    "my_section_write_cb", "",
    "my_section_write_default_cb", "",
    "my_section_create_option_cb", "",
    "my_section_delete_option_cb", "")
----------------------------------------

weechat_config_search_section
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Recherche une section dans un fichier de configuration.

Prototype :

[source,C]
----------------------------------------
struct t_config_section *weechat_config_search_section (
    struct t_config_file *config_file,
    const char *section_name);
----------------------------------------

Paramètres :

* 'config_file' : pointeur vers le fichier de configuration
* 'section_name' : nom de la section à chercher

Valeur de retour :

* pointeur vers la section trouvée, ou NULL si la section n'a pas été trouvée

Exemple en C :

[source,C]
----------------------------------------
struct t_config_section *section = weechat_config_search_section (config_file,
                                                                  "section");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
section = weechat.config_search_section(config_file, section_name)

# exemple
section = weechat.config_search_section(config_file, "section")
----------------------------------------

weechat_config_new_option
^^^^^^^^^^^^^^^^^^^^^^^^^

Crée une nouvelle option dans une section d'un fichier de configuration.

Prototype :

[source,C]
----------------------------------------
struct t_config_option *weechat_config_new_option (
    struct t_config_file *config_file,
    struct t_config_section *section,
    const char *name,
    const char *type,
    const char *description,
    const char *string_values,
    int min,
    int max,
    const char *default_value,
    const char *value,
    int null_value_allowed,
    int (*callback_check_value)(void *data,
                                struct t_config_option *option,
                                const char *value),
    void *callback_check_value_data,
    void (*callback_change)(void *data,
                            struct t_config_option *option),
    void *callback_change_data,
    void (*callback_delete)(void *data,
                            struct t_config_option *option),
    void *callback_delete_data);
----------------------------------------

Paramètres :

* 'config_file' : pointeur vers le fichier de configuration
* 'section' : pointeur vers la section
* 'name' : nom de l'option
* 'type' : type de l'option :
** 'boolean' : valeur booléenne (on/off)
** 'integer' : valeur entière (avec en option une chaîne pour chaque valeur)
** 'string' : une chaîne de caractères
** 'color' : une couleur
* 'description' : description de l'option
* 'string_values' : valeurs sous forme de chaîne (séparées par "|"), utilisées
  pour le type 'integer' (optionnel)
* 'min' : valeur minimum (pour le type 'integer')
* 'max' : valeur maximum (pour le type 'integer')
* 'default_value' : valeur par défaut de l'option (utilisée quand l'option est
  réinitialisée)
* 'value' : valeur de l'option
* 'null_value_allowed' : 1 si 'null' (valeur non définie) est autorisé pour
  l'option, sinon 0
* 'callback_check_value' : fonction appelée pour vérifier la nouvelle valeur
  de l'option (optionnel), paramètres et valeur de retour :
** 'void *data' : pointeur
** 'struct t_config_option *option' : pointeur vers l'option
** 'const char *value' : nouvelle valeur pour l'option
** valeur de retour :
*** 1 si la valeur est ok
*** 0 si la valeur est invalide
* 'callback_check_value_data' : pointeur donné au "callback" lorsqu'il est
  appelé par WeeChat
* 'callback_change' : fonction appelée lorsque la valeur de l'option a changé
  (optionnel), paramètres :
** 'void *data' : pointeur
** 'struct t_config_option *option' : pointeur vers l'option
* 'callback_change_data' : pointeur donné au "callback" lorsqu'il est appelé
  par WeeChat
* 'callback_delete' : fonction appelée lorsque l'option est supprimée
  (optionnel), paramètres :
** 'void *data' : pointeur
** 'struct t_config_option *option' : pointeur vers l'option
* 'callback_delete_data' : pointeur donné au "callback" lorsqu'il est appelé
  par WeeChat

Valeur de retour :

* pointeur vers la nouvelle option de la section, NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
/* booléen */
struct t_config_option *option1 =
    weechat_config_new_option (config_file, section, "option1", "boolean",
                               "Mon option, type booléen"
                               NULL, /* valeurs sous forme de chaînes */
                               0, 0, /* min, max */
                               "on", /* défaut */
                               "on", /* valeur */
                               0, /* valeur null autorisée */
                               NULL, NULL, /* callback de vérification */
                               NULL, NULL, /* callback de changement de valeur */
                               NULL, NULL); /* callback de suppression de l'option */

/* entier */
struct t_config_option *option2 =
    weechat_config_new_option (config_file, section, "option2", "integer",
                               "Mon option, type entier"
                               NULL, /* valeurs sous forme de chaînes */
                               0, 100, /* min, max */
                               "15", /* défaut */
                               "15", /* valeur */
                               0, /* valeur null autorisée */
                               NULL, NULL, /* callback de vérification */
                               NULL, NULL, /* callback de changement de valeur */
                               NULL, NULL); /* callback de suppression de l'option */

/* entier (avec valeurs sous forme de chaînes) */
struct t_config_option *option3 =
    weechat_config_new_option (config_file, section, "option3", "integer",
                               "Mon option, type entier "
                               "(avec valeurs sous forme de chaînes)"
                               "top|bottom|left|right", /* valeurs sous forme de chaînes */
                               0, 0, /* min, max */
                               "bottom", /* défaut */
                               "bottom", /* valeur */
                               0, /* valeur null autorisée */
                               NULL, NULL, /* callback de vérification */
                               NULL, NULL, /* callback de changement de valeur */
                               NULL, NULL); /* callback de suppression de l'option */

/* chaîne */
struct t_config_option *option4 =
    weechat_config_new_option (config_file, section, "option4", "string",
                               "Mon option, type chaîne"
                               NULL, /* valeurs sous forme de chaînes */
                               0, 0, /* min, max */
                               "test", /* défaut */
                               "test", /* valeur */
                               1, /* valeur null autorisée */
                               NULL, NULL, /* callback de vérification */
                               NULL, NULL, /* callback de changement de valeur */
                               NULL, NULL); /* callback de suppression de l'option */

/* couleur */
struct t_config_option *option5 =
    weechat_config_new_option (config_file, section, "option5", "color",
                               "Mon option, type couleur"
                               NULL, /* valeurs sous forme de chaînes */
                               0, 0, /* min, max */
                               "lightblue", /* défaut */
                               "lightblue", /* valeur */
                               0, /* valeur null autorisée */
                               NULL, NULL, /* callback de vérification */
                               NULL, NULL, /* callback de changement de valeur */
                               NULL, NULL); /* callback de suppression de l'option */
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
option = weechat.config_new_option(config_file, section, name, type, description,
    string_values, min, max, default_value, value, null_value_allowed,
    callback_check_value, callback_check_value_data,
    callback_change, callback_change_data,
    callback_delete, callback_delete_data)

# exemple
def option4_check_value_cb(data, option, value):
    # ...
    return 1
    # return 0

def option4_change_cb(data, option):
    # ...

def option4_delete_cb(data, option):
    # ...

option1 = weechat.config_new_option(config_file, section, "option1", "boolean",
    "Mon option, type booléen",
    "", 0, 0, "on", "on", 0,
    "", "",
    "", "",
    "", "")

option2 = weechat.config_new_option(config_file, section, "option2", "integer",
    "Mon option, type entier",
    "", 0, 100, "15", "15", 0,
    "", "",
    "", "",
    "", "")

option3 = weechat.config_new_option(config_file, section, "option3", "integer",
    "Mon option, type entier (avec valeurs sous forme de chaînes)",
    "top|bottom|left|right",
    0, 0, "bottom", "bottom", 0,
    "", "",
    "", "",
    "", "")

option4 = weechat.config_new_option(config_file, section, "option4", "string",
    "Mon option, type chaîne",
    "", 0, 0, "test", "test", 1,
    "option4_check_value_cb", ""
    "option4_change_cb", "",
    "option4_delete_cb", "")

option5 = weechat.config_new_option(config_file, section, "option5", "color",
    "Mon option, type couleur",
    "", 0, 0, "lightblue", "lightblue", 0,
    "", "",
    "", "",
    "", "")
----------------------------------------

weechat_config_search_option
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Recherche une option dans une section d'un fichier de configuration.

Prototype :

[source,C]
----------------------------------------
struct t_config_option *weechat_config_search_option (
    struct t_config_file *config_file,
    struct t_config_section *section,
    const char *option_name);
----------------------------------------

Paramètres :

* 'config_file' : pointeur vers le fichier de configuration
* 'section' : pointeur vers la section
* 'name' : nom de l'option à rechercher

Valeur de retour :

* pointeur vers l'option trouvée, NULL si l'option n'a pas été trouvée

Exemple en C :

[source,C]
----------------------------------------
struct t_config_option *option =
    weechat_config_search_option (config_file, section, "option");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
option = weechat.config_search_option(config_file, section, option_name)

# exemple
option = weechat.config_search_option(config_file, section, "option")
----------------------------------------

weechat_config_search_section_option
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Recherche une section et une option dans un fichier de configuration ou une
section.

Prototype :

[source,C]
----------------------------------------
void weechat_config_search_section_option (struct t_config_file *config_file,
                                           struct t_config_section *section,
                                           const char *option_name,
                                           struct t_config_section **section_found,
                                           struct t_config_option **option_found);
----------------------------------------

Paramètres :

* 'config_file' : pointeur vers le fichier de configuration
* 'section' : pointeur vers la section
* 'option_name' : nom de l'option
* 'section' : pointeur vers un pointeur sur une section, sera alimenté avec le
  pointeur vers la section de l'option trouvée
* 'option' : pointeur vers un pointeur sur une option, sera alimenté avec le
  pointeur vers l'option trouvée

Exemple en C :

[source,C]
----------------------------------------
struct t_config_section *ptr_section;
struct t_config_option *ptr_option;

weechat_config_search_section_option (config_file,
                                      section,
                                      "option",
                                      &ptr_section,
                                      &ptr_option);
if (ptr_option)
{
    /* option trouvée */
}
else
{
    /* option non trouvée */
}
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_config_search_with_string
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Recherche une option avec le nom complet.

Prototype :

[source,C]
----------------------------------------
void weechat_config_search_with_string (const char *option_name,
                                        struct t_config_file **config_file,
                                        struct t_config_section **section,
                                        struct t_config_option **option);
----------------------------------------

Paramètres :

* 'option_name' : nom complet de l'option (format : "fichier.section.option")
* 'config_file' : pointeur vers un pointeur sur un fichier de configuration,
  sera alimenté avec le pointeur vers le fichier de configuration de l'option
  trouvée
* 'section' : pointeur vers un pointeur sur une section, sera alimenté avec le
  pointeur vers la section de l'option trouvée
* 'option' : pointeur vers un pointeur sur une option, sera alimenté avec le
  pointeur vers l'option trouvée

Exemple en C :

[source,C]
----------------------------------------
struct t_config_file *ptr_config_file;
struct t_config_section *ptr_section;
struct t_config_option *ptr_option;

weechat_config_search_with_string ("fichier.section.option",
                                   &ptr_config_file,
                                   &ptr_section,
                                   &ptr_option);
if (ptr_option)
{
    /* option trouvée */
}
else
{
    /* option non trouvée */
}
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_config_string_to_boolean
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Vérifie si un texte est "vrai" ou "faux", au sens booléen.

Prototype :

[source,C]
----------------------------------------
int weechat_config_string_to_boolean (const char *text);
----------------------------------------

Paramètres :

* 'text' : texte à analyser

Valeur de retour :

* 1 si le texte est "vrai" ("on", "yes", "y", "true", "t", "1")
* 0 si le texte est "faux" ("off", "no", "n", "false", "f", "0")

Exemple en C :

[source,C]
----------------------------------------
if (weechat_config_string_to_boolean (option_value))
{
    /* la valeur est "vrai" */
}
else
{
    /* la valeur est "faux" */
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.config_string_to_boolean(text)

# exemple
if weechat.config_string_to_boolean(text):
    # ...
----------------------------------------

weechat_config_option_reset
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Réinitialise une option à sa valeur par défaut.

Prototype :

[source,C]
----------------------------------------
int weechat_config_option_reset (struct t_config_option *option,
                                 int run_callback);
----------------------------------------

Paramètres :

* 'option' : pointeur vers l'option
* 'run_callback' : 1 pour appeler le "callback" si la valeur de l'option est
  changée, sinon 0

Valeur de retour :

* 'WEECHAT_CONFIG_OPTION_SET_OK_CHANGED' si la valeur de l'option a été
  réinitialisée
* 'WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE' si la valeur n'a pas changé
* 'WEECHAT_CONFIG_OPTION_SET_ERROR' en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
switch (weechat_config_option_reset (option, 1))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* .... */
        break;
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
rc = weechat.config_option_reset(option, run_callback)

# exemple
rc = weechat.config_option_reset(option, 1)
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----------------------------------------

weechat_config_option_set
^^^^^^^^^^^^^^^^^^^^^^^^^

Affecter une nouvelle valeur pour une option.

Prototype :

[source,C]
----------------------------------------
int weechat_config_option_set (struct t_config_option *option,
                               const char *value, int run_callback);
----------------------------------------

Paramètres :

* 'option' : pointeur vers l'option
* 'value' : nouvelle valeur pour l'option
* 'run_callback' : 1 pour appeler le "callback" si la valeur de l'option est
  changée, sinon 0

Valeur de retour :

* 'WEECHAT_CONFIG_OPTION_SET_OK_CHANGED' si la veleur de l'option a été changée
* 'WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE' si la valeur n'a pas changé
* 'WEECHAT_CONFIG_OPTION_SET_ERROR' en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
switch (weechat_config_option_set (option, "nouvelle_valeur", 1))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* .... */
        break;
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
rc = weechat.config_option_set(option, value, run_callback)

# exemple
rc = weechat.config_option_set(option, "nouvelle_valeur", 1)
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----------------------------------------

weechat_config_option_set_null
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Affecter "null" (valeur indéfinie) à une option.

Prototype :

[source,C]
----------------------------------------
int weechat_config_option_set_null (struct t_config_option *option,
                                    int run_callback);
----------------------------------------

Paramètres :

* 'option' : pointeur vers l'option
* 'run_callback' : 1 pour appeler le "callback" si la valeur de l'option est
  changée (elle n'était pas "null"), sinon 0

[NOTE]
Vous pouvez affecter "null" à une option seulement si c'est autorisé pour
l'option (voir <<_weechat_config_new_option,weechat_config_new_option>>).

Valeur de retour :

* 'WEECHAT_CONFIG_OPTION_SET_OK_CHANGED' si la valeur de l'option a été changée
* 'WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE' si la valeur n'a pas changé
* 'WEECHAT_CONFIG_OPTION_SET_ERROR' en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
switch (weechat_config_option_set_null (option, 1))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* .... */
        break;
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
rc = weechat.config_option_set_null(option, run_callback)

# exemple
rc = weechat.config_option_set_null(option, 1)
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----------------------------------------

weechat_config_option_unset
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Réinitialiser ou supprimer une option.

Prototype :

[source,C]
----------------------------------------
int weechat_config_option_unset (struct t_config_option *option);
----------------------------------------

Paramètres :

* 'option' : pointeur vers l'option

Valeur de retour :

* 'WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET' si la valeur de l'option n'a pas
  été réinitialisée
* 'WEECHAT_CONFIG_OPTION_UNSET_OK_RESET' si la valeur de l'option a été
  réinitialisée
* 'WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED' si l'option a été supprimée
* 'WEECHAT_CONFIG_OPTION_UNSET_ERROR' en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
switch (weechat_config_option_unset (option))
{
    case WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_ERROR:
        /* .... */
        break;
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
rc = weechat.config_option_unset(option)

# exemple
rc = weechat.config_option_unset(option)
if rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_ERROR:
    # ...
----------------------------------------

weechat_config_option_rename
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Renomme une option.

Prototype :

[source,C]
----------------------------------------
void weechat_config_option_rename (struct t_config_option *option,
                                   const char *new_name);
----------------------------------------

Paramètres :

* 'option' : pointeur vers l'option
* 'new_name' : nouveau nom pour l'option

Exemple en C :

[source,C]
----------------------------------------
weechat_config_option_rename (option, "nouveau_nom");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.config_option_rename(option, new_name)

# exemple
weechat.config_option_rename(option, "nouveau_nom")
----------------------------------------

weechat_config_option_get_pointer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Retourne un pointeur vers une propriété de l'option.

Prototype :

[source,C]
----------------------------------------
void *weechat_config_option_get_pointer (struct t_config_option *option,
                                         const char *property);
----------------------------------------

Paramètres :

* 'option' : pointeur vers l'option
* 'property' : nom de la propriété :
** 'config_file' : pointeur vers le fichier de configuration
   ('struct t_config_file *')
** 'section' : pointeur vers la section ('struct t_config_section *')
** 'name' : nom de l'option ('char *')
** 'type' : type de l'option ('int *')
** 'description' : description de l'option ('char *')
** 'string_values' : valeurs sous forme de chaîne ('char *')
** 'min' : valeur minimum ('int *')
** 'max' : valeur maximum ('int *')
** 'default_value' : valeur par défaut (dépend du type)
** 'value' : valeur courante (dépend du type)
** 'prev_option' : pointeur vers l'option précédente
   ('struct t_config_option *')
** 'next_option' : pointeur vers l'option suivante
   ('struct t_config_option *')

Valeur de retour :

* pointeur vers la propriété demandée

Exemple en C :

[source,C]
----------------------------------------
char *description = weechat_config_option_get_pointer (option, "description");
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_config_option_is_null
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Vérifie si une option est "null" (valeur non définie).

Prototype :

[source,C]
----------------------------------------
int weechat_config_option_is_null (struct t_config_option *option);
----------------------------------------

Paramètres :

* 'option' : pointeur vers l'option

Valeur de retour :

* 1 si la valeur de l'option est "null"
* 0 si la valeur de l'option n'est pas "null"

Exemple en C :

[source,C]
----------------------------------------
if (weechat_config_option_is_null (option))
{
    /* la valeur est "null" */
}
else
{
    /* la valeur n'est pas "null" */
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
is_null = weechat.config_option_is_null(option)

# exemple
if weechat.config_option_is_null(option):
    # ...
----------------------------------------

weechat_config_option_default_is_null
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Vérifie si la valeur par défaut d'une option est "null" (valeur non définie).

Prototype :

[source,C]
----------------------------------------
int weechat_config_option_default_is_null (struct t_config_option *option);
----------------------------------------

Paramètres :

* 'option' : pointeur vers l'option

Valeur de retour :

* 1 si la valeur par défaut de l'option est "null"
* 0 si la valeur par défaut de l'option n'est pas "null"

Exemple en C :

[source,C]
----------------------------------------
if (weechat_config_option_default_is_null (option))
{
    /* la valeur par défaut est "null" */
}
else
{
    /* la valeur par défaut n'est pas "null" */
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
is_null = weechat.config_option_default_is_null(option)

# exemple
if weechat.config_option_default_is_null(option):
    # ...
----------------------------------------

weechat_config_boolean
^^^^^^^^^^^^^^^^^^^^^^

Retourne la valeur booléenne de l'option.

Prototype :

[source,C]
----------------------------------------
int weechat_config_boolean (struct t_config_option *option);
----------------------------------------

Paramètres :

* 'option' : pointeur vers l'option

Valeur de retour :

* valeur booléenne de l'option (0 ou 1)

Exemple en C :

[source,C]
----------------------------------------
if (weechat_config_boolean (option))
{
    /* la valeur est "vrai" */
}
else
{
    /* la valeur est "faux" */
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.config_boolean(option)

# exemple
if weechat.config_boolean(option):
    # ...
----------------------------------------

weechat_config_boolean_default
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Retourne la valeur booléenne par défaut de l'option.

Prototype :

[source,C]
----------------------------------------
int weechat_config_boolean_default (struct t_config_option *option);
----------------------------------------

Paramètres :

* 'option' : pointeur vers l'option

Valeur de retour :

* valeur booléenne par défaut de l'option (0 ou 1)

Exemple en C :

[source,C]
----------------------------------------
if (weechat_config_boolean_default (option))
{
    /* la valeur est "vrai" */
}
else
{
    /* la valeur est "faux" */
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.config_boolean_default(option)

# exemple
if weechat.config_boolean_default(option):
    # ...
----------------------------------------

weechat_config_integer
^^^^^^^^^^^^^^^^^^^^^^

Retourne la valeur entière de l'option.

Prototype :

[source,C]
----------------------------------------
int weechat_config_integer (struct t_config_option *option);
----------------------------------------

Paramètres :

* 'option' : pointeur vers l'option

Valeur de retour :

* valeur entière de l'option

Exemple en C :

[source,C]
----------------------------------------
int value = weechat_config_integer (option);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.config_integer(option)

# exemple
if weechat.config_integer(option):
    # ...
----------------------------------------

weechat_config_integer_default
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Retourne la valeur entière par défaut de l'option.

Prototype :

[source,C]
----------------------------------------
int weechat_config_integer_default (struct t_config_option *option);
----------------------------------------

Paramètres :

* 'option' : pointeur vers l'option

Valeur de retour :

* valeur entière par défaut de l'option

Exemple en C :

[source,C]
----------------------------------------
int value = weechat_config_integer_default (option);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.config_integer_default(option)

# exemple
if weechat.config_integer_default(option):
    # ...
----------------------------------------

weechat_config_string
^^^^^^^^^^^^^^^^^^^^^

Retourne la valeur de l'option, sous forme de chaîne.

Prototype :

[source,C]
----------------------------------------
const char *weechat_config_string (struct t_config_option *option);
----------------------------------------

Paramètres :

* 'option' : pointeur vers l'option

Valeur de retour :

* valeur de l'option, sous forme de chaîne

Exemple en C :

[source,C]
----------------------------------------
const char *value = weechat_config_string (option);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.config_string(option)

# exemple
value = weechat.config_string(option)
----------------------------------------

weechat_config_string_default
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Retourne la valeur par défaut de l'option, sous forme de chaîne.

Prototype :

[source,C]
----------------------------------------
const char *weechat_config_string_default (struct t_config_option *option);
----------------------------------------

Paramètres :

* 'option' : pointeur vers l'option

Valeur de retour :

* valeur par défaut de l'option, sous forme de chaîne

Exemple en C :

[source,C]
----------------------------------------
const char *value = weechat_config_string_default (option);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.config_string_default(option)

# exemple
value = weechat.config_string_default(option)
----------------------------------------

weechat_config_color
^^^^^^^^^^^^^^^^^^^^

Retourne la valeur de l'option, sous forme de couleur.

Prototype :

[source,C]
----------------------------------------
const char *weechat_config_color (struct t_config_option *option);
----------------------------------------

Paramètres :

* 'option' : pointeur vers l'option

Valeur de retour :

* valeur de l'option sous forme de couleur (chaîne avec le nom de la couleur)

Exemple en C :

[source,C]
----------------------------------------
const char *color = weechat_config_color (option);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.config_color(option)

# exemple
value = weechat.config_color(option)
----------------------------------------

weechat_config_color_default
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Retourne la valeur par défaut de l'option, sous forme de couleur.

Prototype :

[source,C]
----------------------------------------
const char *weechat_config_color_default (struct t_config_option *option);
----------------------------------------

Paramètres :

* 'option' : pointeur vers l'option

Valeur de retour :

* valeur par défaut de l'option sous forme de couleur (chaîne avec le nom de la
  couleur)

Exemple en C :

[source,C]
----------------------------------------
const char *color = weechat_config_color_default (option);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.config_color_default(option)

# exemple
value = weechat.config_color_default(option)
----------------------------------------

weechat_config_write_option
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Ecrit une ligne dans le fichier de configuration avec l'option et sa valeur
(cette fonction doit être appelée uniquement dans un "callback" "write" ou
"write_default" pour une section).

Prototype :

[source,C]
----------------------------------------
void weechat_config_write_option (struct t_config_file *config_file,
                                  struct t_config_option *option);
----------------------------------------

Paramètres :

* 'config_file' : pointeur vers le fichier de configuration
* 'option' : pointeur vers l'option

Exemple en C :

[source,C]
----------------------------------------
int
my_section_write_cb (void *data, struct t_config_file *config_file,
                     const char *section_name)
{
    weechat_config_write_line (config_file, "ma_section", NULL);

    weechat_config_write_option (config_file, option);

    return WEECHAT_RC_OK;
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.config_write_option(config_file, option)

# exemple
def my_section_write_cb(data, config_file, section_name):
    weechat.config_write_line(config_file, "ma_section", "")
    weechat.config_write_option(config_file, option)
    return weechat.WEECHAT_RC_OK
----------------------------------------

weechat_config_write_line
^^^^^^^^^^^^^^^^^^^^^^^^^

Ecrit une ligne dans un fichier de configuration (cette fonction doit être
appelée uniquement dans un "callback" "write" ou "write_default" pour une
section).

Prototype :

[source,C]
----------------------------------------
void weechat_config_write_line (struct t_config_file *config_file,
                                const char *option_name,
                                const char *value, ...);
----------------------------------------

Paramètres :

* 'config_file' : pointeur vers le fichier de configuration
* 'option_name' : nom de l'option
* 'value' : valeur (si NULL, alors la ligne est écrite avec le nom de la
  section, par exemple : "[section]")

Exemple en C :

[source,C]
----------------------------------------
int
my_section_write_cb (void *data, struct t_config_file *config_file,
                     const char *section_name)
{
    weechat_config_write_line (config_file, "ma_section", NULL);

    weechat_config_write_line (config_file, "option", "%s;%d",
                               "valeur", 123);

    return WEECHAT_RC_OK;
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.config_write_line(config_file, option_name, value)

# exemple
def my_section_write_cb(data, config_file, section_name):
    weechat.config_write_line(config_file, "ma_section", "")
    weechat.config_write_line(config_file, "option", "valeur")
    return weechat.WEECHAT_RC_OK
----------------------------------------

weechat_config_write
^^^^^^^^^^^^^^^^^^^^

Ecrit un fichier de configuration sur le disque.

Prototype :

[source,C]
----------------------------------------
int weechat_config_write (struct t_config_file *config_file);
----------------------------------------

Paramètres :

* 'config_file' : pointeur vers le fichier de configuration.

Valeur de retour :

* 'WEECHAT_CONFIG_WRITE_OK' si la configuration a été écrite
* 'WEECHAT_CONFIG_WRITE_MEMORY_ERROR' s'il n'y a pas eu suffisamment de mémoire
* 'WEECHAT_CONFIG_WRITE_ERROR' si une autre erreur s'est produite

Exemple en C :

[source,C]
----------------------------------------
switch (weechat_config_write (config_file))
{
    case WEECHAT_CONFIG_WRITE_OK:
        /* ... */
        break;
    case WEECHAT_CONFIG_WRITE_MEMORY_ERROR:
        /* ... */
        break;
    case WEECHAT_CONFIG_WRITE_ERROR:
        /* ... */
        break;
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
rc = weechat.config_write(config_file)

# exemple
rc = weechat.config_write(config_file)
if rc == weechat.WEECHAT_CONFIG_WRITE_OK:
    # ...
elif rc == weechat.WEECHAT_CONFIG_WRITE_MEMORY_ERROR:
    # ...
elif rc == weechat.WEECHAT_CONFIG_WRITE_ERROR:
    # ...
----------------------------------------

weechat_config_read
^^^^^^^^^^^^^^^^^^^

Lit un fichier de configuration depuis le disque.

Prototype :

[source,C]
----------------------------------------
int weechat_config_read (struct t_config_file *config_file);
----------------------------------------

Paramètres :

* 'config_file' : pointeur vers le fichier de configuration

Valeur de retour :

* 'WEECHAT_CONFIG_READ_OK' si la configuration a été chargée
* 'WEECHAT_CONFIG_READ_MEMORY_ERROR' s'il n'y a pas eu suffisamment de mémoire
* 'WEECHAT_CONFIG_READ_FILE_NOT_FOUND' si le fichier n'a pas été trouvé

Exemple en C :

[source,C]
----------------------------------------
switch (weechat_config_read (config_file))
{
    case WEECHAT_CONFIG_READ_OK:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_MEMORY_ERROR:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
        /* ... */
        break;
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
rc = weechat.config_read(config_file)

# exemple
rc = weechat.config_read(config_file)
if rc == weechat.WEECHAT_CONFIG_READ_OK:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_MEMORY_ERROR:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
    # ...
----------------------------------------

weechat_config_reload
^^^^^^^^^^^^^^^^^^^^^

Relit un fichier de configuration depuis le disque.

Prototype :

[source,C]
----------------------------------------
int weechat_config_reload (struct t_config_file *config_file);
----------------------------------------

Paramètres :

* 'config_file' : pointeur vers le fichier de configuration

Valeur de retour :

* 'WEECHAT_CONFIG_READ_OK' si la configuration a été rechargée
* 'WEECHAT_CONFIG_READ_MEMORY_ERROR' s'il n'y a pas eu suffisamment de mémoire
* 'WEECHAT_CONFIG_READ_FILE_NOT_FOUND' si le fichier n'a pas été trouvé

Exemple en C :

[source,C]
----------------------------------------
switch (weechat_config_reload (config_file))
{
    case WEECHAT_CONFIG_READ_OK:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_MEMORY_ERROR:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
        /* ... */
        break;
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
rc = weechat.config_reload(config_file)

# exemple
rc = weechat.config_reload(config_file)
if rc == weechat.WEECHAT_CONFIG_READ_OK:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_MEMORY_ERROR:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
    # ...
----------------------------------------

weechat_config_option_free
^^^^^^^^^^^^^^^^^^^^^^^^^^

Libère une option.

Prototype :

[source,C]
----------------------------------------
void weechat_config_option_free (struct t_config_option *option);
----------------------------------------

Paramètres :

* 'option' : pointeur vers l'option

Exemple en C :

[source,C]
----------------------------------------
weechat_config_option_free (option);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.config_option_free(option)

# exemple
weechat.config_option_free(option)
----------------------------------------

weechat_config_section_free_options
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Libère toutes les options dans une section.

Prototype :

[source,C]
----------------------------------------
void weechat_config_section_free_options (struct t_config_section *section);
----------------------------------------

Paramètres :

* 'section' : pointeur vers la section

Exemple en C :

[source,C]
----------------------------------------
weechat_config_section_free_options (section);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.config_section_free_options(section)

# exemple
weechat.config_section_free_options(section)
----------------------------------------

weechat_config_section_free
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Libère une section.

Prototype :

[source,C]
----------------------------------------
void weechat_config_section_free (struct t_config_option *option);
----------------------------------------

Paramètres :

* 'section' : pointeur vers la section

Exemple en C :

[source,C]
----------------------------------------
weechat_config_section_free (section);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.config_section_free(section)

# exemple
weechat.config_section_free(section)
----------------------------------------

weechat_config_free
^^^^^^^^^^^^^^^^^^^

Libère un fichier de configuration.

Prototype :

[source,C]
----------------------------------------
void weechat_config_free (struct t_config_file *config_file);
----------------------------------------

Paramètres :

* 'config_file' : pointeur vers le fichier de configuration

Exemple en C :

[source,C]
----------------------------------------
weechat_config_free (config_file);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.config_free(config_file)

# exemple
weechat.config_free(config_file)
----------------------------------------

weechat_config_get
^^^^^^^^^^^^^^^^^^

Recherche une option avec le nom complet.

Prototype :

[source,C]
----------------------------------------
struct t_config_option *weechat_config_get (const char *option_name);
----------------------------------------

Paramètres :

* 'option_name' : nom complet de l'option (format : "fichier.section.option")

Valeur de retour :

* pointeur vers l'option trouvée, NULL si l'option n'a pas été trouvée

Exemple en C :

[source,C]
----------------------------------------
struct t_config_option *option = weechat_config_get ("weechat.look.item_time_format");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
option = weechat.config_get(option_name)

# exemple
option = weechat.config_get("weechat.look.item_time_format")
----------------------------------------

weechat_config_get_plugin
^^^^^^^^^^^^^^^^^^^^^^^^^

Recherche une option dans le fichier de configuration des extensions
(plugins.conf).

Prototype :

[source,C]
----------------------------------------
const char *weechat_config_get_plugin (const char *option_name);
----------------------------------------

Paramètres :

* 'option_name' : nom de l'option, WeeChat ajoutera le préfixe
  "plugins.var.xxx." (où "xxx" est le nom de l'extension courante)

Valeur de retour :

* valeur de l'option trouvée, NULL si l'option n'a pas été trouvée

Exemple en C :

[source,C]
----------------------------------------
/* si l'extension courante est "test", alors on cherche la valeur de l'option
   "plugins.var.test.option" dans le fichier plugins.conf */
char *value = weechat_config_get_plugin ("option");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.config_get_plugin(option_name)

# exemple
value = weechat.config_get_plugin("option")
----------------------------------------

weechat_config_is_set_plugin
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Vérifie si une option existe dans le fichier de configuration des extensions
(plugins.conf).

Prototype :

[source,C]
----------------------------------------
int weechat_config_is_set_plugin (const char *option_name);
----------------------------------------

Paramètres :

* 'option_name' : nom de l'option, WeeChat ajoutera le préfixe
  "plugins.var.xxx." (où "xxx" est le nom de l'extension courante)

Valeur de retour :

* 1 si l'option est définie, 0 si l'option n'existe pas

Exemple en C :

[source,C]
----------------------------------------
if (weechat_config_is_set_plugin ("option"))
{
    /* l'option existe */
}
else
{
    /* l'option n'existe pas */
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.config_is_set_plugin(option_name)

# exemple
if weechat.config_is_set_plugin("option"):
    # l'option existe
    # ...
else:
    # l'option n'existe pas
    # ...
----------------------------------------

weechat_config_set_plugin
^^^^^^^^^^^^^^^^^^^^^^^^^

Affecter une nouvelle valeur pour une option dans le fichier de configuration
des extensions (plugins.conf).

Prototype :

[source,C]
----------------------------------------
int weechat_config_set_plugin (const char *option_name, const char *value);
----------------------------------------

Paramètres :

* 'option_name' : nom de l'option, WeeChat ajoutera le préfixe
  "plugins.var.xxx." (où "xxx" est le nom de l'extension courante)
* 'value' : nouvelle valeur pour l'option

Valeur de retour :

* 'WEECHAT_CONFIG_OPTION_SET_OK_CHANGED' si la valeur de l'option a été changée
* 'WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE' si la valeur n'a pas changé
* 'WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND' si l'option n'a pas été trouvée
* 'WEECHAT_CONFIG_OPTION_SET_ERROR' en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
switch (weechat_config_set_plugin ("option", "valeur_test"))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* ... */
        break;
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
rc = weechat.config_set_plugin(option_name, value)

# exemple
rc = weechat.config_set_plugin("option", "valeur_test")
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----------------------------------------

weechat_config_set_desc_plugin
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.5._

Affecter une description pour une option dans le fichier de configuration des
extensions (plugins.conf).

Prototype :

[source,C]
----------------------------------------
void weechat_config_set_desc_plugin (const char *option_name,
                                     const char *description);
----------------------------------------

Paramètres :

* 'option_name' : nom de l'option, WeeChat ajoutera le préfixe
  "plugins.desc.xxx." (où "xxx" est le nom de l'extension courante)
* 'description' : description pour l'option

[NOTE]
Ce n'est pas un problème si l'option (plugins.var.xxx.option_name) n'existe pas.
Une création future de cette option utilisera cette description.

Exemple en C :

[source,C]
----------------------------------------
weechat_config_set_desc_plugin ("option", "description de l'option");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.config_set_desc_plugin(option_name, description)

# exemple
version = weechat.info_get("version_number", "") or 0
if int(version) >= 0x00030500:
    weechat.config_set_desc_plugin("option", "description de l'option")
----------------------------------------

weechat_config_unset_plugin
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Supprime une option du fichier de configuration des extensions (plugins.conf).

Prototype :

[source,C]
----------------------------------------
int weechat_config_unset_plugin (const char *option_name);
----------------------------------------

Paramètres :

* 'option_name' : nom de l'option, WeeChat ajoutera le préfixe
  "plugins.var.xxx." (où "xxx" est le nom de l'extension courante)

Valeur de retour :

* 'WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET' si la valeur de l'option n'a pas
  été réinitialisée
* 'WEECHAT_CONFIG_OPTION_UNSET_OK_RESET' si la valeur de l'option a été
  réinitialisée
* 'WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED' si l'option a été supprimée
* 'WEECHAT_CONFIG_OPTION_UNSET_ERROR' en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
switch (weechat_config_unset_plugin ("option"))
{
    case WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_ERROR:
        /* ... */
        break;
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
rc = weechat.config_unset_plugin(option_name)

# exemple
rc = weechat.config_unset_plugin("option")
if rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_ERROR:
    # ...
----------------------------------------

[[key_bindings]]
Associations de touches
~~~~~~~~~~~~~~~~~~~~~~~

Fonctions pour les associations de touches.

weechat_key_bind
^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.6._

Ajouter de nouvelles associations de touches.

[NOTE]
Contrairement à la commande `/key bind`, cette fonction ne changera jamais
une association de touche existante, seulement des nouvelles touches seront
créées. Pour supprimer une association de touche, utilisez
<<_weechat_key_unbind,weechat_key_unbind>>.

Prototype :

[source,C]
----------------------------------------
int weechat_key_bind (const char *context, struct t_hashtable *keys);
----------------------------------------

Paramètres :

* 'context' : contexte pour les touches :
** 'default' : contexte par défaut (actions courantes)
** 'search' : contexte de recherche (lors de la recherche de texte dans le
   tampon)
** 'cursor' : mouvement libre du curseur à l'écran
** 'mouse' : touches pour les évènements de souris
* 'keys' : hashtable avec les associations de touches

Valeur de retour :

* nombre d'associations de touches ajoutées

Exemple en C :

[source,C]
----------------------------------------
struct t_hashtable *keys = weechat_hashtable_new (8,
                                                  WEECHAT_HASHTABLE_STRING,
                                                  WEECHAT_HASHTABLE_STRING,
                                                  NULL,
                                                  NULL);
if (keys)
{
    weechat_hashtable_set (keys, "@chat(plugin.buffer):button1", "hsignal:test_mouse");
    weechat_hashtable_set (keys, "@chat(plugin.buffer):wheelup", "/mycommand up");
    weechat_hashtable_set (keys, "@chat(plugin.buffer):wheeldown", "/mycommand down");
    weechat_key_bind ("mouse", keys);
    weechat_hashtable_free (keys);
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
num_keys = weechat.key_bind(context, keys)

# exemple
keys = { "@chat(python.test):button1": "hsignal:test_mouse",
         "@chat(python.test):wheelup": "/mycommand up",
         "@chat(python.test):wheeldown": "/mycommand down" }
weechat.key_bind("mouse", keys)
----------------------------------------

weechat_key_unbind
^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.6._

Supprimer une/des association(s) de touche(s).

[WARNING]
When calling this function, ensure that you will not remove a user key binding.

Prototype :

[source,C]
----------------------------------------
int weechat_key_unbind (const char *context, const char *key);
----------------------------------------

Paramètres :

* 'context' : contexte pour les touches (voir
   <<_weechat_key_bind,weechat_key_bind>>)
* 'key' : touche à supprimer ou la valeur spéciale "area:XXX" pour supprimer
  toutes les touches ayant 'XXX' comme première ou deuxième zone

Valeur de retour :

* nombre d'associations de touches supprimées

Exemples en C :

[source,C]
----------------------------------------
/* supprimer une seule touche */
weechat_key_unbind ("mouse", "@chat(plugin.buffer):button1");

/* supprimer toutes les touches avec la zone "chat(plugin.buffer)" */
weechat_key_unbind ("mouse", "area:chat(plugin.buffer)");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
num_keys = weechat.key_unbind(context, key)

# exemples

# supprimer une seule touche
weechat.key_unbind("mouse", "@chat(plugin.buffer):button1")

# supprimer toutes les touches avec la zone "chat(python.test)"
weechat.key_unbind("mouse", "area:chat(python.test)")
----------------------------------------

[[display]]
Affichage
~~~~~~~~~

Fonctions pour afficher du texte dans les tampons.

weechat_prefix
^^^^^^^^^^^^^^

Retourne un préfixe.

Prototype :

[source,C]
----------------------------------------
const char *weechat_prefix (const char *prefix);
----------------------------------------

Paramètres :

* 'prefix' : nom du préfixe :

[width="70%",cols="^2e,^1l,^3,5",options="header"]
|========================================
| Préfixe | Valeur | Couleur                   | Description
| error   | =!=    | jaune ("yellow")          | message d'erreur
| network | --     | violet ("magenta")        | message du réseau
| action  | *      | blanc ("white")           | action personnelle
| join    | -->    | vert clair ("lightgreen") | quelqu'un a rejoint la discussion
| quit    | <--    | rouge clair ("lightred")  | quelqu'un a quitté la discussion
|========================================

[NOTE]
Les valeurs et couleurs peuvent être configurées avec la commande `/set`.

Valeur de retour :

* valeur du préfixe (chaîne avec le préfixe et des codes couleur), chaîne vide
  si le préfixe n'a pas été trouvé

Exemple en C :

[source,C]
----------------------------------------
weechat_printf (NULL, "%sCeci est une erreur...", weechat_prefix ("error"));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.prefix(prefix)

# exemple
weechat.prnt("", "%sCeci est une erreur..." % weechat.prefix("error"))
----------------------------------------

weechat_color
^^^^^^^^^^^^^

Retourne une chaîne avec un code couleur pour affichage.

Prototype :

[source,C]
----------------------------------------
const char *weechat_color (const char *color_name);
----------------------------------------

Paramètres :

* 'color_name' : nom de la couleur, parmi :
** une option WeeChat (de weechat.color.xxx), par exemple 'chat_delimiters'
** une couleur avec des attributs/fond optionnels (voir ci-dessous)
** un attribut :
*** 'bold' : activer le gras
*** '-bold' : désactiver le gras
*** 'reverse' : activer la vidéo inverse
*** '-reverse' : désactiver la vidéo inverse
*** 'italic' : activer l'italique
*** '-italic' : désactiver l'italique
*** 'underline' : activer le souligné
*** '-underline' : désactiver le souligné
** nom d'une couleur de barre :
*** 'bar_fg' : couleur de texte pour la barre
*** 'bar_delim' : couleur des délimiteurs pour la barre
*** 'bar_bg' : couleur de fond pour la barre
** réinitialisation :
*** 'reset' : réinitialiser la couleur et les attributs
*** 'resetcolor' : réinitialiser la couleur (garder les attributs)
    (_nouveau dans la version 0.3.6_)

Le format de la couleur est : attributs (optionnel) + nom de couleur + ",fond"
(optionnel). Les attributs possibles sont :

* `*` : texte gras
* `!` : mode vidéo inverse
* `_` : texte souligné
* `|` : garder les attributs : ne pas réinitialiser gras/inverse/souligné lors
  du changement de couleur (_nouveau dans la version 0.3.6_)

Exemples :

* `yellow` : jaune
* `_green` : vert souligné
* `*214` : orange gras
* `yellow,red` : jaune sur rouge
* `|cyan` : cyan (et garder tout attribut définit précédemment)

Valeur de retour :

* chaîne avec le code couleur, ou une chaîne vide si la couleur n'a pas été
  trouvée

Exemple en C :

[source,C]
----------------------------------------
weechat_printf (NULL, "Couleur : %sbleu %scouleur par défaut %sjaune sur rouge",
                weechat_color ("blue"),
                weechat_color ("chat"),
                weechat_color ("yellow,red"));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.color(color_name)

# exemple
weechat.prnt("", "%sCouleur : %sbleu %scouleur par défaut %sjaune sur rouge"
    % (weechat.color("blue"), weechat.color("chat"), weechat.color("yellow,red")))
----------------------------------------

weechat_printf
^^^^^^^^^^^^^^

Affiche un message sur un tampon.

Prototype :

[source,C]
----------------------------------------
void weechat_printf (struct t_gui_buffer *buffer, const char *message, ...);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon, si NULL, le message est affiché sur le
  tampon WeeChat
* 'message' : message à afficher

[NOTE]
La première tabulation dans le message ("\t") est utilisée pour séparer le
préfixe du message. +
Si votre message contient des tabulations et si vous ne voulez pas de préfixe,
utilisez un espace, une tabulation, puis le message : cela désactivera le
préfixe (l'espace avant la tabulation ne sera pas affiché).

Exemple en C :

[source,C]
----------------------------------------
weechat_printf (NULL, "Bonjour sur le tampon WeeChat");
weechat_printf (buffer, "Bonjour sur ce tampon");
weechat_printf (buffer, "%sCeci est une erreur !", weechat_prefix ("error"));
weechat_printf (buffer, " \tMessage sans préfixe mais avec \t quelques \t tabulations");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.prnt(buffer, message)

# exemple
weechat.prnt("", "Bonjour sur le tampon WeeChat")
weechat.prnt(buffer, "Bonjour sur ce tampon")
weechat.prnt(buffer, "%sCeci est une erreur !" % weechat.prefix("error"))
weechat.prnt(buffer, " \tMessage sans préfixe mais avec \t quelques \t tabulations")
----------------------------------------

[NOTE]
La fonction s'appelle "print" dans les scripts ("prnt" en Python).

weechat_printf_date
^^^^^^^^^^^^^^^^^^^

Affiche un message sur un tampon, en utilisant une date personnalisée.

Prototype :

[source,C]
----------------------------------------
void weechat_printf_date (struct t_gui_buffer *buffer, time_t date,
                          const char *message, ...);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon, si NULL, le message est affiché sur le
  tampon Weechat
* 'date' : date pour le message (0 signifie la date/heure courante)
* 'message' : message à afficher

Exemple en C :

[source,C]
----------------------------------------
weechat_printf_date (NULL, time (NULL) - 120, "Bonjour, il y a 2 minutes");
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_printf_tags
^^^^^^^^^^^^^^^^^^^

Affiche un message sur un tampon, avec des étiquettes ("tags") personnalisées.

Prototype :

[source,C]
----------------------------------------
void weechat_printf_tags (struct t_gui_buffer *buffer, const char *tags,
                          const char *message, ...);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon, si NULL, le message est affiché sur le
  tampon Weechat
* 'tags' : liste d'étiquettes ("tags") séparées par des virgules
* 'message' : message à afficher

Exemple en C :

[source,C]
----------------------------------------
weechat_printf_tags (NULL, "notify_message",
                     "Message avec une étiquette 'notify_message'");
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_printf_date_tags
^^^^^^^^^^^^^^^^^^^^^^^^

Affiche un message sur un tampon, en utilisant une date et des étiquettes
("tags") personnalisées.

Prototype :

[source,C]
----------------------------------------
void weechat_printf_date_tags (struct t_gui_buffer *buffer, time_t date,
                               const char *tags, const char *message, ...);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon, si NULL, le message est affiché sur le
  tampon Weechat
* 'date' : date pour le message (0 signifie la date/heure courante)
* 'tags' : liste d'étiquettes ("tags") séparées par des virgules
* 'message' : message à afficher

Tags couramment utilisés (liste non exhaustive) :

[width="70%",cols="1m,4",options="header"]
|========================================
| Tag              | Description
| no_filter        | La ligne ne peut pas être filtrée
| no_highlight     | Aucun highlight n'est possible sur cette ligne
| no_log           | La ligne n'est pas écrite dans le fichier de log
| log0 ... log9    | Niveau de log pour la ligne (voir `/help logger`)
| notify_none      | Le tampon avec la ligne ne sera pas ajouté à la "hotlist"
| notify_message   | Le tampon avec la ligne sera ajouté à la "hotlist" avec le niveau "message"
| notify_private   | Le tampon avec la ligne sera ajouté à la "hotlist" avec le niveau "private"
| notify_highlight | Le tampon avec la ligne sera ajouté à la "hotlist" avec le niveau "highlight"
| nick_xxx         | Le message vient du pseudo "xxx"
| prefix_nick_ccc  | Le préfixe est un pseudo avec la couleur "ccc"
| irc_xxx          | Message IRC "xxx" (peut-être une commande ou un numérique sur 3 chiffres)
| irc_numeric      | Message IRC numérique
| irc_error        | Erreur du serveur IRC
| irc_action       | Action d'un pseudo (commande `/me`)
| irc_ctcp         | Message CTCP
| irc_ctcp_reply   | Réponse à un message CTCP
| irc_smart_filter | Message IRC qui peut être filtré avec le "smart filter" (filtre intelligent)
| away_info        | Message avec une info d'absence
|========================================

Exemple en C :

[source,C]
----------------------------------------
weechat_printf_date_tags (NULL, time (NULL) - 120, "notify_message",
                          "Message il y a 2 minutes avec une étiquette 'notify_message'");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.prnt_date_tags(buffer, date, tags, message)

# exemple
time = int(time.time())
weechat.prnt_date_tags("", time - 120, "notify_message",
    "Message il y a 2 minutes avec une étiquette 'notify_message'")
----------------------------------------

[NOTE]
La fonction s'appelle "print_date_tags" dans les scripts ("prnt_date_tags" en
Python).

weechat_printf_y
^^^^^^^^^^^^^^^^

Affiche un message sur une ligne d'un tampon avec contenu libre.

Prototype :

[source,C]
----------------------------------------
void weechat_printf_y (struct t_gui_buffer *buffer, int y,
                       const char *message, ...);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'y' : numéro de ligne (la première ligne est 0)
* 'message' : message à afficher

Exemple en C :

[source,C]
----------------------------------------
weechat_printf_y (buffer, 2, "Mon message sur la 3ème ligne");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.prnt_y(buffer, y, message)

# exemple
weechat.prnt_y("", 2, "Mon message sur la 3ème ligne")
----------------------------------------

[NOTE]
La fonction s'appelle "print_y" dans les scripts ("prnt_y" en Python).

weechat_log_printf
^^^^^^^^^^^^^^^^^^

Ecrit un message dans le fichier de log WeeChat (weechat.log).

Prototype :

[source,C]
----------------------------------------
void weechat_log_printf (const char *message, ...);
----------------------------------------

Paramètres :

* 'message' : message à écrire

Exemple en C :

[source,C]
----------------------------------------
weechat_log_printf ("Mon message dans le fichier log");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.log_print(message)

# exemple
weechat.log_print("Mon message dans le fichier log")
----------------------------------------

[NOTE]
La fonction s'appelle "log_print" dans les scripts.

[[hooks]]
Hooks
~~~~~

[[hook_priority]]
[float]
Hook priority
^^^^^^^^^^^^^

_Nouveau dans la version 0.3.4._

Pour certains "hooks", vous pouvez définir une priorité. Un "hook" avec une
priorité plus élevée sera au début de la liste des "hooks", et donc il sera
trouvé et exécuté avant les autres "hooks". Cela est pratique pour les
"modifieurs", car l'ordre d'exécution est important.

Pour définir une priorité, vous devez utiliser cette syntaxe, pour un paramètre
où la priorité est autorisée : "nnn|nom" où "nnn" est un entier positif ou nul
avec la priorité et "nom" le nom pour le paramètre (la priorité n'apparaît pas
dans le nom, elle est automatiquement retirée de la chaîne).

La priorité par défaut est 1000.

Exemple en C :

[source,C]
----------------------------------------
/* accroche un modifieur avec priorité = 2000 */
weechat_hook_modifier ("2000|input_text_display", &modifier_cb, NULL);
----------------------------------------

Les types de "hooks" suivants autorisent une priorité : command, command_run,
signal, hsignal, config, completion, modifier, info, info_hashtable, infolist,
hdata, focus.

weechat_hook_command
^^^^^^^^^^^^^^^^^^^^

Accroche une commande.

Prototype :

[source,C]
----------------------------------------
struct t_hook *weechat_hook_command (const char *command,
                                     const char *description,
                                     const char *args,
                                     const char *args_description,
                                     const char *completion,
                                     int (*callback)(void *data,
                                                     struct t_gui_buffer *buffer,
                                                     int argc,
                                                     char **argv,
                                                     char **argv_eol),
                                     void *callback_data);
----------------------------------------

Paramètres :

* 'command' : nom de la commande
  (priorité autorisée, voir la note sur la <<hook_priority,priorité>>)
* 'description' : description de la commande (affiché avec `/help command`)
* 'args' : paramètres pour la commande (affichés avec `/help command`)
* 'args_description' : description des paramètres (affichée avec
  `/help command`)
* 'completion' : modèlé pour la complétion de la commande : liste des
  complétions pour chaque paramètre, séparés par des espaces. Plusieurs
  complétions sont possibles pour un paramètre, séparées par "|". Plusieurs
  modèles de complétions sont possibles pour une même commande, séparés par
  "||".
* 'callback' : fonction appelée lorsque la commande est utilisée, paramètres et
  valeur de retour :
** 'void *data' : pointeur
** 'struct t_gui_buffer *buffer' : tampon où la commande est exécutée
** 'int argc' : nombre de paramètres passés à la commande
** 'char **argv' : paramètres pour la commande
** 'char **argv_eol' : paramètres pour la commande (jusqu'à fin de ligne pour
   chaque paramètre)
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Les codes complétions par défaut sont :
include::autogen/plugin_api/completions.txt[]

Codes spéciaux :

* '%%command' : réutiliser le modèle de complétion de la commande 'command'
* '%-' : arrêter la complétion
* '%*' : répéter la dernière complétion

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
int
my_command_cb (void *data, struct t_gui_buffer *buffer, int argc,
               char **argv, char **argv_eol)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* cet exemple s'inspire de la commande /filter */
struct t_hook *my_command_hook =
    weechat_hook_command (/* nom de la commande */
                          "monfiltre",
                          /* description */
                          "description de monfiltre",
                          /* paramètres */
                          "[list] | [enable|disable|toggle [nom]] | "
                          "[add nom extension.tampon tags regex] | "
                          "[del nom|-all]",
                          /* description des paramètres */
                          "description des paramètres...",
                          /* complétion */
                          "list"
                          " || enable %(filters_names)"
                          " || disable %(filters_names)"
                          " || toggle %(filters_names)"
                          " || add %(filters_names) %(buffers_plugins_names)|*"
                          " || del %(filters_names)|-all",
                          /* callback */
                          &my_command_cb,
                          /* callback_data */
                          NULL);
----------------------------------------

Par exemple, si la commande appelée est `/command abc def ghi`, alors 'argv' et
'argv_eol' ont les valeurs suivantes :

* 'argv':
** 'argv[0]' == "/command"
** 'argv[1]' == "abc"
** 'argv[2]' == "def"
** 'argv[3]' == "ghi"
* 'argv_eol':
** 'argv_eol[0]' == "/command abc def ghi"
** 'argv_eol[1]' == "abc def ghi"
** 'argv_eol[2]' == "def ghi"
** 'argv_eol[3]' == "ghi"

Pour les scripts, 'args' a la valeur "abc def ghi".

Script (Python) :

[source,python]
----------------------------------------
# prototype
hook = weechat.hook_command(command, description, args, args_description,
    completion, callback, callback_data)

# exemple
def my_command_cb(data, buffer, args):
    # ...
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_command("monfiltre", "description de monfiltre",
    "[list] | [enable|disable|toggle [name]] | [add name plugin.buffer tags regex] | [del name|-all]",
    "description des paramètres...",
    "list"
    " || enable %(filters_names)"
    " || disable %(filters_names)"
    " || toggle %(filters_names)"
    " || add %(filters_names) %(buffers_plugins_names)|*"
    " || del %(filters_names)|-all",
    "my_command_cb", "")
----------------------------------------

weechat_hook_command_run
^^^^^^^^^^^^^^^^^^^^^^^^

Intercepter une commande lorsqu'elle est exécutée par WeeChat.

Prototype :

[source,C]
----------------------------------------
struct t_hook *weechat_hook_command_run (const char *command,
                                         int (*callback)(void *data,
                                                         struct t_gui_buffer *buffer,
                                                         const char *command),
                                         void *callback_data);
----------------------------------------

Paramètres :

* 'command' : commande à intercepter, peut commencer ou se terminer par le
  caractère joker "*"
  (priorité autorisée, voir la note sur la <<hook_priority,priorité>>)
* 'callback' : fonction appelée lorsque la commande est exécutée, paramètres et
  valeur de retour :
** 'void *data' : pointeur
** 'struct t_gui_buffer *buffer' : tampon où la command est exécutée
** 'const char *command' : la commande exécutée, avec ses paramètres
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_OK_EAT'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

[NOTE]
Le "callback" peut retourner 'WEECHAT_RC_OK' ou 'WEECHAT_RC_OK_EAT' (la
commande ne sera pas exécutée par WeeChat après le "callback").

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
int
my_command_run_cb (void *data, struct t_gui_buffer *buffer, const char *command)
{
    weechat_printf (NULL,
                    "Vous voulez compléter ? Je mange la commande, ahah !");
    return WEECHAT_RC_OK_EAT;
}

struct t_hook *my_command_run_hook =
    weechat_hook_command_run ("/input complete*",
                              &my_command_run_cb, NULL);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
hook = weechat.hook_command_run(command, callback, callback_data)

# exemple
def my_command_run_cb(data, buffer, command):
    weechat.prnt("", "Vous voulez compléter ? Je mange la commande, ahah !")
    return weechat.WEECHAT_RC_OK_EAT

hook = weechat.hook_command_run("/input complete*", "my_command_run_cb", "")
----------------------------------------

weechat_hook_timer
^^^^^^^^^^^^^^^^^^

Accroche un "timer" (fonction appelée à intervalles réguliers).

Prototype :

[source,C]
----------------------------------------
struct t_hook *weechat_hook_timer (long interval,
                                   int align_second,
                                   int max_calls,
                                   int (*callback)(void *data,
                                                   int remaining_calls),
                                   void *callback_data);
----------------------------------------

Paramètres :

* 'interval' : intervalle entre deux appels (en millisecondes, donc 1000 = 1
  seconde)
* 'align_second' : alignement sur la seconde. Par exemple, si la date courante
  est 09:00, si l'intervalle est 60000 (60 secondes), et que align_second = 60,
  alors le timer sera appelé chaque minutes quand la seconde sera 00
* 'max_calls' : nombre maximum d'appels au timer (si 0, le timer n'a pas de
  fin)
* 'callback' : fonction appelée quand le délai est atteint, paramètres et valeur
  de retour :
** 'void *data' : pointeur
** 'int remaining_calls' : nombre d'appels restants (-1 si le timer n'a pas de
   fin)
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
int
my_timer_cb (void *data, int remaining_calls)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* timer appelé toutes les 20 secondes */
struct t_hook *my_timer_hook =
    weechat_hook_timer (20 * 1000, 0, 0, &my_timer_cb, NULL);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
hook = weechat.hook_timer(interval, align_second, max_calls, callback, callback_data)

# exemple
def my_timer_cb(data, remaining_calls):
    # ...
    return weechat.WEECHAT_RC_OK

# timer appelé toutes les 20 secondes
hook = weechat.hook_timer(20 * 1000, 0, 0, "my_timer_cb", "")
----------------------------------------

weechat_hook_fd
^^^^^^^^^^^^^^^

Accroche un descripteur de fichier (fichier ou socket).

Prototype :

[source,C]
----------------------------------------
struct t_hook *weechat_hook_fd (int fd,
                                int flag_read,
                                int flag_write,
                                int flag_exception,
                                int (*callback)(void *data,
                                                int fd),
                                void *callback_data);
----------------------------------------

Paramètres :

* 'fd' : descripteur de fichier
* 'flag_read' : 1 = intercepter un évènement de lecture, 0 = ignorer
* 'flag_write' : 1 = intercepter un évènement d'éctiture, 0 = ignorer
* 'flag_exception' : 1 = intercepter un évènement d'exception, 0 = ignorer
* 'callback' : fonction appelée lorsqu'un des évènements sélectionnés se
  produit pour le fichier (ou la socket), paramètres et valeur de retour :
** 'void *data' : pointeur
** 'int fd' : descripteur de fichier
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
int
my_fd_cb (void *data, int fd)
{
    /* ... */
    return WEECHAT_RC_OK;
}

int sock = socket (AF_INET, SOCK_STREAM, 0);
/* définir les options de la socket */
/* ... */
struct t_hook *my_fd_hook = weechat_hook_fd (sock, 1, 0, 0, &my_fd_cb, NULL);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
hook = weechat.hook_fd(fd, flag_read, flag_write, flag_exception, callback, callback_data)

# exemple
def my_fd_cb(data, fd):
    # ...
    return weechat.WEECHAT_RC_OK

sock = ...
hook = weechat.hook_fd(sock, 1, 0, 0, "my_fd_cb", "")
----------------------------------------

weechat_hook_process
^^^^^^^^^^^^^^^^^^^^

Accroche un processus (lancé par un fork), et intercepter sa sortie.

Prototype :

[source,C]
----------------------------------------
struct t_hook *weechat_hook_process (const char *command,
                                     int timeout,
                                     int (*callback)(void *data,
                                                     const char *command,
                                                     int return_code,
                                                     const char *out,
                                                     const char *err),
                                     void *callback_data);
----------------------------------------


Paramètres :

* 'command' : commande à lancer dans le processus fils ou URL
  (_nouveau dans la version 0.3.7_), voir ci-dessous
* 'timeout' : timeout pour la commande (en millisecondes) : après ce délai, le
  processus fils est tué (0 signifie pas de limite)
* 'callback' : function appelée quand des données du fils sont disponibles, or
  ou quand le fils s'est terminé, paramètres et valeur de retour :
** 'void *data' : pointeur
** 'const char *command' : commande exécutée par le fils
** 'int return_code' : code retour :
*** '>= 0': code retour du fils pour une commande, et pour l'URL, les valeurs
    possibles sont :
**** '0': transfert ok
**** '1': URL invalide
**** '2': erreur de transfert
**** '3': pas assez de mémoire
**** '4': erreur avec un fichier
*** '< 0' : 'WEECHAT_HOOK_PROCESS_RUNNING' (données disponibles, mais le
    fils tourne toujours) ou 'WEECHAT_HOOK_PROCESS_ERROR' (erreur en lançant
    la commande)
** 'out' : sortie standard de la commande (stdout)
** 'err' : erreurs de la commande (stderr)
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Lorsque la commande est terminée, ou si le timeout est atteint, WeeChat
supprimera automatiquement le "hook" (et tuera le processus s'il tourne
toujours).

La commande peut être une URL avec le format : "url:http://www.example.com",
pour télécharger le contenu de l'URL (_nouveau dans la version 0.3.7_).
Des options pour l'URL sont possibles avec la fonction
<<_weechat_hook_process_hashtable,weechat_hook_process_hashtable>>.

[NOTE]
La taille du tampon pour l'envoi des données au "callback" est de 64 Ko (il y a
2 tampons : un pour stdout et un pour stderr).
Si la sortie du processus fils (stdout ou stderr) est plus longue que 64 Ko, le
"callback" sera appelé plusieurs fois.

[IMPORTANT]
Même si la plupart du temps le "callback" n'est appelé qu'une seule fois, vous
devez vous assurer que plusieurs appels au "callback" sont ok dans votre code :
vous devez concaténer les données issues de plusieurs appels et n'utiliser les
données que lorsque le code retour est positif ou nul.

Exemple en C :

[source,C]
----------------------------------------
int
my_process_cb (void *data, const char *command, int return_code,
               const char *out, const char *err)
{
    if (return_code == WEECHAT_HOOK_PROCESS_ERROR)
    {
        weechat_printf (NULL, "Erreur avec la commande '%s'", command);
        return WEECHAT_RC_OK;
    }

    if (return_code >= 0)
    {
        weechat_printf (NULL, "return_code = %d", return_code);
    }

    if (out)
    {
        weechat_printf (NULL, "stdout : %s", out);
    }

    if (err)
    {
        weechat_printf (NULL, "stderr : %s", err);
    }

    return WEECHAT_RC_OK;
}

struct t_hook *my_process_hook = weechat_hook_process ("ls", 5000,
                                                       &my_process_cb, NULL);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
hook = weechat.hook_process(command, timeout, callback, callback_data)

# exemple
def my_process_cb(data, command, return_code, out, err):
    if return_code == weechat.WEECHAT_HOOK_PROCESS_ERROR:
        weechat.prnt("", "Erreur avec la commande '%s'" % command)
        return weechat.WEECHAT_RC_OK
    if return_code >= 0:
        weechat.prnt("", "return_code = %d" % return_code)
    if out != "":
        weechat.prnt("", "stdout: %s" % out)
    if err != "":
        weechat.prnt("", "stderr: %s" % err)
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_process("ls", 5000, "my_process_cb", "")
----------------------------------------

weechat_hook_process_hashtable
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.7._

Accroche un processus (lancé par un fork) en utilisant des options dans une
hashtable, et intercepter sa sortie.

Prototype :

[source,C]
----------------------------------------
struct t_hook *weechat_hook_process_hashtable (const char *command,
                                               struct t_hashtable *options,
                                               int timeout,
                                               int (*callback)(void *data,
                                                               const char *command,
                                                               int return_code,
                                                               const char *out,
                                                               const char *err),
                                               void *callback_data);
----------------------------------------

Les paramètres sont les mêmes que ceux de la fonction
<<_weechat_hook_process,weechat_hook_process>>, avec un paramètre
supplémentaire :

* 'options' : options pour la commande exécutée (voir le tableau ci-dessous);
  la hashtable est dupliquée dans la fonction, donc il est possible de la
  supprimer après cet appel

Pour la commande "url:...", les options suivantes sont disponibles (voir
`man curl_easy_setopt` pour une description de chaque option) :

include::autogen/plugin_api/url_options.txt[]

[NOTE]
^(1)^ Lorsque des constantes sont disponibles, elles doivent être utilisées
comme valeur pour l'option. Pour les options avec le type "mask", le format est :
"valeur1+valeur2+valeur3".

Pour l'URL, deux options supplémentaires (chaînes) sont autorisées, pour le
fichier en entrée/sortie :

* 'file_in' : fichier à lire pour envoyer avec l'URL (envoi de fichier "post")
* 'file_out' : écrire l'URL/fichier dans ce fichier (au lieu de la sortie
  standard)

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
int
my_process_cb (void *data, const char *command, int return_code,
               const char *out, const char *err)
{
    if (return_code == WEECHAT_HOOK_PROCESS_ERROR)
    {
        weechat_printf (NULL, "Erreur avec la commande '%s'", command);
        return WEECHAT_RC_OK;
    }

    if (return_code >= 0)
    {
        weechat_printf (NULL, "return_code = %d", return_code);
    }

    if (out)
    {
        weechat_printf (NULL, "stdout : %s", out);
    }

    if (err)
    {
        weechat_printf (NULL, "stderr : %s", err);
    }

    return WEECHAT_RC_OK;
}

struct t_hashtable *options = weechat_hashtable_new (8,
                                                     WEECHAT_HASHTABLE_STRING,
                                                     WEECHAT_HASHTABLE_STRING,
                                                     NULL,
                                                     NULL);
if (options)
{
    weechat_hashtable_set (options, "file_out", "/tmp/weechat.org.html");
    struct t_hook *my_process_hook = weechat_hook_process_hashtable ("url:http://www.weechat.org/",
                                                                     options,
                                                                     20000,
                                                                     &my_process_cb, NULL);
    weechat_hashtable_free (options);
}
----------------------------------------

Script (Python):

[source,python]
----------------------------------------
# prototype
hook = weechat.hook_process_hashtable(command, options, timeout, callback, callback_data)

# exemple
def my_process_cb(data, command, return_code, out, err):
    if return_code == weechat.WEECHAT_HOOK_PROCESS_ERROR:
        weechat.prnt("", "Erreur avec la commande '%s'" % command)
        return weechat.WEECHAT_RC_OK
    if return_code >= 0:
        weechat.prnt("", "return_code = %d" % return_code)
    if out != "":
        weechat.prnt("", "stdout: %s" % out)
    if err != "":
        weechat.prnt("", "stderr: %s" % err)
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_process_hashtable("url:http://www.weechat.org/",
                                      { "file_out": "/tmp/weechat.org.html" },
                                      20000, "my_process_cb", "")
----------------------------------------

weechat_hook_connect
^^^^^^^^^^^^^^^^^^^^

Accroche une connexion (connexion à une machine distante en tâche de fond).

Prototype :

[source,C]
----------------------------------------
struct t_hook *weechat_hook_connect (const char *proxy,
                                     const char *address,
                                     int port,
                                     int sock,
                                     int ipv6,
                                     void *gnutls_sess,
                                     void *gnutls_cb,
                                     int gnutls_dhkey_size,
                                     const char *gnutls_priorities,
                                     const char *local_hostname,
                                     int (*callback)(void *data,
                                                     int status,
                                                     int gnutls_rc,
                                                     const char *error,
                                                     const char *ip_address),
                                     void *callback_data);
----------------------------------------

Paramètres :

* 'proxy' : nom du proxy à utiliser pour la connexion (optionnel, NULL signifie
  une connexion sans proxy)
* 'address' : nom ou adresse IP de la machine à laquelle se connecter
* 'port' : numéro de port
* 'sock' : socket utilisée pour la connexion
* 'ipv6' : 1 pour utiliser IPv6, 0 pour utiliser IPv4
* 'gnutls_sess' : GnuTLS session (optionnel)
* 'gnutls_cb' : callback pour GnuTLS (optionnel)
* 'gnutls_dhkey_size' : taille de clé utilisée pour l'échange de clé
  Diffie-Hellman (GnuTLS)
* 'gnutls_priorities' : priorités pour gnutls (pour la syntaxe, voir la
  documentation de la fonction 'gnutls_priority_init' dans le manuel gnutls),
  les valeurs de base sont :
** 'PERFORMANCE'
** 'NORMAL' (défaut)
** 'SECURE128'
** 'SECURE256'
** 'EXPORT'
** 'NONE'
* 'local_hostname' : nom de machine local à utiliser pour la connexion
  (optionnel)
* 'callback' : fonction appelée lorsque la connexion est ok ou a échoué,
  paramètres et valeur de retour :
** 'void *data' : pointeur
** 'int status' : connection status :
*** 'WEECHAT_HOOK_CONNECT_OK' : connextion ok
*** 'WEECHAT_HOOK_CONNECT_ADDRESS_NOT_FOUND' : adresse non trouvée
*** 'WEECHAT_HOOK_CONNECT_IP_ADDRESS_NOT_FOUND' : adresse IP non trouvée
*** 'WEECHAT_HOOK_CONNECT_CONNECTION_REFUSED' : connexion refusée
*** 'WEECHAT_HOOK_CONNECT_PROXY_ERROR' : erreur avec le proxy
*** 'WEECHAT_HOOK_CONNECT_LOCAL_HOSTNAME_ERROR' : erreur avec le nom local
*** 'WEECHAT_HOOK_CONNECT_GNUTLS_INIT_ERROR' : erreur d'initialisation GnuTLS
*** 'WEECHAT_HOOK_CONNECT_GNUTLS_HANDSHAKE_ERROR' : erreur avec la
    "poignée de main" GnuTLS
*** 'WEECHAT_HOOK_CONNECT_MEMORY_ERROR' : mémoire insuffisante
*** 'WEECHAT_HOOK_CONNECT_TIMEOUT' : temps maximum dépassé
** 'gnutls_rc' : valeur retour de 'gnutls_handshake()'
** 'const char *error' : valeur retour de 'gnutls_strerror(gnutls_rc)'
** 'const char *ip_address' : adresse IP trouvée
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
int
my_connect_cb (void *data, int status, int gnutls_rc, const char *error,
               const char *ip_address)
{
    switch (status)
    {
        case WEECHAT_HOOK_CONNECT_OK:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_ADDRESS_NOT_FOUND:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_IP_ADDRESS_NOT_FOUND:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_CONNECTION_REFUSED:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_PROXY_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_LOCAL_HOSTNAME_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_GNUTLS_INIT_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_GNUTLS_HANDSHAKE_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_MEMORY_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_TIMEOUT:
            /* ... */
            break;
    }
    return WEECHAT_RC_OK;
}

struct t_hook *my_connect_hook = weechat_hook_connect (NULL,
                                                       "my.server.org", 1234,
                                                       sock, 0,
                                                       NULL, NULL, 0, /* GnuTLS */
                                                       NULL,
                                                       &my_connect_cb, NULL);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
hook = weechat.hook_connect(proxy, address, port, sock, ipv6, local_hostname,
    callback, callback_data)

# exemple
def my_connect_cb(data, status, gnutls_rc, error, ip_address):
    if status == WEECHAT_HOOK_CONNECT_OK:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_ADDRESS_NOT_FOUND:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_IP_ADDRESS_NOT_FOUND:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_CONNECTION_REFUSED:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_PROXY_ERROR:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_LOCAL_HOSTNAME_ERROR:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_GNUTLS_INIT_ERROR:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_GNUTLS_HANDSHAKE_ERROR:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_MEMORY_ERROR:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_TIMEOUT:
        # ...
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_connect("", "my.server.org", 1234, sock, 0, "",
                            "my_connect_cb", "")
----------------------------------------

weechat_hook_print
^^^^^^^^^^^^^^^^^^

Intercepte un message affiché.

Prototype :

[source,C]
----------------------------------------
struct t_hook *weechat_hook_print (struct t_gui_buffer *buffer,
                                   const char *tags,
                                   const char *message,
                                   int strip_colors,
                                   int (*callback)(void *data,
                                                   struct t_gui_buffer *buffer,
                                                   time_t date,
                                                   int tags_count,
                                                   const char **tags,
                                                   int displayed,
                                                   int highlight,
                                                   const char *prefix,
                                                   const char *message),
                                   void *callback_data);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon, si NULL, les messages de tous les tampons
  sont interceptés
* 'tags' : seulement les messages avec ces étiquettes ("tags") (liste séparée
  par des virgules) seront interceptés (optionnel)
* 'message' : seulement les messages contenant cette chaîne seront interceptés
  (optionnel, insensible à la casse)
* 'strip_colors' : si 1, les couleurs seront supprimées du message affiché,
  avant d'appeler le "callback"
* 'callback' : fonction appelée lorsqu'un message est affiché, paramètres et
  valeur de retour :
** 'void *data' : pointeur
** 'struct t_gui_buffer *buffer' : pointeur vers le tampon
** 'time_t date' : date
** 'int tags_count' : nombre d'étiquettes ("tags") de la ligne
** 'const char **tags' : tableau avec les étiquettes ("tags") de la ligne
** 'int displayed' : 1 si la ligne est affichée, 0 si elle est filtrée (cachée)
** 'int highlight' : 1 si la ligne contient un highlight, sinon 0
** 'const char *prefix' : préfixe
** 'const char *message' : message
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
int
my_print_cb (void *data, struct t_gui_buffer *buffer, time_t date,
             int tags_count, const char **tags,
             int displayed, int highlight,
             const char *prefix, const char *message)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* intercepter tous les messages, de tous les tampons, sans couleur */
struct t_hook *my_print_hook =
    weechat_hook_print (NULL, NULL, NULL, 1, &my_print_cb, NULL);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
hook = weechat.hook_print(buffer, tags, message, strip_colors, callback, callback_data)

# exemple
def my_print_cb(data, buffer, date, tags, displayed, highlight, prefix, message):
    # ...
    return weechat.WEECHAT_RC_OK

# intercepter tous les messages, de tous les tampons, sans couleur
hook = weechat.hook_print("", "", "", 1, "my_print_cb", "")
----------------------------------------

weechat_hook_signal
^^^^^^^^^^^^^^^^^^^

S'accroche à un signal.

Prototype :

[source,C]
----------------------------------------
struct t_hook *weechat_hook_signal (const char *signal,
                                    int (*callback)(void *data,
                                                    const char *signal,
                                                    const char *type_data,
                                                    void *signal_data),
                                    void *callback_data);
----------------------------------------

Paramètres :

* 'signal' : signal à intercepter, peut commencer ou se terminer par "*"
  (priorité autorisée, voir la note sur la <<hook_priority,priorité>>) :

[width="100%",cols="^1,^3,^4,5",options="header"]
|========================================
| Extension | Signal | Paramètres | Description

| irc | xxx,irc_in_yyy ^(1)^ |
  chaîne : message |
  message irc du serveur (avant utilisation par l'extension irc,
  signal envoyé uniquement si le message n'est *pas* ignoré)

| irc | xxx,irc_in2_yyy ^(1)^ |
  chaîne : message |
  message irc du serveur (après utilisation par l'extension irc,
  signal envoyé uniquement si le message n'est *pas* ignoré)

| irc | xxx,irc_raw_in_yyy ^(1)^ +
  (_nouveau dans la version 0.3.2_) |
  chaîne : message |
  message irc du serveur (avant utilisation par l'extension irc,
  signal envoyé même si le message est ignoré)

| irc | xxx,irc_raw_in2_yyy ^(1)^ +
  (_nouveau dans la version 0.3.2_) |
  chaîne : message |
  message irc du serveur (après utilisation par l'extension irc,
  signal envoyé même si le message est ignoré)

| irc | xxx,irc_out1_yyy ^(1)^ +
  (_nouveau dans la version 0.3.7_) |
  chaîne : message |
  message irc envoyé au serveur (avant découpage automatique pour tenir dans les 512 octets)

| irc | xxx,irc_out_yyy ^(1)^ |
  chaîne : message |
  message irc envoyé au serveur (après découpage automatique pour tenir dans les 512 octets)

| irc | xxx,irc_outtags_yyy ^(1)^ +
  (_nouveau dans la version 0.3.4_) |
  chaîne : étiquettes + ";" + message |
  étiquettes + message irc envoyé au serveur

| irc | irc_ctcp |
  chaîne : message |
  CTCP reçu

| irc | irc_dcc |
  chaîne : message |
  nouveau DCC

| irc | irc_pv |
  chaîne : message |
  message privé reçu

| irc | irc_channel_opened |
  pointeur : tampon |
  canal ouvert

| irc | irc_pv_opened |
  pointeur : tampon |
  discussion privée ouverte

| irc | irc_server_opened +
  (_nouveau dans la version 0.3.7_) |
  pointeur : tampon |
  tampon du serveur ouvert

| irc | irc_server_connecting |
  chaîne : nom du serveur |
  connexion en cours au serveur

| irc | irc_server_connected |
  chaîne : nom du serveur |
  connecté au serveur

| irc | irc_server_disconnected |
  chaîne : nom du serveur |
  déconnecté du serveur

| irc | irc_ignore_removing |
  pointeur : ignore |
  suppression d'un ignore en cours

| irc | irc_ignore_removed |
  - |
  ignore supprimé

| irc | irc_notify_join +
  (_nouveau dans la version 0.3.8_) |
  chaîne: nom du serveur + "," + pseudo |
  un pseudo dans la liste de notifications a rejoint le serveur

| irc | irc_notify_quit +
  (_nouveau dans la version 0.3.8_) |
  chaîne: nom du serveur + "," + pseudo |
  un pseudo dans la liste de notifications a quitté le serveur

| irc | irc_notify_away +
  (_nouveau dans la version 0.3.8_) |
  chaîne: nom du serveur + "," + pseudo + "," + message d'absence |
  un pseudo dans la liste de notifications est maintenant absent sur le serveur

| irc | irc_notify_still_away +
  (_nouveau dans la version 0.3.8_) |
  chaîne: nom du serveur + "," + pseudo + "," + message d'absence |
  un pseudo dans la liste de notifications est toujours absent sur le serveur (le message d'absence a changé)

| irc | irc_notify_back +
  (_nouveau dans la version 0.3.8_) |
  chaîne: nom du serveur + "," + pseudo |
  un pseudo dans la liste de notifications est de retour (statut d'absence supprimé)

| logger | logger_start |
  pointeur : tampon |
  démarrage de l'enregistrement sur disque pour le tampon

| logger | logger_stop |
  pointeur : tampon |
  fin de l'enregistrement sur disque pour le tampon

| logger | logger_backlog |
  pointeur : tampon |
  affichage du backlog pour le tampon

| weechat | buffer_closing |
  pointeur : tampon |
  fermeture du tampon en cours

| weechat | buffer_closed |
  pointeur : tampon |
  tampon fermé

| weechat | buffer_lines_hidden |
  pointeur : tampon |
  lignes cachées dans le tampon

| weechat | buffer_localvar_added |
  pointeur : tampon |
  variable locale ajoutée

| weechat | buffer_localvar_changed |
  pointeur : tampon |
  variable locale modifiée

| weechat | buffer_localvar_removed |
  pointeur : tampon |
  variable locale supprimée

| weechat | buffer_moved |
  pointeur : tampon |
  tampon déplacé

| weechat | buffer_opened |
  pointeur : tampon |
  tampon ouvert

| weechat | buffer_renamed |
  pointeur : tampon |
  tampon renommé

| weechat | buffer_switch |
  pointeur : tampon |
  basculement vers un autre tampon

| weechat | buffer_title_changed |
  pointeur : tampon |
  titre du tampon changé

| weechat | buffer_type_changed |
  pointeur : tampon |
  type de tampon changé

| weechat | buffer_line_added +
  (_nouveau dans la version 0.3.7_) |
  pointeur : ligne |
  ligne ajoutée dans un tampon

| weechat | day_changed +
  (_nouveau dans la version 0.3.2_) |
  chaîne : nouvelle date, format : "2010-01-31" |
  le jour de la date système a changé

| weechat | debug_dump |
  chaîne : nom d'extension |
  requête de "dump"

| weechat | filter_added |
  pointeur : filtre |
  filtre ajouté

| weechat | filter_removing |
  pointre : filtre |
  suppression de filtre en cours

| weechat | filter_removed |
  - |
  filtre supprimé

| weechat | filters_enabled |
  - |
  filtres activés

| weechat | filters_disabled |
  - |
  filtres désactivés

| weechat | hotlist_changed |
  - |
  la hotlist a changé

| weechat | input_paste_pending |
  - |
  coller de lignes en cours

| weechat | input_search |
  - |
  recherche de texte dans le tampon

| weechat | input_text_changed |
  - |
  texte modifié dans la barre "input"

| weechat | input_text_cursor_moved |
  - |
  curseur déplacé dans la barre "input"

| weechat | key_pressed |
  chaîne : touche appuyée |
  touche appuyée

| weechat | nicklist_group_added +
  (_nouveau dans la version 0.3.2_) |
  chaîne : pointeur tampon + "," + nom du groupe |
  groupe ajouté dans la liste des pseudos

| weechat | nicklist_group_removed +
  (_nouveau dans la version 0.3.2_) |
  chaîne : pointeur tampon + "," + nom du groupe |
  groupe supprimé de la liste des pseudos

| weechat | nicklist_nick_added +
  (_nouveau dans la version 0.3.2_) |
  chaîne : pointeur tampon + "," + pseudo |
  pseudo ajouté dans la liste des pseudos

| weechat | nicklist_nick_removed +
  (_nouveau dans la version 0.3.2_) |
  chaîne : pointeur tampon + "," + pseudo |
  pseudo supprimé de la liste des pseudos

| weechat | partial_completion |
  - |
  une complétion partielle a été faite

| weechat | quit |
  chaîne : paramètres pour le /quit |
  la commande `/quit` a été exécutée par l'utilisateur

| weechat | upgrade |
  - |
  la commande `/upgrade` a été exécutée par l'utilisateur

| weechat | upgrade_ended +
  (_nouveau dans la version 0.3.4_) |
  - |
  fin du processus de mise à jour (commande `/upgrade`)

| weechat | weechat_highlight |
  chaîne : message avec le préfixe |
  un highlight est survenu

| weechat | weechat_pv |
  chaîne : message avec le préfixe |
  un message privé a été affiché

| weechat | window_scrolled |
  pointeur : fenêtre |
  défilement dans la fenêtre

| weechat | window_switch +
  (_nouveau dans la version 0.3.7_) |
  pointeur : fenêtre |
  basculement vers une autre fenêtre

| weechat | window_unzoom |
  pointeur : fenêtre courante |
  fin du zoom en cours sur la fenêtre

| weechat | window_unzoomed |
  pointeur : fenêtre courante |
  fin du zoom effectué sur la fenêtre

| weechat | window_zoom |
  pointeur : fenêtre courante |
  zoom en cours sur la fenêtre

| weechat | window_zoomed |
  pointeur : fenêtre courante |
  zomm effectué sur la fenêtre

| xfer | xfer_add |
  pointeur : infolist avec l'info xfer |
  nouveau xfer

| xfer | xfer_send_ready |
  pointeur : infolist avec l'info xfer |
  xfer ready

| xfer | xfer_accept_resume |
  pointeur : infolist avec l'info xfer |
  le xfer accepte la reprise (envoi)

| xfer | xfer_send_accept_resume |
  pointeur : infolist avec l'info xfer |
  le xfer accepte la reprise (envoi)

| xfer | xfer_start_resume |
  pointeur : infolist avec l'info xfer |
  redémarrage

| xfer | xfer_resume_ready |
  pointer : infolist avec l'info xfer |
  redémarrage prêt

| xfer | xfer_ended +
  (_nouveau dans la version 0.3.2_) |
  pointer : infolist avec l'info xfer |
  le xfer s'est terminé
|========================================

[NOTE]
^(1)^ 'xxx' est le nom du serveur IRC, 'yyy' est le nom d'une commande IRC.

* 'callback' : fonction appelée quand le signal est reçu, paramètres et valeur
  de retour :
** 'void *data' : pointeur
** 'const char *signal' : signal reçu
** 'const char *type_data' : type de donnée reçu avec le signal :
*** 'WEECHAT_HOOK_SIGNAL_STRING' : chaîne de caractères
*** 'WEECHAT_HOOK_SIGNAL_INT' : nombre entier
*** 'WEECHAT_HOOK_SIGNAL_POINTER' : pointeur
** 'void *signal_data' : données envoyées avec le signal
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
int
my_signal_cb (void *data, const char *signal, const char *type_data,
              void *signal_data)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* intercepter le signal "quit" */
struct t_hook *my_signal_hook = weechat_hook_signal ("quit",
                                                     &my_signal_cb, NULL);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
hook = weechat.hook_signal(signal, callback, callback_data)

# exemple
def my_signal_cb(data, signal, signal_data):
    # ...
    return weechat.WEECHAT_RC_OK

# intercepter le signal "quit"
hook = weechat.hook_signal("quit", "my_signal_cb", "")
----------------------------------------

weechat_hook_signal_send
^^^^^^^^^^^^^^^^^^^^^^^^

Envoie un signal.

Prototype :

[source,C]
----------------------------------------
void weechat_hook_signal_send (const char *signal, const char *type_data,
                               void *signal_data);
----------------------------------------

Paramètres :

* 'signal' : signal à envoyer
* 'type_data' : type de données à envoyer avec le signal (voir
  <<_weechat_hook_signal,weechat_hook_signal>>)
* 'signal_data' : données envoyées avec le signal

Exemple en C :

[source,C]
----------------------------------------
weechat_hook_signal_send ("mon_signal", WEECHAT_HOOK_SIGNAL_STRING, ma_chaine);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.hook_signal_send(signal, type_data, signal_data)

# exemple
weechat.hook_signal_send("mon_signal", weechat.WEECHAT_HOOK_SIGNAL_STRING, ma_chaine)
----------------------------------------

[[signal_logger_backlog]]
Signal logger_backlog
+++++++++++++++++++++

Le signal "logger_backlog" peut être envoyé pour afficher l'historique de
discussion dans le tampon (par exemple si vous ouvrez votre propre tampon dans
votre extension/script).

Le paramètre est un pointeur vers le tampon.

Exemple en C :

[source,C]
----------------------------------------
weechat_hook_signal_send ("logger_backlog", WEECHAT_HOOK_SIGNAL_POINTER, buffer);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
weechat.hook_signal_send("logger_backlog", weechat.WEECHAT_HOOK_SIGNAL_POINTER, buffer)
----------------------------------------

[[signals_xxx_script_install]]
Signaux xxx_script_install
++++++++++++++++++++++++++

Cinq signaux peuvent être envoyés pour installer un script, selon le langage :

* 'perl_script_install'
* 'python_script_install'
* 'ruby_script_install'
* 'lua_script_install'
* 'tcl_script_install'

Le "callback" effectuera les actions suivantes lorsqu'il recevra le signal :

. déchargement et suppression du script installé
. déplacement du nouveau script vers le répertoire '~/.weechat/xxx/' (où 'xxx'
  est le langage)
. création d'un lien vers le nouveau script dans le répertoire
  '~/.weechat/xxx/autoload/'
. chargement du nouveau script

Ces signaux sont utilisés par le script 'weeget.py' pour installer des scripts.

Le paramètre est une chaîne avec le chemin vers le script à installer.

Exemple en C :

[source,C]
----------------------------------------
weechat_hook_signal_send ("python_script_install", WEECHAT_HOOK_SIGNAL_STRING,
                          "/home/xxx/.weechat/test.py");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
weechat.hook_signal_send("python_script_install", WEECHAT_HOOK_SIGNAL_STRING,
                         "/home/xxx/.weechat/test.py")
----------------------------------------

[[signals_xxx_script_remove]]
Signaux xxx_script_remove
+++++++++++++++++++++++++

Cinq signaux peuvent être envoyés pour supprimer une liste de scripts, selon le
langage :

* 'perl_script_remove'
* 'python_script_remove'
* 'ruby_script_remove'
* 'lua_script_remove'
* 'tcl_script_remove'

Pour chaque script dans la liste, le "callback" déchargera et supprimera le
script.

Ces signaux sont utilisés par le script 'weeget.py' pour supprimer des scripts.

Le paramètre est une chaîne avec une liste de scripts à supprimer (séparés par
des virgules, nom du script sans le chemin, par exemple 'script.py').

Exemple en C :

[source,C]
----------------------------------------
/* décharge et supprime les scripts test.py et script.py */
weechat_hook_signal_send ("python_script_remove", WEECHAT_HOOK_SIGNAL_STRING,
                          "test.py,script.py");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# décharge et supprime les scripts test.py et script.py
weechat.hook_signal_send("python_script_remove", WEECHAT_HOOK_SIGNAL_STRING,
                         "test.py,script.py")
----------------------------------------

[[signal_irc_input_send]]
Signal irc_input_send
+++++++++++++++++++++

_Nouveau dans la version 0.3.4._

Le signal "irc_input_send" peut être envoyé pour simuler une entrée de texte
dans un tampon irc (serveur, canal ou privé).

Le paramètre est une chaîne avec le format suivant :

* nom interne du serveur (requis)
* point-virgule
* nom de canal (optionnel)
* point-virgule
* drapeaux utilisés lors de l'envoi du message (optionnel, 1 par
  défaut) :
** '1' : file d'attente avec haute priorité (comme les messages utilisateur)
** '2' : file d'attente avec basse priorité (comme les messages envoyés
   automatiquement par WeeChat)
* point-virgule
* liste d'étiquettes (séparées par des virgules) utilisées lors de l'envoi du
  du message (optionnel)
* point-virgule
* texte ou commande (requis)

Exemples en C :

[source,C]
----------------------------------------
/* dis "Bonjour !" sur le serveur freenode, canal #weechat */
weechat_hook_signal_send ("irc_input_send", WEECHAT_HOOK_SIGNAL_STRING,
                          "freenode;#weechat;1;;Bonjour !");

/* envoie la commande "/whois FlashCode" sur le canal freenode, en basse priorité */
weechat_hook_signal_send ("irc_input_send", WEECHAT_HOOK_SIGNAL_STRING,
                          "freenode;;2;;/whois FlashCode");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# dis "Bonjour !" sur le serveur freenode, canal #weechat
weechat.hook_signal_send("irc_input_send", weechat.WEECHAT_HOOK_SIGNAL_STRING,
                         "freenode;#weechat;1;;Bonjour !")

# envoie la commande "/whois FlashCode" sur le canal freenode, en basse priorité
weechat.hook_signal_send("irc_input_send", weechat.WEECHAT_HOOK_SIGNAL_STRING,
                         "freenode;;2;;/whois FlashCode")
----------------------------------------

weechat_hook_hsignal
^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.4._

S'accroche à un hsignal (signal avec une hashtable).

Prototype :

[source,C]
----------------------------------------
struct t_hook *weechat_hook_hsignal (const char *signal,
                                     int (*callback)(void *data,
                                                     const char *signal,
                                                     struct t_hashtable *hashtable),
                                     void *callback_data);
----------------------------------------

Paramètres :

* 'signal' : signal à intercepter, peut commencer ou se terminer par "*"
  (priorité autorisée, voir la note sur la <<hook_priority,priorité>>) :

[width="100%",cols="^1,^3,5",options="header"]
|========================================
| Extension | Signal | Paramètres

| irc | irc_redirection_xxx_yyy ^(1)^ |
  sortie de la redirection (voir <<hsignal_irc_redirect_command>>)
|========================================

[NOTE]
^(1)^ 'xxx' est l'argument "signal" utilisé dans la redirection, 'yyy' est le
modèle de redirection ("pattern").

* 'callback' : fonction appelée quand le signal est reçu, paramètres et valeur
  de retour :
** 'void *data' : pointeur
** 'const char *signal' : signal reçu
** 'struct t_hashtable *hashtable' : hashtable
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
int
my_hsignal_cb (void *data, const char *signal, struct t_hashtable *hashtable)
{
    /* ... */
    return WEECHAT_RC_OK;
}

struct t_hook *my_hsignal_hook = weechat_hook_hsignal ("test",
                                                       &my_hsignal_cb, NULL);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
hook = weechat.hook_hsignal(signal, callback, callback_data)

# exemple
def my_hsignal_cb(data, signal, hashtable):
    # ...
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_hsignal("test", "my_hsignal_cb", "")
----------------------------------------

weechat_hook_hsignal_send
^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.4._

Envoie un hsignal (signal avec hashtable).

Prototype :

[source,C]
----------------------------------------
void weechat_hook_hsignal_send (const char *signal, struct t_hashtable *hashtable);
----------------------------------------

Paramètres :

* 'signal' : signal à envoyer
* 'hashtable' : hashtable

Exemple en C :

[source,C]
----------------------------------------
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
if (hashtable)
{
    weechat_hashtable_set (hashtable, "clé", "valeur");
    weechat_hook_hsignal_send ("my_hsignal", hashtable);
    weechat_hashtable_free (hashtable);
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.hook_hsignal_send(signal, hashtable)

# exemple
weechat.hook_hsignal_send("my_hsignal", { "clé": "valeur" })
----------------------------------------

[[hsignal_irc_redirect_command]]
Hsignal irc_redirect_command
++++++++++++++++++++++++++++

_Nouveau dans la version 0.3.4._

Le hsignal "irc_redirect_command" peut être envoyé pour rediriger la sortie
d'une commande irc vers un "callback".

Le paramètre est une hashtable avec les entrées suivantes (les clés et valeurs
sont des chaînes) :

* 'server' : nom interne du serveur (requis)
* 'pattern' : modèle de redirection à utiliser (requis), soit un par défaut
  (défini par l'extension irc), ou un modèle utilisateur (voir
  <<hsignal_irc_redirect_pattern>>), les modèles par défaut sont :
** 'ison'
** 'list'
** 'mode_channel'
** 'mode_channel_ban' ("mode #channel b")
** 'mode_channel_ban_exception' ("mode #channel e")
** 'mode_channel_invite' ("mode #channel I")
** 'mode_user'
** 'names'
** 'ping'
** 'time'
** 'topic'
** 'userhost'
** 'who'
** 'whois'
** 'whowas'
* 'signal' : nom du signal (requis)
* 'count' : nombre de fois que la redirection sera exécutée (optionnel, 1 par
  défaut)
* 'string' : chaîne qui doit être dans les messages irc reçus (optionnel, mais
  recommandé, si une chaîne peut être utilisée pour identifier les messages)
* 'timeout' : temps d'attente maxi pour la redirection, en secondes (optionnel,
  60 par défaut)
* 'cmd_filter' : liste de commandes irc (séparées par des virgules) à filtrer
  (seules ces commandes seront transmises au "callback", les autres seront
  ignorées) (optionnel)

Immédiatement après l'envoi de ce hsignal, vous devez envoyer la commande au
serveur irc, et la redirection sera utilisée pour cette commande.

Lorsque la réponse complète à votre commande a été reçue, un hsignal est envoyé.
Ce hsignal a le nom 'irc_redirection_xxx_yyy' où 'xxx' est le 'signal' et 'yyy'
le 'pattern' utilisé.

La hashtable envoyée dans le hsignal a le contenu suivant (les clés et valeurs
sont des chaînes) :

* 'output' : sortie de la commande (les messages sont séparés par "\n")
* 'output_size' : nombre d'octets dans 'output' (sous forme de chaîne)
* 'error' : chaîne d'erreur (si une erreur s'est produite) :
** 'timeout' : redirection stoppée après le délai maximum dépassé
* 'server' : nom interne du serveur
* 'pattern' : modèle de redirection
* 'signal' : nom du signal
* 'command' : commande redirigée

Exemple en C :

[source,C]
----------------------------------------
int
test_whois_cb (void *data, const char *signal, struct t_hashtable *hashtable)
{
    weechat_printf (NULL, "erreur = %s", weechat_hashtable_get (hashtable, "error"));
    weechat_printf (NULL, "sortie = %s", weechat_hashtable_get (hashtable, "output"));
    return WEECHAT_RC_OK;
}

weechat_hook_hsignal ("irc_redirection_test_whois", &test_whois_cb, NULL);
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
if (hashtable)
{
    weechat_hashtable_set (hashtable, "server", "freenode");
    weechat_hashtable_set (hashtable, "pattern", "whois");
    weechat_hashtable_set (hashtable, "signal", "test");
    weechat_hashtable_set (hashtable, "string", "FlashCode");
    weechat_hook_hsignal_send ("irc_redirect_command", hashtable);
    weechat_hook_signal_send ("irc_input_send", WEECHAT_HOOK_SIGNAL_STRING,
                              "freenode;;2;;/whois FlashCode");
    weechat_hashtable_free (hashtable);
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
def test_whois_cb(data, signal, hashtable):
    weechat.prnt("", "erreur = %s" % hashtable["error"])
    weechat.prnt("", "sortie = %s" % hashtable["output"])
    return weechat.WEECHAT_RC_OK

weechat.hook_hsignal ("irc_redirection_test_whois", "test_whois_cb", "")
weechat.hook_hsignal_send("irc_redirect_command",
                          { "server": "freenode", "pattern": "whois", "signal": "test",
                            "string": "FlashCode" })
weechat.hook_signal_send("irc_input_send", weechat.WEECHAT_HOOK_SIGNAL_STRING,
                         "freenode;;2;;/whois FlashCode")
----------------------------------------

[[hsignal_irc_redirect_pattern]]
Hsignal irc_redirect_pattern
++++++++++++++++++++++++++++

_Nouveau dans la version 0.3.4._

Le hsignal "irc_redirect_pattern" peut être envoyé pour créer un modèle de
redirection irc (voir <<hsignal_irc_redirect_command>>).

Le paramètre est une hashtable avec les entrées suivantes (les clés et valeurs
sont des chaînes) :

* 'pattern' : nom du modèle (requis)
* 'timeout' : temps d'attente maxi pour le modèle, en secondes (optionnel, 60
  par défaut)
* 'cmd_start' : liste de commandes (séparées par des virgules) démarrant la
  redirection (optionnel)
* 'cmd_stop' : liste de commandes (séparées par des virgules) stoppant la
  redirection (requis)
* 'cmd_extra' : liste de commandes (séparées par des virgules) pouvant être
  reçues après les commandes de stop (optionnel)

Pour chaque commande dans 'cmd_start', 'cmd_stop' et 'cmd_extra', il est
possible de donner un entier avec la position de la chaîne "string" qui doit
être trouvée dans le message reçu, par exemple :

----------------------------------------
352:1,354,401:1
----------------------------------------

Pour les commandes 352 et 401, la chaîne "string" doit être trouvée dans le
message reçu, comme premier paramètre.

[IMPORTANT]
Le modèle est détruit dès qu'il est utilisé dans une redirection. Si vous avez
besoin du modèle pour plusieurs redirections, vous devez créer un modèle pour
chaque redirection.

Exemple en C :

[source,C]
----------------------------------------
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
if (hashtable)
{
    weechat_hashtable_set (hashtable, "pattern", "my_whois");
    weechat_hashtable_set (hashtable, "timeout", "30");
    weechat_hashtable_set (hashtable, "cmd_start", "311:1");
    weechat_hashtable_set (hashtable, "cmd_stop", "318:1,401:1,402:1,431:1,461");
    weechat_hashtable_set (hashtable, "cmd_extra", "318:1");
    weechat_hook_hsignal_send ("irc_redirect_pattern", hashtable);
    /*
     * rediriger maintenant la commande irc whois avec le hsignal irc_redirect_command,
     * en utilisant le modèle "my_whois"
     */
    /* ... */
    weechat_hashtable_free (hashtable);
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
weechat.hook_hsignal_send("irc_redirect_pattern",
                          { "pattern": "my_whois", "timeout": "30",
                            "cmd_start": "311:1",
                            "cmd_stop": "318:1,401:1,402:1,431:1,461",
                            "cmd_extra": "318:1" })
# rediriger maintenant la commande irc whois avec le hsignal irc_redirect_command,
# en utilisant le modèle "my_whois"
# ...
----------------------------------------

weechat_hook_config
^^^^^^^^^^^^^^^^^^^

S'accroche à une option de configuration.

Prototype :

[source,C]
----------------------------------------
struct t_hook *weechat_hook_config (const char *option,
                                    int (*callback)(void *data,
                                                    const char *option,
                                                    const char *value),
                                    void *callback_data);
----------------------------------------

Paramètres :

* 'option' : option, le format est le nom complet, celui utilisé avec la
  commande `/set` (par exemple : `weechat.look.item_time_format`)
  (priorité autorisée, voir la note sur la <<hook_priority,priorité>>)
* 'callback' : fonction appelée lorsque l'option de configuration est modifiée,
  paramètres et valeur de retour :
** 'void *data' : pointeur
** 'const char *option' : nom de l'option
** 'const char *value' : nouvelle valeur pour l'option
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
int
my_config_cb (void *data, const char *option, const char *value)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* intercepter les changements de l'option "weechat.look.item_time_format" */
struct t_hook *my_config_hook = weechat_hook_config ("weechat.look.item_time_format",
                                                     &my_config_cb, NULL);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
hook = weechat.hook_config(option, callback, callback_data)

# exemple
def my_config_cb(data, option, value):
    # ...
    return weechat.WEECHAT_RC_OK

# intercepter les changements de l'option "weechat.look.item_time_format"
hook = weechat.hook_config("weechat.look.item_time_format", "my_config_cb", "")
----------------------------------------

weechat_hook_completion
^^^^^^^^^^^^^^^^^^^^^^^

Accroche une complétion.

Prototype :

[source,C]
----------------------------------------
struct t_hook *weechat_hook_completion (const char *completion_item,
                                        const char *description,
                                        int (*callback)(void *data,
                                                        const char *completion_item,
                                                        struct t_gui_buffer *buffer,
                                                        struct t_gui_completion *completion),
                                        void *callback_data);
----------------------------------------

Paramètres :

* 'completion_item' : nom de l'objet de complétion, après vous pouvez utiliser
  '%(nom)' dans une commande (paramètre 'completion')
  (priorité autorisée, voir la note sur la <<hook_priority,priorité>>)
* 'description' : description de la complétion
* 'callback' : fonction appelée lorsque la complétion est utilisée
  (l'utilisateur est en train de compléter quelque chose qui fait appel à cette
  complétion), paramètres et valeur de retour :
** 'void *data' : pointeur
** 'const char *completion_item' : nom de la complétion
** 'struct t_gui_buffer *buffer' : tampon où la complétion est effectuée
** 'struct t_gui_completion *completion' : structure utilisée pour ajouter
   les mots pour la complétion (voir
   <<_weechat_hook_completion_list_add,weechat_hook_completion_list_add>>)
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

[NOTE]
Les noms de complétion sont globaux (partagés entre WeeChat et les extensions).
Il est donc recommandé de choisir un nom avec un préfixe unique, comme
"monextension_xxx" (où "xxx" est le nom de votre complétion).

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
int
my_completion_cb (void *data, const char *completion_item,
                  struct t_gui_buffer *buffer,
                  struct t_gui_completion *completion)
{
    weechat_hook_completion_list_add (completion, "mot1",
                                      0, WEECHAT_LIST_POS_SORT);
    weechat_hook_completion_list_add (completion, "test_mot2",
                                      0, WEECHAT_LIST_POS_SORT);
    return WEECHAT_RC_OK;
}

struct t_hook *my_completion_hook = weechat_hook_completion ("extension_item",
                                                             "ma complétion !",
                                                             &my_completion_cb, NULL);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
hook = weechat.hook_completion(completion_item, description, callback, callback_data)

# exemple
def my_completion_cb(data, completion_item, buffer, completion):
    weechat.hook_completion_list_add(completion, "mot1", 0, weechat.WEECHAT_LIST_POS_SORT)
    weechat.hook_completion_list_add(completion, "test_mot2", 0, weechat.WEECHAT_LIST_POS_SORT)
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_completion("extension_item", "ma complétion !",
                               "my_completion_cb", "")
----------------------------------------

weechat_hook_completion_get_string
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.4._

Retourne la valeur d'une propriété de la complétion sous forme de chaîne.

Prototype :

[source,C]
----------------------------------------
const char *weechat_hook_completion_get_string (struct t_gui_completion *completion,
                                                const char *property);
----------------------------------------

Paramètres :

* 'completion' : pointeur vers la complétion
* 'property' : nom de la propriété :
** 'base_command' : commande utilisée pour la complétion
** 'base_word' : le mot qui va être complété
** 'args' : paramètres de la commande (incluant le mot de base "base_word")

Exemple en C :

[source,C]
----------------------------------------
int
my_completion_cb (void *data, const char *completion_item,
                  struct t_gui_buffer *buffer,
                  struct t_gui_completion *completion)
{
    /* récupère les paramètres de la commande */
    const char *args = weechat_hook_completion_get_string (completion, "args");

    /* complétion selon les paramètres */
    /* ... */

    return WEECHAT_RC_OK;
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.hook_completion_get_string(completion, property)

# exemple
def my_completion_cb(data, completion_item, buffer, completion):
    # récupère les paramètres de la commande
    args = weechat.hook_completion_get_string(completion, "args")
    # complétion selon les paramètres
    # ...
    return weechat.WEECHAT_RC_OK
----------------------------------------

weechat_hook_completion_list_add
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Ajoute un mot pour une complétion.

Prototype :

[source,C]
----------------------------------------
void weechat_hook_completion_list_add (struct t_gui_completion *completion,
                                       const char *word,
                                       int nick_completion,
                                       const char *where);
----------------------------------------

Paramètres :

* 'completion' : pointeur vers la complétion
* 'word' : mot à ajouter
* 'nick_completion' : 1 si le mot est un pseudo, sinon 0
* 'where' : pposition où sera inséré le mot dans la liste :
** 'WEECHAT_LIST_POS_SORT' : n'importe où, pour maintenir la liste triée
** 'WEECHAT_LIST_POS_BEGINNING' : au début de la liste
** 'WEECHAT_LIST_POS_END' : à la fin de la liste

Exemple en C : voir <<_weechat_hook_completion,weechat_hook_completion>>.

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.hook_completion_list_add(completion, word, nick_completion, where)

# exemple : voir la fonction hook_completion ci-dessus
----------------------------------------

weechat_hook_modifier
^^^^^^^^^^^^^^^^^^^^^

Accroche un "modifieur".

Prototype :

[source,C]
----------------------------------------
struct t_hook *weechat_hook_modifier (const char *modifier,
                                      char *(*callback)(void *data,
                                                        const char *modifier,
                                                        const char *modifier_data,
                                                        const char *string),
                                      void *callback_data);
----------------------------------------

Paramètres :

* 'modifier' : nom du "modifieur", liste des "modifieurs" utilisés par WeeChat
  ou des extensions
  (priorité autorisée, voir la note sur la <<hook_priority,priorité>>) :

[width="100%",cols="^1,^2,3,4,4",options="header"]
|========================================
| Extension | "Modifieur" | Données du "modifieur" | Chaîne | Sortie

| charset | charset_decode |
  extension.nom_tampon |
  toute chaîne |
  chaîne décodée depuis le jeu de caractères trouvé pour l'extension/tampon
  vers UTF-8

| charset | charset_encode |
  extension.nom_tampon |
  toute chaîne |
  chaîne encodée depuis UTF-8 vers le jeu de caractères trouvé pour
  l'extension/tampon

| irc | irc_color_decode |
  "1" pour garder les couleurs, "0" pour les supprimer |
  toute chaîne |
  chaîne avec dec codes couleur WeeChat, ou sans couleur

| irc | irc_color_encode |
  "1" pour garder les couleurs, "0" pour les supprimer |
  toute chaîne |
  chaîne avec des codes couleur IRC, ou sans couleur

| irc | irc_in_xxx ^(1)^ |
  nom de serveur |
  contenu du message reçu du serveur IRC (avant décodage du jeu de caractères) |
  nouveau contenu du message

| irc | irc_in2_xxx ^(1)^ +
  (_nouveau dans la version 0.3.5_) |
  nom de serveur |
  contenu du message reçu du serveur IRC (après décodage du jeu de caractères) |
  nouveau contenu du message

| irc | irc_out1_xxx ^(1)^ +
  (_nouveau dans la version 0.3.7_) |
  nom de serveur |
  contenu du message qui va être envoyé au serveur IRC (avant découpage automatique pour tenir dans les 512 octets) |
  nouveau contenu du message

| irc | irc_out_xxx ^(1)^ |
  nom de serveur |
  contenu du message qui va être envoyé au serveur IRC (après découpage automatique pour tenir dans les 512 octets) |
  nouveau contenu du message

| weechat | bar_condition_yyy ^(2)^ |
  chaîne avec un pointeur vers la fenêtre ("0x123..") |
  chaîne vide |
  "1" pour afficher la barre, "0" pour la cacher

| weechat | history_add +
  (_nouveau dans la version 0.3.2_) |
  chaîne avec un pointeur vers le tampon ("0x123..") |
  contenu de la ligne de commande à ajouter à l'historique des commandes
  (tampon et global) |
  chaîne ajoutée à l'historique des commandes

| weechat | input_text_content |
  chaîne avec un pointeur vers le tampon ("0x123..") |
  contenu de la ligne de commande |
  nouvelle chaîne pour la ligne de commande

| weechat | input_text_display |
  chaîne avec un pointeur vers le tampon ("0x123..") |
  contenu de la ligne de commande, sans le code du curseur dedans |
  nouvelle chaîne, pour affichage seulement (la ligne de commande n'est pas
  modifiée)

| weechat | input_text_display_with_cursor |
  chaîne avec un pointeur vers le tampon ("0x123..") |
  contenu de la ligne de commande, avec le code du curseur dedans |
  nouvelle chaîne, pour affichage seulement (la ligne de commande n'est pas
  modifiée)

| weechat | input_text_for_buffer +
  (_nouveau dans la version 0.3.7_) |
  chaîne avec un pointeur vers le tampon ("0x123..") |
  contenu de la ligne de commande envoyée au tampon (texte ou commande) |
  nouveau contenu de la ligne de commande envoyée au tampon

| weechat | weechat_print |
  extension;nom_tampon;étiquettes |
  message affiché |
  nouveau message affiché
|========================================

[NOTE]
^(1)^ 'xxx' est un nom de commande IRC. +
^(2)^ 'yyy' est le nom de la barre.

* 'callback' : fonction appelée lorsque le "modifieur" est utilisé, paramètres
  et valeur de retour :
** 'void *data' : pointeur
** 'const char *modifier' : nom du "modifieur"
** 'const char *modifier_data' : données pour le "modifieur"
** 'const char *string' : chaîne à modifier
** valeur de retour : nouvelle chaîne
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
char *
my_modifier_cb (void *data, const char *modifier,
                const char *modifier_data,
                const char *string)
{
    char *result;
    int length;

    if (!string)
        return NULL;

    length = strlen (string) + 5;
    result = malloc (length);
    if (result)
    {
        /* ajouter "xxx" à chaque message affiché */
        snprintf (result, length, "%s xxx", string);
    }

    return result;
}

struct t_hook *my_modifier_hook = weechat_hook_modifier ("weechat_print",
                                                         &my_modifier_cb, NULL);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
hook = weechat.hook_modifier(modifier, callback, callback_data)

# exemple
def my_modifier_cb(data, modifier, modifier_data, string):
    return "%s xxx" % string

hook = weechat.hook_modifier("weechat_print", "my_modifier_cb", "")
----------------------------------------

weechat_hook_modifier_exec
^^^^^^^^^^^^^^^^^^^^^^^^^^

Exécute un ou plusieurs "modifieurs".

Prototype :

[source,C]
----------------------------------------
char *weechat_hook_modifier_exec (const char *modifier,
                                  const char *modifier_data,
                                  const char *string);
----------------------------------------

Paramètres :

* 'modifier' : nom du "modifieur"
* 'modifier_data' : données du "modifieur"
* 'string' : chaîne à modifier

Valeur de retour :

* chaîne modifiée, NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
char *new_string = weechat_hook_modifier_exec ("mon_modifier",
                                               mes_donnees, ma_chaine);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.hook_modifier_exec(modifier, modifier_data, string)

# exemple
weechat.hook_modifier_exec("mon_modifier", mes_donnees, ma_chaine)
----------------------------------------

weechat_hook_info
^^^^^^^^^^^^^^^^^

Accroche une information (le "callback" prend et retourne une chaîne).

Prototype :

[source,C]
----------------------------------------
struct t_hook *weechat_hook_info (const char *info_name,
                                  const char *description,
                                  const char *args_description,
                                  const char *(*callback)(void *data,
                                                          const char *info_name,
                                                          const char *arguments),
                                  void *callback_data);
----------------------------------------

Paramètres :

* 'info_name' : nom de l'information
  (priorité autorisée, voir la note sur la <<hook_priority,priorité>>)
* 'description' : description
* 'args_description' : description des paramètres (optionnel, peut être NULL)
* 'callback' : fonction appelée quand l'information est demandée, paramètres et
  valeur de retour :
** 'void *data' : pointeur
** 'const char *info_name' : nom de l'information
** 'const char *arguments' : paramètres additionnels, dépendant de
   l'information
** valeur de retour : valeur de l'information demandée
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
const char *
my_info_cb (void *data, const char *info_name, const char *arguments)
{
    /* ... */
    return pointeur_vers_chaine;
}

/* ajoute l'information "mon_info" */
struct t_hook *my_info_hook = weechat_hook_info ("mon_info",
                                                 "Une information",
                                                 "Info sur les paramètres",
                                                 &my_info_cb, NULL);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
hook = weechat.hook_info(info_name, description, args_description,
                         callback, callback_data)

# exemple
def my_info_cb(data, info_name, arguments):
    return "some_info"

hook = weechat.hook_info("mon_info", "Une information", "Info sur les paramètres",
                         "my_info_cb", "")
----------------------------------------

weechat_hook_info_hashtable
^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.4._

Accroche une information (le "callback" prend et retourne une hashtable).

Prototype :

[source,C]
----------------------------------------
struct t_hook *weechat_hook_info_hashtable (const char *info_name,
                                            const char *description,
                                            const char *args_description,
                                            const char *output_description,
                                            struct t_hashtable *(*callback)(void *data,
                                                                            const char *info_name,
                                                                            struct t_hashtable *hashtable),
                                            void *callback_data);
----------------------------------------

Paramètres :

* 'info_name' : nom de l'information
  (priorité autorisée, voir la note sur la <<hook_priority,priorité>>)
* 'description' : description
* 'args_description' : description de la hashtable attendue
  (optionnel, peut être NULL)
* 'output_description' : description de la hashtable retournée par le "callback"
  (optionnel, peut être NULL)
* 'callback' : fonction appelée quand l'information est demandée, paramètres et
  valeur de retour :
** 'void *data' : pointeur
** 'const char *info_name' : nom de l'information
** 'struct t_hashtable *hashtable' : hashtable, dépendant de l'information
** valeur de retour : hashtable demandée
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
struct t_hashtable *
my_info_hashtable_cb (void *data, const char *info_name, struct t_hashtable *hashtable)
{
    /* ... */
    return pointer_vers_nouvelle_hashtable;
}

/* ajoute l'information "mon_info_hashtable" */
struct t_hook *my_info_hook = weechat_hook_info_hashtable ("mon_info_hashtable",
                                                           "Une information",
                                                           "Info sur la hashtable en entrée",
                                                           "Info sur la hashtable en sortie",
                                                           &my_info_hashtable_cb, NULL);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
hook = weechat.hook_info_hashtable(info_name, description, args_description,
                                   output_description, callback, callback_data)

# exemple
def my_info_hashtable_cb(data, info_name, hashtable):
    return { "test_cle": "test_valeur" }

hook = weechat.hook_info_hashtable("mon_info_hashtable", "Une information",
                                   "Info sur la hashtable en entrée",
                                   "Info sur la hashtable en sortie",
                                   "my_info_hashtable_cb", "")
----------------------------------------

weechat_hook_infolist
^^^^^^^^^^^^^^^^^^^^^

Accroche une infolist : le "callback" retournera un pointeur vers l'infolist
demandée.

Prototype :

[source,C]
----------------------------------------
struct t_hook *weechat_hook_infolist (const char *infolist_name,
                                      const char *description,
                                      const char *pointer_description,
                                      const char *args_description,
                                      struct t_infolist *(*callback)(void *data,
                                                                     const char *infolist_name,
                                                                     void *pointer,
                                                                     const char *arguments),
                                      void *callback_data);
----------------------------------------

Paramètres :

* 'infolist_name' : nom de l'infolist
  (priorité autorisée, voir la note sur la <<hook_priority,priorité>>)
* 'description' : description
* 'pointer_description' : description du pointeur (optionnel, peut être NULL)
* 'args_description' : description des paramètres (optionnel, peut être NULL)
* 'callback' : fonction appelée quand l'infolist est demandée, paramètres et
  valeur de retour :
** 'void *data' : pointeur
** 'const char *infolist_name' : nom de l'infolist
** 'void *pointer' : pointeur vers un objet que l'infolist doit retourner (pour
   obtenir unituqment cet objet dans l'infolist)
** 'const char *arguments' : paramètres additionnels, dépendant de l'infolist
** valeur de retour : infolist demandée
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
struct t_infolist *
my_infolist_cb (void *data, const char *infolist_name, void *pointer,
                const char *arguments)
{
    struct t_infolist *mon_infolist;

    /* construction de l'infolist */
    /* ... */

    return mon_infolist;
}

/* ajoute l'infolist "mon_infolist" */
struct t_hook *my_infolist = weechat_hook_infolist ("mon_infolist",
                                                    "Mon infolist",
                                                    "Info sur le pointeur",
                                                    "Info sur les paramètres",
                                                    &my_infolist_cb, NULL);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
hook = weechat.hook_infolist(infolist_name, description, pointer_description,
                             args_description, callback, callback_data)

# exemple
def my_infolist_cb(data, infolist_name, pointer, arguments):
    # construction de l'infolist
    # ...
    return my_infolist

hook = weechat.hook_infolist("mon_infolist", "Mon infolist",
                             "Info sur le pointeur", "Info sur les paramètres",
                             "my_infolist_cb", "")
----------------------------------------

weechat_hook_hdata
^^^^^^^^^^^^^^^^^^

Accroche un hdata : le "callback" retournera un pointeur vers le hdata demandé.

Prototype :

[source,C]
----------------------------------------
struct t_hook *weechat_hook_hdata (const char *hdata_name,
                                   const char *description,
                                   struct t_hdata *(*callback)(void *data,
                                                               const char *hdata_name),
                                   void *callback_data);
----------------------------------------

Paramètres :

* 'hdata_name' : nom du hdata
  (priorité autorisée, voir la note sur la <<hook_priority,priorité>>)
* 'description' : description
* 'callback' : fonction appelée quand le hdata est demandé, paramètres et valeur
  de retour :
** 'void *data' : pointeur
** 'const char *hdata_name' : nom du hdata
** valeur de retour : hdata demandé
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
struct t_hdata *
my_hdata_cb (void *data, const char *hdata_name)
{
    struct t_hdata *mon_hdata;

    /* construction du hdata */
    /* ... */

    return mon_hdata;
}

/* ajoute le hdata "mon_hdata" */
struct t_hook *my_hdata = weechat_hook_hdata ("mon_hdata",
                                              "Hdata pour ma structure",
                                              &my_hdata_cb, NULL);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_hook_focus
^^^^^^^^^^^^^^^^^^

Accroche un focus : évènement souris ou touche du clavier pressée dans le mode
"curseur" (mouvement libre du curseur).

Prototype :

[source,C]
----------------------------------------
struct t_hook *weechat_hook_focus (const char *area,
                                   struct t_hashtable *(*callback)(void *data,
                                                                   struct t_hashtable *info),
                                   void *callback_data);
----------------------------------------

Paramètres :

* 'area' : "chat" pour la zone de discussion, ou un nom d'objet de barre
  (priorité autorisée, voir la note sur la <<hook_priority,priorité>>)
* 'callback' : fonction appelée quand le focus est fait, paramètres et valeur de
  retour :
** 'void *data' : pointeur
** 'struct t_hashtable *info' : hashtable avec les informations sur le focus et
   les chaînes retournées par les autres appels aux "callbacks" de focus (avec
   plus haute priorité) (voir le tableau ci-dessous)
** valeur de retour : soit le pointeur vers la hashtable "info" (avec la
   hashtable complétée), ou un pointeur vers une nouvelle hashtable (créée par
   le "callback", avec clés et valeurs de type "string"), le contenu de cette
   nouvelle hashtable sera ajouté à 'info' pour les autres appels aux
   "callbacks" focus
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
   WeeChat

[IMPORTANT]
Pour un geste de souris, votre "callback" sera appelé deux fois : la première
lorsque le bouton est pressé (ici la zone correspond à vôtre zone), la seconde
fois lorsque le bouton est relâché, et la zone peut ne pas correspondre à la
vôtre : donc vous devez *toujours* tester dans le "callback" si la zone
correspond avant d'utiliser les informations de la hashtable.

Contenu de la hashtable envoyée au "callback" (les clés et valeurs sont de type
"string) :

[width="100%",cols="5m,5,8,3",options="header"]
|========================================
| Clé ^(1)^                  | Description                   | Exemples de valeur                               | Valeur si non applicable
| _x                         | colonne sur l'écran         2+| "0" ... "n"
| _y                         | ligne sur l'écran           2+| "0" ... "n"
| _key                       | touche ou évènement souris  2+| "button1", "button2-gesture-left", ...
| _window                    | pointeur vers la fenêtre      | "0x12345678"                                     | ""
| _window_number             | numéro de la fenêtre          | "1" ... "n"                                      | "*"
| _buffer                    | pointeur vers le tampon       | "0x12345678"                                     | ""
| _buffer_number             | numéro du tampon              | "1" ... "n"                                      | "-1"
| _buffer_plugin             | nom d'extension du tampon     | "core", "irc", ...                               | ""
| _buffer_name               | nom du tampon                 | "weechat", "freenode.#weechat", ...              | ""
| _buffer_full_name          | nom complet du tampon         | "core.weechat", "irc.freenode.#weechat", ...     | ""
| _buffer_localvar_XXX ^(2)^ | variables locales du tampon   | toute chaîne                                     | non défini
| _chat                      | indicateur zone "chat"        | "0" ou "1"                                       | "0"
| _chat_line_x               | colonne de la ligne ^(3)^     | "0" ... "n"                                      | "-1"
| _chat_line_y               | numéro de ligne ^(3)^         | "0" ... "n"                                      | "-1"
| _chat_line_date            | date/heure de la ligne        | "1313237175"                                     | "0"
| _chat_line_date_printed    | date/heure de la ligne ^(4)^  | "1313237175"                                     | "0"
| _chat_line_time            | heure affichée                | "14:06:15"                                       | ""
| _chat_line_tags            | étiquettes de la ligne        | "irc_privmsg,notify_message,nick_FlashCode,log1" | ""
| _chat_line_nick            | pseudo de la ligne            | "FlashCode"                                      | ""
| _chat_line_prefix          | préfixe de la ligne           | "@FlashCode"                                     | ""
| _chat_line_message         | message de la ligne           | "Hello world!"                                   | ""
| _chat_word                 | mot à la position (x,y)       | "Hello"                                          | ""
| _chat_bol                  | début de ligne ⇒ (x-1,y)      | "He"                                             | ""
| _chat_eol                  | (x,y) ⇒ fin de ligne          | "llo world!"                                     | ""
| _bar_name                  | nom de la barre               | "title", "nicklist", ...                         | ""
| _bar_filling               | remplissage de la barre       | "horizontal", "vertical", ...                    | ""
| _bar_item_name             | nom de l'objet de barre       | "buffer_nicklist", "hotlist", ...                | ""
| _bar_item_line             | ligne dans l'objet de barre   | "0" ... "n"                                      | "-1"
| _bar_item_col              | colonne dans l'objet de barre | "0" ... "n"                                      | "-1"
|========================================

[NOTE]
^(1)^ Il y a les mêmes clés suffixées par "2" (c'est-à-dire : "_x2", "_y2",
"_window2", ...) avec l'information sur le second point (pratique seulement
pour les gestes de souris, pour savoir où le bouton de la souris a été
relâché). +
^(2)^ `XXX` est le nom d'une variable locale du tampon. +
^(3)^ Renseigné seulement pour les tampons avec contenu libre. +
^(4)^ Il s'agit de la date lorsque WeeChat ajoute la ligne dans le tampon
(supérieure ou égale à "_chat_line_date").

Informations additionnelles pour l'objet de barre "buffer_nicklist" :

[width="70%",cols="3m,3,8",options="header"]
|========================================
| Clé            | Extension ^(1)^ | Description
| nick           | core            | pseudonyme
| prefix         | core            | préfixe du pseudonyme
| group          | core            | nom du groupe
| irc_host       | irc             | nom d'hôte pour le pseudonyme (si connu)
|========================================

[NOTE]
^(1)^ Le nom de l'extension qui définit un hook_focus pour retourner des infos
pour cet objet de barre (donc par exemple si l'extension est "irc", ces infos
ne seront disponibles que sur les tampons irc).

Valeur de retour :

* pointeur vers le nouveau "hook", NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
struct t_hashtable *
my_focus_nicklist_cb (void *data, struct t_hashtable *info)
{
    /* ajout de chaînes dans la hashtable */
    /* ... */

    return info;
}

/* ajoute le focus sur la liste des pseudos */
struct t_hook *my_focus = weechat_hook_focus ("buffer_nicklist",
                                              &my_focus_nicklist_cb, NULL);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
hook = weechat.hook_focus(area, callback, callback_data)

# exemple
def my_focus_nicklist_cb(data, info):
    # construction du dict
    # ...
    return my_dict

hook = weechat.hook_focus("buffer_nicklist", "my_focus_nicklist_cb", "")
----------------------------------------

weechat_unhook
^^^^^^^^^^^^^^

Décroche quelque chose qui est a été accroché.

Prototype :

[source,C]
----------------------------------------
void weechat_unhook (struct t_hook *hook);
----------------------------------------

Paramètres :

* 'hook' : quelque chose d'accroché avec "weechat_hook_xxx()"

Exemple en C :

[source,C]
----------------------------------------
struct t_hook *my_hook = weechat_hook_command ( /* ... */ );
/* ... */
weechat_unhook (my_hook);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.unhook(hook)

# exemple
weechat.unhook(my_hook)
----------------------------------------

weechat_unhook_all
^^^^^^^^^^^^^^^^^^

Décroche tout ce qui a été accroché par l'extension courante.

Prototype :

[source,C]
----------------------------------------
void weechat_unhook_all ();
----------------------------------------

Exemple en C :

[source,C]
----------------------------------------
weechat_unhook_all ();
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.unhook_all()

# exemple
weechat.unhook_all()
----------------------------------------

[[buffers]]
Buffers
~~~~~~~

Fonctions pour créer/interroger/fermer les tampons.

weechat_buffer_new
^^^^^^^^^^^^^^^^^^

Ouvre un nouveau tampon.

Prototype :

[source,C]
----------------------------------------
struct t_gui_buffer *weechat_buffer_new (const char *name,
                                         int (*input_callback)(void *data,
                                                               struct t_gui_buffer *buffer,
                                                               const char *input_data),
                                         void *input_callback_data,
                                         int (*close_callback)(void *data,
                                                               struct t_gui_buffer *buffer),
                                         void *close_callback_data);
----------------------------------------

Paramètres :

* 'name' : nom du tampon (doit être unique pour l'extension)
* 'input_callback' : fonction appelée lorsque du texte saisi est envoyé au
  tampon, paramètres et valeur de retour :
** 'void *data' : pointeur
** 'struct t_gui_buffer *buffer' : pointeur vers le tampon
** 'const char *input_data' : données en entrée
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat
* 'close_callback' : fonction appelée lorsque le tampon est fermé, paramètres et
  valeur de retour :
** 'void *data' : pointeur
** 'struct t_gui_buffer *buffer' : pointeur vers le tampon
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouveau tampon, NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
int
my_input_cb (void *data, struct t_gui_buffer *buffer, const char *input_data)
{
    weechat_printf (buffer, "Texte : %s", input_data);
    return WEECHAT_RC_OK;
}

int
my_close_cb (void *data, struct t_gui_buffer *buffer)
{
    weechat_printf (NULL, "Le tampon '%s' va être fermé !",
                    weechat_buffer_get_string (buffer, "name"));
    return WEECHAT_RC_OK;
}

struct t_gui_buffer *my_buffer = weechat_buffer_new ("mon_buffer",
                                                     &my_input_cb, NULL,
                                                     &my_close_cb, NULL);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
buffer = weechat.buffer_new(name, input_callback, input_callback_data,
    close_callback, close_callback_data)

# exemple
def my_input_cb(data, buffer, input_data):
    weechat.prnt(buffer, "Texte : %s" % input_data)
    return weechat.WEECHAT_RC_OK

def my_close_cb(data, buffer):
    weechat.prnt("", "Le tampon '%s' va être fermé !" % weechat.buffer_get_string(buffer, "name"))
    return weechat.WEECHAT_RC_OK

buffer = weechat.buffer_new("mon_buffer", "my_input_cb", "", "my_close_cb", "")
----------------------------------------

weechat_current_buffer
^^^^^^^^^^^^^^^^^^^^^^

Retourne un pointeur vers le tampon courant (le tampon affiché par la fenêtre
courante).

Prototype :

[source,C]
----------------------------------------
struct t_gui_buffer *weechat_current_buffer ();
----------------------------------------

Valeur de retour :

* pointeur vers le tampon courant

Exemple en C :

[source,C]
----------------------------------------
weechat_printf (weechat_current_buffer (), "Texte sur le tampon courant");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
buffer = weechat.current_buffer()

# exemple
weechat.prnt(weechat.current_buffer(), "Texte sur le tampon courant")
----------------------------------------

weechat_buffer_search
^^^^^^^^^^^^^^^^^^^^^

Recherche un tampon par l'extension et/ou le nom.

Prototype :

[source,C]
----------------------------------------
struct t_gui_buffer *weechat_buffer_search (const char *plugin,
                                            const char *name);
----------------------------------------

Paramètres :

* 'plugin' : nom de l'extension
* 'name' : nom du tampon, si c'est NULL ou une chaîne vide, le tampon courant
  est retourné (tampon affiché par la fenêtre courante)

Valeur de retour :

* pointeur vers le tampon trouvé, NULL s'il n'a pas été trouvé

Exemple en C :

[source,C]
----------------------------------------
struct t_gui_buffer *my_buffer = weechat_buffer_search ("mon_extension",
                                                        "mon_tampon");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
buffer = weechat.buffer_search(plugin, name)

# exemple
buffer = weechat.buffer_search("mon_extension", "mon_tampon")
----------------------------------------

weechat_buffer_search_main
^^^^^^^^^^^^^^^^^^^^^^^^^^

Recherche le tampon principal de WeeChat (tampon 'core', premier tampon
affiché lorsque WeeChat démarre).

Prototype :

[source,C]
----------------------------------------
struct t_gui_buffer *weechat_buffer_search_main ();
----------------------------------------

Valeur de retour :

* pointeur vers le tampon principal WeeChat (tampon 'core')

Exemple en C :

[source,C]
----------------------------------------
struct t_gui_buffer *weechat_buffer = weechat_buffer_search_main ();
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
buffer = weechat.buffer_search_main()

# exemple
buffer = weechat.buffer_search_main()
----------------------------------------

weechat_buffer_clear
^^^^^^^^^^^^^^^^^^^^

Efface le contenu d'un tampon.

Prototype :

[source,C]
----------------------------------------
void weechat_buffer_clear (struct t_gui_buffer *buffer);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon

Exemple en C :

[source,C]
----------------------------------------
struct t_gui_buffer *my_buffer = weechat_buffer_search ("mon_extension",
                                                        "mon_tampon");
if (my_buffer)
{
    weechat_buffer_clear (my_buffer);
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.buffer_clear(buffer)

# exemple
buffer = weechat.buffer_search("mon_extension", "mon_tampon")
if buffer != "":
    weechat.buffer_clear(buffer)
----------------------------------------

weechat_buffer_close
^^^^^^^^^^^^^^^^^^^^

Ferme un tampon.

Prototype :

[source,C]
----------------------------------------
void weechat_buffer_close (struct t_gui_buffer *buffer);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon

Exemple en C :

[source,C]
----------------------------------------
struct t_gui_buffer *my_buffer = weechat_buffer_new ("mon_tampon",
                                                     &my_input_cb, NULL,
                                                     &my_close_cb, NULL);
/* ... */
weechat_buffer_close (my_buffer);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.buffer_close(buffer)

# exemple
buffer = weechat.buffer_new("mon_tampon", "my_input_cb", "", "my_close_cb", "")
# ...
weechat.buffer_close(buffer)
----------------------------------------

weechat_buffer_merge
^^^^^^^^^^^^^^^^^^^^

Mélange le tampon avec un autre tampon : les deux tampons continueront
d'exister chacun de leur côté, mais avec le même numéro, et WeeChat affichera
les lignes des deux tampons (lignes mélangées).

Prototype :

[source,C]
----------------------------------------
void weechat_buffer_merge (struct t_gui_buffer *buffer,
                           struct t_gui_buffer *target_buffer);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'target_buffer' : tampon cible avec lequel on doit mélanger

Exemple en C :

[source,C]
----------------------------------------
/* mélanger le tampon courant avec le tampon "core" */
weechat_buffer_merge (weechat_current_buffer (),
                      weechat_buffer_search_main ());
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.buffer_merge(buffer, target_buffer)

# exemple
# mélanger le tampon courant avec le tampon "core"
weechat.buffer_merge(weechat.current_buffer(), weechat.buffer_search_main())
----------------------------------------

weechat_buffer_unmerge
^^^^^^^^^^^^^^^^^^^^^^

Supprime le mélange d'un tampon.

Prototype :

[source,C]
----------------------------------------
void weechat_buffer_unmerge (struct t_gui_buffer *buffer,
                             int number);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'number' : numéro cible pour le tampon détaché, s'il est < 1, alors le tampon
  sera déplacé vers le numéro du tampon + 1

Exemple en C :

[source,C]
----------------------------------------
weechat_buffer_unmerge (weechat_current_buffer (), 1);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.buffer_unmerge(buffer, number)

# exemple
weechat.buffer_unmerge(weechat.current_buffer(), 1)
----------------------------------------

weechat_buffer_get_integer
^^^^^^^^^^^^^^^^^^^^^^^^^^

Retourne une valeur entière pour une propriété du tampon.

Prototype :

[source,C]
----------------------------------------
int weechat_buffer_get_integer (struct t_gui_buffer *buffer,
                                const char *property);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'property' : nom de la propriété :
** 'number' : numéro du tampon (commence à 1)
** 'layout_number' : numéro du tampon sauvegardé dans le "layout"
** 'layout_number_merge_order' : ordre du tampon mélangé pour le "layout"
** 'short_name_is_set' : 1 si le nom court est défini, 0 si non défini
** 'type' : type de tampon (0 : formaté, 1 : contenu libre)
** 'notify' : niveau de notification du tampon
** 'num_displayed' : nombre de fenêtres affichant ce tampon
** 'active' : 1 si le tampon est actif, 0 si le tampon est mélangé et n'est pas
   sélectionné
** 'print_hooks_enabled' : 1 si les hooks "print" sont activés, sinon 0
** 'lines_hidden' : 1 si au moins une ligne est cachée dans le tampon
   (filtrée), ou 0 si toutes les lignes sont affichées
** 'prefix_max_length' : longueur maximale du préfixe dans ce tampon
** 'time_for_each_line' : 1 si l'heure est affichée pour chaque ligne du tampon
   (par défaut), sinon 0
** 'nicklist' : 1 si la liste de pseudos est activée, sinon 0
** 'nicklist_case_sensitive' : 1 si les pseudos sont sensibles à la casse,
   sinon 0
** 'nicklist_max_length' : longueur maxi d'un pseudo
** 'nicklist_display_groups' : 1 si les groupes sont affichés, sinon 0
** 'nicklist_visible_count' : nombre de pseudos/groupes affichés
** 'input' : 1 si la zone de saisie est activée, sinon 0
** 'input_get_unknown_commands' : 1 si les commandes inconnues sont envoyées
   au "callback input", sinon 0
** 'input_size' : taille de la zone de saisie (en octets)
** 'input_length' : longueur de la zone de saisie (nombre de caractères)
** 'input_pos' : position du curseur dans la zone de saisie
** 'input_1st_display' : premier caractère affiché à l'écran
** 'num_history' : nombre de commandes dans l'historique
** 'text_search' : type de recherche de texte :
*** 0 : pas de recherche en cours
*** 1 : recherche arrière (vers les messages les plus anciens)
*** 2 : recherche avant (vers les messages les plus récents)
** 'text_search_exact' : 1 si la recherche de texte est sensible à la casse
** 'text_search_found' : 1 si du texte a été trouvé, sinon 0

Valeur de retour :

* valeur entière de la propriété

Exemple en C :

[source,C]
----------------------------------------
weechat_printf (NULL, "mon numéro de tampon est : %d",
                weechat_buffer_get_integer (mon_tampon, "number"));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.buffer_get_integer(buffer, property)

# exemple
weechat.prnt("", "mon numéro de tampon est : %d" % weechat.buffer_get_integer(my_buffer, "number"))
----------------------------------------

weechat_buffer_get_string
^^^^^^^^^^^^^^^^^^^^^^^^^

Retourne la valeur d'une propriété du tampon sous forme de chaîne.

Prototype :

[source,C]
----------------------------------------
const char *weechat_buffer_get_string (struct t_gui_buffer *buffer,
                                       const char *property);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'property' : nom de la propriété :
** 'plugin' : nom de l'extension qui a créé ce tampon ("core" pour le tampon
   principal WeeChat)
** 'name' : nom du tampon
** 'full_name' : nom complet du tampon ("extension.nom") (_nouveau dans la version 0.3.7_)
** 'short_name' : nom court du tampon (note: utilisé pour l'affichage seulement
   et peut être changé par l'utilisateur, il ne doit pas être utilisé pour
   trouver le nom du tampon, utlisez à la place 'name', 'full_name' ou bien la
   variable locale 'channel')
** 'title' : titre du tampon
** 'input' : texte saisi
** 'text_search_input' : texte saisi sauvegardé avant la recherche de texte
** 'highlight_words' : liste des mots pour le highlight
** 'highlight_regex' : expression régulière pour le highlight
** 'highlight_tags' : liste des étiquettes pour le highlight
** 'hotlist_max_level_nicks' : niveau maximum pour la hotlist pour certains
   pseudos
** 'localvar_xxx' : contenu de la variable locale "xxx" (remplacer "xxx" par le
   nom de la variable locale à lire)

Valeur de retour :

* valeur de la propriété, sous forme de chaîne

Exemple en C :

[source,C]
----------------------------------------
weechat_printf (NULL, "nom / nom court du tampon sont : %s / %s",
                weechat_buffer_get_string (my_buffer, "name"),
                weechat_buffer_get_string (my_buffer, "short_name"));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.buffer_get_string(buffer, property)

# exemple
weechat.prnt("", "nom / nom court du tampon sont : %s / %s"
    % (weechat.buffer_get_string(my_buffer, "name"),
    weechat.buffer_get_string(my_buffer, "short_name")))
----------------------------------------

weechat_buffer_get_pointer
^^^^^^^^^^^^^^^^^^^^^^^^^^

Retourne la valeur d'une propriété sous forme d'un pointeur.

Prototype :

[source,C]
----------------------------------------
void *weechat_buffer_pointer (struct t_gui_buffer *buffer,
                              const char *property);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'property' : nom de la propriété :
** 'plugin' : pointeur vers l'extension qui a créé le tampon (NULL pour le
   tampon principal WeeChat)
** 'highlight_regex_compiled' : expression régulière 'highlight_regex' compilée

Valeur de retour :

* valeur de la propriété, sous forme de pointeur

Exemple en C :

[source,C]
----------------------------------------
weechat_printf (NULL, "pointeur vers l'extension de mon tampon : %lx",
                weechat_buffer_get_pointer (mon_tampon, "plugin"));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.buffer_get_pointer(buffer, property)

# exemple
weechat.prnt("", "pointeur vers l'extension de mon tampon : %s" % weechat.buffer_get_pointer(my_buffer, "plugin"))
----------------------------------------

weechat_buffer_set
^^^^^^^^^^^^^^^^^^

Affecte une valeur à une propriété d'un tampon.

Prototype :

[source,C]
----------------------------------------
void weechat_buffer_set (struct t_gui_buffer *buffer, const char *property,
                         const char *value);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'property' et 'value' : nom de la propriété, avec sa valeur :

[width="100%",cols="^2,4,8",options="header"]
|========================================
| Nom | Valeur | Description

| hotlist | "+", "-", WEECHAT_HOTLIST_LOW, WEECHAT_HOTLIST_MESSAGE,
  WEECHAT_HOTLIST_PRIVATE, WEECHAT_HOTLIST_HIGHLIGHT |
  "+" : active la hotlist (option globale, le pointeur vers le tampon n'est pas
  utilisé) +
  "-" : désactive la hotlist (option globale, le pointeur vers le tampon n'est
  pas utilisé) +
  priorité : ajouter ce tampon dans la hotlist avec cette priorité

| unread | - |
  définit le marqueur de données non lues après la dernière ligne du tampon

| display | "1", "auto" |
  "1" : basculer vers ce tampon dans la fenêtre active +
  "auto" : basculer vers ce tampon dans la fenêtre active, le marqueur de
  données non lues n'est pas réinitialisé

| number | numéro |
  déplace le tampon vers ce numéro

| name | toute chaîne |
  change le nom du tampon

| short_name | toute chaîne |
  change le nom court du tampon

| type | "formatted" ou "free" |
  définit le type de tampon : "formatted" (pour afficher les messages d'une
  discussion), ou "free" (pour du contenu libre)

| notify | "0", "1", "2", "3" |
  définit le niveau de notification du tampon : "0" = ne jamais ajouter à la
  hotlist, "1" = ajouter pour les highlights seulement, "2" = ajouter pour les
  highlights et les messages, "3" = ajouter pour tous les messages

| title | toute chaîne |
  change le titre du tampon

| time_for_each_line | "0" ou "1" |
  "0" pour cacher l'heure sur toutes les lignes du tampon, "1" pour afficher
  l'heure sur toutes les lignes (par défaut pour un nouveau tampon)

| nicklist | "0" ou "1" |
  "0" pour supprimer la liste des pseudos du tampon, "1" pour ajouter la liste
  des pseudos du tampon

| nicklist_case_sensitive | "0" ou "1" |
  "0" pour avoir la liste des pseudos insensible à la casse, "1" pour avoir
  la liste des pseudos sensible à la casse

| nicklist_display_groups | "0" ou "1" |
  "0" pour cacher les groupes de la liste des pseudos, "1" pour afficher les
  groupes de la liste des pseudos

| highlight_words | "-" ou une liste de mots séparés par des virgules |
  "-" est une valeur spécials pour désactiver tout highlight sur ce tampon, ou
  une liste de mots à mettre en valeur dans ce tampon, par exemple :
  "abc,def,ghi"

| highlight_words_add | liste de mots séparés par des virgules |
  liste de mots à mettre en valeur dans ce tampon, ces mots sont ajoutés aux
  mots existants pour le tampon

| highlight_words_del | liste de mots séparés par des virgules |
  liste de mots à supprimer de la liste des mots à mettre en valeur dans ce
  tampon

| highlight_regex | toute chaîne |
  expression régulière pour le highlight

| highlight_tags | liste d'étiquettes ("tags") séparées par des virgules |
  liste d'étiquettes ("tags") à mettre en valeur pour ce tampon

| hotlist_max_level_nicks | liste de "pseudo:niveau" séparés par des virgules |
  liste de pseudos avec niveau max pour la hotlist sur ce tampon (le niveau peut
  être : -1: jamais dans la hotlist, 0: faible, 1: message, 2: privé,
  3: highlight), par exemple : "joe:2,mike:-1,robert:-1" (joe ne produira
  jamais de highlight sur le tampon, mike et robert ne changeront jamais la
  hotlist)

| hotlist_max_level_nicks_add | liste de "pseudo:niveau" séparés par des virgules" |
  liste de pseudos avec niveau pour la hotlist, ces pseudos sont ajoutés aux
  pseudos existant dans le tampon

| hotlist_max_level_nicks_del | liste de pseudos séparés par des virgules |
  liste de pseudos à supprimer des niveaux max de hotlist

| key_bind_xxx | toute chaîne |
  associe la nouvelle touche 'xxx', spécifique à ce tampon, la valeur est la
  commande à exécuter pour cette touche

| key_unbind_xxx | - |
  supprime la touche 'xxx' pour ce tampon

| input | toute chaîne |
  change le contenu de la zone de saisie

| input_pos | position |
  change la position du curseur dans la zone de saisie

| input_get_unknown_commands | "0" ou "1" |
  "0" pour désactiver les commandes inconnues sur ce tampon (comportement par
  défaut), "1" pour recevoir les commandes inconnues, par exemple si
  l'utilisateur tape "/commandeinconnue", le tampon le recevra (pas d'erreur
  sur la commande inconnue)

| localvar_set_xxx | toute chaîne |
  change la valeur de la variable locale 'xxx' (la variable est créée si elle
  n'existe pas)

| localvar_del_xxx | - |
  supprime la variable locale 'xxx'
|========================================

Exemple en C :

[source,C]
----------------------------------------
/* désactiver la hotlist (pour tous les tampons) */
weechat_buffer_set (NULL, "hotlist", "-");

/* activer à nouveaula hotlist */
weechat_buffer_set (NULL, "hotlist", "+");

/* changer le nom du tampon */
weechat_buffer_set (mon_tampon, "name", "nouveau_nom");

/* ajouter une variable locale "toto" avec la valeur "abc" */
weechat_buffer_set (mon_tampon, "localvar_set_toto", "abc");

/* supprimer la variable locale "toto" */
weechat_buffer_set (mon_tampon, "localvar_del_toto", NULL);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.buffer_set(buffer, property, value)

# exemples

# désactiver la hotlist (pour tous les tampons)
weechat.buffer_set("", "hotlist", "-")

# activer à nouveau la hotlist
weechat.buffer_set("", "hotlist", "+")

# changer le nom du tampon
weechat.buffer_set(my_buffer, "name", "my_new_name")

# ajouter une variable locale "toto" avec la valeur "abc"
weechat.buffer_set(my_buffer, "localvar_set_toto", "abc")

# supprimer la variable locale "toto"
weechat.buffer_set(my_buffer, "localvar_del_toto", "")
----------------------------------------

weechat_buffer_set_pointer
^^^^^^^^^^^^^^^^^^^^^^^^^^

Affecte un pointeur à une propriété d'un tampon.

Prototype :

[source,C]
----------------------------------------
void weechat_buffer_set_pointer (struct t_gui_buffer *buffer, const char *property,
                                 void *pointer);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'property' et 'value' : nom de la propriété, avec sa valeur :
** 'close_callback' : définit la fonction "callback" de fermeture du tampon
** 'close_callback_data' : définit les données pour le "callback" de fermeture
   du tampon
** 'input_callback' : définit la fonction de "callback" pour les données en
   entrée
** 'input_callback_data' : définit les données pour le "callback" des données
   en entrée
** 'nickcmp_callback' : définit la fonction "callback" de comparaison de pseudos
   (ce "callback" est appelé lors de la recherche d'un pseudo dans la liste des
   pseudos) (_nouveau dans la version 0.3.9_)
** 'nickcmp_callback_data': définit les données pour le "callback" de
   comparaison de pseudos (_nouveau dans la version 0.3.9_)

Prototypes pour les "callbacks" :

[source,C]
----------------------------------------
int close_callback (void *data, struct t_gui_buffer *buffer);

int input_callback (void *data, struct t_gui_buffer *buffer, const char *input_data);

int nickcmp_callback (void *data, struct t_gui_buffer *buffer, const char *nick1, const char *nick2);
----------------------------------------

Exemple en C :

[source,C]
----------------------------------------
int
my_close_cb (void *data, struct t_gui_buffer *buffer)
{
    /* ... */
    return WEECHAT_RC_OK;
}

weechat_buffer_set_pointer (mon_tampon, "close_callback", &my_close_cb);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_buffer_string_replace_local_var
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Remplace les variables locales dans une chaîne par leurs valeurs, en utilisant
les variables locales du tampon.

Prototype :

[source,C]
----------------------------------------
char *weechat_buffer_string_replace_local_var (struct t_gui_buffer *buffer,
                                               const char *string);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'string' : chaîne avec du texte et des variables locales, au format "$var"

Valeur de retour :

* chaîne avec les valeurs des variables locales

Exemple en C :

[source,C]
----------------------------------------
weechat_buffer_set (mon_tampon, "localvar_set_toto", "abc");

char *str = weechat_buffer_string_replace_local_var (mon_tampon,
                                                     "test avec $toto");
/* str contient "test avec abc" */
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.buffer_string_replace_local_var(buffer, string)

# exemple
weechat.buffer_set(my_buffer, "localvar_set_toto", "abc")
str = weechat.buffer_string_replace_local_var(my_buffer, "test avec $toto")
# str contient "test avec abc"
----------------------------------------

weechat_buffer_match_list
^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.5._

Vérifie si le tampon correspond à la liste de tampons.

Prototype :

[source,C]
----------------------------------------
int weechat_buffer_match_list (struct t_gui_buffer *buffer, const char *string);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'string' : liste de tampons, séparés par des virgules :
** "*" signigie tous les tampons
** un nom commençant par "!" est exclu
** un nom peut commencer ou se terminer par "*" pour correspondre à plusieurs
   tampons

Valeur de retour :

* 1 si le tampon correspond à la liste de tampons, 0 sinon

Exemple en C :

[source,C]
----------------------------------------
struct t_gui_buffer *buffer = weechat_buffer_search ("irc", "freenode.#weechat");
if (buffer)
{
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "*"));                   /* 1 */
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "*,!*#weechat*"));       /* 0 */
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "irc.freenode.*"));      /* 1 */
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "irc.oftc.*,python.*")); /* 0 */
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
match = weechat.buffer_match_list(buffer, string)

# exemple
buffer = weechat.buffer_search("irc", "freenode.#weechat")
if buffer:
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "*"))                   # 1
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "*,!*#weechat*"))       # 0
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "irc.freenode.*"))      # 1
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "irc.oftc.*,python.*")) # 0
----------------------------------------

[[windows]]
Fenêtres
~~~~~~~~

Fonctions pour interroger les fenêtres.

weechat_current_window
^^^^^^^^^^^^^^^^^^^^^^

Retourne le pointeur vers la fenêtre courante.

Prototype :

[source,C]
----------------------------------------
struct t_gui_window *weechat_current_window ();
----------------------------------------

Valeur de retour :

* pointeur vers la fenêtre courante

Exemple en C :

[source,C]
----------------------------------------
struct t_gui_window *current_window = weechat_current_window ();
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
window = weechat.current_window()

# exemple
current_window = weechat.current_window()
----------------------------------------

weechat_window_search_with_buffer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.5._

Retourne le pointeur vers la fenêtre affichant un tampon.

Prototype :

[source,C]
----------------------------------------
struct t_gui_window *weechat_window_search_with_buffer (struct t_gui_buffer *buffer);
----------------------------------------

Paramètre :

* 'buffer' : pointeur vers le tampon

Valeur de retour :

* pointeur vers la fenêtre affichant un tampon (NULL si aucune fenêtre n'affiche
  ce tampon)

Exemple en C :

[source,C]
----------------------------------------
weechat_printf (NULL,
                "fenêtre affichant le tampon core: %lx",
                weechat_window_search_with_buffer (weechat_buffer_search_main ()));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
window = weechat.window_search_with_buffer(buffer)

# exemple
weechat.prnt("", "fenêtre affichant le tampon core: %s"
    % weechat.window_search_with_buffer(weechat.buffer_search_main()))
----------------------------------------

weechat_window_get_integer
^^^^^^^^^^^^^^^^^^^^^^^^^^

Retourne la valeur entière d'une propriété de la fenêtre.

Prototype :

[source,C]
----------------------------------------
int weechat_window_get_integer (struct t_gui_window *window,
                                const char *property);
----------------------------------------

Paramètres :

* 'window' : pointeur vers la fenêtre
* 'property' : nom de la propriété :
** 'number' : numéro de la fenêtre (commence à 1)
** 'win_x' : position X de la fenêtre dans le terminal (la première colonne est
   0)
** 'win_y' : position Y de la fenêtre dans le terminal (la première ligne est
   0)
** 'win_width' : largeur de la fenêtre, en caractères
** 'win_height' : hauteur de la fenêtre, en caractères
** 'win_width_pct' : taille en pourcentage, en comparaison avec la fenêtre
   parente (par exemple 50 indique une largeur de moitié)
** 'win_height_pct' : taille en pourcentage, en comparaison avec la fenêtre
   parente (par exemple 50 indique une hauteur de moitié)
** 'win_chat_x' : position X de la fenêtre de discussion ("chat") dans le
   terminal (la première colonne est 0)
** 'win_chat_y' : position Y de la fenêtre de discussion ("chat") dans le
   terminal (la première ligne est 0)
** 'win_chat_width' : largeur de la fenêtre de discussion ("chat"), en
   caractères
** 'win_chat_height' : hauteur de la fenêtre de discussion ("chat"), en
   caractères
** 'first_line_displayed' : 1 si la première du tampon est affichée à l'écran,
   sinon 0
** 'scrolling' : 1 s'il y a un défilement en cours dans la fenêtre (la dernière
   ligne n'est pas affichée)
** 'lines_after' : nombre de lignes non affichées après la dernière ligne
   affichée (lors d'un défilement)

Valeur de retour :

* valeur entière de la propriété

Exemple en C :

[source,C]
----------------------------------------
weechat_printf (NULL, "la fenêtre courante est en position (x,y) : (%d,%d)",
                weechat_window_get_integer (weechat_current_window (), "win_x"),
                weechat_window_get_integer (weechat_current_window (), "win_y"));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.window_get_integer(window, property)

# exemple
weechat.prnt("", "la fenêtre courante est en position (x,y) : (%d,%d)"
    % (weechat.window_get_integer(weechat.current_window(), "win_x"),
    weechat.window_get_integer(weechat.current_window(), "win_y")))
----------------------------------------

weechat_window_get_string
^^^^^^^^^^^^^^^^^^^^^^^^^

Retourne la valeur d'une propriété de la fenêtre sous forme d'une chaîne.

[NOTE]
Cette fonction n'est pas utilisée aujourd'hui, elle est réservée pour une
version future.

Prototype :

[source,C]
----------------------------------------
int weechat_window_get_string (struct t_gui_window *window,
                               const char *property);
----------------------------------------

Paramètres :

* 'window' : pointeur vers la fenêtre
* 'property' : nom de la propriété

Valeur de retour :

* valeur de la propriété, sous forme de chaîne

weechat_window_get_pointer
^^^^^^^^^^^^^^^^^^^^^^^^^^

Retourne la valeur d'une propriété, sous forme d'un pointeur.

Prototype :

[source,C]
----------------------------------------
void *weechat_window_get_pointer (struct t_gui_window *window,
                                  const char *property);
----------------------------------------

Paramètres :

* 'window' : pointeur vers la fenêtre
* 'property' : nom de la propriété :
** 'current' : pointeur vers la fenêtre courante
** 'buffer' : pointeur vers le tampon affiché par la fenêtre

Valeur de retour :

* valeur de la propriété, sous forme de pointeur

Exemple en C :

[source,C]
----------------------------------------
weechat_printf (NULL,
                "tampon affiché dans la fenêtre courante : %lx",
                weechat_window_get_pointer (weechat_current_window (), "buffer"));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.window_get_pointer(window, property)

# exemple
weechat.prnt("", "tampon affiché dans la fenêtre courante : %s"
    % weechat.window_get_pointer(weechat.current_window(), "buffer"))
----------------------------------------

weechat_window_set_title
^^^^^^^^^^^^^^^^^^^^^^^^

Définit le titre du terminal.

Prototype :

[source,C]
----------------------------------------
void weechat_window_set_title (const char *title);
----------------------------------------

Paramètres :

* 'title' : nouveau titre pour le terminal (NULL pour réinitialiser le titre)

Exemple en C :

[source,C]
----------------------------------------
weechat_window_set_title ("nouveau titre ici");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.window_set_title(window, title)

# exemple
weechat.window_set_title("nouveau titre ici")
----------------------------------------

[[nicklist]]
Nicklist
~~~~~~~~

Fonctions pour la liste des pseudos.

weechat_nicklist_add_group
^^^^^^^^^^^^^^^^^^^^^^^^^^

Ajoute un groupe dans la liste des pseudos.

Prototype :

[source,C]
----------------------------------------
struct t_gui_nick_group *weechat_nicklist_add_group (struct t_gui_buffer *buffer,
                                                     struct t_gui_nick_group *parent_group,
                                                     const char *name,
                                                     const char *color,
                                                     int visible);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'parent_group' : pointeur vers le parent du groupe, NULL si le groupe n'a pas
  de parent (racine de la liste des pseudos)
* 'name' : nom du groupe
* 'color' : nom de l'option contenant la couleur :
** une option WeeChat, par exemple 'weechat.color.nicklist_group'
** une couleur avec un fond optionnel, par exemple 'yellow' ou 'yellow,red'
** nom d'une couleur de barre :
*** 'bar_fg' : couleur de texte pour la barre
*** 'bar_delim' : couleur des délimiteurs pour la barre
*** 'bar_bg' : couleur de fond pour la barre
* 'visible' :
** '1' : le groupe et ses sous-groupes/pseudos sont visibles
** '0' : le groupe et ses sous-groupes/pseudos sont cachés

[NOTE]
Le nom du groupe peut commencer par un ou plusieurs chiffres, suivis d'un pipe
("|"), puis du nom du groupe. Quand une telle chaîne est trouvée au début, elle
est utilisée pour trier les groupes dans la liste des pseudos. Par exemple les
groupes "1|test" et "2|abc" seront affichés dans cet ordre : "test" en premier,
puis "abc" en second.

Valeur de retour :

* pointeur vers le nouveau groupe, NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
struct t_gui_nick_group *my_group =
    weechat_nicklist_add_group (my_buffer,
                                my_parent_group,
                                "groupe_test",
                                "weechat.color.nicklist_group",
                                1);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
group = weechat.nicklist_add_group(buffer, parent_group, name, color, visible)

# exemple
group = weechat.nicklist_add_group(my_buffer, my_parent_group, "groupe_test",
    "weechat.color.nicklist_group", 1)
----------------------------------------

weechat_nicklist_search_group
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Recherche un groupe dans la liste des pseudos.

Prototype :

[source,C]
----------------------------------------
struct t_gui_nick_group *weechat_nicklist_search_group (struct t_gui_buffer *buffer,
                                                        struct t_gui_nick_group *from_group,
                                                        const char *name);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'from_group' : recherche depuis ce groupe seulement, si NULL, alors recherche
  dans toute la liste des pseudos
* 'name' : nom du groupes à rechercher

Valeur de retour :

* pointeur vers le groupe trouvé, NULL s'il n'est pas trouvé

Exemple en C :

[source,C]
----------------------------------------
struct t_gui_nick_group *ptr_group = weechat_nicklist_search_group (my_buffer,
                                                                    NULL, "groupe_test");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
group = weechat.nicklist_search_group(buffer, from_group, name)

# exemple
group = weechat.nicklist_search_group(my_buffer, "", "groupe_test")
----------------------------------------

weechat_nicklist_add_nick
^^^^^^^^^^^^^^^^^^^^^^^^^

Ajoute un pseudo dans un groupe.

Prototype :

[source,C]
----------------------------------------
struct t_gui_nick_group *weechat_nicklist_add_nick (struct t_gui_buffer *buffer,
                                                    struct t_gui_nick_group *group,
                                                    const char *name,
                                                    const char *color,
                                                    const char *prefix,
                                                    const char *prefix_color,
                                                    int visible);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'group' : pointeur vers le groupe
* 'name' : nom du pseudo
* 'color' : nom de l'option contenant la couleur pour le pseudo :
** une option WeeChat, par exemple 'weechat.color.nicklist_group'
** une couleur avec un fond optionnel, par exemple 'yellow' ou 'yellow,red'
** nom d'une couleur de barre :
*** 'bar_fg' : couleur de texte pour la barre
*** 'bar_delim' : couleur des délimiteurs pour la barre
*** 'bar_bg' : couleur de fond pour la barre
* 'prefix' : préfixe affiché avant le pseudo
* 'prefix_color' : nom de l'option contenant la couleur pour le préfixe :
** une option WeeChat, par exemple 'weechat.color.nicklist_group'
** une couleur avec un fond optionnel, par exemple 'yellow' ou 'yellow,red'
** nom d'une couleur de barre :
*** 'bar_fg' : couleur de texte pour la barre
*** 'bar_delim' : couleur des délimiteurs pour la barre
*** 'bar_bg' : couleur de fond pour la barre
* 'visible' :
** '1' : le pseudo est visible
** '0' : le pseudo est caché

Valeur de retour :

* pointeur vers le nouveau pseudo, NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
struct t_gui_nick *my_nick =
    weechat_nicklist_add_nick (my_buffer, my_group,
                               "test_nick",
                               (nick_away) ? "weechat.color.nicklist_away" : "bar_fg",
                               "@", "lightgreen",
                               1);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
nick = weechat.nicklist_add_nick(buffer, group, name, color, prefix, prefix_color, visible)

# exemple
if nick_away:
    color = "weechat.color.nicklist_away"
else:
    color = "bar_fg"
nick = weechat.nicklist_add_nick(my_buffer, my_group, "test_nick", color, "@", "lightgreen", 1)
----------------------------------------

weechat_nicklist_search_nick
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Recherche un pseudo dans la liste des pseudos.

Prototype :

[source,C]
----------------------------------------
struct t_gui_nick *weechat_nicklist_search_nick (struct t_gui_buffer *buffer,
                                                 struct t_gui_nick_group *from_group,
                                                 const char *name);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'from_group' : recherche depuis ce groupe seulement, si NULL, alors recherche
  dans toute la liste des pseudos
* 'name' : nom du pseudo à rechercher

Valeur de retour :

* pointeur vers le pseudo trouvé, NULL s'il n'est pas trouvé

Exemple en C :

[source,C]
----------------------------------------
struct t_gui_nick *ptr_nick = weechat_nicklist_search_nick (my_buffer,
                                                            NULL, "test_nick");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
nick = weechat.nicklist_search_nick(buffer, from_group, name)

# exemple
nick = weechat.nicklist_search_nick(my_buffer, "", "test_nick")
----------------------------------------

weechat_nicklist_remove_group
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Supprime un groupe de la liste des pseudos.

Prototype :

[source,C]
----------------------------------------
void weechat_nicklist_remove_group (struct t_gui_buffer *buffer,
                                    struct t_gui_nick_group *group);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'group' : pointeur vers le groupe à supprimer (tous les sous-groupes/pseudos
  seront supprimés également)

Exemple en C :

[source,C]
----------------------------------------
weechat_nicklist_remove_group (my_buffer, my_group);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.nicklist_remove_group(buffer, group)

# exemple
weechat.nicklist_remove_group(my_buffer, my_group)
----------------------------------------

weechat_nicklist_remove_nick
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Supprime un pseudo de la liste des pseudos.

Prototype :

[source,C]
----------------------------------------
void weechat_nicklist_remove_nick (struct t_gui_buffer *buffer,
                                   struct t_gui_nick *nick);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'nick' : pointeur vers le pseudo à supprimer

Exemple en C :

[source,C]
----------------------------------------
weechat_nicklist_remove_nick (my_buffer, my_nick);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.nicklist_remove_nick(buffer, nick)

# exemple
weechat.nicklist_remove_nick(my_buffer, my_nick)
----------------------------------------

weechat_nicklist_remove_all
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Supprime tous les groupes/pseudos de la liste des pseudos.

Prototype :

[source,C]
----------------------------------------
void weechat_nicklist_remove_all (struct t_gui_buffer *buffer);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon

Exemple en C :

[source,C]
----------------------------------------
weechat_nicklist_remove_all (my_buffer);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.nicklist_remove_all(buffer)

# exemple
weechat.nicklist_remove_all(my_buffer)
----------------------------------------

weechat_nicklist_get_next_item
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.7._

Retourne le prochain groupe ou pseudo de la liste des pseudos (utilisé
principalement pour afficher la liste des pseudos).

Prototype :

[source,C]
----------------------------------------
void gui_nicklist_get_next_item (struct t_gui_buffer *buffer,
                                 struct t_gui_nick_group **group,
                                 struct t_gui_nick **nick);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'group' : pointeur vers un pointeur sur le groupe
* 'nick' : pointeur vers un pointeur sur le pseudo

Exemple en C :

[source,C]
----------------------------------------
struct t_gui_nick_group *ptr_group;
struct t_gui_nick *ptr_nick;

ptr_group = NULL;
ptr_nick = NULL;
gui_nicklist_get_next_item (buffer, &ptr_group, &ptr_nick);
while (ptr_group || ptr_nick)
{
    if (ptr_nick)
    {
        /* pseudo */
        /* ... */
    }
    else
    {
        /* groupe */
        /* ... */
    }
    gui_nicklist_get_next_item (buffer, &ptr_group, &ptr_nick);
}
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_nicklist_group_get_integer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.4._

Retourne une valeur entière pour une propriété du groupe.

Prototype :

[source,C]
----------------------------------------
int weechat_nicklist_group_get_integer (struct t_gui_buffer *buffer,
                                        struct t_gui_nick_group *group,
                                        const char *property);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'group' : pointeur vers le groupe
* 'property' : nom de la propriété :
** 'visible' : 1 si le groupe est visible, sinon 0
** 'level' : niveau du groupe (la racine est 0)

Valeur de retour :

* valeur entière de la propriété

Exemple en C :

[source,C]
----------------------------------------
int visible = weechat_nicklist_group_get_integer (buffer, group, "visible");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.nicklist_group_get_integer(buffer, group, property)

# exemple
visible = weechat.nicklist_group_get_integer(buffer, group, "visible")
----------------------------------------

weechat_nicklist_group_get_string
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.4._

Retourne la valeur d'une propriété du groupe sous forme de chaîne.

Prototype :

[source,C]
----------------------------------------
const char *weechat_nicklist_group_get_string (struct t_gui_buffer *buffer,
                                               struct t_gui_nick_group *group,
                                               const char *property);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'group' : pointeur vers le groupe
* 'property' : nom de la propriété :
** 'name' : nom du groupe
** 'color' : couleur du groupe dans la liste des pseudos

Valeur de retour :

* valeur de la propriété, sous forme de chaîne

Exemple en C :

[source,C]
----------------------------------------
const char *color = weechat_nicklist_group_get_string (buffer, group, "color");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.nicklist_group_get_string(buffer, group, property)

# exemple
color = weechat.nicklist_group_get_string(buffer, group, "color")
----------------------------------------

weechat_nicklist_group_get_pointer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.4._

Retourne la valeur d'une propriété du groupe sous forme d'un pointeur.

Prototype :

[source,C]
----------------------------------------
void *weechat_nicklist_group_get_pointer (struct t_gui_buffer *buffer,
                                          struct t_gui_nick_group *group,
                                          const char *property);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'group' : pointeur vers le groupe
* 'property' : nom de la propriété :
** 'parent' : pointeur vers le groupe parent

Valeur de retour :

* valeur de la propriété, sous forme de pointeur

Exemple en C :

[source,C]
----------------------------------------
struct t_gui_nick_group *parent = weechat_nicklist_group_get_pointer (buffer, group, "parent");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.nicklist_group_get_pointer(buffer, group, property)

# exemple
parent = weechat.nicklist_group_get_pointer(buffer, group, "parent")
----------------------------------------

weechat_nicklist_group_set
^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.4._

Affecte une valeur à une propriété d'un groupe.

Prototype :

[source,C]
----------------------------------------
void weechat_nicklist_group_set (struct t_gui_buffer *buffer,
                                 struct t_gui_nick_group *group,
                                 const char *property,
                                 const char *value);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'group' : pointeur vers le groupe
* 'property' et 'value' : nom de la propriété, avec sa valeur :

[width="100%",cols="^2,4,8",options="header"]
|========================================
| Nom | Valeur | Description

| color | nom d'option de couleur WeeChat |
  voir le paramètre "color" de la fonction
  <<_weechat_nicklist_add_group,weechat_nicklist_add_group>>

| visible | "0", "1" |
  "0" = groupe caché, "1" = groupe visible
|========================================

Exemples en C :

[source,C]
----------------------------------------
/* changer la couleur du groupe en "bar_fg" */
weechat_nicklist_group_set (buffer, group, "color", "bar_fg");

/* changer la couleur du groupe en jaune */
weechat_nicklist_group_set (buffer, group, "color", "yellow");

/* cacher le groupe dans la liste des pseudos */
weechat_nicklist_group_set (buffer, group, "visible", "0");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.nicklist_group_set(buffer, group, property, value)

# exemples

# changer la couleur du groupe en "bar_fg"
weechat.nicklist_group_set(buffer, group, "color", "bar_fg")

# changer la couleur du groupe en jaune
weechat.nicklist_group_set(buffer, group, "color", "yellow")

# cacher le groupe dans la liste des pseudos
weechat.nicklist_group_set(buffer, group, "visible", "0")
----------------------------------------

weechat_nicklist_nick_get_integer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.4._

Retourne une valeur entière pour une propriété du pseudo.

Prototype :

[source,C]
----------------------------------------
int weechat_nicklist_nick_get_integer (struct t_gui_buffer *buffer,
                                       struct t_gui_nick *nick,
                                       const char *property);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'nick' : pointeur vers le pseudo
* 'property' : nom de la propriété :
** 'visible' : 1 si le pseudo est visible, sinon 0

Valeur de retour :

* valeur entière de la propriété

Exemple en C :

[source,C]
----------------------------------------
int visible = weechat_nicklist_nick_get_integer (buffer, nick, "visible");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.nicklist_nick_get_integer(buffer, nick, property)

# exemple
visible = weechat.nicklist_nick_get_integer(buffer, nick, "visible")
----------------------------------------

weechat_nicklist_nick_get_string
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.4._

Retourne la valeur d'une propriété du pseudo sous forme de chaîne.

Prototype :

[source,C]
----------------------------------------
const char *weechat_nicklist_nick_get_string (struct t_gui_buffer *buffer,
                                              struct t_gui_nick *nick,
                                              const char *property);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'nick' : pointeur vers le pseudo
* 'property' : nom de la propriété :
** 'name' : nom du pseudo
** 'color' : couleur du pseudo dans la liste des pseudos
** 'prefix' : préfixe du pseudo
** 'prefix_color' : couleur du préfixe dans la liste des pseudos

Valeur de retour :

* valeur de la propriété, sous forme de chaîne

Exemple en C :

[source,C]
----------------------------------------
const char *color = weechat_nicklist_nick_get_string (buffer, nick, "color");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.nicklist_nick_get_string(buffer, nick, property)

# exemple
color = weechat.nicklist_nick_get_string(buffer, nick, "color")
----------------------------------------

weechat_nicklist_nick_get_pointer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.4._

Retourne la valeur d'une propriété du pseudo sous forme d'un pointeur.

Prototype :

[source,C]
----------------------------------------
void *weechat_nicklist_nick_get_pointer (struct t_gui_buffer *buffer,
                                         struct t_gui_nick *nick,
                                         const char *property);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'nick' : pointeur vers le pseudo
* 'property' : nom de la propriété :
** 'group' : pointeur vers le groupe contenant ce pseudo

Valeur de retour :

* valeur de la propriété, sous forme de pointeur

Exemple en C :

[source,C]
----------------------------------------
struct t_gui_nick_group *group = weechat_nicklist_nick_get_pointer (buffer, nick, "group");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.nicklist_nick_get_pointer(buffer, nick, property)

# exemple
group = weechat.nicklist_nick_get_pointer(buffer, nick, "group")
----------------------------------------

weechat_nicklist_nick_set
^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.4._

Affecte une valeur à une propriété d'un pseudo.

Prototype :

[source,C]
----------------------------------------
void weechat_nicklist_nick_set (struct t_gui_buffer *buffer,
                                struct t_gui_nick *nick,
                                const char *property,
                                const char *value);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon
* 'nick' : pointeur vers le pseudo
* 'property' et 'value' : nom de la propriété, avec sa valeur :

[width="100%",cols="^2,4,8",options="header"]
|========================================
| Nom | Valeur | Description

| color | nom d'option de couleur WeeChat |
  voir le paramètre "color" de la fonction
  <<_weechat_nicklist_add_nick,weechat_nicklist_add_nick>>

| prefix | toute chaîne |
  préfixe du pseudo

| prefix_color | nom d'option de couleur WeeChat |
  voir le paramètre "prefix_color" de la fonction
  <<_weechat_nicklist_add_nick,weechat_nicklist_add_nick>>

| visible | "0", "1" |
  "0" = pseudo caché, "1" = pseudo visible
|========================================

Exemples en C :

[source,C]
----------------------------------------
/* changer la couleur du pseudo en cyan */
weechat_nicklist_nick_set (buffer, nick, "color", "cyan");

/* changer le préfixe en "+" */
weechat_nicklist_nick_set (buffer, nick, "prefix", "+");

/* changer la couleur du préfixe en jaune */
weechat_nicklist_nick_set (buffer, nick, "prefix_color", "yellow");

/* cacher le pseudo dans la liste des pseudos */
weechat_nicklist_nick_set (buffer, nick, "visible", "0");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.nicklist_nick_set(buffer, nick, property, value)

# exemples

# changer la couleur du pseudo en cyan
weechat.nicklist_nick_set(buffer, nick, "color", "cyan")

# changer le préfixe en "+"
weechat.nicklist_nick_set(buffer, nick, "prefix", "+")

# changer la couleur du préfixe en jaune
weechat.nicklist_nick_set(buffer, nick, "prefix_color", "yellow")

# cacher le pseudo dans la liste des pseudos
weechat.nicklist_nick_set(buffer, nick, "visible", "0")
----------------------------------------

[[bars]]
Barres
~~~~~~

Fonctions pour les barres.

weechat_bar_item_search
^^^^^^^^^^^^^^^^^^^^^^^

Recherche un objet de barre.

Prototype :

[source,C]
----------------------------------------
struct t_gui_bar_item *weechat_bar_item_search (const char *name);
----------------------------------------

Paramètres :

* 'name' : nom de l'objet de barre

Valeur de retour :

* pointeur vers l'objet de barre trouvé, NULL s'il n'a pas été trouvé

Exemple en C :

[source,C]
----------------------------------------
struct t_gui_bar_item *bar_item = weechat_bar_item_search ("myitem");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
bar_item = weechat.bar_item_search(name)

# exemple
bar_item = weechat.bar_item_search("myitem")
----------------------------------------

weechat_bar_item_new
^^^^^^^^^^^^^^^^^^^^

Créé un nouvel objet de barre.

Prototype :

[source,C]
----------------------------------------
struct t_gui_bar_item *weechat_bar_item_new (const char *name,
                                             char *(build_callback)(void *data,
                                                                    struct t_gui_bar_item *item,
                                                                    struct t_gui_window *window),
                                             void *build_callback_data);
----------------------------------------

Paramètres :

* 'name' : nom de l'objet de barre
* 'build_callback' : fonction appelée lorsque l'objet est construit, paramètres
  et valeur de retour :
** 'void *data' : pointeur
** 'struct t_gui_bar_item *item' : pointeur vers l'objet de barre
** 'struct t_gui_window *window' : pointeur vers la fenêtre
** valeur de retour : contenu de l'objet de barre
* 'build_callback_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* pointeur vers le nouvel objet de barre, NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
char *
my_build_callback (void *data,
                   struct t_gui_bar_item *item,
                   struct t_gui_window *window)
{
    return strdup ("mon contenu");
}

struct t_gui_bar_item *my_item = weechat_bar_item_new ("myitem",
                                                       &my_build_callback,
                                                       NULL);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
bar_item = weechat.bar_item_new(name, build_callback, build_callback_data)

# exemple
def my_build_callback(data, item, window):
    return "my content"

bar_item = weechat.bar_item_new("myitem", "my_build_callback", "")
----------------------------------------

weechat_bar_item_update
^^^^^^^^^^^^^^^^^^^^^^^

Met à jour le contenu d'un objet de barre, en appelant son "callback" de
construction.

Prototype :

[source,C]
----------------------------------------
void weechat_bar_item_update (const char *name);
----------------------------------------

Paramètres :

* 'name' : nom de l'objet de barre

Exemple en C :

[source,C]
----------------------------------------
weechat_bar_item_update ("myobjet");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.bar_item_update(name)

# exemple
weechat.bar_item_update("myitem")
----------------------------------------

weechat_bar_item_remove
^^^^^^^^^^^^^^^^^^^^^^^

Supprime un objet de barre.

Prototype :

[source,C]
----------------------------------------
void weechat_bar_item_remove (struct t_gui_bar_item *item);
----------------------------------------

Paramètres :

* 'item' : bar item pointer

Exemple en C :

[source,C]
----------------------------------------
weechat_bar_item_remove (&my_item);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.bar_item_remove(item)

# exemple
weechat.bar_item_remove(myitem)
----------------------------------------

weechat_bar_search
^^^^^^^^^^^^^^^^^^

Recherche une barre.

Prototype :

[source,C]
----------------------------------------
struct t_gui_bar *weechat_bar_search (const char *name);
----------------------------------------

Paramètres :

* 'name' : nom de la barre

Valeur de retour :

* pointeur vers la barre trouvée, NULL si elle n'est pas trouvée

Exemple en C :

[source,C]
----------------------------------------
struct t_gui_bar *bar = weechat_bar_search ("my_barre");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
bar = weechat.bar_search(name)

# exemple
bar = weechat.bar_search("mybar")
----------------------------------------

weechat_bar_new
^^^^^^^^^^^^^^^

Créé une nouvelle barre.

Prototype :

[source,C]
----------------------------------------
struct t_gui_bar *weechat_bar_new (const char *name,
                                   const char *hidden,
                                   const char *priority,
                                   const char *type,
                                   const char *condition,
                                   const char *position,
                                   const char *filling_top_bottom,
                                   const char *filling_left_right,
                                   const char *size,
                                   const char *size_max,
                                   const char *color_fg,
                                   const char *color_delim,
                                   const char *color_bg,
                                   const char *separator,
                                   const char *items);
----------------------------------------

Paramètres :

* 'name' : nom de la barre
* 'hidden' :
** 'on' : la barre est cachée
** 'off' : la barre est visible
* 'priority' : priorité de la barre (nombre entier)
* 'type' :
** 'root' : la barre est affichée une seule fois, hors des fenêtres
** 'window' : la barre est affichée dans chaque fenêtre
* 'condition' : condition pour afficher la barre :
** 'active' : la barre est affichée dans la fenêtre active seulement
** 'inactive' : la barre est affichée dans les fenêtres inactives seulement
** 'nicklist' : la barre est affichée dans les fenêtres possédant une liste des
   pseudos
* 'position' : 'top' (en haut), 'bottom' (en bas), 'left' (à gauche) ou 'right'
  (à droite)
* 'filling_top_bottom' :
** 'horizontal' : les objets sont remplis horizontallement (avec un espace
   entre chaque objet)
** 'vertical' : les objets sont remplis verticalement (avec une nouvelle ligne
   entre chaque objet)
** 'columns_horizontal' : les objets sont remplis horizontallement, affichés
   sous forme de colonnes
** 'columns_vertical' : les objets sont remplis verticalement, affichés sous
   forme de colonnes
* 'filling_left_right' :
** 'horizontal' : les objets sont remplis horizontallement (avec un espace
   entre chaque objet)
** 'vertical' : les objets sont remplis verticalement (avec une nouvelle ligne
   entre chaque objet)
** 'columns_horizontal' : les objets sont remplis horizontallement, affichés
   sous forme de colonnes
** 'columns_vertical' : les objets sont remplis verticalement, affichés sous
   forme de colonnes
* 'size' : taille de la barre en caractères (0 indique une taille automatique)
* 'size_max' : taille maximum de la barre (0 pour pas de maximum)
* 'color_fg' : couleur du texte dans la barre
* 'color_delim' : couleur pour les délimiteurs dans la barre
* 'color_bg' : couleur de fond pour la barre
* 'separator' :
** 'on' : la barre a un séparateur avec les autres fenêtres/barres
** 'off' : pas de séparateur
* 'items' : liste des objets dans la barre, séparés par une virbule (espace
  entre les objets), ou "+" (objets collés)

Valeur de retour :

* pointeur vers la nouvelle barre, NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
struct t_gui_bar *my_bar = weechat_bar_new ("mybar",
                                            "off",
                                            100,
                                            "window",
                                            "",
                                            "top",
                                            "horizontal",
                                            "vertical",
                                            "0",
                                            "5",
                                            "default",
                                            "cyan",
                                            "blue",
                                            "off",
                                            "time,buffer_number+buffer_name");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
bar = weechat.bar_new(name, hidden, priority, type, condition, position,
    filling_top_bottom, filling_left_right, size, size_max,
    color_fg, color_delim, color_bg, separator, items)

# exemple
bar = weechat.bar_new("mybar", "off", 100, "window", "", "top", "horizontal", "vertical",
    "0", "5", "default", "cyan", "blue", "off", "time,buffer_number+buffer_name")
----------------------------------------

weechat_bar_set
^^^^^^^^^^^^^^^

Affecte une nouvelle valeur pour une propriété de la barre.

Prototype :

[source,C]
----------------------------------------
int weechat_bar_set (struct t_gui_bar *bar, const char *property,
                     const char *value);
----------------------------------------

Paramètres :

* 'bar' : pointeur vers la barre
* 'property' : name, hidden, priority, conditions, position, filling_top_bottom,
  filling_left_right, size, size_max, color_fg, color_delim, color_bg,
  separator, items (voir <<_weechat_bar_new,weechat_bar_new>>)
* 'value' : nouvelle valeur pour la propriété

Valeur de retour :

* 1 si la valeur a été affectée, 0 en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
weechat_bar_set (my_bar, "position", "bottom");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.bar_set(bar, property, value)

# exemple
weechat.bar_set(my_bar, "position", "bottom")
----------------------------------------

weechat_bar_update
^^^^^^^^^^^^^^^^^^

Met à jour le contenu d'une barre à l'écran.

Prototype :

[source,C]
----------------------------------------
void weechat_bar_update (const char *name);
----------------------------------------

Paramètres :

* 'name' : nom de la barre

Exemple en C :

[source,C]
----------------------------------------
weechat_bar_update ("mybar");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.bar_update(name)

# exemple
weechat.bar_update("mybar")
----------------------------------------

weechat_bar_remove
^^^^^^^^^^^^^^^^^^

Supprime une barre.

Prototype :

[source,C]
----------------------------------------
void weechat_bar_remove (struct t_gui_bar *bar);
----------------------------------------

Paramètres :

* 'bar' : pointeur vers la barre

Exemple en C :

[source,C]
----------------------------------------
weechat_bar_remove (my_bar);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.bar_remove(bar)

# exemple
weechat.bar_remove(my_bar)
----------------------------------------

[[commands]]
Commandes
~~~~~~~~~

Fonctions pour exécuter des commandes WeeChat.

weechat_command
^^^^^^^^^^^^^^^

Exécute une commande.

Prototype :

[source,C]
----------------------------------------
void weechat_command (struct t_gui_buffer *buffer, const char *command);
----------------------------------------

Paramètres :

* 'buffer' : pointeur vers le tampon (la commande est exécutée sur ce tampon,
  NULL pour le tampon "core")
* 'command' : commande à exécuter (si elle commence par "/"), ou texte à
  envoyer au tampon

Exemple en C :

[source,C]
----------------------------------------
weechat_command (weechat_buffer_search ("irc", "freenode.#weechat"),
                 "/whois FlashCode");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.command(buffer, command)

# exemple
weechat.command(weechat.buffer_search("irc", "freenode.#weechat"), "/whois FlashCode")
----------------------------------------

[[network]]
Réseau
~~~~~~

Fonctions pour le réseau.

weechat_network_pass_proxy
^^^^^^^^^^^^^^^^^^^^^^^^^^

Etablit une connexion/authentification avec un proxy.

Prototype :

[source,C]
----------------------------------------
int weechat_network_pass_proxy (const char *proxy,
                                int sock,
                                const char *address,
                                int port);
----------------------------------------

Paramètres :

* 'proxy' : nom du proxy à utiliser
* 'sock' : socket à utiliser
* 'address' : addresse (nom de machine ou adresse IP)
* 'port' : port

Valeur de retour :

* 1 si la connexion est ok, 0 en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
if (weechat_network_pass_proxy ("mon_proxy", sock, "irc.freenode.net", 6667))
{
    /* OK */
}
else
{
    /* erreur */
}
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_network_connect_to
^^^^^^^^^^^^^^^^^^^^^^^^^^

Etablit une connexion à une machine distante.

Prototype :

[source,C]
----------------------------------------
int weechat_network_connect_to (const char *proxy,
                                int sock,
                                unsigned long address,
                                int port);
----------------------------------------

Paramètres :

* 'proxy' : nom du proxy à utiliser
* 'sock' : socket à utiliser
* 'address' : addresse
* 'port' : port

Valeur de retour :

* 1 si la connexion est ok, 0 en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
struct sockaddr_in addr;
socklen_t length;
unsigned long address;

memset (&addr, 0, sizeof (struct sockaddr_in));
length = sizeof (addr);
getsockname (sock, (struct sockaddr *) &addr, &length);
addr.sin_family = AF_INET;
address = ntohl (addr.sin_addr.s_addr);

if (weechat_network_connect_to (NULL, sock, address, 6667))
{
    /* OK */
}
else
{
    /* erreur */
}
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

[[infos]]
Infos
~~~~~

Fonctions pour obtenir des informations.

weechat_info_get
^^^^^^^^^^^^^^^^

Retourne une information, sous forme de chaîne, de WeeChat ou d'une extension.

Prototype :

[source,C]
----------------------------------------
const char *weechat_info_get (const char *info_name, const char *arguments);
----------------------------------------

Paramètres :

* 'info_name' : nom de l'information à lire :
include::autogen/plugin_api/infos.txt[]
* 'arguments' : paramètres pour l'information demandée (optionnels, NULL si
  aucun paramètre n'est nécessaire)

Valeur de retour :

* chaîne avec l'information demandée, NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
weechat_printf (NULL, "La version de WeeChat est : %s (compilée le %s)",
                weechat_info_get ("version", NULL),
                weechat_info_get ("date", NULL));
weechat_printf (NULL, "Le répertoire de WeeChat est : %s",
                weechat_info_get ("weechat_dir", NULL));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.info_get(info_name, arguments)

# exemple
weechat.prnt("", "La version de WeeChat est : %s (compilée le %s)"
    % (weechat.info_get("version", ""), weechat.info_get("date", ""))
weechat.prnt("", "Le répertoire de WeeChat est : %s" % weechat.info_get("weechat_dir", ""))
----------------------------------------

weechat_info_get_hashtable
^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.4._

Retourne une information, sous forme de hashtable, de WeeChat ou d'une extension.

Prototype :

[source,C]
----------------------------------------
struct t_hashtable *weechat_info_get_hashtable (const char *info_name,
                                                struct t_hashtable *hashtable);
----------------------------------------

Paramètres :

* 'info_name' : nom de l'information à lire :
include::autogen/plugin_api/infos_hashtable.txt[]
* 'hashtable' : hashtable avec les paramètres (dépendant de l'information
  demandée) (optionnel, NULL si aucun paramètre n'est nécessaire)

Valeur de retour :

* hashtable avec l'information demandée, NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
struct t_hashtable *hashtable_in, *hashtable_out;

hashtable_in = weechat_hashtable_new (8,
                                      WEECHAT_HASHTABLE_STRING,
                                      WEECHAT_HASHTABLE_STRING,
                                      NULL,
                                      NULL);
if (hashtable_in)
{
    weechat_hashtable_set (hashtable_in, "message",
                           ":nick!user@host PRIVMSG #weechat :message ici");
    hashtable_out = weechat_info_get_hashtable ("irc_message_parse",
                                                hashtable_in);
    /*
     * maintenant hashtable_out a les clés/valeurs suivantes :
     *   "nick"     : "nick"
     *   "host"     : "nick!user@host"
     *   "command"  : "PRIVMSG"
     *   "channel"  : "#weechat"
     *   "arguments": "#weechat :message ici"
     */
    weechat_hashtable_free (hashtable_in);
    weechat_hashtable_free (hashtable_out);
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
dict = weechat.info_get_hashtable(info_name, dict_in)

# exemple
dict_in = { "message": ":nick!user@host PRIVMSG #weechat :message ici" }
weechat.prnt("", "message analysé: %s"
             % weechat.info_get_hashtable("irc_message_parse", dict_in))
----------------------------------------

[[infolists]]
Infolists
~~~~~~~~~

Une "infolist" est une liste composée d'objets ("items"). Chaque objet contient
des variables.

Par exemple, l'infolist "irc_server" a N objets (N est le nombre de serveurs
IRC définis). Pour chaque objet, il y a des variables, comme "name", "buffer",
"is_connected", ...

Chaque variable a un type et une valeur. Les types possibles sont :

* 'integer' : nombre entier
* 'string' : chaîne de caractères
* 'pointer' : pointeur
* 'buffer' : tampon avec une taille fixe, peut contenit n'importe quel type
  de données
* 'time' : date/heure

weechat_infolist_new
^^^^^^^^^^^^^^^^^^^^

Créé une "infolist".

Prototype :

[source,C]
----------------------------------------
struct t_infolist *weechat_infolist_new ();
----------------------------------------

Valeur de retour :

* pointeur vers la nouvelle "infolist"

Exemple en C :

[source,C]
----------------------------------------
struct t_infolist *infolist = weechat_infolist_new ();
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
infolist = weechat.infolist_new()

# exemple
infolist = weechat.infolist_new()
----------------------------------------

weechat_infolist_new_item
^^^^^^^^^^^^^^^^^^^^^^^^^

Ajoute un objet dans l'infolist.

Prototype :

[source,C]
----------------------------------------
struct t_infolist_item *weechat_infolist_new_item (struct t_infolist *infolist);
----------------------------------------

Paramètres :

* 'infolist' : pointeur vers l'infolist

Valeur de retour :

* pointeur vers le nouvel objet

Exemple en C :

[source,C]
----------------------------------------
struct t_infolist_item *item = weechat_infolist_new_item (infolist);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
item = weechat.infolist_new_item(infolist)

# exemple
item = weechat.infolist_new_item(infolist)
----------------------------------------

weechat_infolist_new_var_integer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Ajoute une variable de type "integer" dans l'objet de l'infolist.

Prototype :

[source,C]
----------------------------------------
struct t_infolist_var *weechat_infolist_new_var_integer (struct t_infolist_item *item,
                                                         const char *name,
                                                         int value);
----------------------------------------

Paramètres :

* 'item' : pointeur vers l'objet de l'infolist
* 'name' : nom de la variable
* 'value' : valeur

Valeur de retour :

* pointeur vers la nouvelle variable

Exemple en C :

[source,C]
----------------------------------------
struct t_infolist_var *var = weechat_infolist_new_var_integer (item,
                                                               "mon_entier",
                                                               123);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
var = weechat.infolist_new_var_integer(item, name, value)

# exemple
var = weechat.infolist_new_var_integer(item, "mon_entier", 123)
----------------------------------------

weechat_infolist_new_var_string
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Ajoute une variable de type "string" dans l'objet de l'infolist.

Prototype :

[source,C]
----------------------------------------
struct t_infolist_var *weechat_infolist_new_var_string (struct t_infolist_item *item,
                                                        const char *name,
                                                        const char *value);
----------------------------------------

Paramètres :

* 'item' : pointeur vers l'objet de l'infolist
* 'name' : nom de la variable
* 'value' : valeur

Valeur de retour :

* pointeur vers la nouvelle variable

Exemple en C :

[source,C]
----------------------------------------
struct t_infolist_var *var = weechat_infolist_new_var_string (item,
                                                              "ma_chaine",
                                                              "valeur");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
var = weechat.infolist_new_var_string(item, name, value)

# exemple
var = weechat.infolist_new_var_string(item, "ma_chaine", "valeur")
----------------------------------------

weechat_infolist_new_var_pointer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Ajoute une variable de type "pointer" dans l'objet de l'infolist.

Prototype :

[source,C]
----------------------------------------
struct t_infolist_var *weechat_infolist_new_var_pointer (struct t_infolist_item *item,
                                                         const char *name,
                                                         void *pointer);
----------------------------------------

Paramètres :

* 'item' : pointeur vers l'objet de l'infolist
* 'name' : nom de la variable
* 'pointer' : pointeur

Valeur de retour :

* pointeur vers la nouvelle variable

Exemple en C :

[source,C]
----------------------------------------
struct t_infolist_var *var = weechat_infolist_new_var_pointer (item,
                                                               "mon_pointeur",
                                                               &pointer);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
var = weechat.infolist_new_var_pointer(item, name, pointer)

# exemple
var = weechat.infolist_new_var_pointer(item, "mon_pointeur", pointer)
----------------------------------------

weechat_infolist_new_var_buffer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Ajoute une variable de type "buffer" dans l'objet de l'infolist.

Prototype :

[source,C]
----------------------------------------
struct t_infolist_var *weechat_infolist_new_var_buffer (struct t_infolist_item *item,
                                                        const char *name,
                                                        void *pointer,
                                                        int size);
----------------------------------------

Paramètres :

* 'item' : pointeur vers l'objet de l'infolist
* 'name' : nom de la variable
* 'pointer' : pointeur
* 'size' : taille du tampon

Valeur de retour :

* pointeur vers la nouvelle variable

Exemple en C :

[source,C]
----------------------------------------
char buffer[256];
/* ... */
struct t_infolist_var *var = weechat_infolist_new_var_buffer (item,
                                                              "mon_buffer",
                                                              buffer,
                                                              sizeof (buffer));
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_infolist_new_var_time
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Ajoute une variable de type "time" dans l'objet de l'infolist.

Prototype :

[source,C]
----------------------------------------
struct t_infolist_var *weechat_infolist_new_var_time (struct t_infolist_item *item,
                                                      const char *name,
                                                      time_t time);
----------------------------------------

Paramètres :

* 'item' : pointeur vers l'objet de l'infolist
* 'name' : nom de la variable
* 'time' : valeur

Valeur de retour :

* pointeur vers la nouvelle variable

Exemple en C :

[source,C]
----------------------------------------
struct t_infolist_var *var = weechat_infolist_new_var_time (item,
                                                            "mon_time",
                                                            time (NULL));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
var = weechat.infolist_new_var_time(item, name, time)

# exemple
var = weechat.infolist_new_var_time(item, "mon_time", int(time.time()))
----------------------------------------

weechat_infolist_get
^^^^^^^^^^^^^^^^^^^^

Retourne une "infolist" de WeeChat ou d'une extension.

[IMPORTANT]
Le contenu d'une infolist est une duplication des données réelles. Donc si vous
demandez une infolist avec beaucoup de données (comme "buffer_lines"), WeeChat
allouera de la mémoire pour dupliquer toutes les données, et cela peut prendre
du temps. +
Au lieu d'utiliser une grosse infolist, il est préférable d'utiliser un hdata
(mais l'infolist peut contenir plus de données que le hdata, qui contient des
données brutes), voir <<hdata,hdata>>.

Prototype :

[source,C]
----------------------------------------
struct t_infolist *weechat_infolist_get (const char *infolist_name,
                                         void *pointer,
                                         const char *arguments);
----------------------------------------

Paramètres :

* 'infolist_name' : nom de l'infolist à lire :
include::autogen/plugin_api/infolists.txt[]
* 'pointer' : pointeur vers un objet, pour n'obtenir que celui-ci dans
  l'infolist (optionnel, peut être NULL)
* 'arguments' : paramètres pour l'infolist demandée (optionnels, NULL si aucun
  paramètre n'est nécessaire)

Valeur de retour :

* pointeur vers l'infolist, NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
struct t_infolist *infolist = weechat_infolist_get ("irc_server", NULL, NULL);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
infolist = weechat.infolist_get(infolist_name, pointer, arguments)

# exemple
infolist = weechat.infolist_get("irc_server", "", "")
----------------------------------------

weechat_infolist_next
^^^^^^^^^^^^^^^^^^^^^

Déplace le "curseur" vers l'objet suivant dans l'infolist. Le premier appel à
cette fonction sur une infolist déplace le curseur sur le premier objet de
l'infolist.

Prototype :

[source,C]
----------------------------------------
int weechat_infolist_next (struct t_infolist *infolist);
----------------------------------------

Paramètres :

* 'infolist' : pointeur vers l'infolist

Valeur de retour :

* 1 si le curseur a été déplacé sur l'objet suivant, 0 si la fin de la liste a
  été atteinte

Exemple en C :

[source,C]
----------------------------------------
if (weechat_infolist_next (infolist))
{
    /* lecture des variables dans l'objet... */
}
else
{
    /* pas d'autre objet disponible */
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
rc = weechat.infolist_next(infolist)

# exemple
rc = weechat.infolist_next(infolist)
if rc:
    # lecture des variables dans l'objet...
else:
    # pas d'autre objet disponible
----------------------------------------

weechat_infolist_prev
^^^^^^^^^^^^^^^^^^^^^

Déplace le "curseur" vers l'objet précédent dans l'infolist. Le premier appel à
cette fonction sur une infolist déplace le curseur sur le dernier objet de
l'infolist.

Prototype :

[source,C]
----------------------------------------
int weechat_infolist_prev (struct t_infolist *infolist);
----------------------------------------

Paramètres :

* 'infolist' : pointeur vers l'infolist

Valeur de retour :

* 1 si le curseur a été déplacé sur l'objet précédent, 0 si le début de liste a
  été atteint

Exemple en C :

[source,C]
----------------------------------------
if (weechat_infolist_prev (infolist))
{
    /* lecture des variables dans l'objet... */
}
else
{
    /* pas d'autre objet disponible */
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
rc = weechat.infolist_prev(infolist)

# exemple
rc = weechat.infolist_prev(infolist)
if rc:
    # lecture des variables dans l'objet
else:
    # pas d'autre objet disponible
----------------------------------------

weechat_infolist_reset_item_cursor
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Réinitialise le "curseur" de l'infolist.

Prototype :

[source,C]
----------------------------------------
void weechat_infolist_reset_item_cursor (struct t_infolist *infolist);
----------------------------------------

Paramètres :

* 'infolist' : pointeur vers l'infolist

Exemple en C :

[source,C]
----------------------------------------
weechat_infolist_reset_item_cursor (infolist);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.infolist_reset_item_cursor(infolist)

# exemple
weechat.infolist_reset_item_cursor(infolist)
----------------------------------------

weechat_infolist_fields
^^^^^^^^^^^^^^^^^^^^^^^

Retourne la liste des champs pour l'objet courant de l'infolist.

Prototype :

[source,C]
----------------------------------------
const char *weechat_infolist_fields (struct t_infolist *infolist);
----------------------------------------

Paramètres :

* 'infolist' : pointeur vers l'infolist

Valeur de retour :

* chaîne avec la liste des champs pour l'objet courant de l'infolist. La liste,
  séparée par des virgules, contient la lettre pour le type, suivi du nom de la
  variable. Les types sont : "i" (nombre entier), "s" (chaîne), "p" (pointeur),
  "b" (buffer), "t" (date/heure).

Exemple en C :

[source,C]
----------------------------------------
const char *fields = weechat_infolist_fields (infolist);
/* fields contient quelque chose comme :
   "i:mon_entier,s:ma_chaine,p:mon_pointeur,b:mon_buffer,t:ma_date" */
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
fields = weechat.infolist_fields(infolist)

# exemple
fields = weechat.infolist_fields(infolist)
# fields contient quelque chose comme :
# "i:mon_entier,s:ma_chaine,p:mon_pointeur,b:mon_buffer,t:ma_date"
----------------------------------------

weechat_infolist_integer
^^^^^^^^^^^^^^^^^^^^^^^^

Retourne la valeur de la variable de l'objet courant de l'infolist, sous forme
d'entier.

Prototype :

[source,C]
----------------------------------------
int weechat_infolist_integer (struct t_infolist *infolist, const char *var);
----------------------------------------

Paramètres :

* 'infolist' : pointeur vers l'infolist
* 'var' : nom de la variable (doit être de type "integer")

Valeur de retour :

* valeur de la variable, sous forme d'entier

Exemple en C :

[source,C]
----------------------------------------
weechat_printf (NULL, "entier = %d",
                weechat_infolist_integer (infolist, "mon_entier"));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.infolist_integer(infolist, var)

# exemple
weechat.prnt("", "entier = %d" % weechat.infolist_integer(infolist, "mon_entier"))
----------------------------------------

weechat_infolist_string
^^^^^^^^^^^^^^^^^^^^^^^

Retourne la valeur de la variable de l'objet courant de l'infolist, sous forme
de chaîne de caractères.

Prototype :

[source,C]
----------------------------------------
const char *weechat_infolist_string (struct t_infolist *infolist, const char *var);
----------------------------------------

Paramètres :

* 'infolist' : pointeur vers l'infolist
* 'var' : nom de la variable (doit être de type "string")

Valeur de retour :

* valeur de la variable, sous forme de chaîne

Exemple en C :

[source,C]
----------------------------------------
weechat_printf (NULL, "chaîne = %s",
                weechat_infolist_string (infolist, "ma_chaine"));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.infolist_string(infolist, var)

# exemple
weechat.prnt("", "chaîne = %s" % weechat.infolist_string(infolist, "ma_chaine"))
----------------------------------------

weechat_infolist_pointer
^^^^^^^^^^^^^^^^^^^^^^^^

Retourne la valeur de la variable de l'objet courant de l'infolist, sous forme
de pointeur.

Prototype :

[source,C]
----------------------------------------
void *weechat_infolist_pointer (struct t_infolist *infolist, const char *var);
----------------------------------------

Paramètres :

* 'infolist' : pointeur vers l'infolist
* 'var' : nom de la variable (doit être de type "pointer")

Valeur de retour :

* valeur de la variable, sous forme de pointeur

Exemple en C :

[source,C]
----------------------------------------
weechat_printf (NULL, "pointeur = 0x%lx",
                weechat_infolist_pointer (infolist, "mon_pointeur"));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.infolist_pointer(infolist, var)

# exemple
weechat.prnt("", "pointeur = 0x%s" % weechat.infolist_pointer(infolist, "mon_pointeur"))
----------------------------------------

weechat_infolist_buffer
^^^^^^^^^^^^^^^^^^^^^^^

Retourne la valeur de la variable de l'objet courant de l'infolist, sous forme
de buffer.

Prototype :

[source,C]
----------------------------------------
void *weechat_infolist_buffer (struct t_infolist *infolist, const char *var,
                               int *size);
----------------------------------------

Paramètres :

* 'infolist' : pointeur vers l'infolist
* 'var' : nom de la variable (doit être de type "buffer")
* 'size' : pointeur vers une variable entière, qui sera alimenté avec la taille
  de la zone

Valeur de retour :

* pointeur vers le "buffer"

Exemple en C :

[source,C]
----------------------------------------
int size;
void *pointer = weechat_infolist_buffer (infolist, "mon_buffer", &size);
weechat_printf (NULL, "buffer = 0x%lx, taille = %d",
                pointer, size);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_infolist_time
^^^^^^^^^^^^^^^^^^^^^

Retourne la valeur de la variable de l'objet courant de l'infolist, sous forme
de date/heure.

Prototype :

[source,C]
----------------------------------------
time_t weechat_infolist_time (struct t_infolist *infolist, const char *var);
----------------------------------------

Paramètres :

* 'infolist' : pointeur vers l'infolist
* 'var' : nom de la variable (doit être de type "time")

Valeur de retour :

* valeur de la variable, sous forme de date/heure

Exemple en C :

[source,C]
----------------------------------------
weechat_printf (NULL, "date/heure = %ld",
                weechat_infolist_time (infolist, "mon_time"));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.infolist_time(infolist, var)

# exemple
weechat.prnt("", "date/heure = %ld" % weechat.infolist_time(infolist, "mon_time"))
----------------------------------------

weechat_infolist_free
^^^^^^^^^^^^^^^^^^^^^

Libère une infolist.

Prototype :

[source,C]
----------------------------------------
void weechat_infolist_free (struct t_infolist *infolist);
----------------------------------------

Paramètres :

* 'infolist' : pointeur vers l'infolist

Exemple en C :

[source,C]
----------------------------------------
weechat_infolist_free (infolist);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.infolist_free(infolist)

# exemple
weechat.infolist_free(infolist)
----------------------------------------

[[hdata]]
Hdata
~~~~~

Fonctions pour les hdata (accès brut aux données de WeeChat ou des extensions).

[IMPORTANT]
Le "hdata" fournit seulement un accès en lecture seule aux données. Il est
*STRICTEMENT INTERDIT* d'écrire quelque chose dans une zone mémoire pointée par
les variables du hdata.

weechat_hdata_new
^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.6._

Créé un "hdata".

[NOTE]
.hdata vs infolist
========================================
Le "hdata" est un moyen rapide de lire des données de WeeChat ou des extensions.
Il est similaire à l'infolist, mais il y a quelques différences :

* il est plus rapide et utilise moins de mémoire : accès direct aux données sans
  duplication
* il peut contenir des informations différentes de l'infolist : il contient
  seulement les données brutes des structures (l'infolist peut ajouter des
  données supplémentaires pour plus de commodité)
========================================

Prototype :

[source,C]
----------------------------------------
struct t_hdata *weechat_hdata_new (const char *hdata_name, const char *var_prev, const char *var_next);
----------------------------------------

Paramètres :

* 'hdata_name' : nom du hdata
* 'var_prev' : nom de la variable dans la structure qui est un pointeur vers
  l'élément précédent dans la liste (peut être NULL si une telle variable
  n'existe pas)
* 'var_next' : nom de la variable dans la structure qui est un pointeur vers
  l'élément suivant dans la liste (peut être NULL si une telle variable
  n'existe pas)

Valeur de retour :

* pointeur vers le nouveau "hdata"

Exemple en C :

[source,C]
----------------------------------------
struct t_hdata *hdata = weechat_hdata_new ("myplugin_list", "prev", "next");
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_hdata_new_var
^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.6._

Créé une nouvelle variable dans le hdata.

Prototype :

[source,C]
----------------------------------------
void weechat_hdata_new_var (struct t_hdata *hdata, const char *name, int offset, int type,
                            const char *hdata_name);
----------------------------------------

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'name' : nom de la variable
* 'offset' : position (offset) de la variable dans la structure
* 'type' : type de la variable, un parmi ceux-ci :
** WEECHAT_HDATA_CHAR
** WEECHAT_HDATA_INTEGER
** WEECHAT_HDATA_LONG
** WEECHAT_HDATA_STRING
** WEECHAT_HDATA_POINTER
** WEECHAT_HDATA_TIME
** WEECHAT_HDATA_OTHER
* 'hdata_name' : nom d'un hdata (si c'est un pointeur vers une structure qui a un
  hdata)

Exemple en C :

[source,C]
----------------------------------------
struct t_myplugin_list
{
    char *name;
    struct t_gui_buffer *buffer;
    int count;
    struct t_myplugin_list *prev;
    struct t_myplugin_list *next;
};

/* ... */

struct t_hdata *hdata = weechat_hdata_new ("myplugin_list", "prev", "next");
weechat_hdata_new_var (hdata, "name", offsetof (struct t_myplugin_list, name), WEECHAT_HDATA_STRING, NULL);
weechat_hdata_new_var (hdata, "buffer", offsetof (struct t_myplugin_list, buffer), WEECHAT_HDATA_POINTER, NULL);
weechat_hdata_new_var (hdata, "count", offsetof (struct t_myplugin_list, count), WEECHAT_HDATA_INTEGER, NULL);
weechat_hdata_new_var (hdata, "prev", offsetof (struct t_myplugin_list, prev), WEECHAT_HDATA_POINTER, "myplugin_list");
weechat_hdata_new_var (hdata, "next", offsetof (struct t_myplugin_list, next), WEECHAT_HDATA_POINTER, "myplugin_list");
----------------------------------------

La macro "WEECHAT_HDATA_VAR" peut être utilisée pour raccourcir le code :

[source,C]
----------------------------------------
WEECHAT_HDATA_VAR(struct t_myplugin_list, name, STRING, NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, buffer, POINTER, NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, count, INTEGER, NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, prev, POINTER, "myplugin_list");
WEECHAT_HDATA_VAR(struct t_myplugin_list, next, POINTER, "myplugin_list");
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_hdata_new_list
^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.6._

Créé un nouveau pointer vers une liste dans le hdata.

Prototype :

[source,C]
----------------------------------------
void weechat_hdata_new_list (struct t_hdata *hdata, const char *name, void *pointer);
----------------------------------------

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'name' : nom de la variable
* 'pointer' : pointeur vers la liste

Exemple en C :

[source,C]
----------------------------------------
struct t_myplugin_list
{
    char *name;
    struct t_gui_buffer *buffer;
    int count;
    struct t_myplugin_list *prev;
    struct t_myplugin_list *next;
};

struct t_myplugin_list *buffers = NULL;
struct t_myplugin_list *last_buffer = NULL;

/* ... */

struct t_hdata *hdata = weechat_hdata_new ("myplugin_list", "prev", "next");
weechat_hdata_new_var (hdata, "name", offsetof (struct t_myplugin_list, name), WEECHAT_HDATA_STRING);
weechat_hdata_new_var (hdata, "buffer", offsetof (struct t_myplugin_list, buffer), WEECHAT_HDATA_POINTER);
weechat_hdata_new_var (hdata, "count", offsetof (struct t_myplugin_list, count), WEECHAT_HDATA_INTEGER);
weechat_hdata_new_var (hdata, "prev", offsetof (struct t_myplugin_list, prev), WEECHAT_HDATA_POINTER);
weechat_hdata_new_var (hdata, "next", offsetof (struct t_myplugin_list, next), WEECHAT_HDATA_POINTER);
weechat_hdata_new_list (hdata, "buffers", &buffers);
weechat_hdata_new_list (hdata, "last_buffer", &last_buffer);
----------------------------------------

La macro "WEECHAT_HDATA_LIST" peut être utilisée pour raccourcir le code :

[source,C]
----------------------------------------
WEECHAT_HDATA_LIST(buffers);
WEECHAT_HDATA_LIST(last_buffer);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_hdata_get
^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.6._

Retourne un "hdata" pour une structure de WeeChat ou d'une extension.

[NOTE]
Le "hdata" ne contient aucune donnée, il s'agit seulement d'une hashtable avec
la position (offset) des variables dans la structure. Cela signifie que vous
aurez besoin de ce hdata et d'un pointeur vers un objet WeeChat ou d'une
extension pour lire des données.

Prototype :

[source,C]
----------------------------------------
struct t_hdata *weechat_hdata_get (const char *hdata_name);
----------------------------------------

Paramètres :

* 'hdata_name' : nom du hdata :
include::autogen/plugin_api/hdata.txt[]

Valeur de retour :

* pointeur vers le hdata, NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
struct t_hdata *hdata = weechat_hdata_get ("irc_server");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
hdata = weechat.hdata_get(hdata_name)

# exemple
hdata = weechat.hdata_get("irc_server")
----------------------------------------

weechat_hdata_get_var_offset
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.6._

Retourne la position (offset) de la variable dans le hdata.

Prototype :

[source,C]
----------------------------------------
int weechat_hdata_get_var_offset (struct t_hdata *hdata, const char *name);
----------------------------------------

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'name' : nom de la variable

Valeur de retour :

* position (offset) de la variable, 0 en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
int offset = weechat_hdata_get_var_offset (hdata, "name");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
offset = weechat.hdata_get_var_offset(hdata, name)

# exemple
offset = weechat.hdata_get(hdata, "name")
----------------------------------------

weechat_hdata_get_var_type
^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.6._

Retourne le type de la variable dans le hdata (sous forme d'entier).

Prototype :

[source,C]
----------------------------------------
int weechat_hdata_get_var_type (struct t_hdata *hdata, const char *name);
----------------------------------------

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'name' : nom de la variable

Valeur de retour :

* type de la variable, -1 en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
int type = weechat_hdata_get_var_type (hdata, "name");
switch (type)
{
    case WEECHAT_HDATA_CHAR:
        /* ... */
        break;
    case WEECHAT_HDATA_INTEGER:
        /* ... */
        break;
    case WEECHAT_HDATA_LONG:
        /* ... */
        break;
    case WEECHAT_HDATA_STRING:
        /* ... */
        break;
    case WEECHAT_HDATA_POINTER:
        /* ... */
        break;
    case WEECHAT_HDATA_TIME:
        /* ... */
        break;
    case WEECHAT_HDATA_OTHER:
        /* ... */
        break;
    default:
        /* variable non trouvée */
        break;
}
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_hdata_get_var_type_string
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.6._

Retourne le type de la variable dans le hdata (sous forme de chaîne).

Prototype :

[source,C]
----------------------------------------
const char *weechat_hdata_get_var_type_string (struct t_hdata *hdata, const char *name);
----------------------------------------

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'name' : nom de la variable

Valeur de retour :

* type de la variable, NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
weechat_printf (NULL, "type = %s", weechat_hdata_get_var_type_string (hdata, "name"));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
type = weechat.hdata_get_var_type_string(hdata, name)

# exemple
weechat.prnt("", "type = %s" % weechat.hdata_get_var_type_string(hdata, "name"))
----------------------------------------

weechat_hdata_get_var_hdata
^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.6._

Retourne le hdata pour la variable dans le hdata.

Prototype :

[source,C]
----------------------------------------
const char *weechat_hdata_get_var_hdata (struct t_hdata *hdata, const char *name);
----------------------------------------

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'name' : nom de la variable

Valeur de retour :

* hdata pour la variable, NULL si pas de hdata ou en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
weechat_printf (NULL, "hdata = %s", weechat_hdata_get_var_hdata (hdata, "name"));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
hdata_name = weechat.hdata_get_var_hdata(hdata, name)

# exemple
weechat.prnt("", "hdata = %s" % weechat.hdata_get_var_hdata(hdata, "name"))
----------------------------------------

weechat_hdata_get_var
^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.6._

Retourne un pointeur vers le contenu de la variable dans le hdata.

Prototype :

[source,C]
----------------------------------------
void *weechat_hdata_get_var (struct t_hdata *hdata, void *pointer, const char *name);
----------------------------------------

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'name' : nom de la variable

Valeur de retour :

* pointeur vers le contenu de la variable, NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
void *pointer = weechat_hdata_get_var (hdata, buffer, "name");
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_hdata_get_var_at_offset
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.6._

Retourne un pointeur vers le contenu de la variable dans le hdata, en utilisant
une position (offset).

Prototype :

[source,C]
----------------------------------------
void *weechat_hdata_get_var_at_offset (struct t_hdata *hdata, void *pointer, int offset);
----------------------------------------

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'offset' : position (offset) de la variable

Valeur de retour :

* pointeur vers le contenu de la variable, NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
int offset = weechat_hdata_get_var_offset (hdata, "name");
void *pointer = weechat_hdata_get_var_at_offset (hdata, buffer, offset);
----------------------------------------

[NOTE]
Cette fonction n'est pas disponible dans l'API script.

weechat_hdata_get_list
^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.6._

Retourne un pointeur de liste du hdata.

Prototype :

[source,C]
----------------------------------------
void *weechat_hdata_get_list (struct t_hdata *hdata, const char *name);
----------------------------------------

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'name' : nom de la liste

Valeur de retour :

* pointeur vers la liste, NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffers = weechat_hdata_get_list (hdata, "gui_buffers");
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
list = weechat.hdata_get_list(hdata, name)

# exemple
hdata = weechat.hdata_get("buffer")
buffers = weechat.hdata_get_list(hdata, "gui_buffers")
----------------------------------------

weechat_hdata_check_pointer
^^^^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.7._

Vérifie si un pointeur est valide pour un hdata et un pointeur de liste.

Prototype :

[source,C]
----------------------------------------
int weechat_hdata_check_pointer (struct t_hdata *hdata, void *list, void *pointer);
----------------------------------------

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'list' : pointeur vers une liste
* 'pointer' : pointeur à vérifier

Valeur de retour :

* 1 si le pointeur est dans la liste, 0 si non trouvé

Exemple en C :

[source,C]
----------------------------------------
/* vérifie si le pointeur vers le tampon est valide */
struct t_hdata *hdata = weechat_hdata_get ("buffer");
if (weechat_hdata_check_pointer (hdata,
                                 weechat_hdata_get_list (hdata, "gui_buffers"),
                                 ptr_buffer))
{
    /* pointeur valide */
}
else
{
    /* pointeur invalide */
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
rc = weechat.hdata_check_pointer(hdata, list, pointer)

# exemple
hdata = weechat.hdata_get("buffer")
if weechat.hdata_check_pointer(hdata, weechat.hdata_get_list(hdata, "gui_buffers"), ptr_buffer):
    # pointeur valide
    # ...
else:
    # pointeur invalide
    # ...
----------------------------------------

weechat_hdata_move
^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.6._

Déplace le pointeur vers un autre élément dans la liste.

Prototype :

[source,C]
----------------------------------------
void *weechat_hdata_move (struct t_hdata *hdata, void *pointer, int count);
----------------------------------------

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'count' : nombre de saut(s) à exécuter (entier négatif ou positif, différent
  de 0)

Valeur de retour :

* pointeur vers l'élément atteint, NULL en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();

/* se déplacer au tampon suivant, 2 fois */
buffer = weechat_hdata_move (hdata, buffer, 2);

/* se déplacer au tampon précédent */
if (buffer)
    buffer = weechat_hdata_move (hdata, buffer, -1);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
pointer = weechat.hdata_move(hdata, pointer, count)

# exemple
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()

# se déplacer au tampon suivant, 2 fois
buffer = weechat.hdata_move(hdata, buffer, 2)

# se déplacer au tampon précédent
if buffer:
    buffer = weechat.hdata_move(hdata, buffer, -1)
----------------------------------------

weechat_hdata_char
^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.7._

Retourne la valeur de la variable dans la structure en utilisant le hdata, sous
forme de caractère.

Prototype :

[source,C]
----------------------------------------
char weechat_hdata_char (struct t_hdata *hdata, void *pointer, const char *name);
----------------------------------------

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'name' : nom de la variable (doit être de type "char")

Valeur de retour :

* valeur de la variable, sous forme de caractère

Exemple en C :

[source,C]
----------------------------------------
weechat_printf (NULL, "letter = %c", weechat_hdata_char (hdata, pointer, "letter"));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.hdata_char(hdata, pointer, name)

# exemple
weechat.prnt("", "letter = %c" % weechat.hdata_char(hdata, pointer, "letter"))
----------------------------------------

weechat_hdata_integer
^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.6._

Retourne la valeur de la variable dans la structure en utilisant le hdata, sous
forme d'entier.

Prototype :

[source,C]
----------------------------------------
int weechat_hdata_integer (struct t_hdata *hdata, void *pointer, const char *name);
----------------------------------------

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'name' : nom de la variable (doit être de type "integer")

Valeur de retour :

* valeur de la variable, sous forme d'entier

Exemple en C :

[source,C]
----------------------------------------
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
weechat_printf (NULL, "number = %d", weechat_hdata_integer (hdata, buffer, "number"));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.hdata_integer(hdata, pointer, name)

# exemple
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
weechat.prnt("", "number = %d" % weechat.hdata_integer(hdata, buffer, "number"))
----------------------------------------

weechat_hdata_long
^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.6._

Retourne la valeur de la variable dans la structure en utilisant le hdata, sous
forme d'entier long.

Prototype :

[source,C]
----------------------------------------
long weechat_hdata_long (struct t_hdata *hdata, void *pointer, const char *name);
----------------------------------------

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'name' : nom de la variable (doit être de type "long")

Valeur de retour :

* valeur de la variable, sous forme d'entier long

Exemple en C :

[source,C]
----------------------------------------
weechat_printf (NULL, "longvar = %ld", weechat_hdata_long (hdata, pointer, "longvar"));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.hdata_long(hdata, pointer, name)

# exemple
weechat.prnt("", "longvar = %ld" % weechat.hdata_long(hdata, pointer, "longvar"))
----------------------------------------

weechat_hdata_string
^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.6._

Retourne la valeur de la variable dans la structure en utilisant le hdata, sous
forme de chaîne.

Prototype :

[source,C]
----------------------------------------
const char *weechat_hdata_string (struct t_hdata *hdata, void *pointer, const char *name);
----------------------------------------

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'name' : nom de la variable (doit être de type "string")

Valeur de retour :

* valeur de la variable, sous forme de chaîne

Exemple en C :

[source,C]
----------------------------------------
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
weechat_printf (NULL, "name = %s", weechat_hdata_string (hdata, buffer, "name"));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.hdata_string(hdata, pointer, name)

# exemple
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
weechat.prnt("", "name = %s" % weechat.hdata_string(hdata, buffer, "name"))
----------------------------------------

weechat_hdata_pointer
^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.6._

Retourne la valeur de la variable dans la structure en utilisant le hdata, sous
forme de pointeur.

Prototype :

[source,C]
----------------------------------------
void *weechat_hdata_pointer (struct t_hdata *hdata, void *pointer, const char *name);
----------------------------------------

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'name' : nom de la variable (doit être de type "pointeur")

Valeur de retour :

* valeur de la variable, sous forme de pointeur

Exemple en C :

[source,C]
----------------------------------------
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
weechat_printf (NULL, "lines = %lx", weechat_hdata_pointer (hdata, buffer, "lines"));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.hdata_pointer(hdata, pointer, name)

# exemple
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
weechat.prnt("", "lines = %lx" % weechat.hdata_pointer(hdata, buffer, "lines"))
----------------------------------------

weechat_hdata_time
^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.6._

Retourne la valeur de la variable dans la structure en utilisant le hdata, sous
forme de date/heure.

Prototype :

[source,C]
----------------------------------------
time_t weechat_hdata_time (struct t_hdata *hdata, void *pointer, const char *name);
----------------------------------------

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'name' : nom de la variable (doit être de type "time")

Valeur de retour :

* valeur de la variable, sous forme de date/heure

Exemple en C :

[source,C]
----------------------------------------
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *ptr = weechat_buffer_search_main ();
ptr = weechat_hdata_pointer (hdata, ptr, "lines");
if (ptr)
{
    hdata = weechat_hdata_get ("lines");
    ptr = weechat_hdata_pointer (hdata, ptr, "first_line");
    if (ptr)
    {
        hdata = weechat_hdata_get ("line");
        ptr = weechat_hdata_pointer (hdata, ptr, "data");
        if (ptr)
        {
            hdata = weechat_hdata_get ("line_data");
            time_t date = weechat_hdata_time (hdata, hdata, "date");
            weechat_printf (NULL, "heure de la première ligne affichée = %s", ctime (&date));
        }
    }
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.hdata_time(hdata, pointer, name)

# exemple
hdata = weechat.hdata_get("buffer")
ptr = weechat.buffer_search_main()
ptr = weechat.hdata_pointer(hdata, ptr, "lines")
if ptr:
    hdata = weechat.hdata_get("lines")
    ptr = weechat.hdata_pointer(hdata, ptr, "first_line")
    if ptr:
        hdata = weechat.hdata_get("line")
        ptr = weechat.hdata_pointer(hdata, ptr, "data")
        if ptr:
            hdata = weechat.hdata_get("line_data")
            weechat.prnt("", "heure de la première ligne affichée = %s" % weechat.hdata_time(hdata, ptr, "date"))
----------------------------------------

weechat_hdata_hashtable
^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.7._

Retourne la valeur de la variable dans la structure en utilisant le hdata, sous
forme de hashtable.

Prototype :

[source,C]
----------------------------------------
struct t_hashtable *weechat_hdata_hashtable (struct t_hdata *hdata, void *pointer, const char *name);
----------------------------------------

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'pointer' : pointeur vers un objet WeeChat ou d'une extension
* 'name' : nom de la variable (doit être de type "hashtable")

Valeur de retour :

* valeur de la variable, sous forme de pointeur vers la hashtable

Exemple en C :

[source,C]
----------------------------------------
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
struct t_hashtable *hashtable = weechat_hdata_hashtable (hdata, buffer, "local_variables");
weechat_printf (NULL, "%d variables locales dans le tampon principal",
                weechat_hashtable_get_integer (hashtable, "items_count"));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
hashtable = weechat.hdata_hashtable(hdata, pointer, name)

# exemple
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
hash = weechat.hdata_hashtable(hdata, buffer, "local_variables")
weechat.prnt("", "variables locales dans le tampon principal :")
for key in hash:
    weechat.prnt("", "  %s == %s" % (key, hash[key]))
----------------------------------------

weechat_hdata_get_string
^^^^^^^^^^^^^^^^^^^^^^^^

_Nouveau dans la version 0.3.6._

Retourne une valeur pour une propriété d'un hdata sous forme de chaîne.

Prototype :

[source,C]
----------------------------------------
const char *weechat_hdata_get_string (struct t_hdata *hdata, const char *property);
----------------------------------------

Paramètres :

* 'hdata' : pointeur vers le hdata
* 'property' : nom de la propriété :
** 'var_keys' : chaîne avec la liste des clés pour les variables du hdata
   (format : "key1,key2,key3")
** 'var_values' : chaîne avec la liste des valeurs pour les variables du hdata
   (format : "value1,value2,value3")
** 'var_keys_values' : chaîne avec la liste des clés et valeurs pour les
   variables du hdata (format : "key1:value1,key2:value2,key3:value3")
** 'var_prev' : nom de la variable dans la structure qui est un pointeur vers
   l'élément précédent dans la liste
** 'var_next' : nom de la variable dans la structure qui est un pointeur vers
   l'élément suivant dans la liste
** 'list_keys' : chaîne avec la liste des clés pour les listes du hdata
   (format : "key1,key2,key3")
** 'list_values' : chaîne avec la liste des valeurs pour les listes du hdata
   (format : "value1,value2,value3")
** 'list_keys_values' : chaîne avec la liste des clés et valeurs pour les listes
   du hdata (format : "key1:value1,key2:value2,key3:value3")

Valeur de retour :

* valeur de la propriété sous forme de chaîne

Exemple en C :

[source,C]
----------------------------------------
weechat_printf (NULL, "variables dans le hdata: %s" weechat_hdata_get_string (hdata, "var_keys"));
weechat_printf (NULL, "listes dans le hdata: %s" weechat_hdata_get_string (hdata, "list_keys"));
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
value = weechat.hdata_get_string(hdata, property)

# exemple
weechat.prnt("", "variables dans le hdata: %s" % weechat.hdata_get_string(hdata, "var_keys"))
weechat.prnt("", "listes dans le hdata: %s" % weechat.hdata_get_string(hdata, "list_keys"))
----------------------------------------

[[upgrade]]
Mise à jour
~~~~~~~~~~~

Fonctions pour la mise à jour de WeeChat (commande "/upgrade").

weechat_upgrade_new
^^^^^^^^^^^^^^^^^^^

Créé ou lit un fichier pour la mise à jour.

Prototype :

[source,C]
----------------------------------------
struct t_upgrade_file *weechat_upgrade_new (const char *filename, int write);
----------------------------------------

Paramètres :

* 'filename' : nom du fichier (l'extension ".upgrade" sera ajoutée
  automatiquement par WeeChat)
* 'write' :
** '1' : création du fichier (mode écriture, avant la mise à jour)
** '0' : lecture du fichier (après la mise à jour)

Valeur de retour :

* pointeur vers le fichier de mise à jour

Exemple en C :

[source,C]
----------------------------------------
struct t_upgrade_file *upgrade_file = weechat_upgrade_new ("mon_fichier", 1);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
upgrade_file = weechat.upgrade_new(filename, write)

# exemple
upgrade_file = weechat.upgrade_new("mon_fichier", 1)
----------------------------------------

weechat_upgrade_write_object
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Ecrit un objet dans le fichier de mise à jour.

Prototype :

[source,C]
----------------------------------------
int weechat_upgrade_write_object (struct t_upgrade_file *upgrade_file,
                                  int object_id,
                                  struct t_infolist *infolist);
----------------------------------------

Paramètres :

* 'upgrade_file' : pointeur vers le fichier de mise à jour
* 'object_id' : identifiant de l'objet
* 'infolist' : infolist à écrire dans le fichier

Valeur de retour :

* 1 si ok, 0 en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
if (weechat_upgrade_write_object (upgrade_file, 1, &infolist))
{
    /* ok */
}
else
{
    /* erreur */
}
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
rc = weechat.upgrade_write_object(upgrade_file, object_id, infolist)

# exemple
weechat.upgrade_write_object(upgrade_file, 1, infolist)
----------------------------------------

weechat_upgrade_read
^^^^^^^^^^^^^^^^^^^^

Lit un fichier de mise à jour.

Prototype :

[source,C]
----------------------------------------
int weechat_upgrade_read (struct t_upgrade_file *upgrade_file,
                          int (*callback_read)(void *data,
                                               struct t_upgrade_file *upgrade_file,
                                               int object_id,
                                               struct t_infolist *infolist),
                          void *callback_read_data);
----------------------------------------

Paramètres :

* 'upgrade_file' : pointeur vers le fichier de mise à jour
* 'callback_read' : fonction appelée pour chaque objet lu dans le fichier de
  mise à jour, paramètres et valeur de retour :
** 'void *data' : pointeur
** 'struct t_upgrade_file *upgrade_file' : pointeur vers le fichier de mise à jour
** 'int object_id' : identifiant de l'objet
** 'struct t_infolist *infolist' : infolist avec le contenu de l'objet
** valeur de retour :
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_read_data' : pointeur donné au "callback" lorsqu'il est appelé par
  WeeChat

Valeur de retour :

* 1 si ok, 0 en cas d'erreur

Exemple en C :

[source,C]
----------------------------------------
int
my_upgrade_read_cb (struct t_upgrade_file *upgrade_file,
                    int object_id,
                    struct t_infolist *infolist)
{
    /* lecture des variables... */
    return WEECHAT_RC_OK;
}

weechat_upgrade_read (upgrade_file, &my_upgrade_read_cb, NULL);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
rc = weechat.upgrade_read(upgrade_file, callback_read, callback_read_data)

# exemple
def my_upgrade_read_cb(upgrade_file, object_id, infolist):
    # read variables...
    return weechat.WEECHAT_RC_OK

weechat.upgrade_read(upgrade_file, "my_upgrade_read_cb", ""))
----------------------------------------

weechat_upgrade_close
^^^^^^^^^^^^^^^^^^^^^

Ferme un fichier de mise à jour.

Prototype :

[source,C]
----------------------------------------
void weechat_upgrade_close (struct t_upgrade_file *upgrade_file);
----------------------------------------

Paramètres :

* 'upgrade_file' : pointeur vers le fichier de mise à jour

Exemple en C :

[source,C]
----------------------------------------
weechat_upgrade_close (upgrade_file);
----------------------------------------

Script (Python) :

[source,python]
----------------------------------------
# prototype
weechat.upgrade_close(upgrade_file)

# exemple
weechat.upgrade_close(upgrade_file)
----------------------------------------
