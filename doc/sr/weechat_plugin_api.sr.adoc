= WeeChat референтни приручник API додатака
:author: Sébastien Helleu
:email: flashcode@flashtux.org
:lang: sr
include::includes/attributes-sr.adoc[]

Превод:

* Иван Пешић (<ivan.pesic@gmail.com>), 2025.

Ово упутство описује WeeChat чет клијент и део је програма WeeChat.

Последња верзија овог документа се налази на
https://weechat.org/doc/[овој страници ^↗^^].

[[introduction]]
== Увод

WeeChat (Wee Enhanced Environment for Chat) је бесплатни чет клијент, једноставан и брз, дизајниран за многе оперативне системе.

Ово упутство документује API додатака програма WeeChat, који за интеракцију са WeeChat језгром користе C додаци.

[[plugins_in_weechat]]
== Додаци у програму WeeChat

Додатак је C програм који може да позива функције програма WeeChat дефинисане у интерфејсу.

Овом C програму нису потребни WeeChat изворни фајлови да би се компајлирао и може динамички да се учита у програм WeeChat командом `/plugin`.

Додатак мора да буде динамичка библиотека, коју оперативни систем динамички учитава. Под GNU/Linux, фајл има „.so” екстензију, а „.dll” под системом Windows.

Додатак мора да укључи фајл „weechat-plugin.h” (који се налази у изворном коду програма WeeChat). Овај фајл дефинише структуре и типове који се користе за комуникацију са програмом WeeChat.

Да бисте позивали функције програма WeeChat у формату који је приказан у <<plugin_api>>, у функцији <<_weechat_plugin_init,weechat_plugin_init>> морате декларисати и иницијализовати следећи глобални показивач:

[source,c]
----
struct t_weechat_plugin *weechat_plugin;
----

[[macros]]
=== Макрои

Додатак мора да користи неке макрое (за дефиницију неких променљивих):

WEECHAT_PLUGIN_NAME("име")::
    име додатка

WEECHAT_PLUGIN_DESCRIPTION("опис")::
    кратак опис додатка

WEECHAT_PLUGIN_AUTHOR("author")::
    име аутора

WEECHAT_PLUGIN_VERSION("1.0")::
    верзија додатка plugin version

WEECHAT_PLUGIN_LICENSE("GPL3")::
    лиценца додатка

WEECHAT_PLUGIN_PRIORITY(1000)::
    приоритет додатка (није обавезно, погледајте испод)

[[main_functions]]
=== Главне функције

Додатак мора да користи две функције:

* weechat_plugin_init
* weechat_plugin_end

==== weechat_plugin_init

Ова функција се позива када програм WeeChat учита додатак.

Прототип:

[source,c]
----
int weechat_plugin_init (struct t_weechat_plugin *plugin,
                         int argc, char *argv[]);
----

Аргументи:

* _plugin_: показивач на структуру додатка програма WeeChat, користи се за иницијализацију погодног глобалног показивача `+weechat_plugin+`
* _argc_: број аргумената за додатак
* _argv_: аргументи за додатак (погледајте испод)

Повратна вредност:

* _WEECHAT_RC_OK_ ако је успешно (додатак ће се учитати)
* _WEECHAT_RC_ERROR_ ако је дошло до грешке (додатак се НЕЋЕ учитати)

[[plugin_arguments]]
===== Аргументи додатка

Када програм WeeChat учита додатак, он прима листу аргумената у параметру `argv` и број аргумената у `argc`.

Аргументи могу бити:

* аргументи командне линије када се покреће WeeChat бинарни фајл,
* аргументи дати команди `/plugin load xxx`, када корисник ручно учитава додатак.

Када аргументи долазе из командне линије, додатку се прослеђују само следећи аргументи:

*-a*, *--no-connect*::
    Искључује ауто повезивање са серверима током покретања програма WeeChat.

*-s*, *--no-script*::
    Искључује ауто учитавање скрипти.

*додатак:опција*::
    Опције за додатак: шаљу се само опције у вези додатка, на пример додатку „irc” се шаљу само опције које почињу на `irc:`.

[[plugin_priority]]
===== Приоритет додатка

Када се додаци аутоматски учитавају (на пример, током покретања), програм WeeChat најпре учитава све додатке, па затим позива _init_ функције, користећи приоритет дефинисан у сваком додатку. Висок приоритет значи да се _init_ функција прва позива.

Подразумевани приоритет је 1000 (са тим приоритетом, додатак се учитава након свих подразумеваних додатака).

Подразумевани додаци програма WeeChat се иницијализују у следећем редоследу:

include::{autogendir}/autogen_api_plugins_priority.sr.adoc[tag=plugins_priority]

==== weechat_plugin_end

Ова функција се позива када програм WeeChat уклони додатак из меморије.

Прототип:

[source,c]
----
int weechat_plugin_end (struct t_weechat_plugin *plugin);
----

Аргументи:

* _plugin_: показивач на структуру додатка програма WeeChat

Повратна вредност:

* _WEECHAT_RC_OK_ ако је успешно
* _WEECHAT_RC_ERROR_ ако је дошло до грешке

[[compile_plugin]]
=== Компајлирање додатка

Компајлирање не захтева WeeChat изворне фајлове, неопходан је само фајл _weechat-plugin.h_.

Да бисте компајлирали додатак који има само један фајл „toto.c” (на систему GNU/Linux):

[source,shell]
----
gcc -fPIC -Wall -c toto.c
gcc -shared -fPIC -o toto.so toto.o
----

[[load_plugin]]
=== Учитавање додатка

Копирајте фајл _toto.so_ у системски директоријум додатака (на пример _/usr/local/lib/weechat/plugins_) или у корисников директоријум додатака (на пример _/home/user/.local/share/weechat/plugins_).

У програму WeeChat:

----
/plugin load toto
----

[[plugin_example]]
=== Пример додатка

Комплетан пример додатка који обезбеђује команду `/double`: приказује аргументе два пута у текућем баферу, или два пута извршава команду (ОК, то и није баш нешто корисно, али ово је само пример!):

[source,c]
----
#include <stdlib.h>

#include "weechat-plugin.h"

WEECHAT_PLUGIN_NAME("double");
WEECHAT_PLUGIN_DESCRIPTION("Test plugin for WeeChat");
WEECHAT_PLUGIN_AUTHOR("Sébastien Helleu <flashcode@flashtux.org>");
WEECHAT_PLUGIN_VERSION("0.1");
WEECHAT_PLUGIN_LICENSE("GPL3");

struct t_weechat_plugin *weechat_plugin = NULL;


/* функција повратног позива за команду "/double" */

int
command_double_cb (const void *pointer, void *data,
                   struct t_gui_buffer *buffer,
                   int argc, char **argv, char **argv_eol)
{
    /* усрећите C компајлер */
    (void) pointer;
    (void) data;
    (void) buffer;
    (void) argv;

    if (argc > 1)
    {
        weechat_command (NULL, argv_eol[1]);
        weechat_command (NULL, argv_eol[1]);
    }

    return WEECHAT_RC_OK;
}

int
weechat_plugin_init (struct t_weechat_plugin *plugin,
                     int argc, char *argv[])
{
    weechat_plugin = plugin;

    weechat_hook_command ("double",
                          "Display two times a message "
                          "or execute two times a command",
                          "message | command",
                          "message: message to display two times\n"
                          "command: command to execute two times",
                          NULL,
                          &command_double_cb, NULL, NULL);

    return WEECHAT_RC_OK;
}

int
weechat_plugin_end (struct t_weechat_plugin *plugin)
{
    /* усрећите C компајлер */
    (void) plugin;

    return WEECHAT_RC_OK;
}
----

[[plugin_api]]
== API додатака

Поглавља која следе описују функције у API, сортиране по категорији.

За сваку функцију, дајемо:

* опис функције,
* C прототип,
* детаље аргумената,
* повратну вредност
* C пример,
* пример у Python скрипти (синтакса за остале скрипт језике је слична).

[[registering]]
=== Регистрација

Функције за регистрацију скрипте: користе се само у API скриптовања, не у C API.

==== register

Регистрација скрипте.

За више информација, погледајте link:weechat_plugin_api.sr.html[WeeChat водич за скриптовање ^↗^^].

Скрипта (Python):

[source,python]
----
# прототип
def register(name: str, author: str, version: str, license: str, description: str, shutdown_function: str, charset: str) -> int: ...
----

[NOTE]
Ова функција не постоји у C API.

[[plugins]]
=== Додаци

Функције које враћају инфо о додацима.

==== plugin_get_name

Враћа име додатка.

Прототип:

[source,c]
----
const char *weechat_plugin_get_name (struct t_weechat_plugin *plugin);
----

Аргументи:

* _plugin_: показивач на структуру WeeChat додатка (може бити NULL)

Повратна вредност:

* име додатка, „core” за језгро програма WeeChat (ако је показивач на додатак NULL)

C пример:

[source,c]
----
const char *name = weechat_plugin_get_name (plugin);
----

Скрипта (Python):

[source,python]
----
# прототип
def plugin_get_name(plugin: str) -> str: ...

# пример
plugin = weechat.buffer_get_pointer(weechat.current_buffer(), "plugin")
name = weechat.plugin_get_name(plugin)
----

[[strings]]
=== Стрингови

Многе стринг функције наведене испод су већ доступне кроз стандардне C функције, али се препоручује да користите функције у овом API јер су оне безбедне за UTF-8 и локал.

==== charset_set

Поставља нови скуп карактера додатка (подразумевани скуп карактера је _UTF-8_, тако да ако ваш додатак користи _UTF-8_, нема потребе да позивате ову функцију).

Прототип:

[source,c]
----
void weechat_charset_set (const char *charset);
----

Аргументи:

* _charset_: нови скуп карактера који желите да користите

C пример:

[source,c]
----
weechat_charset_set ("iso-8859-1");
----

Скрипта (Python):

[source,python]
----
# прототип
def charset_set(charset: str) -> int: ...

# пример
weechat.charset_set("iso-8859-1")
----

==== iconv_to_internal

Конвертује стринг у интерни скуп карактера програма WeeChat (UTF-8).

Прототип:

[source,c]
----
char *weechat_iconv_to_internal (const char *charset, const char *string);
----

Аргументи:

* _charset_: скуп карактера који се конвертује
* _string_: стринг који се конвертује

Повратна вредност:

* конвертовани стринг (након употребе мора да се ослободи позивом „free”)

C пример:

[source,c]
----
char *str = weechat_iconv_to_internal ("iso-8859-1", "iso string: é à");
/* ... */
free (str);
----

Скрипта (Python):

[source,python]
----
# прототип
def iconv_to_internal(charset: str, string: str) -> str: ...

# пример
str = weechat.iconv_to_internal("iso-8859-1", "iso string: é à")
----

==== iconv_from_internal

Конвертује стринг из интерног скупа карактера програма WeeChat (UTF-8) у неки други.

Прототип:

[source,c]
----
char *weechat_iconv_from_internal (const char *charset, const char *string);
----

Аргументи:

* _charset_: циљни скуп карактера
* _string_: стринг који се конвертује

Повратна вредност:

* конвертовани стринг (након употребе мора да се ослободи позивом „free”)

C пример:

[source,c]
----
char *str = weechat_iconv_from_internal ("iso-8859-1", "utf-8 string: é à");
/* ... */
free (str);
----

Скрипта (Python):

[source,python]
----
# прототип
def iconv_from_internal(charset: str, string: str) -> str: ...

# пример
str = weechat.iconv_from_internal("iso-8859-1", "utf-8 string: é à")
----

==== gettext

Враћа преведени стринг (зависно од локалног језика).

Прототип:

[source,c]
----
const char *weechat_gettext (const char *string);
----

Аргументи:

* _string_: стринг који треба да се преведе

Повратна вредност:

* преведени стринг или _string_ ако не постоји превод на локални језик

C пример:

[source,c]
----
char *str = weechat_gettext ("hello");
----

Скрипта (Python):

[source,python]
----
# прототип
def gettext(string: str) -> str: ...

# пример
str = weechat.gettext("hello")
----

==== ngettext

Враћа преведени стринг користећи једнину или облик множине, зависно од аргумента _count_.

Прототип:

[source,c]
----
const char *weechat_ngettext (const char *string, const char *plural,
                              int count);
----

Аргументи:

* _string_: стринг који треба да се преведе, у облику једнине
* _plural_: стринг који треба да се преведе, у облику множине
* _count_: користи се за избор између једнине и облика множине (избор се врши сагласно са локалним језиком)

Повратна вредност:

* преведени стринг или _string_ / _plural_ ако се не постоји превод на локални језик

C пример:

[source,c]
----
char *str = weechat_ngettext ("file", "files", num_files);
----

Скрипта (Python):

[source,python]
----
# прототип
def ngettext(string: str, plural: str, count: int) -> str: ...

# пример
num_files = 2
str = weechat.ngettext("file", "files", num_files)
----

==== asprintf

_WeeChat ≥ 4.3.0._

Форматира поруку у стрингу који је алоцирала функција.

[NOTE]
Ова функција је дефинисана за системе на којима није доступна GNU функција
`asprintf()`. +
Понашање је скоро исто, осим што се у случају грешке `*result` поставља на NULL.

Прототип:

[source,c]
----
int weechat_asprintf (char **result, const char *fmt, ...);
----

Аргументи:

* _result_: показивач на стринг показивач
* _fmt_: стринг формата

Повратна вредност:

* број бајтова које уписан у `*result` (не рачунајући завршни null бајт),
  негативна вредност у случају грешке.

C пример:

[source,c]
----
char *str;

if (weechat_asprintf (&str, "%s, %d", "test", 42) >= 0)
{
    /* *str == "test, 42" */
    /* ... */
    free (str);
}
else
{
    /* error: *str == NULL */
}
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== strndup

Враћа дуплирани стринг, са максималним бројем бајтова.

Прототип:

[source,c]
----
char *weechat_strndup (const char *string, int bytes);
----

Аргументи:

* _string_: стринг који се дуплира
* _bytes_: максимални број бајтова који може да се дуплира

Повратна вредност:

* дуплирани стринг (након употребе мора да се ослободи позивом „free”)

C пример:

[source,c]
----
char *str = weechat_strndup ("abcdef", 3);  /* резултат: „abc” */
/* ... */
free (str);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_cut

_WeeChat ≥ 3.3._

Одсеца стринг након датог броја карактера и додаје необавезни суфикс на
крај остатка стринга.

Прототип:

[source,c]
----
char *weechat_string_cut (const char *string, int length, int count_suffix, int screen, const char *cut_suffix);
----

Аргументи:

* _string_: стринг које треба да се скрати
* _length_: макс дужина
* _count_suffix_: ако је 1, дужина суфикса се урачунава у макс дужину
* _screen_: ако је 1, одсецање је базирано на ширини приказаних карактера
* _cut_suffix_: суфикс који се додаје након што се стринг одсече

Повратна вредност:

* скраћени стринг (након употребе мора да се ослободи позивом „free”)

C пример:

[source,c]
----
char *str = weechat_string_cut ("this is a test", 5, 1, 1, "…");  /* result: "this…" */
/* ... */
free (str);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_tolower

_Ажурирано у верзији 3.8._

Враћа стринг у којем су велика слова претворена у мала.

[NOTE]
Понашање је измењено у верзији 3.8: сада се сва велика слова исправно
претварају у мала (позивом функције `towlower`), не само из опсега
`A` до `Z`. +
Уз то, враћа се ново алоцирани стринг и он мора да се ослободи након употребе.

Прототип:

[source,c]
----
char *weechat_string_tolower (const char *string);
----

Аргументи:

* _string_: стринг који се конвертује

Повратна вредност:

* стринг од малих слова (након употребе мора да се ослободи позивом „free”)

C пример:

[source,c]
----
char *str = weechat_string_tolower ("ABCD_É");  /* result: „abcd_é” */
/* ... */
free (str);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_toupper

_Ажурирано у верзији 3.8._

Враћа стринг у којем су мала слова претворена у велика.

[NOTE]
Понашање је измењено у верзији 3.8: сада се сва велика слова исправно
претварају у мала (позивом функције `towupper`), не само из опсега
`a` до `z`. +
Уз то, враћа се ново алоцирани стринг и он мора да се ослободи након употребе.

Прототип:

[source,c]
----
char *weechat_string_toupper (const char *string);
----

Аргументи:

* _string_: стринг који се конвертује

Повратна вредност:

* стринг од великих слова (након употребе мора да се ослободи позивом „free”)

C пример:

[source,c]
----
char *str = weechat_string_toupper ("abcd_é");  /* result: „ABCD_É” */
/* ... */
free (str);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_charcmp

_Ажурирано у верзији 1.0, 3.8._

Пореди два карактера.

Прототип:

[source,c]
----
int weechat_string_charcmp (const char *string1, const char *string2);
----

Аргументи:

* _string1_: први стринг за поређење
* _string2_: други стринг за поређење

Вредност која се враћа:

* аритметички резултат одузимања првог UTF-8 карактера у _string2_
  од првог UTF-8 карактера у _string1_:
** < 0 ако је char1 < char2
** 0 ако је char1 == char2
** > 0 ако је char1 > char2

C пример:

[source,c]
----
int diff = weechat_string_charcmp ("aaa", "ccc");  /* == -2 */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_charcasecmp

_Ажурирано у верзији 1.0, 3.8._

Пореди два карактера, уз игнорисање разлике у величини слова.

[NOTE]
Понашање је промењено у верзији 3.8: сада се сва велика слова исправно претварају
у мала (позивом функције `towlower`), заједно уз опсег `A` до `Z`.

Прототип:

[source,c]
----
int weechat_string_charcasecmp (const char *string1, const char *string2);
----

Аргументи:

* _string1_: први стринг за поређење
* _string2_: други стринг за поређење

Вредност која се враћа:

* аритметички резултат одузимања првог UTF-8 карактера у _string2_
  (претвореног у мало слово) од првог UTF-8 карактера у _string1_
  (претвореног у мало слово):
** < 0 ако је char1 < char2
** 0 ако је char1 == char2
** > 0 ако је char1 > char2

C пример:

[source,c]
----
int diff = weechat_string_charcasecmp ("aaa", "CCC");  /* == -2 */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== strcmp

_WeeChat ≥ 3.8._

Поређење стрингова које разликује величину слова.

Прототип:

[source,c]
----
int weechat_strcmp (const char *string1, const char *string2);
----

Аргументи:

* _string1_: први стринг за поређење
* _string2_: други стринг за поређење

Повратна вредност:

Вредност која се враћа:

* аритметички резултат одузимања последњег поређеног UTF-8 карактера у
  _string2_ од последње поређеног UTF-8 карактера у _string1_:
** < 0 ако је string1 < string2
** 0 ако је string1 == string2
** > 0 ако је string1 > string2

C пример:

[source,c]
----
int diff = weechat_strcmp ("aaa", "ccc");  /* == -2 */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== strncmp

_WeeChat ≥ 3.8._

Поређење стрингова које води рачуна о величини слова, до _max_ карактера.

Прототип:

[source,c]
----
int weechat_strncmp (const char *string1, const char *string2, int max);
----

Аргументи:

* _string1_: први стринг за поређење
* _string2_: други стринг за поређење
* _max_: максимални број карактера који се пореде

Вредност која се враћа:

* аритметички резултат одузимања последњег поређеног UTF-8 карактера у
  _string2_ од последње поређеног UTF-8 карактера у _string1_:
** < 0 ако је string1 < string2
** 0 ако је string1 == string2
** > 0 ако је string1 > string2

C пример:

[source,c]
----
int diff = weechat_strncmp ("aabb", "aacc", 2);  /* == 0 */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== strcasecmp

_Ажурирано у верзији 1.0, 3.8._

Поређење стрингова које не води рачуна о величини слова.

[NOTE]
Понашање је промењено у верзији 3.8: сада се сва велика слова исправно
претварају у мала (позивом функције `towlower`), заједно уз опсег
`A` до `Z`.

Прототип:

[source,c]
----
int weechat_strcasecmp (const char *string1, const char *string2);
----

Аргументи:

* _string1_: први стринг за поређење
* _string2_: други стринг за поређење

Вредност која се враћа:

* аритметички резултат одузимања последњег поређеног UTF-8 карактера у
  _string2_ (претвореног у мало слово) од последњег поређеног UTF-8 карактера у _string1_
  (претвореног у мало слово):
** < 0 ако је string1 < string2
** 0 ако је string1 == string2
** > 0 ако је string1 > string2

C пример:

[source,c]
----
int diff;
diff = weechat_strcasecmp ("aaa", "CCC");    /* == -2 */
diff = weechat_strcasecmp ("noël", "NOËL");  /* == 0  */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== strcasecmp_range

_WeeChat ≥ 0.3.7, ажурирано у верзији 1.0, 3.8._

Поређење стрингова независно од величине слова и локал подешавања, употребом опсега за поређење величине слова.

Прототип:

[source,c]
----
int weechat_strcasecmp_range (const char *string1, const char *string2, int range);
----

Аргументи:

* _string1_: први стринг за поређење
* _string2_: други стринг за поређење
* _range_: број карактера у поређењу по величини слова, на пример:
** 26: `+A-Z+` се постављају на `+a-z+`
** 29: `+A-Z [ \ ]+` се постављају на `+a-z { | }+`
** 30: `+A-Z [ \ ] ^+` се постављају на `+a-z { | } ~+`

[NOTE]
Вредности 29 и 30 користе неки протоколи, као што је IRC.

Вредност која се враћа:

* аритметички резултат одузимања последњег поређеног UTF-8 карактера у
  _string2_ (претвореног у мало слово) од последњег поређеног UTF-8 карактера у _string1_
  (претвореног у мало слово):
** < 0 ако је string1 < string2
** 0 ако је string1 == string2
** > 0 ако је string1 > string2

C пример:

[source,c]
----
int diff = weechat_strcasecmp_range ("nick{away}", "NICK[away]", 29);  /* == 0 */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== strncasecmp

_Ажурирано у верзији 1.0, 3.8._

Поређење стрингова које не прави разлику у величини слова, за _max_ карактера.

[NOTE]
Понашање је промењено у верзији 3.8: сада се сва велика слова исправно
претварају у мала (позивом функције `towlower`), заједно уз опсег
`A` до `Z`.

Прототип:

[source,c]
----
int weechat_strncasecmp (const char *string1, const char *string2, int max);
----

Аргументи:

* _string1_: први стринг за поређење
* _string2_: други стринг за поређење
* _max_: максимални број карактера који се пореде

Вредност која се враћа:

* аритметички резултат одузимања последњег поређеног UTF-8 карактера у
  _string2_ (претвореног у мало слово) од последњег поређеног UTF-8 карактера у _string1_
  (претвореног у мало слово):
** < 0 ако је string1 < string2
** 0 ако је string1 == string2
** > 0 ако је string1 > string2

C пример:

[source,c]
----
int diff = weechat_strncasecmp ("aabb", "AACC", 2);  /* == 0 */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== strncasecmp_range

_WeeChat ≥ 0.3.7, ажурирано у верзији 1.0, 3.8._

Поређење стрингова независно од величине слова и локал подешавања, за _max_ карактера, користећи опсег за поређење величине слова.

Прототип:

[source,c]
----
int weechat_strncasecmp_range (const char *string1, const char *string2, int max, int range);
----

Аргументи:

* _string1_: први стринг за поређење
* _string2_: други стринг за поређење
* _max_: максимални број карактера који се пореде
* _range_: број карактера у поређењу по величини слова, на пример:
** 26: `+A-Z+` се постављају на `+a-z+`
** 29: `+A-Z [ \ ]+` се постављају на `+a-z { | }+`
** 30: `+A-Z [ \ ] ^+` се постављају на `+a-z { | } ~+`

[NOTE]
Вредности 29 и 30 користе неки протоколи, као што је IRC.

Вредност која се враћа:

* аритметички резултат одузимања последњег поређеног UTF-8 карактера у
  _string2_ (претвореног у мало слово) од последњег UTF-8 карактера у _string1_
  (претвореног у мало слово):
** < 0 ако је string1 < string2
** 0 ако је string1 == string2
** > 0 ако је string1 > string2

C пример:

[source,c]
----
int diff = weechat_strncasecmp_range ("nick{away}", "NICK[away]", 6, 29);  /* == 0 */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== strcmp_ignore_chars

_Ажурирано у верзији 1.0, 3.8._

Поређење стрингова које игнорише неке карактере.

Прототип:

[source,c]
----
int weechat_strcmp_ignore_chars (const char *string1, const char *string2,
                                 const char *chars_ignored,
                                 int case_sensitive);
----

Аргументи:

* _string1_: први стринг за поређење
* _string2_: други стринг за поређење
* _chars_ignored_: стринг са карактерима који се игноришу
* _case_sensitive_: 1 за поређење које прави разлику у величини слова, у супротном 0

[NOTE]
Понашање се променило у верзији 3.8 када се _case_sensitive_ постави на 0: сада се
сва велика слова исправно претварају у мала (позивом функције `towlower`),
заједно уз опсег `A` до `Z`.

Вредност која се враћа:

* аритметички резултат одузимања последњег поређеног UTF-8 карактера у
  _string2_ (претвореног у мало слово) од последњег поређеног UTF-8
  карактера у _string1_ (претвореног у мало слово ако је _case_sensitive_
  постављено на 0):
** < 0 ако је string1 < string2
** 0 ако је string1 == string2
** > 0 ако је string1 > string2

C пример:

[source,c]
----
int diff = weechat_strcmp_ignore_chars ("a-b", "--a-e", "-", 1);  /* == -3 */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== strcasestr

_Ажурирано у верзији 1.3, 3.8._

Претрага стринга која не прави разлику у величини слова.

[NOTE]
Понашање се променило у верзији 3.8: сада се сва велика слова исправно
претварају у мала (позивом функције `towlower`), заједно уз опсег
`A` до `Z`.

Прототип:

[source,c]
----
const char *weechat_strcasestr (const char *string, const char *search);
----

Аргументи:

* _string_: стринг
* _search_: стринг који се тражи у _string_

Повратна вредност:

* показивач на пронађени стринг, или NULL ако се не пронађе (_WeeChat ≥ 1.3_: показивач се враћа је _const char *_ уместо _char *_)

C пример:

[source,c]
----
const char *pos = weechat_strcasestr ("aBcDeF", "de");  /* резултат: показивач на "DeF" */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== strlen_screen

_WeeChat ≥ 0.4.2, ажурирано у верзији 3.8._

Враћа број карактера који су потребни да се на екран испише UTF-8 стринг.

WeeChat кодови боја се прескачу у не броје се у резултату (ово је једина
разлика у односу на функцију <<_utf8_strlen_screen,utf8_strlen_screen>>).

Прототип:

[source,c]
----
int weechat_strlen_screen (const char *string);
----

Аргументи:

* _string_: стринг

Повратна вредност:

* број карактера на екрану који су потребни да се испише UTF-8 стринг

C пример:

[source,c]
----
int length_on_screen = weechat_strlen_screen ("é");  /* == 1 */
----

Скрипта (Python):

[source,python]
----
# прототип
def strlen_screen(string: str) -> int: ...

# пример
length = weechat.strlen_screen("é")  # 1
----

==== string_match

_Ажурирано у верзији 1.0, 3.8._

Провера да ли стринг задовољава маску.

Прототип:

[source,c]
----
int weechat_string_match (const char *string, const char *mask,
                          int case_sensitive);
----

Аргументи:

* _string_: стринг
* _mask_: маска са џокерима (`+*+`), сваки џокер хвата 0 или више карактера у стрингу
* _case_sensitive_: 1 за поређење које прави разлику у величини слова, у супротном 0

[NOTE]
Почевши од верзије 1.0, у маски се дозвољава употреба џокера (не само на почетку/крају маске).

[NOTE]
Понашање се променило у верзији 3.8 када се _case_sensitive_ постави на 0: сада се
сва велика слова исправно претварају у мала (позивом функцкје `towlower`), заједно
уз опсег `A` до `Z`.

Повратна вредност:

* 1 ако стринг задовољава маску, у супротном 0

C пример:

[source,c]
----
int match1 = weechat_string_match ("abcdef", "abc*", 0);   /* == 1 */
int match2 = weechat_string_match ("abcdef", "*dd*", 0);   /* == 0 */
int match3 = weechat_string_match ("abcdef", "*def", 0);   /* == 1 */
int match4 = weechat_string_match ("abcdef", "*de*", 0);   /* == 1 */
int match5 = weechat_string_match ("abcdef", "*b*d*", 0);  /* == 1 */
----

Скрипта (Python):

[source,python]
----
# прототип
def string_match(string: str, mask: str, case_sensitive: int) -> int: ...

# примери
match1 = weechat.string_match("abcdef", "abc*", 0)   # == 1
match2 = weechat.string_match("abcdef", "*dd*", 0)   # == 0
match3 = weechat.string_match("abcdef", "*def", 0)   # == 1
match4 = weechat.string_match("abcdef", "*de*", 0)   # == 1
match5 = weechat.string_match("abcdef", "*b*d*", 0)  # == 1
----

==== string_match_list

_WeeChat ≥ 2.5, ажурирано у верзији 3.8._

Проверава да ли стринг задовољава листу маски, при чему је дозвољена употреба негативних маски у формату „!реч”. Негативна маска има виши приоритет у односу на стандардну маску.

Прототип:

[source,c]
----
int weechat_string_match_list (const char *string, const char **masks,
                               int case_sensitive);
----

Аргументи:

* _string_: стринг
* _masks_: листа маски, са NULL након последње маске у листи; свака маска се пореди са стрингом функцијом <<_string_match,string_match>>
* _case_sensitive_: 1 за поређење које прави разлику у величини слова, у супротном 0

[NOTE]
Понашање се променило у верзији 3.8 када је _case_sensitive_ постављени на 0: сада се
сва велика слова исправно претварају у мала (позивом функције `towlower`), заједно уз
опсег `A` до `Z`.

Повратна вредност:

* 1 ако стринг задовољава листу маски (барем једна од маски је задовољена и ниједна од негативних маски), у супротном 0

C пример:

[source,c]
----
const char *masks[3] = { "*", "!abc*", NULL };
int match1 = weechat_string_match_list ("abc", masks, 0);     /* == 0 */
int match2 = weechat_string_match_list ("abcdef", masks, 0);  /* == 0 */
int match3 = weechat_string_match_list ("def", masks, 0);     /* == 1 */
----

Скрипта (Python):

[source,python]
----
# прототип
def string_match_list(string: str, masks: str, case_sensitive: int) -> int: ...

# примери
match1 = weechat.string_match("abc", "*,!abc*", 0)     # == 0
match2 = weechat.string_match("abcdef", "*,!abc*", 0)  # == 0
match3 = weechat.string_match("def", "*,!abc*", 0)     # == 1
----

==== string_expand_home

_WeeChat ≥ 0.3.3._

Замењује водеће `+~+` стрингом са почетним директоријумом. Ако стринг не почиње са `+~+`, онда се враћа исти стринг.

Прототип:

[source,c]
----
char *weechat_string_expand_home (const char *path);
----

Аргументи:

* _path_: путања

Повратна вредност:

* путања са водећим `+~+` замењеним са почетним директоријумом (након употребе мора да се ослободи позивом „free”)

C пример:

[source,c]
----
char *str = weechat_string_expand_home ("~/file.txt");
/* резултат: "/home/user/file.txt" */
/* ... */
free (str);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_eval_path_home

_WeeChat ≥ 1.3, ажурирано у верзији 3.2._

Израчунава путање у 3 корака:

. замењује водеће `%h` са почетним директоријумом програма WeeChat (подразумевано data )
. замењује водеће `+~+` са корисниковим почетним директоријумом (позивом <<_string_expand_home,string_expand_home>>),
. израчунава променљиве (погледајте <<_string_eval_expression,string_eval_expression>>).

Прототип:

[source,c]
----
char *weechat_string_eval_path_home (const char *path,
                                     struct t_hashtable *pointers,
                                     struct t_hashtable *extra_vars,
                                     struct t_hashtable *options);
----

Аргументи:

* _path_: путања
* _pointers_: хеш табела за позив функције <<_string_eval_expression,string_eval_expression>>
* _extra_vars_: хеш табела за позив функције <<_string_eval_expression,string_eval_expression>>
* _options_: хеш табела за позив функције <<_string_eval_expression,string_eval_expression>>, са једним од подржаних додатних кључева:
** _directory_: WeeChat директоријум који се користи када се замењује `%h`, један од:
*** config
*** _data_ (подразумевано)
*** _cache_
*** _runtime_

Повратна вредност:

* израчуната путања (након употребе мора да се ослободи позивом „free”)

C пример:

[source,c]
----
char *str = weechat_string_eval_path_home ("${weechat_config_dir}/test.conf", NULL, NULL, NULL);
/* резултат: "/home/user/.config/weechat/test.conf" */
/* ... */
free (str);
----

Скрипта (Python):

[source,python]
----
# прототип
def string_eval_path_home(path: str, pointers: Dict[str, str], extra_vars: Dict[str, str], options: Dict[str, str]) -> str: ...

# пример
path = weechat.string_eval_path_home("${weechat_config_dir}/test.conf", {}, {}, {})
# path == "/home/user/.config/weechat/test.conf"
----

==== string_remove_quotes

Уклања знаке навода са почетка и краја стринга (ако постоје размаци испред првог знака навода или након последњег, игноришу се).

Прототип:

[source,c]
----
char *weechat_string_remove_quotes (const char *string, const char *quotes);
----

Аргументи:

* _string_: стринг
* _quotes_: стринг са листом знакова навода

Повратна вредност:

* стринг без знакова навода на почетку/крају (након употребе мора да се ослободи позивом „free”)

C пример:

[source,c]
----
char *str = weechat_string_remove_quotes (string, " 'I can't' ", "'");
/* result: "I can't" */
/* ... */
free (str);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_strip

Одсеца карактере на почетку и/или крају стринга.

Прототип:

[source,c]
----
char *weechat_string_strip (const char *string, int left, int right,
                            const char *chars);
----

Аргументи:

* _string_: стринг
* _left_: одсеца карактере с лева ако је различито од 0
* _right_: одсеца карактере с десна ако је различито од 0
* _chars_: стринг са карактерима који треба да се одсеку

Повратна вредност:

* одсечени стринг (након употребе мора да се ослободи позивом „free”)

C пример:

[source,c]
----
char *str = weechat_string_strip (".abc -", 0, 1, "- .");  /* result: ".abc" */
/* ... */
free (str);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_convert_escaped_chars

_WeeChat ≥ 1.0._

Конвертује означене карактере у њихову вредност:

* `+\"+`: знак навода
* `+\\+`: обрнута коса црта
* `+\a+`: звучно упозорење (BEL)
* `+\b+`: брисање у лево
* `+\e+`: escape
* `+\f+`: form feed
* `+\n+`: прелом линије
* `+\r+`: carriage return
* `+\t+`: хоризонтални таб
* `+\v+`: вертикални таб
* `+\0ooo+`: карактер као октална вредност (`ooo` је од 0 до 3 цифре)
* `+\xhh+`: карактер као хексадецимална вредност (`hh` је од 1 до 2 цифре)
* `+\uhhhh+`: уникод карактер као хексадецимална вредност (`hhhh` је од 1 до 4 цифре)
* `+\Uhhhhhhhh+`: уникод карактер као хексадецимална вредност (`hhhhhhhh` је од 1 до 8 цифара)

Прототип:

[source,c]
----
char *weechat_string_convert_escaped_chars (const char *string);
----

Аргументи:

* _string_: стринг

Повратна вредност:

* стринг у којем су означени карактери замењени својим вредностима (након употребе мора да се ослободи позивом „free”)

C пример:

[source,c]
----
char *str = weechat_string_convert_escaped_chars ("snowman: \\u2603");
/* str == "snowman: ☃" */
/* ... */
free (str);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_mask_to_regex

Враћа регуларни израз изграђен маском, у којем је једини специјални карактер `+*+`. Сви остали специјални карактери за регуларни израз се означавају.

Прототип:

[source,c]
----
char *weechat_string_mask_to_regex (const char *mask);
----

Аргументи:

* _mask_: маска

Повратна вредност:

* регуларни израз, као стринг (након употребе мора да се ослободи позивом „free”)

C пример:

[source,c]
----
char *str_regex = weechat_string_mask_to_regex ("test*mask");
/* резултат: "test.*mask" */
/* ... */
free (str_regex);
----

Скрипта (Python):

[source,python]
----
# прототип
def string_mask_to_regex(mask: str) -> str: ...

# пример
regex = weechat.string_mask_to_regex("test*mask")  # "test.*mask"
----

==== string_regex_flags

_WeeChat ≥ 0.3.7._

Враћа показивач на стринг након заставица и маску са заставицама за компајлирање регуларног израза.

Прототип:

[source,c]
----
const char *weechat_string_regex_flags (const char *regex, int default_flags, int *flags)
----

Аргументи:

* _regex_: POSIX проширени регуларни израз
* _default_flags_: комбинација следећих вредности (погледајте `man regcomp`):
** REG_EXTENDED
** REG_ICASE
** REG_NEWLINE
** REG_NOSUB
* _flags_: вредност показивача се поставља заставицама које се користе у регуларном изразу (подразумеване заставице + заставице постављене у регуларном изразу)

Заставице морају да се налазе на почетку регуларног израза. Формат је: „(?eins-eins)стринг”.

Дозвољене су следеће заставице:

* _e_: POSIX проширени регуларни израз (_REG_EXTENDED_)
* _i_: не прави се разлика у величини слова (_REG_ICASE_)
* _n_: оператори подударања било ког карактера се не подударају са преломом линије (_REG_NEWLINE_)
* _s_: није потребна подршка за адресирање подударања подстрингова (_REG_NOSUB_)

Повратна вредност:

* показивач у _regex_, иза заставица

C пример:

[source,c]
----
const char *regex = "(?i)test";
int flags;
const char *ptr_regex = weechat_string_regex_flags (regex, REG_EXTENDED, &flags);
/* ptr_regex == "test", flags == REG_EXTENDED | REG_ICASE */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_regcomp

_WeeChat ≥ 0.3.7._

Компајлира POSIX проширени регуларни израз користећи необавезне заставице на почетку стринга (за формат заставица, погледајте <<_string_regex_flags,string_regex_flags>>).

Прототип:

[source,c]
----
int weechat_string_regcomp (void *preg, const char *regex, int default_flags)
----

Аргументи:

* _preg_: показивач на _regex_t_ структуру
* _regex_: POSIX проширени регуларни израз
* _default_flags_: комбинација следећих вредности (погледајте `man regcomp`):
** REG_EXTENDED
** REG_ICASE
** REG_NEWLINE
** REG_NOSUB

Повратна вредност:

* исти повратни кôд као и функција `regcomp` (0 ако је OK, нека друга вредност у случају грешке, погледајте `man regcomp`)

[NOTE]
Након употребе, регуларни израз _preg_ мора да се очисти позивом „regfree”, у случају да је функција вратила 0 (OK).

C пример:

[source,c]
----
regex_t my_regex;
if (weechat_string_regcomp (&my_regex, "(?i)test", REG_EXTENDED) == 0)
{
    /* OK */
    /* ... */
    regfree (&my_regex);
}
else
{
    /* грешка */
    /* ... */
}
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_has_highlight

Проверава да ли стринг има једно или више истицања, користећи листу речи за истицање.

Прототип:

[source,c]
----
int weechat_string_has_highlight (const char *string,
                                  const char highlight_words);
----

Аргументи:

* _string_: стринг
* _highlight_words_: листа речи за истицање, раздвојених запетама

Повратна вредност:

* 1 ако стринг има једно или више истицања, у супротном 0

C пример:

[source,c]
----
int hl = weechat_string_has_highlight ("мој тест стринг", "тест,реч2");  /* == 1 */
----

Скрипта (Python):

[source,python]
----
# прототип
def string_has_highlight(string: str, highlight_words: str) -> int: ...

# пример
highlight = weechat.string_has_highlight("my test string", "test,word2")  # 1
----

==== string_has_highlight_regex

_WeeChat ≥ 0.3.4._

Проверава да ли стринг има једно или више истицања, користећи POSIX проширени регуларни израз. +
За бар једно подударање регуларног израза над стрингом, он мора бити уоквирен граничницима (карактери различити од: алфанумерика, `+-+`, `+_+` и `+|+`).

Прототип:

[source,c]
----
int weechat_string_has_highlight_regex (const char *string, const char *regex);
----

Аргументи:

* _string_: стринг
* _regex_: POSIX проширени регуларни израз

Повратна вредност:

* 1 ако стринг има једно или више истицања, у супротном 0

C пример:

[source,c]
----
int hl = weechat_string_has_highlight_regex ("мој тест стринг", "тест|реч2");  /* == 1 */
----

Скрипта (Python):

[source,python]
----
# прототип
def string_has_highlight_regex(string: str, regex: str) -> int: ...

# пример
highlight = weechat.string_has_highlight_regex("мој тест стринг", "тест|реч2")  # 1
----

==== string_replace

Замењује сва појављивања стринга неким другим стрингом.

Прототип:

[source,c]
----
char *weechat_string_replace (const char *string, const char *search,
                              const char *replace);
----

Аргументи:

* _string_: стринг
* _search_: стринг који треба да се замени
* _replace_: замена за стринг _search_

Повратна вредност:

* стринг у којем је _search_ замењено са _replace_ (након употребе мора да се ослободи позивом „free”)

C пример:

[source,c]
----
char *str = weechat_string_replace ("test", "s", "x");  /* резултат: "text" */
/* ... */
free (str);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_replace_regex

_WeeChat ≥ 1.0._

Замењује текст у стрингу помоћу регуларног израза, текста замене и необавезне функције повратног позива.

Прототип:

[source,c]
----
char *weechat_string_replace_regex (const char *string, void *regex,
                                    const char *replace, const char reference_char,
                                    char *(*callback)(void *data, const char *text),
                                    void *callback_data);
----

Аргументи:

* _string_: стринг
* _regex_: показивач на регуларни израз (_regex_t_ структура) компајлираног WeeChat функцијом <<_string_regcomp,string_regcomp>> или regcomp (погледајте `man regcomp`)
* _replace_: текст замене, у коме су дозвољене следеће референце:
** `+$0+` до `+$99+`: подударање 0 до 99 у регуларном изразу (0 је цело подударање, 1 до 99 су групе ухваћене заградама)
** `+$++`: последње подударање (са највишим бројем)
** `+$.*N+`: подударање `+N+` (може бити `+++` или `+0+` до `+99+`), у коме су сви карактери замењени са `+*+` (карактер `+*+` може бити било који карактер између размака (32) и `+~+` (126))
* _reference_char_: карактер који се користи за референце на подударања (обично је `+$+`)
* _callback_: необавезна функција повратног позива која се позива за сваку референцу у _replace_ (осим за подударања која се замењују карактером); функција повратног позива мора да врати:
** ново алоцирани стринг: он се користи као текст замене (након употребе се ослобађа)
** NULL: као текст замене се користи текст примљену у функцији повратног позива (без измена)
* _callback_data_: показивач прослеђен функцији повратног позива када се позове

Повратна вредност:

* стринг са замењеним текстом, NULL у случају проблема (након употребе мора да се ослободи позивом „free”)

C пример:

[source,c]
----
regex_t my_regex;
char *string;
if (weechat_string_regcomp (&my_regex, "([0-9]{4})-([0-9]{2})-([0-9]{2})",
                            REG_EXTENDED) == 0)
{
    string = weechat_string_replace_regex ("date: 2014-02-14", &my_regex,
                                           "$3/$2/$1", '$', NULL, NULL);
    /* string == "date: 14/02/2014" */
    if (string)
        free (string);
    regfree (&my_regex);
}
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_translate_chars

_WeeChat ≥ 3.8._

Преводи карактере у стрингу.

Прототип:

[source,c]
----
char *string_translate_chars (const char *string, const char *chars1, const char *chars2);
----

Аргументи:

* _string_: стринг
* _chars1_: стринг са карактерима који треба да се преведу
* _chars2_: стринг са карактерима замене; мора да садржи исти број
  UTF-8 карактера као _chars1_

Повратна вредност:

* стринг са преведеним карактерима, NULL ако је дошло до проблема (мора да се ослободи позивом функције „free”
  након употребе)

C примери:

[source,c]
----
/* "test" => "tEst" */
char *str = weechat_string_translate_chars ("test", "abcdef", "ABCDEF");

/* "clean the boat" => "CleAn the BoAt" */
char *str = weechat_string_translate_chars ("clean the boat", "abc", "ABC");
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_split

_Ажурирано у верзијама 2.5, 2.6._

Дели стринг по једном или више граничника.

Прототип:

[source,c]
----
char **weechat_string_split (const char *string, const char *separators,
                             const char *strip_items, int flags,
                             int num_items_max, int *num_items);
----

Аргументи:

* _string_: стринг који се дели
* _separators_: граничници који се користе за поделу
* _strip_items_: карактери који се одсецају од ставки које се враћају (лево/десно); није обавезном, може бити NULL
* _flags_: комбинација вредности која мења подразумевано понашање; ако је вредност 0, користи се подразумевано понашање (нема одсецања граничника са почетка/краја стринга, вишеструки граничници се остављају какви јесу, па могу да се врате и празни стрингови); прихватају се следеће заставице:
** WEECHAT_STRING_SPLIT_STRIP_LEFT: граничници се одсецају с лева (почетка стринга)
** WEECHAT_STRING_SPLIT_STRIP_RIGHT: граничници се одсецају с десна (краја стринга)
** WEECHAT_STRING_SPLIT_COLLAPSE_SEPS: више узастопних граничника се замењује једним
** WEECHAT_STRING_SPLIT_KEEP_EOL: крај линије се задржава у свакој вредности
* _num_items_max_: максимални број креираних ставки (0 = нема ограничења)
* _num_items_: показивач на int који садржи број креираних ставки

[NOTE]
У програму WeeChat верзије ≤ 2.4, аргумент _flags_ се звао _keep_eol_ и узимао је другачије вредности, које морају да се конвертују на следећи начин:
[width="100%", cols="1,10", options="header"]
|===
| keep_eol | flags
| 0        | WEECHAT_STRING_SPLIT_STRIP_LEFT \| WEECHAT_STRING_SPLIT_STRIP_RIGHT \| WEECHAT_STRING_SPLIT_COLLAPSE_SEPS
| 1        | WEECHAT_STRING_SPLIT_STRIP_LEFT \| WEECHAT_STRING_SPLIT_STRIP_RIGHT \| WEECHAT_STRING_SPLIT_COLLAPSE_SEPS \| WEECHAT_STRING_SPLIT_KEEP_EOL
| 2        | WEECHAT_STRING_SPLIT_STRIP_LEFT \| WEECHAT_STRING_SPLIT_COLLAPSE_SEPS \| WEECHAT_STRING_SPLIT_KEEP_EOL
|===

Повратна вредност:

* низ стрингова, NULL у случају проблема (након употребе мора да се ослободи позивом <<_string_free_split,string_free_split>>)

C пример:

[source,c]
----
char **argv;
int argc;

argv = weechat_string_split ("abc de  fghi ", " ", NULL, 0, 0, &argc);
/* result: argv[0] == "abc"
           argv[1] == "de"
           argv[2] == ""
           argv[3] == "fghi"
           argv[4] = ""
           argv[5] == NULL
           argc == 5
*/
weechat_string_free_split (argv);

argv = weechat_string_split ("abc de  fghi ", " ", NULL,
                             WEECHAT_STRING_SPLIT_STRIP_LEFT
                             | WEECHAT_STRING_SPLIT_STRIP_RIGHT
                             | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS,
                             0, &argc);
/* result: argv[0] == "abc"
           argv[1] == "de"
           argv[2] == "fghi"
           argv[3] == NULL
           argc == 3
*/
weechat_string_free_split (argv);

argv = weechat_string_split ("abc de  fghi ", " ", NULL,
                             WEECHAT_STRING_SPLIT_STRIP_LEFT
                             | WEECHAT_STRING_SPLIT_STRIP_RIGHT
                             | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS
                             | WEECHAT_STRING_SPLIT_KEEP_EOL,
                             0, &argc);
/* result: argv[0] == "abc de  fghi"
           argv[1] == "de  fghi"
           argv[2] == "fghi"
           argv[3] == NULL
           argc == 3
*/
weechat_string_free_split (argv);

argv = weechat_string_split ("abc de  fghi ", " ", NULL,
                             WEECHAT_STRING_SPLIT_STRIP_LEFT
                             | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS
                             | WEECHAT_STRING_SPLIT_KEEP_EOL,
                             0, &argc);
/* result: argv[0] == "abc de  fghi "
           argv[1] == "de  fghi "
           argv[2] == "fghi "
           argv[3] == NULL
           argc == 3
*/
weechat_string_free_split (argv);

argv = weechat_string_split (" abc, de,, fghi ", ",", " ",
                             WEECHAT_STRING_SPLIT_STRIP_LEFT
                             | WEECHAT_STRING_SPLIT_STRIP_RIGHT
                             | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS,
                             0, &argc);
/* result: argv[0] == "abc"
           argv[1] == "de"
           argv[2] == "fghi"
           argv[3] == NULL
           argc == 3
*/
weechat_string_free_split (argv);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_split_shell

_WeeChat ≥ 1.0._

Дели стринг на начин на који командно окружење дели команду са аргументима.

Ова функција је C конверзија Python класе "shlex" (фајл: Lib/shlex.py у
Python репозиторијуму), погледајте
https://docs.python.org/3/library/shlex.html[ову страницу ^↗^^].

Прототип:

[source,c]
----
char **weechat_string_split_shell (const char *string, int *num_items);
----

Аргументи:

* _string_: стринг који се дели
* _num_items_: показивач на int који садржи број креираних ставки

Повратна вредност:

* низ стрингова, NULL у случају проблема (након употребе мора да се ослободи позивом <<_string_free_split,string_free_split>>)

C пример:

[source,c]
----
char **argv;
int argc;
argv = weechat_string_split_shell ("test 'first arg'  \"second arg\"", &argc);
/* result: argv[0] == "test"
           argv[1] == "first arg"
           argv[2] == "second arg"
           argv[3] == NULL
           argc == 3
*/
weechat_string_free_split (argv);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_free_split

Ослобађа меморију коју је употребило дељење стринга.

Прототип:

[source,c]
----
void weechat_string_free_split (char **split_string);
----

Аргументи:

* _split_string_: стринг подељен функцијом <<_string_split,string_split>>

C пример:

[source,c]
----
char *argv;
int argc;
argv = weechat_string_split (string, " ", 0, 0, &argc);
/* ... */
weechat_string_free_split (argv);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_rebuild_split_string

_Ажурирано у верзији 3.7._

Поново изграђује стринг уз помоћ стринга за поделу, користећи необавезни граничник и индекс
први/последњи.

Прототип:

[source,c]
----
char *weechat_string_rebuild_split_string (char **split_string,
                                           const char *separator,
                                           int index_start, int index_end);
----

Аргументи:

* _split_string_: стринг подељен функцијом <<_string_split,string_split>>
* _separator_: стринг који се користи за раздвајање стрингова (Може да буде NULL или празан стринг)
* _index_start_: индекст првог стринга који треба да се користи (≥ 0)
* _index_end_: индекс последњег стринга који треба да се користи
  (мора бити ≥ _index_start_; може да се користи специјална вредност -1 да се употребе сви аргументи
  док се не наиђе на NULL)

Повратна вредност:

* стринг изграђен са (након употребе мора да се ослободи позивом „free”)

C пример:

[source,c]
----
char **argv;
int argc;
argv = weechat_string_split ("abc def ghi", " ", 0, 0, &argc);
char *str = weechat_string_rebuild_split_string (argv, ";", 0, -1);
/* str == "abc;def;ghi" */
/* ... */
free (str);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_split_command

Дели листу команди раздвојених са _separator_ (које у стрингу могу да се означе са `+\+`).

Прототип:

[source,c]
----
char **weechat_string_split_command (const char *command, char separator);
----

Аргументи:

* _command_: команда која се дели
* _separator_: граничник

Повратна вредност:

* низ стрингова, NULL у случају проблема (након употребе мора да се ослободи позивом <<_free_split_command,free_split_command>>)

C пример:

[source,c]
----
char **argv = weechat_string_split_command ("/command1 arg;/command2", ';');
/* result: argv[0] == "/command1 arg"
           argv[1] == "/command2"
           argv[2] == NULL
*/
weechat_free_split_command (argv);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_free_split_command

Ослобађа меморију коју је употребила команда поделе.

Прототип:

[source,c]
----
void weechat_string_free_split_command (char **split_command);
----

Аргументи:

* _split_command_: команда подељена са <<_string_split_command,string_split_command>>

C пример:

[source,c]
----
char **argv = weechat_string_split_command ("/command1 arg;/command2", ';');
/* ... */
weechat_free_split_command (argv);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_format_size

Изграђује стринг са форматираном величином фајла и јединицама преведеним на локални језик.

Прототип:

[source,c]
----
char *weechat_string_format_size (unsigned long long size);
----

Аргументи:

* _size_: величина (у бајтовима)

Повратна вредност:

* форматирани стринг (након употребе мора да се ослободи позивом „free”)

C примери:

[source,c]
----
/* примери са енглеским локал подешавањем */

char *str = weechat_string_format_size (0);  /* str == "0 bytes" */
/* ... */
free (str);

char *str = weechat_string_format_size (1);  /* str == "1 byte" */
/* ... */
free (str);

char *str = weechat_string_format_size (200);  /* str == "200 bytes" */
/* ... */
free (str);

char *str = weechat_string_format_size (15200);  /* str == "15.2 KB" */
/* ... */
free (str);

char *str = weechat_string_format_size (2097152);  /* str == "2.10 MB" */
/* ... */
free (str);
----

Скрипта (Python), _WeeChat ≥ 2.2_:

[source,python]
----
# прототип
def string_format_size(size: int) -> str: ...

# пример
str = weechat.string_format_size(15200)  # == "15.2 KB"
----

==== string_parse_size

_WeeChat ≥ 3.7._

Парсира стринг са величином и јединицом која није обавезна, па враћа величину у бајтовима.

Прототип:

[source,c]
----
unsigned long long weechat_string_parse_size (const char *size);
----

Аргументи:

* _size_: величина као стринг: позитиван цео број након кога следе необавезни размаци и необавезна јединица
  (малим или великим словима), која је једно од:
** _b_: бајтова
** _k_: килобајта (1k = 1000 бајтова)
** _m_: мегаaбајта (1m = 1000k = 1,000,000 бајтова)
** _g_: гигабајта (1g = 1000m = 1,000,000,000 бајтова)
** _t_: терабајта (1t = 1000g = 1,000,000,000,000 бајтова)

Повратна вредност:

* величина у бајтовима, 0 у случају грешке

C пример:

[source,c]
----
unsigned long long size = weechat_parse_size ("1.34m");  /* size == 1340000 */
----

Скрипта (Python):

[source,python]
----
# прототип
def string_parse_size(size: str) -> int: ...

# пример
size = weechat.string_parse_size("1.34m")  # 1340000
----

==== string_color_code_size

_WeeChat ≥ 3.0._

Враћа величину (у бајтовима) WeeChat кода боје на почетку стринга.

Прототип:

[source,c]
----
int weechat_string_color_code_size (const char *string);
----

Аргументи:

* _string_: стринг

Повратна вредност:

* величина (у бајтовима) WeeChat кода боје на почетку стринга; ако је стринг NULL, празан или не почиње кодом боје, враћа се 0; ако стринг почиње са више кодова боје, враћа се само величина првог

C примери:

[source,c]
----
int size;

size = weechat_string_color_code_size ("test");  /* size == 0 */
size = weechat_string_color_code_size (weechat_color ("bold"));  /* size == 2 */
size = weechat_string_color_code_size (weechat_color ("yellow,red"));  /* size == 7 */
----

Скрипта (Python):

[source,python]
----
# прототип
def string_color_code_size(string: str) -> int: ...

# примери
size = weechat.string_color_code_size("test")  # size == 0
size = weechat.string_color_code_size(weechat.color("bold"))  # size == 2
size = weechat.string_color_code_size(weechat.color("yellow,red"))  # size == 7
----

==== string_remove_color

_Ажурирано у верзији 4.3.0._

Уклања WeeChat боје из стринга.

Прототип:

[source,c]
----
char *weechat_string_remove_color (const char *string, const char *replacement);
----

Аргументи:

* _string_: стринг
* _replacement_: ако није NULL и ако није празно, овај стринг замењује WeeChat кодове боје, у супротном се WeeChat кодови боје и наредни карактери (ако су у вези са бојом) уклањају из стринга

Повратна вредност:

* стринг без боја (након употребе мора да се ослободи позивом „free”)

C примери:

[source,c]
----
/* уклони кодове боје */
char *str = weechat_string_remove_color (my_string1, NULL);
/* ... */
free (str);

/* замени кодове боје са „?” */
char *str = weechat_string_remove_color (my_string2, "[color]");
/* ... */
free (str);
----

Скрипта (Python):

[source,python]
----
# прототип
def string_remove_color(string: str, replacement: str) -> str: ...

# пример
str = weechat.string_remove_color(my_string, "[color]")
----

==== string_base_encode

_WeeChat ≥ 2.4, ажурирано у 4.3.0._

Кодира стринг као base 16, 32, или 64.

Прототип:

[source,c]
----
int weechat_string_base_encode (const char *base, const char *from, int length, char *to);
----

Аргументи:

* _base_: "16", "32", "64", или "64url"
* _from_: стринг који се кодира
* _length_: дужина стринга који се кодира (на пример `strlen(from)`)
* _to_: показивач на стринг у који се смешта резултат (мора бити довољне дужине, резултат је дужи од почетног стринга)

Повратна вредност:

* дужина стринга смештеног у _*to_ (не рачунајући завршно `\0`), -1 у случају грешке

C пример:

[source,c]
----
char *string = "abcdefgh", result[128];
int length;
length = weechat_string_base_encode ("16", string, strlen (string), result);
/* length == 16, result == "6162636465666768" */
length = weechat_string_base_encode ("32", string, strlen (string), result);
/* length == 16, result == "MFRGGZDFMZTWQ===" */
length = weechat_string_base_encode ("64", string, strlen (string), result);
/* length == 12, result == "YWJjZGVmZ2g=" */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_base_decode

_WeeChat ≥ 2.4, ажурирано у 4.3.0._

Декодира стринг кодиран у base 16, 32, или 64.

Прототип:

[source,c]
----
int weechat_string_base_decode (const char *base, const char *from, char *to);
----

Аргументи:

* _base_: "16", "32", "64", или "64url"
* _from_: стринг који се декодира
* _to_: показивач на стринг у који се смешта резултат (мора бити довољне дужине, резултат је краћи од почетног стринга)

Повратна вредност:

* дужина стринга смештеног у _*to_ (не рачунајући завршно `\0`), -1 у случају грешке

C пример:

[source,c]
----
char result[128];
int length;
length = weechat_string_base_decode ("16", "6162636465666768", result);
/* length == 8, result == "abcdefgh" */
length = weechat_string_base_decode ("32", "MFRGGZDFMZTWQ===", result);
/* length == 8, result == "abcdefgh" */
length = weechat_string_base_decode ("64", "YWJjZGVmZ2g=", result);
/* length == 8, result == "abcdefgh" */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_hex_dump

_WeeChat ≥ 1.4._

Приказује приказ података као хексадецималне и ascii бајтове.

Прототип:

[source,c]
----
char *string_hex_dump (const char *data, int data_size, int bytes_per_line,
                       const char *prefix, const char *suffix);
----

Аргументи:

* _data_: подаци који се приказују
* _data_size_: број бајтова који се приказују у _data_
* _bytes_per_line_: број бајтова који треба да се прикаже у свакој линији
* _prefix_: префикс који се приказује на почетку сваке линије (није обавезан, може да буде NULL)
* _suffix_: суфикс који се приказује на крају сваке линије (није обавезан, може да буде NULL)

Повратна вредност:

* стринг са приказом података (након употребе мора да се ослободи позивом „free”)

C пример:

[source,c]
----
char *string = "abc def-ghi";
char *dump = weechat_string_hex_dump (string, strlen (string), 8, " >> ", NULL);
/* dump == " >> 61 62 63 20 64 65 66 2D   a b c   d e f - \n"
           " >> 67 68 69                  g h i           "  */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_is_command_char

_WeeChat ≥ 0.3.2._

Проверава да ли је први карактер стринга командни карактер (подразумевани командни карактер је `+/+`).

Прототип:

[source,c]
----
int weechat_string_is_command_char (const char *string);
----

Аргументи:

* _string_: стринг

Повратна вредност:

* 1 ако је први карактер стринга командни карактер, у супротном 0

C примери:

[source,c]
----
int command_char1 = weechat_string_is_command_char ("/test");  /* == 1 */
int command_char2 = weechat_string_is_command_char ("test");   /* == 0 */
----

Скрипта (Python):

[source,python]
----
# прототип
def string_is_command_char(string: str) -> int: ...

# примери
command_char1 = weechat.string_is_command_char("/test")  # == 1
command_char2 = weechat.string_is_command_char("test")   # == 0
----

==== string_input_for_buffer

_WeeChat ≥ 0.3.2._

Враћа показивач на текст уноса за бафер (показивач унутар „string” аргумента), или NULL ако стринг није команда.

Прототип:

[source,c]
----
const char *weechat_string_input_for_buffer (const char *string);
----

Аргументи:

* _string_: стринг

Повратна вредност:

* показивач у „string”, или NULL

C примери:

[source,c]
----
const char *str1 = weechat_string_input_for_buffer ("test");    /* "test"  */
const char *str2 = weechat_string_input_for_buffer ("/test");   /* NULL    */
const char *str3 = weechat_string_input_for_buffer ("//test");  /* "/test" */
----

Скрипта (Python):

[source,python]
----
# прототип
def string_input_for_buffer(string: str) -> str: ...

# примери
str1 = weechat.string_input_for_buffer("test")    # "test"
str2 = weechat.string_input_for_buffer("/test")   # ""
str3 = weechat.string_input_for_buffer("//test")  # "/test"
----

==== string_eval_expression

_WeeChat ≥ 0.4.0, ажурирано у верзијама 0.4.2, 0.4.3, 1.0, 1.1, 1.2, 1.3, 1.6, 1.8, 2.0, 2.2, 2.3, 2.7, 2.9, 3.1, 3.2, 3.3, 3.4, 3.6 и 3.8, 4.0.0, 4.2.0, 4.3.0, 4.4.0._

Израчунава израз и враћа вредност као стринг. Специјалне променљиве у формату `+${променљива}+` се развијају (погледајте табелу испод).

[NOTE]
Почевши од верзије 1.0, подржава се угњеждавање променљивих, на пример: `+${color:${променљива}}+`.

Прототип:

[source,c]
----
char *weechat_string_eval_expression (const char *expr,
                                      struct t_hashtable *pointers,
                                      struct t_hashtable *extra_vars,
                                      struct t_hashtable *options);
----

Аргументи:

* _expr_: израз који треба да се израчуна (погледајте <<eval_conditions,услове>> и <<eval_variables,променљиве>>)
* _pointers_: хеш табела са показивачима (кључеви моја бити стринг, вредности морају бити показивач); показивачи „window” и „buffer” се аутоматски додају ако се не налазе у хеш табели (са показивачем на текући прозор/бафер) (може да буде NULL):
** _regex_: показивач на регуларни израз (_regex_t_ структуру) компајлиран WeeChat функцијом <<_string_regcomp,string_regcomp>> или са regcomp (погледајте `man regcomp`); ова опција је слична са _regex_ у хеш табели _options_ (испод), али се користи у циљу бољих перформанси
* _extra_vars_: додатне променљиве које ће се развити (може да буде NULL)
* _options_: хеш табела са неким опцијама (кључеви и вредности морају бити стринг) (може да буде NULL):
** _type_: подразумевано понашање је да се само замене вредности у изразу, остали типови који могу да се изаберу су следећи:
*** _condition_: израз се израчунава као услов: користе се оператори и заграде, резултат је логичка вредност („0” или „1”)
** _prefix_: префикс испред променљиве која се замењује (подразумевано: `+${+`)
** _suffix_: суфикс након променљиве која се замењује (подразумевано: `+}+`)
** _extra_: подразумевано понашање је да се само замене додатне променљиве (_extra_vars_), другачије понашање може да се изабере:
*** _eval_: додатне променљиве (_extra_vars_) се и саме израчунавају пре замене _(WeeChat ≥ 1.6)_
** _regex_: регуларни израз који се користи за замену текста у _expr_ (који се онда не израчунава)
** _regex_replace_: текст за замену који се користи са _regex_, којим се мења текст у _expr_ (_regex_replace_ се израчунава за свако подударање _regex_ у _expr_, све док више нема подударања)
** _debug_: дибаг ниво (стринг са целим бројем ≥ 1), ако је укључен, у хеш табелу _options_ се додаје кључ „debug_output”:
*** _1_: укључује дибаг
*** _2_: укључује детаљнији дибаг

Повратна вредност:

* израчунати израз (након употребе мора да се ослободи позивом „free”), или NULL у случају проблема (неважећи израз или ако нема довољно слободне меморије)

C примери:

[source,c]
----
/* услови */
struct t_hashtable *options1 = weechat_hashtable_new (8,
                                                      WEECHAT_HASHTABLE_STRING,
                                                      WEECHAT_HASHTABLE_STRING,
                                                      NULL,
                                                      NULL);
weechat_hashtable_set (options1, "type", "condition");
char *str1 = weechat_string_eval_expression ("${window.win_width} > 100", NULL, NULL, options1);  /* "1" */
char *str2 = weechat_string_eval_expression ("abc =~ def", NULL, NULL, options1);                 /* "0" */

/* прост израз */
char *str3 = weechat_string_eval_expression ("${buffer.full_name}", NULL, NULL, NULL);  /* "core.weechat" */

/* замена регуларним изразом */
struct t_hashtable *options2 = weechat_hashtable_new (8,
                                                      WEECHAT_HASHTABLE_STRING,
                                                      WEECHAT_HASHTABLE_STRING,
                                                      NULL,
                                                      NULL);
/* додавање заграда око URL адреса */
weechat_hashtable_set (options2, "regex", "[a-zA-Z0-9_]+://[^ ]+");
weechat_hashtable_set (options2, "regex_replace", "[ ${re:0} ]");
char *str4 = weechat_string_eval_expression ("test: https://weechat.org", NULL, NULL, NULL);  /* "test: [ https://weechat.org ]" */

/* скривање лозинки */
weechat_hashtable_set (options2, "regex", "(password=)([^ ]+)");
weechat_hashtable_set (options2, "regex_replace", "${re:1}${hide:*,${re:2}}");
char *str5 = weechat_string_eval_expression ("password=abc password=def", NULL, NULL, NULL);  /* "password=*** password=***" */
----

Скрипта (Python):

[source,python]
----
# прототип
def string_eval_expression(expr: str, pointers: Dict[str, str], extra_vars: Dict[str, str], options: Dict[str, str]) -> str: ...

# примери

# услови
str1 = weechat.string_eval_expression("${window.win_width} > 100", {}, {}, {"type": "condition"})  # "1"
str2 = weechat.string_eval_expression("abc =~ def", {}, {}, {"type": "condition"})                 # "0"

# прост израз
str3 = weechat.string_eval_expression("${buffer.full_name}", {}, {}, {}) # "core.weechat"

# замена регуларним изразом: додавање заграда око URL адреса
options = {
    "regex": "[a-zA-Z0-9_]+://[^ ]+",
    "regex_replace": "[ ${re:0} ]",
}
str4 = weechat.string_eval_expression("test: https://weechat.org", {}, {}, options)  # "test: [ https://weechat.org ]"

# замена са регуларним изразом: скривање лозинки
options = {
    "regex": "(password=)([^ ]+)",
    "regex_replace": "${re:1}${hide:*,${re:2}}",
}
str5 = weechat.string_eval_expression("password=abc password=def", {}, {}, options)  # "password=*** password=***"
----

[[eval_conditions]]
===== Услови

Листа логичких оператора који могу да се користе у условима (по редоследу приоритета, од првог до последњег):

[width="100%", cols="2,1,5,5", options="header"]
|===
| Оператор | Мин WeeChat | Опис | Примери

| `+&&+` |
| Логичко „и”
| >> `+25 && 77+` +
  == `+1+` +
  +
  >> `+25 && 0+` +
  == `+0+`

| `+\|\|+` |
| Логичко „или”
| >> `+25 \|\| 0+` +
  == `+1+` +
  +
  >> `+0 \|\| 0+` +
  == `+0+`
|===

Листа оператора поређења који могу да се користе у условима (према редоследу приоритета, од првог до последњег):

[width="100%", cols="2,1,5,5", options="header"]
|===
| Оператор | Мин WeeChat | Опис | Примери

| `+=~+` |
| Подудара се са POSIX проширеним регуларним изразом (дозвољене су необавезне заставице, погледајте функцију <<_string_regcomp,string_regcomp>>)
| >> `+abc def =~ ab.*ef+` +
  == `+1+` +
  +
  >> `+abc def =~ y.*z+` +
  == `+0+`

| `+!~+` |
| НЕ подудара се са POSIX проширеним регуларним изразом (дозвољене су необавезне заставице, погледајте функцију <<_string_regcomp,string_regcomp>>)
| >> `+abc def !~ ab.*ef+` +
  == `+0+` +
  +
  >> `+abc def !~ y.*z+` +
  == `+1+`

| `+==*+` | 2.9
| Подудара се са маском где је дозвољено „*”, разликује величину слова (погледајте функцију <<_string_match,string_match>>)
| >> `+abc def ==* a*f+` +
  == `+1+` +
  +
  >> `+abc def ==* y*z+` +
  == `+0+`

| `+!!*+` | 2.9
| НИЈЕ џокер маска у којој је дозвољено „*”, разликује величину слова (погледајте функцију <<_string_match,string_match>>)
| >> `+abc def !!* a*f+` +
  == `+0+` +
  +
  >> `+abc def !!* y*z+` +
  == `+1+`

| `+=*+` | 1.8
| Подудара се са маском где је дозвољено „*”, не разликује величину слова (погледајте функцију <<_string_match,string_match>>)
| >> `+abc def =* A*F+` +
  == `+1+` +
  +
  >> `+abc def =* Y*Z+` +
  == `+0+`

| `+!*+` | 1.8
| НИЈЕ џокер маска у којој је дозвољено „*”, не разликује величину слова (погледајте функцију <<_string_match,string_match>>)
| >> `+abc def !* A*F+` +
  == `+0+` +
  +
  >> `+abc def !* Y*Z+` +
  == `+1+`

| `+==-+` | 2.9
| Је укључено, разликује величину слова
| >> `+abc def ==- bc+` +
  == `+1+` +
  +
  >> `+abc def ==- xyz+` +
  == `+0+`

| `+!!-+` | 2.9
| НИЈЕ укључено, разликује величину слова
| >> `+abc def !!- bc+` +
  == `+0+` +
  +
  >> `+abc def !!- xyz+` +
  == `+1+`

| `+=-+` | 2.9
| Је укључено, не разликује величину слова
| >> `+abc def =- BC+` +
  == `+1+` +
  +
  >> `+abc def =- XYZ+` +
  == `+0+`

| `+!-+` | 2.9
| НИЈЕ укључено, не разликује величину слова
| >> `+abc def !- BC+` +
  == `+0+` +
  +
  >> `+abc def !- XYZ+` +
  == `+1+`

| `+==+` |
| Једнако
| >> `+test == test+` +
  == `+1+` +
  +
  >> `+test == string+` +
  == `+0+`

| `+!=+` |
| Није једнако
| >> `+test != test+` +
  == `+0+` +
  +
  >> `+test != string+` +
  == `+1+`

| `+<=+` |
| Мање или једнако
| >> `+abc <= defghi+` +
  == `+1+` +
  +
  >> `+abc <= abc+` +
  == `+1+` +
  +
  >> `+defghi <= abc+` +
  == `+0+` +
  +
  >> `+15 <= 2+` +
  == `+0+`

| `+<+` |
| Мање
| >> `+abc < defghi+` +
  == `+1+` +
  +
  >> `+abc < abc+` +
  == `+0+` +
  +
  >> `+defghi < abc+` +
  == `+0+` +
  +
  >> `+15 < 2+` +
  == `+0+`

| `+>=+` |
| Веће или једнако
| >> `+defghi >= abc+` +
  == `+1+` +
  +
  >> `+abc >= abc+` +
  == `+1+` +
  +
  >> `+abc >= defghi+` +
  == `+0+` +
  +
  >> `+15 >= 2+` +
  == `+1+`

| `+>+` |
| Веће
| >> `+defghi > abc+` +
  == `+1+` +
  +
  >> `+abc > abc+` +
  == `+0+` +
  +
  >> `+abc > defghi+` +
  == `+0+` +
  +
  >> `+15 > 2+` +
  == `+1+`
|===

У случају да су два израза важећи бројеви, поређење се врши употребом бројева у покретном зарезу, у једном од следећих формата:

* цео број (примери: 5, -7)
* број у покретном зарезу (примери: 5.2, -7.5, 2.83e-2) _(WeeChat ≥ 2.0)_
* хексадецимални број (пример: 0xA3, -0xA3) _(WeeChat ≥ 2.0)_

Ако желите да форсирате поређење стрингова, можете сваки израз да уоквирите знацима навода, на пример:

* `50 > 100` враћа 0 (поређење бројева)
* `"50" > "100"` враћа 1 (поређење стрингова)

[[eval_variables]]
===== Променљиве

Листа развијених променљивих у изразу (према редоследу приоритета, од прве развијене, до последње):

[width="100%", cols="2,1,5,5", options="header"]
|===
| Формат | Мин WeeChat | Опис | Примери

| `+${raw_hl:xxx}+` | 4.2.0
| Сирови стринг (не израчунава се), са истицањем синтаксе (употребом боја).
| >> `+${raw_hl:${cut:1,,${rev:hello}}}+` +
  == `+${cut:1,,${rev:hello}}+` (са бојама)

| `+${raw:xxx}+` | 3.1
| Сирови стринг (не израчунава се).
| >> `+${raw:${info:version}}+` +
  == `+${info:version}+`

| `+${hl:xxx}+` | 4.2.0
| Стринг са истицањем синтаксе (употребом боја).
| >> `+${hl:${file.section.option}}+` +
  == `+test ${variable}+` (са бојама)

| `+${име}+` | 3.4
| Корисничка променљива (дефинисана са `+${define:име,вредност}+`).
| >> `+${име}+` +
  == `+вредност+`

| `+${име}+` |
| Променљива `name` из хеш табеле _extra_vars_.
| >> `+${име}+` +
  == `+вредност+`

| `+${weechat_xxx_dir}+` | 3.2
| WeeChat директоријум: `+${weechat_config_dir}+`, `+${weechat_data_dir}+`,
  `+${weechat_state_dir}+`, `+${weechat_cache_dir}+`
  или `+${weechat_runtime_dir}+`.
| >> `+${weechat_config_dir}+` +
  == `+/home/user/.config/weechat+` +
  +
  >> `+${weechat_data_dir}+` +
  == `+/home/user/.local/share/weechat+` +
  +
  >> `+${weechat_state_dir}+` +
  == `+/home/user/.local/state/weechat+` +
  +
  >> `+${weechat_cache_dir}+` +
  == `+/home/user/.cache/weechat+` +
  +
  >> `+${weechat_runtime_dir}+` +
  == `+/run/user/1000/weechat+`

| `+${eval:xxx}+` | 1.3
| Стринг који се израчунава.
| >> `+${eval:${date:${weechat.look.buffer_time_format}}}+` +
  == `+19:02:45+` ^(1)^ +
  +
  ^(1)^ са бојама, ако у опцији weechat.look.buffer_time_format постоје боје

| `+${eval_cond:xxx}+` | 3.1
| Стринг који се израчунава као услов.
| >> `+${eval_cond:${window.win_width} > 100}+` +
  == `+1+`

| `+${esc:xxx}+` +
  `+${\xxx}+` | 1.0
| Стринг са означеним карактерима.
| >> `+${esc:prefix\tmessage}+` +
  == `+prefix<TAB>message+` +
  +
  >> `+${\ua9}+` +
  == `+©+`

| `+${chars:опсег}+` | 3.8
| Стринг са опсегом карактера, где је `опсег` једно од: +
  - `digit` (`0123456789`) +
  - `xdigit` (`0123456789abcdefABCDEF`) +
  - `lower` (сва мала слова) +
  - `upper` (сва велика слова) +
  - `alpha` (сва слова) +
  - `alnum` (сва слова и бројеви) +
  - опсег карактара у формату `c1-c2` (`c1` кодна тачка мора бити нижа од или једнака са `c2`)
| >> `+${chars:digit}+` +
  == `+0123456789+` +
  +
  >> `+${chars:xdigit}+` +
  == `+0123456789abcdefABCDEF+` +
  +
  >> `+${chars:lower}+` +
  == `+abcdefghijklmnopqrstuvwxyz+` +
  +
  >> `+${chars:J-V}+` +
  == `+JKLMNOPQRSTUV+` +
  +
  >> `+${chars:←-↓}+` +
  == `+←↑→↓+`

| `+${lower:string}+` | 3.6
| Стринг конвертован у мала слова.
| >> `+${lower:TEST}+` +
  == `+test+`

| `+${upper:string}+` | 3.6
| Стринг конвертован у велика слова.
| >> `+${upper:test}+` +
  == `+TEST+`

| `+${hide:x,стринг}+` | 1.1
| Стринг са скривеним карактерима (сви карактери у `стринг` се замењују са `x`).
| >> `+${hide:*,password}+` +
  == `+********+`

| `+${cut:макс,суфикс,стринг}+` +
  `+${cut:+макс,суфикс,стринг}+` | 1.8
| Стринг са `макс` карактера и необавезним `суфикс` ако се стринг сече. +
  У формату `+макс`, суфикс се рачуна у максималну дужину.
| >> `+${cut:4,…,this is a test}+` +
  == `+this…+` +
  +
  >> `+${cut:+4,…,this is a test}+` +
  == `+t…+` +
  +
  >> `+${cut:2,>>,こんにちは世界}+` +
  == `+こん>>+`

| `+${cutscr:макс,суфикс,стринг}+` +
  `+${cutscr:+макс,суфикс,стринг}+` | 1.8
| Стринг са `макс` карактера приказаних на екрану, и необавезним `суфикс` ако се стринг сече.
  У формату `+макс`, суфикс се рачуна у максималну дужину.
| >> `+${cutscr:4,…,this is a test}+` +
  == `+this…+` +
  +
  >> `+${cutscr:+4,…,this is a test}+` +
  == `+thi…+` +
  +
  >> `+${cutscr:2,>>,こんにちは世界}+` +
  == `+こ>>+`

| `+${rev:xxx}+` | 2.2
| Обрнути стринг (и кодови боја се обрћу, тако да стринг не би требало да садржи
  кодове боја).
| >> `+${rev:Hello, world!}+` +
  == `+!dlrow ,olleH+` +
  +
  >> `+${rev:Hello, ${color:red}world!}+` +
  == `+!dlrow30F ,olleH+` ^(1)^ +
  +
  ^(1)^ нема боје, кôд боје је обрнут

| `+${revscr:xxx}+` | 2.7
| Обрнути стринг за екран, кодови боја се не обрћу.
| >> `+${revscr:Hello, world!}+` +
  == `+!dlrow ,olleH+` +
  +
  >> `+${revscr:Hello, ${color:red}world!}+` +
  == `+!dlrow ,olleH+` ^(1)^ +
  +
  ^(1)^ `pass:[ ,olleH]` у црвеној боји

| `+${repeat:број,стринг}+` | 2.3
| Поновљени стринг.
| >> `+${repeat:5,-}+` +
  == `+-----+`

| `+${length:xxx}+` | 2.7
| Дужина стринга (број UTF-8 карактера), кодови боја се игноришу.
| >> `+${length:test}+` +
  == `+4+` +
  +
  >> `+${length:こんにちは世界}+` +
  == `+7+`

| `+${lengthscr:xxx}+` | 2.7
| Дужина стринга приказаног на екрану, кодови боја се игноришу.
| >> `+${lengthscr:test}+` +
  == `+4+` +
  +
  >> `+${lengthscr:こんにちは世界}+` +
  == `+14+`

| `+${split:number,seps,flags,xxx}+` | 3.3
|Дели стринг и враћа сагласно са `number`: +
  - `count`: број ставки након поделе +
  - `random`: произвољну ставку +
  - цео број ≥ 1: ставку са индексом (1 = прва ставка) +
  - цео број ≤ -1: ставку са индеком од краја (-1 = последња ставка, -2 = претпоследња ставка, итд.), +
  `seps` је листа карактера који се користе као граничници (ако је празно, користи се запета), +
  `flags` је листа заставица раздвојена са `+`: +
  - `strip_left`: уклања граничнике са леве стране (почетка стринга) +
  - `strip_right`: уклања граничнике са десне стране (краја стринга) +
  - `collapse_seps`: стапа више узастопних граничника у један +
  - `keep_eol`: задржава прелом линије за сваку вредност +
  - `strip_items=xyz`: уклања карактере `x`, `y` и `z` са почетка/краја ставки +
  - `max_items=N`: враћа максимално N ставки
| >> `+${split:1,,,abc,def,ghi}+` +
  == `+abc+` +
  +
  >> `+${split:-1,,,abc,def,ghi}+` +
  == `+ghi+` +
  +
  >> `+${split:count,,,abc,def,ghi}+` +
  == `+3+` +
  +
  >> `+${split:random,,,abc,def,ghi}+` +
  == `+def+` +
  +
  >> `+${split:3,,collapse_seps,abc,,,def,,,ghi}+` +
  == `+ghi+` +
  +
  >> `+${split:3,,strip_items=-_,_-abc-_,_-def-_,_-ghi-_}+` +
  == `+ghi+` +
  +
  >> `+${split:2, ,,this is a test}+` +
  == `+is+` +
  +
  >> `+${split:2, ,strip_left+strip_right, this is a test }+` +
  == `+is+` +
  +
  >> `+${split:2, ,keep_eol,this is a test}+` +
  == `+is a test+`

| `+${split_shell:number,xxx}+` | 3.3
| Дели аргументе љуске и враћа сагласно са `number`: +
  - `count`: број аргумената након поделе +
  - `random`: произвољни аргумент +
  - цео број ≥ 1: аргумент по индексу (1 = први аргумент) +
  - цео број ≤ -1: аргумент по индексу од краја (-1 = последњи аргумент, -2 = претпоследњи аргумент, итд.)
| >> `+${split_shell:1,"first arg" arg2}+` +
  == `+first arg+` +
  +
  >> `+${split_shell:-1,"first arg" arg2}+` +
  == `+arg2+` +
  +
  >> `+${split_shell:count,"first arg" arg2}+` +
  == `+2+` +
  +
  >> `+${split_shell:random,"first arg" arg2}+` +
  == `+arg2+`

| `+${re:xxx}+` | 1.1
| Подаци регуларног израза: +
  `0` = цео подударени стринг, +
  `1` до `99` = ухваћена група, +
  `+++` = последња ухваћена група, +
  `#` = индекс последње ухваћене групе _(WeeChat ≥ 1.8)_, +
  `repl_index` = индекс замене која се врши (почиње од 1) _(WeeChat ≥ 3.3)_.
| >> `+${re:0}+` +
  == `+test1 test2+` +
  +
  >> `+${re:1}+` +
  == `+test1+` +
  +
  >> `+${re:2}+` +
  == `+test2+` +
  +
  >> `pass:[${re:+}]` +
  == `+test2+` +
  +
  >> `+${re:#}+` +
  == `+2+` +
  +
  >> `+${re:repl_index}+` +
  == `+1+`

| `+${color:име}+` | 0.4.2
| Кôд WeeChat боје (име боје има и необавезне атрибуте), погледајте
  функцију <<_color,color>> у вези подржаних формата.
| >> `+${color:red}red text+` +
  == `+red text+` ^(1)^ +
  +
  >> `+${color:*214}bold orange text+` +
  == `+bold orange text+` ^(2)^ +
  +
  ^(1)^ у црвеној +
  ^(2)^ подебљано наранџасто

| `+${modifier:име,подаци,стринг}+` | 2.7
| Резултат модификатора, погледајте функцију
  <<_hook_modifier_exec,hook_modifier_exec>>.
| >> `+${modifier:eval_path_home,,~}+` +
  == `+/home/user+` +
  +
  >> `+${modifier:eval_path_home,directory=config,%h/irc.conf}+` +
  == `+/home/user/.config/weechat/irc.conf+`

| `+${info:име}+` +
  `+${info:име,аргументи}+` | 0.4.3
| Инфо из програма WeeChat или додатка, погледајте функцију
  <<_info_get,info_get>>.
| >> `+${info:version}+` +
  == `+1.0+` +
  +
  >> `+${info:nick_color_name,foo}+` +
  == `+lightblue+`

| `+${base_encode:base,xxx}+` | 2.9
| Стринг кодиран у base 16, 32 или 64.
| >> `+${base_encode:16,test string}+` +
  == `+7465737420737472696E67+` +
  +
  >> `+${base_encode:32,test string}+` +
  == `+ORSXG5BAON2HE2LOM4======+` +
  +
  >> `+${base_encode:64,test string}+` +
  == `+dGVzdCBzdHJpbmc=+`

| `+${base_decode:base,xxx}+` | 2.9
| Декодиран стринг из base 16, 32 или 64.
| >> `+${base_decode:16,7465737420737472696E67}+` +
  == `+test string+` +
  +
  >> `+${base_decode:32,ORSXG5BAON2HE2LOM4======}+` +
  == `+test string+` +
  +
  >> `+${base_decode:64,dGVzdCBzdHJpbmc=}+` +
  == `+test string+`

| `+${date}+` +
  `+${date:xxx}+` | 1.3
| Текући датум/време, у прилагођеном формату (see function <<_util_strftimeval,util_strftimeval>>),
  подразумевани формат је `%F %T`.
| >> `+${date}+` +
  == `+2015-06-30 19:02:45+` +
  +
  >> `+${date:%H:%M:%S}+` +
  == `+19:02:45+` +
  +
  >> `+${date:%!.%.3}+` +
  == `+1435683765.482+`

| `+${env:ИМЕ}+` | 1.2
| Име променљиве окружења `ИМЕ`.
| >> `+${env:HOME}+` +
  == `+/home/user+`

| `+${if:condition}+` +
  `+${if:condition?true}+`
  `+${if:condition?true:false}+| 1.8
| Тернарни оператор са условом, вредност када је услов истинит (није обавезна) и
  друга вредност када је услов неистинит (није обавезна). Ако се вредности не
  задају, враћа се „1” или „0”, у зависности од резултата услова.
| >> `+${if:${info:term_width}>80?big:small}+` +
  == `+big+`

| `+${calc:xxx}+` | 2.7
| Резултат израза, у коме су подржане заграде и следећи
  оператори: +
  `+++`: сабирање +
  `+-+`: одузимање +
  `+*+`: множење +
  `+/+`: дељење +
  `+//+`: резултат дељења без разломљеног дела +
  `+%+`: остатак при дељењу +
  `+**+`: степен.
| >> `+${calc:5+2*3}+` +
  == `+11+` +
  +
  >> `+${calc:(5+2)*3}+` +
  == `+21+` +
  +
  >> `+${calc:10/4}+` +
  == `+2.5+` +
  +
  >> `+${calc:10//4}+` +
  == `+2+` +
  +
  >> `+${calc:9.2%3}+` +
  == `+0.2+` +
  +
  >> `+${calc:2**16}+` +
  == `+65536+`

| `+${random:min,max}+` | 3.3
| Случајни цео број из опсега `min` до `max` (укључујући и њих).
| >> `+${random:0,10}+` +
  == `+3+`

| `+${translate:xxx}+` | 3.2
| Преведени стринг (зависи од језика који програм WeeChat користи за приказ порука).
| >> `+${translate:Plugin}+` +
  == `+Extension+` ^(1)^ +
  +
  ^(1)^ пример из француског

| `+${define:име,вредност}+` | 3.4
| Дефинисање променљиве `име` постављене на `вредност`, која онда може да се користи у истом
  израчунатом изразу са `+${име}+`.
| >> `+${define:len,${calc:5+3}}${len}x${len}+` +
  == `+8x8+`

| `+${hdata_count:име[листа]}+` +
  `+${hdata_count:име[показивач]}+` | 4.4.0
| Број ставки у hdata листи или почевши од `показивач`.
| >> `+${hdata_count:buffer[gui_buffers]}+` +
  == `+15+`

| `+${sec.data.име}+` |
| Вредност обезбеђених података `име`.
| >> `+${sec.data.libera_pass}+` +
  == `+my_password+`

| `+${фајл.одељак.опција}+` |
| Вредност опције.
| >> `+${weechat.look.buffer_time_format}+` +
  == `+%H:%M:%S+`

| `+${име}+` |
| Вредност локалне променљиве `име` у баферу.
| >> `+${nick}+` +
  == `+FlashCode+`

| `+${pointer}+` |
| Променљива `pointer` из хеш табеле _pointers_.
| >> `+${buffer}+` +
  == `+0x1234abcd+`

| `+${hdata.пром1.пром2...}+` +
  `+${hdata[листа].пром1.пром2...}+` |
| Hdata вредност (показивачи `window` и `buffer` се подразумевано постављају на текући
  прозор/бафер), `листа` може бити име листе (пример: „gui_buffers”), показивач
  (пример: „0x1234abcd”) или име показивача (пример: „my_pointer”). +
  Када је `var1` хеш табела, могу да се позову методе `keys()`, `values()`, `keys_sorted()`,
  `keys_values()` и `keys_values_sorted()`.
| >> `+${buffer[gui_buffers].full_name}+` +
  == `+core.weechat+` +
  +
  >> `+${buffer[my_buffer_pointer].full_name}+` +
  == `+core.weechat+` +
  +
  >> `+${window.buffer.number}+` +
  == `+1+` +
  +
  >> `+${buffer.local_variables.keys_values()}+` +
  == `+plugin:core,name:weechat+` +
  +
  >> `+${buffer.local_variables.plugin}+` +
  == `+core+`
|===

==== string_dyn_alloc

_WeeChat ≥ 1.8._

Алоцира динамички стринг, са променљивом дужином. +
Интерно, структура се алоцира показивачем на стринг, алоцирану величину и текућу дужину стринга.

У свим _pass:[string_dyn_*]_ функцијама се користи само показивач показивача на стринг (_**string_).

Прототип:

[source,c]
----
char **weechat_string_dyn_alloc (int size_alloc);
----

Аргументи:

* _size_alloc_: почетна алоцирана величина (мора бити већа од нуле)

Повратна вредност:

* показивач на динамички стринг

C пример:

[source,c]
----
char **string = weechat_string_dyn_alloc (256);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_dyn_copy

_WeeChat ≥ 1.8._

Копира стринг у динамички стринг.

Показивач _*string_ може д асе промени ако се стринг реалоцира (у случају да нема довољно слободног простора за копирање стринга).

Прототип:

[source,c]
----
int weechat_string_dyn_copy (char **string, const char *new_string);
----

Аргументи:

* _string_: показивач на динамички стринг
* _new_string_: стринг који се копира

Повратна вредност:

* 1 ако је све OK, 0 у случају грешке

C пример:

[source,c]
----
char **string = weechat_string_dyn_alloc (256);
if (weechat_string_dyn_copy (string, "test"))
{
    /* OK */
}
else
{
    /* грешка */
}
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_dyn_concat

_WeeChat ≥ 1.8, ажурирано у верзији 3.0._

Надовезује стринг на динамички стринг.

Показивач на стринг _*string_ може да се промени ако се стринг реалоцира (у случају да нема довољно простора за надовезивање стринга).

Прототип:

[source,c]
----
int weechat_string_dyn_concat (char **string, const char *add, int bytes);
----

Аргументи:

* _string_: показивач на динамички стринг
* _add_: стринг који се додаје
* _bytes_: максимални број бајтова у _add_ који могу да се надовежу, мора бити мање или једнако дужини _add_ (-1 = аутоматски: надовезује се комплетан стринг _add_) _(WeeChat ≥ 3.0)_

Повратна вредност:

* 1 ако је све OK, 0 у случају грешке

C пример:

[source,c]
----
char **string = weechat_string_dyn_alloc (256);
if (weechat_string_dyn_copy (string, "test"))
{
    if (weechat_string_dyn_concat (string, "abc", -1))
    {
        /* ... */
    }
}
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_dyn_free

_WeeChat ≥ 1.8._

Ослобађа динамички стринг.

Прототип:

[source,c]
----
char *weechat_string_dyn_free (char **string, int free_string);
----

Аргументи:

* _string_: показивач на динамички стринг
* _free_string_: ослобађање самог стринга; ако је 0, онда садржај _*string_ остаје важећи и након позива ове функције

Повратна вредност:

* показивач на стринг ако је _free_string_ 0, у супротном NULL

C пример:

[source,c]
----
char **string = weechat_string_dyn_alloc (256);
if (weechat_string_dyn_concat (string, "test"))
{
    /* OK */
}
else
{
    /* грешка */
}
/* ... */
weechat_string_dyn_free (string, 1);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== string_concat

_WeeChat ≥ 4.2.0._

Спаја више стрингова користећи граничник.

Прототип:

[source,c]
----
const char *weechat_string_concat (const char *separator, ...);
----

Аргументи:

* _separator_: стринг граничник који се умеће између спојених стрингова
  (може да буде NULL или празан стринг)

[NOTE]
Последњи аргумент *MUST* увек да буде NULL. +
Може да се употреби макро `WEECHAT_STR_CONCAT`, тамо где није потребна
завршна NULL вредност (препоручује се уптореба овог макроа).

Повратна вредност:

* спојени стринг

C пример:

[source,c]
----
const char *result = weechat_string_concat (" / ", "абв", "гдђ", "ежз", NULL);  /* резултат == "абв / гдђ / ежз" */

/* са макроом */
const char *result = WEECHAT_STR_CONCAT(" / ", "абв", "гдђ", "ежз");  /* резултат == "абв / гдђ / ежз" */
----

[NOTE]
Ова функција није доступна у API скриптовања.

[[utf-8]]
=== UTF-8

Неке UTF-8 стринг функције.

==== utf8_has_8bits

Проверава да ли стринг има 8-битне карактере.

Прототип:

[source,c]
----
int weechat_utf8_has_8bits (const char *string);
----

Аргументи:

* _string_: стринг

Повратна вредност:

* 1 ако стринг има 8-битне карактере, 0 ако има само 7-битне карактере

C пример:

[source,c]
----
if (weechat_utf8_has_8bits (string))
{
    /* ... */
}
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== utf8_is_valid

_Ажурирано у верзији 1.4._

Проверава да ли је стринг важећи UTF-8.

Прототип:

[source,c]
----
int weechat_utf8_is_valid (const char *string, int length, char **error);
----

Аргументи:

* _string_: стринг
* _length_: максимални број UTF-8 карактера који може да се провери; ако је ≤ 0, проверава се цео стринг _(WeeChat ≥ 1.4)_
* _error_: ако није NULL, _*error_ се поставља на показивач на први неважећи UTF-8 карактер у стрингу, ако такав постоји

Повратна вредност:

* 1 ако је UTF-8 стринг исправан, у супротном 0

C пример:

[source,c]
----
char *error;
if (weechat_utf8_is_valid (string, -1, &error))
{
    /* ... */
}
else
{
    /* "error" показује на при неважећи карактер */
}
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== utf8_normalize

Нормализује UTF-8 стринг: уклања све карактере који нису UTF-8 и замењује их карактером.

Прототип:

[source,c]
----
void weechat_utf8_normalize (char *string, char replacement);
----

Аргументи:

* _string_: стринг
* _replacement_: карактер којим се замењују неисправни карактери

C пример:

[source,c]
----
weechat_utf8_normalize (string, '?');
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== utf8_prev_char

_Ажурирано у верзији 1.3._

Враћа показивач на претходни UTF-8 карактер у стрингу.

Прототип:

[source,c]
----
const char *weechat_utf8_prev_char (const char *string_start,
                                    const char *string);
----

Аргументи:

* _string_start_: почетак стринга (функција неће вратити карактер пре овог показивача)
* _string_: показивач на стринг (мора бити ≥ _string_start_)

Повратна вредност:

* показивач на претходни UTF-8 карактер, NULL у случају да се не пронађе (достигнут је почетак стринга) (_WeeChat ≥ 1.3_: враћени показивач је _const char *_ уместо _char *_)

C пример:

[source,c]
----
const char *prev_char = weechat_utf8_prev_char (string, ptr_in_string);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== utf8_next_char

_Ажурирано у верзији 1.3._

Враћа показивач на наредни UTF-8 карактер у стрингу.

Прототип:

[source,c]
----
const char *weechat_utf8_next_char (const char *string);
----

Аргументи:

* _string_: стринг

Повратна вредност:

* показивач на наредни UTF-8 карактер, NULL ако се не пронађе (достигнут је крај стринга) (_WeeChat ≥ 1.3_: враћени показивач је _const char *_ уместо _char *_)

C пример:

[source,c]
----
const char *next_char = weechat_utf8_next_char (string);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== utf8_char_int

Враћа UTF-8 карактер као цео број.

Прототип:

[source,c]
----
int weechat_utf8_char_int (const char *string);
----

Аргументи:

* _string_: стринг

Повратна вредност:

* UTF-8 карактер као цео број

C пример:

[source,c]
----
int char_int = weechat_utf8_char_int ("être");  /* "ê" као цео број */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== utf8_char_size

Враћа величину UTF-8 карактера (у бајтовима).

Прототип:

[source,c]
----
int weechat_utf8_char_size (const char *string);
----

Аргументи:

* _string_: стринг

Повратна вредност:

* величина UTF-8 карактера (у бајтовима)

C пример:

[source,c]
----
int char_size = weechat_utf8_char_size ("être");  /* == 2 */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== utf8_strlen

Враћа дужину UTF-8 стринга (у UTF-8 карактерима).

Прототип:

[source,c]
----
int weechat_utf8_strlen (const char *string);
----

Аргументи:

* _string_: стринг

Повратна вредност:

* дужина UTF-8 стринга (број UTF-8 карактера)

C пример:

[source,c]
----
int length = weechat_utf8_strlen ("chêne");  /* == 5 */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== utf8_strnlen

Враћа дужину UTF-8 стринга (у UTF-8 карактерима), за максимално _bytes_ у стрингу.

Прототип:

[source,c]
----
int weechat_utf8_strnlen (const char *string, int bytes);
----

Аргументи:

* _string_: стринг
* _bytes_: максимални број бајтова

Повратна вредност:

* дужина UTF-8 стринга (број UTF-8 карактера)

C пример:

[source,c]
----
int length = weechat_utf8_strnlen ("chêne", 4);  /* == 3 */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== utf8_strlen_screen

Враћа број карактера потребних на екрану да се прикаже UTF-8 стринг.

Прототип:

[source,c]
----
int weechat_utf8_strlen_screen (const char *string);
----

Аргументи:

* _string_: стринг

Повратна вредност:

* број карактера на екрану који су потребни да се испише UTF-8 стринг

C пример:

[source,c]
----
int length_on_screen = weechat_utf8_strlen_screen ("é");  /* == 1 */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== utf8_char_size_screen

_Ажурирано у верзији 3.8._

Враћа број карактера потребних на екрану за испис UTF-8 карактера.

Прототип:

[source,c]
----
int weechat_utf8_char_size_screen (const char *string);
----

Аргументи:

* _string_: стринг

Повратна вредност:

* број карактера на екрану потребних за испис UTF-8 карактера:
** -1: карактер који не може да се одштампа
** ≥ 0: карактер који може да се одштампа

Резултат је вредност враћена из функције `wcwidth` (погледајте `man wcwidth`), уз
изузетак следећих карактера који у програму WeeChat имају посебну улогу:

* U+0009 (Табулатор): вредност опције
  link:weechat_user.sr.html#option_weechat.look.tab_width[weechat.look.tab_width ^↗^^]
* U+0001 (1) до U+001F (31), осим U+0009 (Табулатор): 1
* U+00AD (173, мека цртица): -1
* U+200B (8203, размак нулте ширине): -1

C пример:

[source,c]
----
int length_on_screen = weechat_utf8_char_size_screen ("é");  /* == 1 */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== utf8_add_offset

_Ажурирано у верзији 1.3._

Помера унапред N карактера у UTF-8 стрингу.

Прототип:

[source,c]
----
const char *weechat_utf8_add_offset (const char *string, int offset);
----

Аргументи:

* _string_: стринг
* _offset_: број карактера

Повратна вредност:

* показивач на стринг, N карактера иза (NULL ако не може да се достигне) (_WeeChat ≥ 1.3_: враћени показивач је _const char *_ уместо _char *_)

C пример:

[source,c]
----
const char *str = "chêne";
const char *str2 = weechat_utf8_add_offset (str, 3);  /* показује на "ne" */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== utf8_real_pos

Враћа реалну позицију у UTF-8 стрингу.

Прототип:

[source,c]
----
int weechat_utf8_real_pos (const char *string, int pos);
----

Аргументи:

* _string_: стринг
* _pos_: позиција (број карактера)

Повратна вредност:

* реална позиција (у бајтовима)

C пример:

[source,c]
----
int pos = weechat_utf8_real_pos ("chêne", 3);  /* == 4 */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== utf8_pos

Враћа позицију у UTF-8 стрингу.

Прототип:

[source,c]
----
int weechat_utf8_pos (const char *string, int real_pos);
----

Аргументи:

* _string_: стринг
* _real_pos_: позиција (бајтови)

Повратна вредност:

* позиција (број карактера)

C пример:

[source,c]
----
int pos = weechat_utf8_pos ("chêne", 4);  /* == 3 */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== utf8_strndup

Враћа дупликат стринга, са максимално _length_ карактера.

Прототип:

[source,c]
----
char *weechat_utf8_strndup (const char *string, int length);
----

Аргументи:

* _string_: стринг
* _length_: макс број карактера који може да се дуплира

Повратна вредност:

* дуплирани стринг (након употребе мора да се ослободи позивом „free”)

C пример:

[source,c]
----
char *string = weechat_utf8_strndup ("chêne", 3);  /* враћа "chê" */
/* ... */
free (string);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== utf8_strncpy

_WeeChat ≥ 3.8._

Копира максимално _length_ карактера у други стринг и на крај додаје null бајт.

Прототип:

[source,c]
----
void weechat_utf8_strncpy (char *dest, const char *string, int length);
----

Аргументи:

* _dest_: одредишни стринг (мора да буде довољно дугачак)
* _string_: стринг
* _length_: максимални број карактера који може да се копира

C пример:

[source,c]
----
char dest[256];

weechat_utf8_strncpy (dest, "chêne", 3);  /* copies "chê" to dest */
----

[NOTE]
Ова функција није доступна у API скриптовања.

[[crypto]]
=== Криптографија

Неке криптографске функције.

==== crypto_hash

_WeeChat ≥ 2.8._

Израчунава хеш података.

Прототип:

[source,c]
----
int weechat_crypto_hash (const void *data, int data_size, const char *hash_algo,
                         void *hash, int *hash_size);
----

Аргументи:

* _data_: подаци који треба да се хеширају
* _data_size_: број бајтова у _data_ који се хешира
* _hash_algo_: хеш алгоритам, погледајте табелу испод
* _hash_: показивач на хеш променљиву која се користи за чување резултата хеширања (бафер мора бити довољне величине која зависи од алгоритма, погледајте табелу испод)
* _hash_size_: показивач на променљиву која се користи за чување величине израчунатог хеша (у бајтовима) (може да буде NULL)

[[crypto_hash_algorithms]]
Подржани хеш алгоритми:

[width="100%", cols="2,2,3,6", options="header"]
|===
| Вредност        | Алгоритам   | Величина хеша         | Напомене
| `+crc32+`       | CRC32       | 4 бајта (32 бита)     | Није хеш алгоритам у криптографском смислу.
| `+md5+`         | MD5         | 16 бајтова (128 бита) | *Слаб*, не препоручује се за криптографску употребу.
| `+sha1+`        | SHA-1       | 20 бајтова (160 бита) | *Слаб*, не препоручује се за криптографску употребу.
| `+sha224+`      | SHA-224     | 28 бајтова (224 бита) |
| `+sha256+`      | SHA-256     | 32 бајта (256 бита)   |
| `+sha384+`      | SHA-384     | 48 бајтова (384 бита) |
| `+sha512+`      | SHA-512     | 64 бајта (512 бита)   |
| `+sha512-224+`  | SHA-512/224 | 28 бајтова (224 бита) | Алгоритам је доступан у libgcrypt ≥ 1.9.4.
| `+sha512-256+`  | SHA-512/256 | 32 бајта (256 бита)   | Алгоритам је доступан у libgcrypt ≥ 1.9.4.
| `+sha3-224+`    | SHA3-224    | 28 бајтова (224 бита) | Алгоритам је доступан у libgcrypt ≥ 1.7.0.
| `+sha3-256+`    | SHA3-256    | 32 бајта (256 бита)   | Алгоритам је доступан у libgcrypt ≥ 1.7.0.
| `+sha3-384+`    | SHA3-384    | 48 бајтова (384 бита) | Алгоритам је доступан у libgcrypt ≥ 1.7.0.
| `+sha3-512+`    | SHA3-512    | 64 бајта (512 бита)   | Алгоритам је доступан у libgcrypt ≥ 1.7.0.
| `+blake2b-160+` | BLAKE2B-160 | 20 бајтова (160 бита) | Алгоритам је доступан у libgcrypt ≥ 1.8.0.
| `+blake2b-256+` | BLAKE2B-256 | 32 бајта (256 бита)   | Алгоритам је доступан у libgcrypt ≥ 1.8.0.
| `+blake2b-384+` | BLAKE2B-384 | 48 бајтова (384 бита) | Алгоритам је доступан у libgcrypt ≥ 1.8.0.
| `+blake2b-512+` | BLAKE2B-512 | 64 бајта (512 бита)   | Алгоритам је доступан у libgcrypt ≥ 1.8.0.
| `+blake2s-128+` | BLAKE2S-128 | 16 бајтова (128 бита) | Алгоритам је доступан у libgcrypt ≥ 1.8.0.
| `+blake2s-160+` | BLAKE2S-160 | 20 бајтова (160 бита) | Алгоритам је доступан у libgcrypt ≥ 1.8.0.
| `+blake2s-224+` | BLAKE2S-224 | 28 бајтова (224 бита) | Алгоритам је доступан у libgcrypt ≥ 1.8.0.
| `+blake2s-256+` | BLAKE2S-256 | 32 бајта (256 бита) ) | Алгоритам је доступан у libgcrypt ≥ 1.8.0.
|===

Повратна вредност:

* 1 ако је све OK, 0 у случају грешке

C пример:

[source,c]
----
const char *data = "abcdefghijklmnopqrstuvwxyz";
char hash[256 / 8];
int rc, hash_size;
rc = weechat_crypto_hash (data, strlen (data), "sha256", hash, &hash_size);
/* rc == 1, hash_size == 32 и хеш је бафер са:
   71 c4 80 df 93 d6 ae 2f 1e fa d1 44 7c 66 c9 52 5e 31 62 18 cf 51 fc 8d 9e d8 32 f2 da f1 8b 73 */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== crypto_hash_file

_WeeChat ≥ 3.7._

Израчунава хеш фајла.

Прототип:

[source,c]
----
int weechat_crypto_hash_file (const char *filename, const char *hash_algo,
                              void *hash, int *hash_size);
----

Аргументи:

* _filename_: путања и име фајла
* _hash_algo_: хеш алгоритам, погледајте табелу у функцији
  <<crypto_hash_algorithms,crypto_hash>>
* _hash_: показивач на хеш променљиву која се користи за чување резултата хеширања
  (бафер мора бити довољне величине која зависи од алгоритма, погледајте табелу у
  функцији <<crypto_hash_algorithms,crypto_hash>>)
* _hash_size_: показивач на променљиву која се користи за чување величине израчунатог хеша (у бајтовима) (може да буде NULL)

Повратна вредност:

* 1 ако је све OK, 0 у случају грешке

C пример:

[source,c]
----
char hash[256 / 8];
int rc, hash_size;
rc = weechat_crypto_hash_file ("/path/to/file", "sha256", hash, &hash_size);
/* rc == 1, hash_size == 32 и хеш је бафер са:
   71 c4 80 df 93 d6 ae 2f 1e fa d1 44 7c 66 c9 52 5e 31 62 18 cf 51 fc 8d 9e d8 32 f2 da f1 8b 73 */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== crypto_hash_pbkdf2

_WeeChat ≥ 2.8._

Израчунава PKCS#5 Passphrase Based Key Derivation Function број 2 (PBKDF2) хеш података.

Прототип:

[source,c]
----
int weechat_crypto_hash_pbkdf2 (const void *data, int data_size,
                                const char *hash_algo,
                                const void *salt, int salt_size,
                                int iterations,
                                void *hash, int *hash_size);
----

Аргументи:

* _data_: подаци који треба да се хеширају
* _data_size_: број бајтова у _data_ који се хешира
* _hash_algo_: хеш алгоритам који се користи у функцији за извођење кључа, погледајте табелу у функцији <<crypto_hash_algorithms,crypto_hash>>
* _salt_: со
* _salt_size_: број бајтова у _salt_
* _iterations_: број итерација
* _hash_: показивач на хеш променљиву која се користи за чување резултата (бафер мора бити довољне величине која зависи од алгоритма, погледајте табелу у функцији <<crypto_hash_algorithms,crypto_hash>>)
* _hash_size_: показивач на променљиву која се користи за чување величине израчунатог хеша (у бајтовима) (може да буде NULL)

Повратна вредност:

* 1 ако је све OK, 0 у случају грешке

C пример:

[source,c]
----
const char *data = "abcdefghijklmnopqrstuvwxyz";
const char *salt = "12345678901234567890123456789012";  /* 32 bytes */
char hash[256 / 8];
int rc, hash_size;
rc = weechat_crypto_hash_pbkdf2 (data, strlen (data), "sha256", salt, strlen (salt), 100000,
                                 hash, &hash_size);
/* rc == 1, hash_size == 32 и хеш је бафер са:
   99 b3 5e 42 53 d1 a7 a8 49 c1 dc 2c e2 53 c2 b6 6d a1 8b dc 6e 78 a7 06 e0 ef 34 db 0a 7a a2 bb */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== crypto_hmac

_WeeChat ≥ 3.2._

Израчунава keyed-hash message authentication code (HMAC).

Прототип:

[source,c]
----
int weechat_crypto_hmac (const void *key, int key_size, const void *message, int message_size,
                         int hash_algo, void *hash, int *hash_size);
----

Аргументи:

* _key_: кључ
* _key_size_: број бајтова у _key_
* _message_: порука
* _message_size_: број бајтова у _message_
* _hash_algo_: хеш алгоритам, погледајте табелу у функцији <<crypto_hash_algorithms,crypto_hash>>
* _hash_: показивач на хеш променљиву која се користи за чување резултата (бафер мора бити довољне величине која зависи од алгоритма, погледајте табелу у функцији <<crypto_hash_algorithms,crypto_hash>>)
* _hash_size_: показивач на променљиву која се користи за чување величине израчунатог хеша (у бајтовима) (може да буде NULL)

Повратна вредност:

* 1 ако је све OK, 0 у случају грешке

C пример:

[source,c]
----
const char *key = "the key";
const char *message = "the message";
char hash[256 / 8];
int rc, hash_size;
rc = weechat_crypto_hmac (key, strlen (key), message, strlen (message), "sha256", hash, &hash_size);
/* rc == 1, hash_size == 32 и хеш је бафер са:
   47 36 67 02 fc bc b1 97 a4 25 e6 7a b9 52 92 bd 15 9a 66 91 9c fb 94 b0 b4 9a 39 cb c0 24 2d 7b */
----

[NOTE]
Ова функција није доступна у API скриптовања.

[[directories]]
=== Директоријуми

Неке функције у вези директоријума.

==== mkdir_home

_Ажурирано у верзији 3.2._

Креира директоријум у WeeChat почетном директоријуму.

Прототип:

[source,c]
----
int weechat_mkdir_home (char *directory, int mode);
----

Аргументи:

* _directory_: име директоријума који трба да се креира; може почети једним од следећих стрингова чиме се форсира одређени WeeChat директоријум (WeeChat ≥ 3.2):
** `${weechat_config_dir}`
** `${weechat_data_dir}` (подразумевано)
** `${weechat_state_dir}`
** `${weechat_cache_dir}`
** `${weechat_runtime_dir}`
* _mode_: режим за директоријум

Повратна вредност:

* 1 ако је директоријум успешно креиран, 0 ако је дошло до грешке

C пример:

[source,c]
----
if (!weechat_mkdir_home ("${weechat_cache_dir}/temp", 0755))
{
    /* грешка */
}
----

Скрипта (Python):

[source,python]
----
# прототип
def mkdir_home(directory: str, mode: int) -> int: ...

# пример
weechat.mkdir_home("${weechat_cache_dir}/temp", 0755)
----

==== mkdir

Креира директоријум.

Прототип:

[source,c]
----
int weechat_mkdir (char *directory, int mode);
----

Аргументи:

* _directory_: име директоријума који се креира
* _mode_: режим за директоријум

Повратна вредност:

* 1 ако је директоријум успешно креиран, 0 ако је дошло до грешке

C пример:

[source,c]
----
if (!weechat_mkdir ("/tmp/mydir", 0755))
{
    /* грешка */
}
----

Скрипта (Python):

[source,python]
----
# прототип
def mkdir(directory: str, mode: int) -> int: ...

# пример
weechat.mkdir("/tmp/mydir", 0755)
----

==== mkdir_parents

Креира директоријум и ако је потребно, и родитељ директоријуме.

Прототип:

[source,c]
----
int weechat_mkdir_parents (char *directory, int mode);
----

Аргументи:

* _directory_: име директоријума који се креира
* _mode_: режим за директоријум

Повратна вредност:

* 1 ако је директоријум успешно креиран, 0 ако је дошло до грешке

C пример:

[source,c]
----
if (!weechat_mkdir_parents ("/tmp/my/dir", 0755))
{
    /* грешка */
}
----

Скрипта (Python):

[source,python]
----
# прототип
def mkdir_parents(directory: str, mode: int) -> int: ...

# пример
weechat.mkdir_parents("/tmp/my/dir", 0755)
----

==== exec_on_files

_Ажурирано у верзијама 1.5, 2.0._

Проналази фајлове у директоријуму и извршава функцију повратног позива за сваки фајл.

Прототип:

[source,c]
----
void weechat_exec_on_files (const char *directory,
                            int recurse_subdirs,
                            int hidden_files,
                            void (*callback)(void *data,
                                             const char *filename),
                            void *callback_data);
----

Аргументи:

* _directory_: директоријум за претрагу фајлова
* _recurse_subdirs_: 1 да се спушта у поддиректоријуме _(WeeChat ≥ 2.0)_
* _hidden_files_: 1 да се укључе и скривени фајлови, у супротном 0
* _callback_: функција која се позива за сваки пронађени фајл, аргументи:
** _void *data_: показивач
** _const char *filename_: пронађено име фајла
* _callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat

C пример:

[source,c]
----
void callback (void *data, const char *filename)
{
    /* ... */
}
...
weechat_exec_on_files ("/tmp", 0, 0, &callback, NULL);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== file_get_content

_WeeChat ≥ 0.3.1._

Враћа садржај текст фајла у стрингу.

Прототип:

[source,c]
----
char *weechat_file_get_content (const char *filename);
----

Аргументи:

* _filename_: путања и име фајла

Повратна вредност:

* садржај фајла као стринг (након употребе мора да се ослободи позивом „free”)

C пример:

[source,c]
----
char *content;

content = weechat_file_get_content ("/tmp/test.txt");
/* ... */
free (content);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== file_copy

_WeeChat ≥ 3.3._

Копира фајл на другу локацију.

Прототип:

[source,c]
----
int weechat_file_copy (const char *from, const char *to);
----

Аргументи:

* _from_: изворишни фајл
* _to_: одредишни фајл

Повратна вредност:

* 1 ако је копирање OK, 0 у случају грешке

C пример:

[source,c]
----
if (weechat_file_copy ("/tmp/test.txt", "/path/to/test2.txt"))
{
    /* OK */
}
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== file_compress

_WeeChat ≥ 3.7._

Компресује фајл са gzip или zstd.

Прототип:

[source,c]
----
int weechat_file_compress (const char *from, const char *to,
                           const char *compressor, int compression_level);
----

Аргументи:

* _from_: изворишни фајл
* _to_: одредишни фајл
* _compressor_: компресор који треба да се користи, једно од:
** _gzip_: gzip компресија
** _zstd_: zstandard компресија (доступно само ако је zstd било укључено
   у време када је WeeChat компајлиран)
* _compression_level_: ниво компресије, између 1 (брзо, ниска компресија) и
  100 (споро, најбоља компресија)

Повратна вредност:

* 1 ако је копирање OK, 0 у случају грешке

C пример:

[source,c]
----
if (weechat_file_compress ("/tmp/test.txt", "/tmp/test.txt.zst", "zstd", 50))
{
    /* OK */
}
----

[NOTE]
Ова функција није доступна у API скриптовања.

[[util]]
=== Алати

Неке корисне функције.

==== util_timeval_cmp

Пореди две „timeval” структуре.

Прототип:

[source,c]
----
int weechat_util_timeval_cmp (struct timeval *tv1, struct timeval *tv2);
----

Аргументи:

* _tv1_: прва „timeval” структура
* _tv2_: друга „timeval” структура

Повратна вредност:

* -1 ако је tv1 < tv2
* нула ако је tv1 == tv2
* +1 ако је tv1 > tv2

C пример:

[source,c]
----
if (weechat_util_timeval_cmp (&tv1, &tv2) > 0)
{
    /* tv1 > tv2 */
}
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== util_timeval_diff

_Ажурирано у верзији 1.1._

Враћа разлику (у микросекундама) између две „timeval” структуре.

Прототип:

[source,c]
----
long long weechat_util_timeval_diff (struct timeval *tv1, struct timeval *tv2);
----

Аргументи:

* _tv1_: прва „timeval” структура
* _tv2_: друга „timeval” структура

Повратна вредност:

* разлика у микросекундама

[NOTE]
У програму WeeChat верзије ≤ 1.0, враћена вредност је била у милисекундама.

C пример:

[source,c]
----
long long diff = weechat_util_timeval_diff (&tv1, &tv2);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== util_timeval_add

_Ажурирано у верзији 1.1._

Додаје timeval структури интервал (у микросекундама).

Прототип:

[source,c]
----
void weechat_util_timeval_add (struct timeval *tv, long long interval);
----

Аргументи:

* _tv_: timeval структура
* _interval_: интервал (у микросекундама)

[NOTE]
У програму WeeChat верзије ≤ 1.0, интервал је изражаван у милисекундама.

C пример:

[source,c]
----
weechat_util_timeval_add (&tv, 2000000);  /* додаје 2 секунде */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== util_get_time_string

_WeeChat ≥ 0.3.2, ажурирано у верзији 1.3._

Враћа датум/време као стринг изграђен помоћу „strftime” у формату дефинисаном у опцији _weechat.look.time_format_.

Прототип:

[source,c]
----
const char *weechat_util_get_time_string (const time_t *date);
----

Аргументи:

* _date_: показивач на датум

Повратна вредност:

* показивач на стринг са датумом/временом

C пример:

[source,c]
----
time_t date = time (NULL);
weechat_printf (NULL, "date: %s",
                weechat_util_get_time_string (&date));
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== util_strftimeval

_WeeChat ≥ 4.2.0, ажурирано у 4.3.0._

Форматира датум и време као функција `strftime` из C библиотеке, користећи `struct timeval`
као улаз уз подршку за додатне спецификаторе.

Прототип:

[source,c]
----
int weechat_util_strftimeval (char *string, int max, const char *format, struct timeval *tv);
----

Аргументи:

* _string_: бафер у који се смешта форматирани стринг
* _max_: величина стринга
* _format_: формат, исто као за _strftime_ функцију, са следећим додатним спецификаторима:
** `%.N` где је `N` између 1 и 6: микросекунде допуњене нулама на N цифара
   (на пример `%.3` за милисекунде)
** `%f`: алијас за `%.6`
** `%!`: временска ознака као цео број, у секундама (вредност од tv->tv_sec)

Повратна вредност:

* број бајтова постављен у _string_ (вредност враћена из функције _strftime_)

C пример:

[source,c]
----
char time[256];
struct timeval tv;
gettimeofday (&tv, NULL);
weechat_util_strftimeval (time, sizeof (time), "%FT%T.%f", &tv);
/* резултат: 2023-12-26T18:10:04.460509 */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== util_parse_time

_WeeChat ≥ 4.2.0._

Парсира датум/време са подршком за милисекунде.

Прототип:

[source,c]
----
int util_parse_time (const char *datetime, struct timeval *tv);
----

Аргументи:

* _date_: датум/време
* _tv_: парсиран датум/време („timeval” структура)

Повратна вредност:

* 1 ако је OK, 0 у случају грешке

C пример:

[source,c]
----
struct timeval tv;
weechat_util_parse_time ("2023-12-25T10:29:09.456789Z", &tv);  /* == 1 */
/* резултат: tv.tv_sec == 1703500149, tv.tv_usec = 456789 */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== util_version_number

_WeeChat ≥ 0.3.9._

Конвертује стринг са верзијом програма WeeChat у број.

Прототип:

[source,c]
----
int weechat_util_version_number (const char *version);
----

Аргументи:

* _version_: верзија програма WeeChat као стринг (пример: „0.3.9” или „0.3.9-dev”)

C пример:

[source,c]
----
version_number = weechat_util_version_number ("0.3.8");      /* == 0x00030800 */
version_number = weechat_util_version_number ("0.3.9-dev");  /* == 0x00030900 */
version_number = weechat_util_version_number ("0.3.9-rc1");  /* == 0x00030900 */
version_number = weechat_util_version_number ("0.3.9");      /* == 0x00030900 */
version_number = weechat_util_version_number ("1.0");        /* == 0x01000000 */
version_number = weechat_util_version_number ("4.0.0");      /* == 0x04000000 */
----

[NOTE]
Ова функција није доступна у API скриптовања.

[[sorted_lists]]
=== Сортиране листе

Функције сортираних листи.

==== list_new

Креира нову листу.

Прототип:

[source,c]
----
struct t_weelist *weechat_list_new ();
----

Повратна вредност:

* показивач на нову листу

C пример:

[source,c]
----
struct t_weelist *list = weechat_list_new ();
----

Скрипта (Python):

[source,python]
----
# прототип
def list_new() -> str: ...

# пример
list = weechat.list_new()
----

==== list_add

Додаје ставку у листу.

Прототип:

[source,c]
----
struct t_weelist_item *weechat_list_add (struct t_weelist *weelist,
                                         const char *data,
                                         const char *where,
                                         void *user_data);
----

Аргументи:

* _weelist_: показивач на листу
* _data_: подаци који се умећу у листу
* _where_: позиција у листи:
** _WEECHAT_LIST_POS_SORT_: додавање у листу, уз одржање уређености
** _WEECHAT_LIST_POS_BEGINNING_: додавање на почетак листе
** _WEECHAT_LIST_POS_END_: додавање на крај листе
* _user_data_: било који показивач

Повратна вредност:

* показивач на нову ставку

C пример:

[source,c]
----
struct t_weelist_item *my_item =
    weechat_list_add (list, "my data", WEECHAT_LIST_POS_SORT, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def list_add(list: str, data: str, where: str, user_data: str) -> str: ...

# пример
item = weechat.list_add(list, "my data", weechat.WEECHAT_LIST_POS_SORT, "")
----

==== list_search

Претражује ставку у листи.

Прототип:

[source,c]
----
struct t_weelist_item *weechat_list_search (struct t_weelist *weelist,
                                            const char *data);
----

Аргументи:

* _weelist_: показивач на листу
* _data_: подаци који се траже у листи

Повратна вредност:

* показивач на пронађену ставку, NULL у случају да се ставка не пронађе

C пример:

[source,c]
----
struct t_weelist_item *item = weechat_list_search (list, "my data");
----

Скрипта (Python):

[source,python]
----
# прототип
def list_search(list: str, data: str) -> str: ...

# пример
item = weechat.list_search(list, "my data")
----

==== list_search_pos

_WeeChat ≥ 0.3.4._

Тражи позицију ставке у листи.

Прототип:

[source,c]
----
int weechat_list_search_pos (struct t_weelist *weelist,
                             const char *data);
----

Аргументи:

* _weelist_: показивач на листу
* _data_: подаци који се траже у листи

Повратна вредност:

* позиција пронађене ставке, -1 у случају да се ставка не пронађе

C пример:

[source,c]
----
int pos_item = weechat_list_search_pos (list, "my data");
----

Скрипта (Python):

[source,python]
----
# прототип
def list_search_pos(list: str, data: str) -> int: ...

# пример
pos_item = weechat.list_search_pos(list, "my data")
----

==== list_casesearch

Тражи ставку у листи, без разликовања величине слова.

Прототип:

[source,c]
----
struct t_weelist_item *weechat_list_casesearch (struct t_weelist *weelist,
                                                const char *data);
----

Аргументи:

* _weelist_: показивач на листу
* _data_: подаци који се траже у листи

Повратна вредност:

* показивач на пронађену ставку, NULL у случају да се ставка не пронађе

C пример:

[source,c]
----
struct t_weelist_item *item = weechat_list_casesearch (list, "my data");
----

Скрипта (Python):

[source,python]
----
# прототип
def list_casesearch(list: str, data: str) -> str: ...

# пример
item = weechat.list_casesearch(list, "my data")
----

==== list_casesearch_pos

_WeeChat ≥ 0.3.4._

Тражи позицију ставке у листи, без разликовања величине слова.

Прототип:

[source,c]
----
int weechat_list_casesearch_pos (struct t_weelist *weelist,
                                 const char *data);
----

Аргументи:

* _weelist_: показивач на листу
* _data_: подаци који се траже у листи

Повратна вредност:

* позиција пронађене ставке, -1 у случају да се ставка не пронађе

C пример:

[source,c]
----
int pos_item = weechat_list_casesearch_pos (list, "my data");
----

Скрипта (Python):

[source,python]
----
# прототип
def list_casesearch_pos(list: str, data: str) -> int: ...

# пример
pos_item = weechat.list_casesearch_pos(list, "my data")
----

==== list_get

Враћа ставку са одређене позиције у листи.

Прототип:

[source,c]
----
struct t_weelist_item *weechat_list_get (struct t_weelist *weelist,
                                         int position);
----

Аргументи:

* _weelist_: показивач на листу
* _position_: позиција у листи (прва ставка је 0)

Повратна вредност:

* показивач на пронађену ставку, NULL у случају да се ставка не пронађе

C пример:

[source,c]
----
struct t_weelist_item *item = weechat_list_get (list, 0);  /* прва ставка */
----

Скрипта (Python):

[source,python]
----
# прототип
def list_get(list: str, position: int) -> str: ...

# пример
item = weechat.list_get(list, 0)
----

==== list_set

Поставља ставку на нову вредност.

Прототип:

[source,c]
----
void weechat_list_set (struct t_weelist_item *item, const char *value);
----

Аргументи:

* _item_: показивач на ставку
* _value_: нова вредност ставке

C пример:

[source,c]
----
weechat_list_set (item, "new data");
----

Скрипта (Python):

[source,python]
----
# прототип
def list_set(item: str, value: str) -> int: ...

# пример
weechat.list_set(item, "new data")
----

==== list_next

Враћа наредну ставку у листи.

Прототип:

[source,c]
----
struct t_weelist_item *weechat_list_next (struct t_weelist_item *item);
----

Аргументи:

* _item_: показивач на ставку

Повратна вредност:

* показивач на наредну ставку, NULL у случају да је показивач био на последњој ставки листе

C пример:

[source,c]
----
struct t_weelist_item *next_item = weechat_list_next (item);
----

Скрипта (Python):

[source,python]
----
# прототип
def list_next(item: str) -> str: ...

# пример
item = weechat.list_next(item)
----

==== list_prev

Враћа претходну ставку у листи.

Прототип:

[source,c]
----
struct t_weelist_item *weechat_list_prev (struct t_weelist_item *item);
----

Аргументи:

* _item_: показивач на ставку

Повратна вредност:

* показивач на претходну ставку, NULL у случају да је показивач био на првој ставки листе

C пример:

[source,c]
----
struct t_weelist_item *prev_item = weechat_list_prev (item);
----

Скрипта (Python):

[source,python]
----
# прототип
def list_prev(item: str) -> str: ...

# пример
item = weechat.list_prev(item)
----

==== list_string

Враћа стринг вредност ставке.

Прототип:

[source,c]
----
const char *weechat_list_string (struct t_weelist_item *item);
----

Аргументи:

* _item_: показивач на ставку

Повратна вредност:

* стринг вредност ставке

C пример:

[source,c]
----
weechat_printf (NULL, "вредност ставке: %s", weechat_list_string (item));
----

Скрипта (Python):

[source,python]
----
# прототип
def list_string(item: str) -> str: ...

# пример
weechat.prnt("", "вредност ставке: %s" % weechat.list_string(item))
----

==== list_user_data

_WeeChat ≥ 2.6._

Враћа показивач на корисничке податке ставке.

Прототип:

[source,c]
----
void *weechat_list_user_data (struct t_weelist_item *item);
----

Аргументи:

* _item_: показивач на ставку

Повратна вредност:

* показивач на корисничке податке ставке

C пример:

[source,c]
----
weechat_printf (NULL, "кориснички подаци ставке: %p", weechat_list_user_data (item));
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== list_size

Враћа величину листе (број ставки).

Прототип:

[source,c]
----
char *weechat_list_size (struct t_weelist *weelist);
----

Аргументи:

* _weelist_: показивач на листу

Повратна вредност:

* величина листе (број ставки), 0 у случају да је листа празна

C пример:

[source,c]
----
weechat_printf (NULL, "величина листе: %d", weechat_list_size (list));
----

Скрипта (Python):

[source,python]
----
# прототип
def list_size(list: str) -> int: ...

# пример
weechat.prnt("", "величина листе: %d" % weechat.list_size(list))
----

==== list_remove

Уклања ставку из листе.

Прототип:

[source,c]
----
void weechat_list_remove (struct t_weelist *weelist,
                          struct t_weelist_item *item);
----

Аргументи:

* _weelist_: показивач на листу
* _item_: показивач на ставку

C пример:

[source,c]
----
weechat_list_remove (list, item);
----

Скрипта (Python):

[source,python]
----
# прототип
def list_remove(list: str, item: str) -> int: ...

# пример
weechat.list_remove(list, item)
----

==== list_remove_all

Уклања све ставке из листе.

Прототип:

[source,c]
----
void weechat_list_remove_all (struct t_weelist *weelist);
----

Аргументи:

* _weelist_: показивач на листу

C пример:

[source,c]
----
weechat_list_remove_all (list);
----

Скрипта (Python):

[source,python]
----
# прототип
def list_remove_all(list: str) -> int: ...

# пример
weechat.list_remove_all(list)
----

==== list_free

Ослобађа меморију коју заузима листа.

Прототип:

[source,c]
----
void weechat_list_free (struct t_weelist *weelist);
----

Аргументи:

* _weelist_: показивач на листу

C пример:

[source,c]
----
weechat_list_free (list);
----

Скрипта (Python):

[source,python]
----
# прототип
def list_free(list: str) -> int: ...

# пример
weechat.list_free(list)
----

[[array_lists]]
=== Низ листи

Функције низа листи.

Низ листи је листа показивача са динамичком величином и необавезним сортирањем.

==== arraylist_new

_WeeChat ≥ 1.8._

Креира нови низ листи.

Прототип:

[source,c]
----
struct t_arraylist *weechat_arraylist_new (int initial_size,
                                           int sorted,
                                           int allow_duplicates,
                                           int (*callback_cmp)(void *data,
                                                               struct t_arraylist *arraylist,
                                                               void *pointer1,
                                                               void *pointer2),
                                           void *callback_cmp_data,
                                           void (*callback_free)(void *data,
                                                                 struct t_arraylist *arraylist,
                                                                 void *pointer),
                                           void *callback_free_data);
----

Аргументи:

* _initial_size_: почетна величина низа листи (не број ставки)
* _sorted_: 1 ако низ листи треба да се сортира, 0 ако се не ради сортирање
* _allow_duplicates_: 1 ако су дозвољене дупликат ставке, 0 ако се спречава поновно додавање исте ставке
* _callback_cmp_: функција повратног позива која се користи за поређење две ставке (није обавезна), аргументи и повратна вредност су:
** _void *data_: показивач
** _struct t_arraylist *arraylist_: показивач на низ листи
** _void *pointer1_: показивач на прву ставку
** _void *pointer2_: показивач на другу ставку
** повратна вредност:
*** негативни број ако је прва ставка мања од друге ставке
*** 0 ако су прва и друга ставка једнаке
*** позитивни број ако је прва ставка већа од друге ставке
* _callback_cmp_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_free_: функција повратног позива која се користи да ослободи меморију коју заузима ставка (није обавезна), аргументи су:
** _void *data_: показивач
** _struct t_arraylist *arraylist_: показивач на низ листи
** _void *pointer_: показивач на ставку
* _callback_free_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat

Повратна вредност:

* показивач на нови низ листи

C пример:

[source,c]
----
int
cmp_cb (void *data, struct t_arraylist *arraylist,
        void *pointer1, void *pointer2)
{
    if (...)
        return -1;
    else if (...)
        return 1;
    else
        return 0;
}

struct t_arraylist *list = weechat_arraylist_new (32, 1, 1,
                                                  &cmp_cb, NULL, NULL, NULL);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== arraylist_size

_WeeChat ≥ 1.8._

Враћа величину низа листи (број ставки са показивачима).

Прототип:

[source,c]
----
int weechat_list_size (struct t_arraylist *arraylist);
----

Аргументи:

* _arraylist_: показивач на низ листи

Повратна вредност:

* величина низа листи (број ставки), 0 у случају да је низ листи празан

C пример:

[source,c]
----
weechat_printf (NULL, "величина низа листи: %d", weechat_arraylist_size (arraylist));
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== arraylist_get

_WeeChat ≥ 1.8._

Враћа показивач на ставку на одређеној позицији.

Прототип:

[source,c]
----
void *weechat_arraylist_get (struct t_arraylist *arraylist, int index);
----

Аргументи:

* _arraylist_: показивач на низ листи
* _index_: индекс у листи (први показивач је 0)

Повратна вредност:

* пронађени показивач, NULL ако показивач није могао да се пронађе

C пример:

[source,c]
----
void *pointer = weechat_arraylist_get (arraylist, 0);  /* прва ставка */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== arraylist_search

_WeeChat ≥ 1.8._

Тражи ставку у низу листи.

Прототип:

[source,c]
----
void *weechat_arraylist_search (struct t_arraylist *arraylist, void *pointer,
                                int *index, int *index_insert);
----

Аргументи:

* _arraylist_: показивач на низ листи
* _pointer_: показивач на ставку која се тражи у низу листи
* _index_: показивач на цео број који ће се поставити на пронађени индекс, или -1 ако се индекс не пронађе (није обавезно)
* _index_insert_: показивач на цео број које ће се поставити на индекс који мора да се употреби за уметање елемента у низ листи (како би низ листи остао уређен) (није обавезно)

Повратна вредност:

* показивач на пронађену ставку, NULL у случају да се ставка не пронађе

C пример:

[source,c]
----
int index, index_insert;
void *item = weechat_arraylist_search (arraylist, pointer, &index, &index_insert);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== arraylist_insert

_WeeChat ≥ 1.8._

Умеће ставку у низ листи.

Прототип:

[source,c]
----
int weechat_arraylist_insert (struct t_arraylist *arraylist, int index, void *pointer);
----

Аргументи:

* _arraylist_: показивач на низ листи
* _index_: позиција ставке у низу листи или -1 ако треба да се дода на крај (овај аргумент се користи само у случају да низ листи није сортиран, игнорише се у случају када је низ листи сортиран)
* _pointer_: показивач на ставку која треба да се уметне

Повратна вредност:

* индекс нове ставке (≥ 0), -1 у случају грешке.

C пример:

[source,c]
----
int index = weechat_arraylist_insert (arraylist, -1, pointer);  /* умеће на крај ако низ није сортиран */
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== arraylist_add

_WeeChat ≥ 1.8._

Додаје ставку у низ листи.

Прототип:

[source,c]
----
int weechat_arraylist_add (struct t_arraylist *arraylist, void *pointer);
----

Аргументи:

* _arraylist_: показивач на низ листи
* _pointer_: показивач на ставку која се додаје

Повратна вредност:

* индекс нове ставке (≥ 0), -1 у случају грешке.

C пример:

[source,c]
----
int index = weechat_arraylist_add (arraylist, pointer);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== arraylist_remove

_WeeChat ≥ 1.8._

Уклања ставку из низа листи.

Прототип:

[source,c]
----
int weechat_arraylist_remove (struct t_arraylist *arraylist, int index);
----

Аргументи:

* _arraylist_: показивач на низ листи
* _index_: индекс ставке која треба да се уклони

Повратна вредност:

* индекс уклоњене ставке, -1 у случају грешке.

C пример:

[source,c]
----
int index_removed = weechat_arraylist_remove (arraylist, index);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== arraylist_clear

_WeeChat ≥ 1.8._

Уклања све ставке из низа листи.

Прототип:

[source,c]
----
int weechat_arraylist_clear (struct t_arraylist *arraylist);
----

Аргументи:

* _arraylist_: показивач на низ листи

Повратна вредност:

* 1 ако је све OK, 0 у случају грешке

C пример:

[source,c]
----
if (weechat_arraylist_clear (arraylist))
{
    /* OK */
}
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== arraylist_free

_WeeChat ≥ 1.8._

Ослобађа меморију коју заузима низ листи.

Прототип:

[source,c]
----
void weechat_arraylist_free (struct t_arraylist *arraylist);
----

Аргументи:

* _arraylist_: показивач на низ листи

C пример:

[source,c]
----
weechat_arraylist_free (arraylist);
----

[NOTE]
Ова функција није доступна у API скриптовања.

[[hashtables]]
=== Хеш табеле

Функције хеш табели.

==== hashtable_new

_WeeChat ≥ 0.3.3, ажурирано у верзији 4.4.0._

Креира нову хеш табелу.

Прототип:

[source,c]
----
struct t_hashtable *weechat_hashtable_new (int size,
                                           const char *type_keys,
                                           const char *type_values,
                                           unsigned long long (*callback_hash_key)(struct t_hashtable *hashtable,
                                                                                   const void *key),
                                           int (*callback_keycmp)(struct t_hashtable *hashtable,
                                                                  const void *key1,
                                                                  const void *key2));
----

Аргументи:

* _size_: величина интерног низа који чува хеш кључеве, већа вредност користи више меморије, али су перформансе боље (ово *није* ограничење броја ставки у хеш табели)
* _type_keys_: тип кључева у хеш табели:
** _WEECHAT_HASHTABLE_INTEGER_
** _WEECHAT_HASHTABLE_STRING_
** _WEECHAT_HASHTABLE_POINTER_
** _WEECHAT_HASHTABLE_BUFFER_
** _WEECHAT_HASHTABLE_TIME_
** _WEECHAT_HASHTABLE_LONGLONG_ _(WeeChat ≥ 4.4.0)_
* _type_values_: тип вредности у хеш табели:
** _WEECHAT_HASHTABLE_INTEGER_
** _WEECHAT_HASHTABLE_STRING_
** _WEECHAT_HASHTABLE_POINTER_
** _WEECHAT_HASHTABLE_BUFFER_
** _WEECHAT_HASHTABLE_TIME_
** _WEECHAT_HASHTABLE_LONGLONG_ _(WeeChat ≥ 4.4.0)_
* _callback_hash_key_: функција повратног позива која се користи за „хеширање” кључа (кључ у облику целог броја), може да буде NULL ако тип кључа није „buffer” (користи се подразумевана хеш функција), аргументи и повратна вредност су:
** _struct t_hashtable *hashtable_: показивач на хеш табелу
** _const void *key_: кључ
** return value: хеш кључа
* _callback_keycmp_: функција повратног позива која се користи за поређење два кључа, може да буде NULL ако тип кључа није „buffer” (користи се подразумевана функција за поређење), аргументи и повратна вредност су:
** _struct t_hashtable *hashtable_: показивач на хеш табелу
** _const void *key1_: први кључ
** _const void *key2_: други кључ
** повратна вредност:
*** негативни број ако је _key1_ мањи од _key2_
*** 0 ако су _key1_ и _key2_ једнаки
*** позитивни број ако је _key1_ већи од _key2_

Повратна вредност:

* показивач на нову хеш табелу, NULL у случају грешке

C пример:

[source,c]
----
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== hashtable_set_with_size

_WeeChat ≥ 0.3.3, ажурирано у верзији 0.4.2._

Додаје или ажурира ставку у хеш табели са величином за кључ и вредност.

Прототип:

[source,c]
----
struct t_hashtable_item *weechat_hashtable_set_with_size (struct t_hashtable *hashtable,
                                                          const void *key, int key_size,
                                                          const void *value, int value_size);
----

Аргументи:

* _hashtable_: показивач на хеш табелу
* _key_: показивач на кључ
* _key_size_: величина кључа (у бајтовима), користи се само ако је тип кључева у хеш табели „buffer”
* _value_: показивач на вредност
* _value_size_: величина вредности (у бајтовима), користи се само ако је тип вредности у хеш табели „buffer”

Повратна вредност:

* показивач на креирану/ажурирану ставку, NULL у случају грешке

C пример:

[source,c]
----
weechat_hashtable_set_with_size (hashtable, "my_key", 0,
                                 my_buffer, sizeof (my_buffer_struct));
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== hashtable_set

_WeeChat ≥ 0.3.3, ажурирано у верзији 0.4.2._

Додаје или ажурира ставку у хеш табели.

Прототип:

[source,c]
----
struct t_hashtable_item *weechat_hashtable_set (struct t_hashtable *hashtable,
                                                const void *key, const void *value);
----

Аргументи:

* _hashtable_: показивач на хеш табелу
* _key_: показивач на кључ
* _value_: показивач на вредност

Повратна вредност:

* показивач на креирану/ажурирану ставку, NULL у случају грешке

C пример:

[source,c]
----
weechat_hashtable_set (hashtable, "my_key", "my_value");
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== hashtable_get

_WeeChat ≥ 0.3.3._

Враћа вредност придружену кључу у хеш табели.

Прототип:

[source,c]
----
void *weechat_hashtable_get (struct t_hashtable *hashtable, void *key);
----

Аргументи:

* _hashtable_: показивач на хеш табелу
* _key_: показивач на кључ

Повратна вредност:

* вредност за кључ, NULL ако кључ не може да се пронађе

C пример:

[source,c]
----
void *value = weechat_hashtable_get (hashtable, "my_key");
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== hashtable_has_key

_WeeChat ≥ 0.3.4._

Проверава да ли се кључ налази у хеш табели.

Прототип:

[source,c]
----
int weechat_hashtable_has_key (struct t_hashtable *hashtable, void *key);
----

Аргументи:

* _hashtable_: показивач на хеш табелу
* _key_: показивач на кључ

Повратна вредност:

* 1 ако се кључ налази у хеш табели, 0 ако се кључ не налази у хеш табели

C пример:

[source,c]
----
if (weechat_hashtable_has_key (hashtable, "my_key"))
{
    /* кључ се налази у хеш табели */
    /* ... */
}
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== hashtable_map

_WeeChat ≥ 0.3.3._

Позива функцију над свим ставкама хеш табеле, по редоследу уметања у хештабелу
(од најстарије до најновије).

Прототип:

[source,c]
----
void weechat_hashtable_map (struct t_hashtable *hashtable,
                            void (*callback_map)(void *data,
                                                 struct t_hashtable *hashtable,
                                                 const void *key,
                                                 const void *value),
                            void *callback_map_data);
----

Аргументи:

* _hashtable_: показивач на хеш табелу
* _callback_map_: функција која се позива за сваку ставку у хеш табели
* _callback_map_data_: показивач који се прослеђује функцији повратног позива мапирања када се позове

C пример:

[source,c]
----
void
map_cb (void *data, struct t_hashtable *hashtable,
        const void *key, const void *value)
{
    /* приказује кључ и вредност (овде су оба стрингови) */
    weechat_printf (NULL, "кључ: '%s', вредност: '%s'",
                    (const char *)key,
                    (const char *)value);
}
/* ... */
weechat_hashtable_map (hashtable, &map_cb, NULL);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== hashtable_map_string

_WeeChat ≥ 0.3.7._

Позива функцију над свим ставкама хеш табеле, по редоследу у којем су уметнуте у
хеш табелу (од најстарије до најновије), шаљући књучеве и вредности као стрингове.

Прототип:

[source,c]
----
void weechat_hashtable_map_string (struct t_hashtable *hashtable,
                                   void (*callback_map)(void *data,
                                                        struct t_hashtable *hashtable,
                                                        const char *key,
                                                        const char *value),
                                   void *callback_map_data);
----

Аргументи:

* _hashtable_: показивач на хеш табелу
* _callback_map_: функција која се позива за сваку ставку у хеш табели
* _callback_map_data_: показивач који се прослеђује функцији повратног позива мапирања када се позове

[NOTE]
Стрингови _key_ и _value_ који се шаљу функцији повратног позива су привремени стрингови, они се бришу након позива функције повратног позива.

C пример:

[source,c]
----
void
map_cb (void *data, struct t_hashtable *hashtable,
        const char *key, const char *value)
{
    /* приказ кључа и вредности */
    weechat_printf (NULL, "кључ: '%s', вредност: '%s'",
                    key, value);
}
/* ... */
weechat_hashtable_map_string (hashtable, &map_cb, NULL);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== hashtable_dup

_WeeChat ≥ 1.0._

Прави дупликат хеш табеле.

Прототип:

[source,c]
----
struct t_hashtable *weechat_hashtable_dup (struct t_hashtable *hashtable);
----

Аргументи:

* _hashtable_: показивач на хеш табелу

Повратна вредност:

* дулпирана хеш табела

C пример:

[source,c]
----
struct t_hashtable *new_hashtable = weechat_hashtable_dup (hashtable);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== hashtable_get_integer

_WeeChat ≥ 0.3.3._

Враћа целобројну вредност особине хеш табеле.

Прототип:

[source,c]
----
int weechat_hashtable_get_integer (struct t_hashtable *hashtable,
                                   void *property);
----

Аргументи:

* _hashtable_: показивач на хеш табелу
* _property_: име особине:
** _size_: величина интерног низа „htable” у хеш табели
** _items_count_: број ставки у хеш табели

Повратна вредност:

* целобројна вредност особине

C пример:

[source,c]
----
int items_count = weechat_hashtable_get_integer (hashtable, "items_count");
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== hashtable_get_string

_WeeChat ≥ 0.3.4._

Враћа стринг вредност особине хеш табеле.

Прототип:

[source,c]
----
const char *weechat_hashtable_get_string (struct t_hashtable *hashtable,
                                          const char *property);
----

Аргументи:

* _hashtable_: показивач на хеш табелу
* _property_: име особине:
** _type_keys_: тип кључева:
*** _integer_: цео број
*** _string_: стринг
*** _pointer_: показивач
*** _buffer_: бафер
*** _time_: време
*** _longlong_: long long цео број
** _type_values_: тип вредности:
*** _integer_: цео број
*** _string_: стринг
*** _pointer_: показивач
*** _buffer_: бафер
*** _time_: време
*** _longlong_: long long цео број
** _keys_: стринг са листом кључева (у формату: „кључ1,кључ2,кључ3”)
** _keys_sorted_: стринг са листом сортираних кључева (у формату: „кључ1,кључ2,кључ3”)
** _values_: стринг са листом вредности
** _keys_values_: стринг са листом кључева и вредности (у формату: „кључ1:вредност1,кључ2:вредност2,кључ3:вредност3”)
** _keys_values_sorted_: стринг са листом кључева и вредности (сортиран по кључевима) (у формату: „кључ1:вредност1,кључ2:вредност2,кључ3:вредност3”)

Повратна вредност:

* стринг вредност особине

C примери:

[source,c]
----
weechat_printf (NULL, "keys are type: %s",
                weechat_hashtable_get_string (hashtable, "type_keys"));
weechat_printf (NULL, "list of keys: %s",
                weechat_hashtable_get_string (hashtable, "keys"));
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== hashtable_set_pointer

_WeeChat ≥ 0.3.4._

Поставља вредност показивача на особину хеш табеле.

Прототип:

[source,c]
----
void weechat_hashtable_set_pointer (struct t_hashtable *hashtable,
                                    const char *property, void *pointer);
----

Аргументи:

* _hashtable_: показивач на хеш табелу
* _property_: име особине:
** _callback_free_key_: поставља функцију повратног позива која се користи за ослобађање меморије коју заузимају кључеви у хеш табели _(WeeChat ≥ 0.4.2)_
** _callback_free_value_: поставља функцију повратног позива која се користи за ослобађање меморије коју користе вредности у хеш табели
* _pointer_: нова вредност показивача за особину

C пример:

[source,c]
----
void
my_free_value_cb (struct t_hashtable *hashtable, const void *key, void *value)
{
    /* ... */
}

void
my_free_key_cb (struct t_hashtable *hashtable, void *key)
{
    /* ... */
}

weechat_hashtable_set_pointer (hashtable, "callback_free_value", &my_free_value_cb);
weechat_hashtable_set_pointer (hashtable, "callback_free_key", &my_free_key_cb);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== hashtable_add_to_infolist

_WeeChat ≥ 0.3.3._

Додаје ставе хеш табеле у ставку инфо листе, по редоследу у којем су уметнуте у хеш
табелу (од најстарије до најновије).

Прототип:

[source,c]
----
int weechat_hashtable_add_to_infolist (struct t_hashtable *hashtable,
                                       struct t_infolist_item *infolist_item,
                                       const char *prefix);
----

Аргументи:

* _hashtable_: показивач на хеш табелу
* _infolist_item_: показивач на ставку инфо листе
* _prefix_: стринг који се користи као префикс за имена у инфо листи

Повратна вредност:

* 1 ако је све OK, 0 у случају грешке

C пример:

[source,c]
----
weechat_hashtable_add_to_infolist (hashtable, infolist_item, "testhash");

/* ако хеш табела садржи:
     "кључ1" => "вредност 1"
     "кључ2" => "вредност 2"
   онда ће се у ставку инфо листе додати следеће променљиве:
     "testhash_name_00000"  = "кључ1"
     "testhash_value_00000" = "вредност 1"
     "testhash_name_00001"  = "кључ2"
     "testhash_value_00001" = "вредност 2"
*/
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== hashtable_add_from_infolist

_WeeChat ≥ 2.2._

Додаје ставке инфо листе у хеш табелу.

Прототип:

[source,c]
----
int weechat_hashtable_add_from_infolist (struct t_hashtable *hashtable,
                                         struct t_infolist *infolist,
                                         const char *prefix);
----

Аргументи:

* _hashtable_: показивач на хеш табелу
* _infolist_: показивач на инфо листу
* _prefix_: стринг који се користи као префикс за имена у инфо листи

Повратна вредност:

* 1 ако је све OK, 0 у случају грешке

C пример:

[source,c]
----
weechat_hashtable_add_from_infolist (hashtable, infolist, "testhash");

/* ако инфо листа садржи:
     "testhash_name_00000"  = "кључ1"
     "testhash_value_00000" = "вредност 1"
     "testhash_name_00001"  = "кључ2"
     "testhash_value_00001" = "вредност 2"
   онда ће се у хеш табелу додати следеће променљиве:
     "кључ1" => "вредност 1"
     "кључ2" => "вредност 2"
*/
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== hashtable_remove

_WeeChat ≥ 0.3.3._

Уклања ставку из хеш табеле.

Прототип:

[source,c]
----
void weechat_hashtable_remove (struct t_hashtable *hashtable, const void *key);
----

Аргументи:

* _hashtable_: показивач на хеш табелу
* _key_: показивач на кључ

C пример:

[source,c]
----
weechat_hashtable_remove (hashtable, "my_key");
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== hashtable_remove_all

_WeeChat ≥ 0.3.3._

Уклања све ставке из хеш табеле.

Прототип:

[source,c]
----
void weechat_hashtable_remove_all (struct t_hashtable *hashtable);
----

Аргументи:

* _hashtable_: показивач на хеш табелу

C пример:

[source,c]
----
weechat_hashtable_remove_all (hashtable);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== hashtable_free

_WeeChat ≥ 0.3.3._

Ослобађа меморију коју заузима хеш табела.

Прототип:

[source,c]
----
void weechat_hashtable_free (struct t_hashtable *hashtable);
----

Аргументи:

* _hashtable_: показивач на хеш табелу

C пример:

[source,c]
----
weechat_hashtable_free (hashtable);
----

[NOTE]
Ова функција није доступна у API скриптовања.

[[configuration_files]]
=== Конфигурациони фајлови

Функције за конфигурационе фајлове.

==== config_new

_Ажурирано у верзији 1.5, 4.0.0._

Креира нови конфигурациони фајл.

Прототип:

[source,c]
----
struct t_config_file *weechat_config_new (const char *name,
                                          int (*callback_reload)(const void *pointer,
                                                                 void *data,
                                                                 struct t_config_file *config_file),
                                          const void *callback_reload_pointer,
                                          void *callback_reload_data);
----

Аргументи:

* _name_: име конфигурационог фајла (без путање или екстензије); приоритет
  је дозвољен испред имена, у формату `nnn|име` где је `nnn` цео позитиван број
  који представља приоритет; подразумевани приоритет је 1000; када се извршава
  команда `/reload` фајлови се сортирају према приоритету, од вишег ка нижем
  (погледајте приоритет конфигурационих фајлова испод)
* _callback_reload_: функција која се позива када се командом `/reload` поново учита конфигурациони фајл (није обавезна, може да буде NULL, погледајте испод), аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _struct t_config_file *config_file_: показивач на конфигурациони фајл
** повратна вредност:
*** _WEECHAT_CONFIG_READ_OK_
*** _WEECHAT_CONFIG_READ_MEMORY_ERROR_
*** _WEECHAT_CONFIG_READ_FILE_NOT_FOUND_
* _callback_reload_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_reload_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, онда је алоциран са malloc (или неком сличном функцијом) и аутоматски се ослобађа када се ослободи конфигурациони фајл

Функција повратног позива код поновног учитавања:

* Функција повратног позива сме само да позове функцију <<_config_reload,config_reload>>, не сме да уклања конфигурациони фајл.
* Функција повратног позива је потребна само ако треба да се обаве неке ствари пре и/или након позива функције <<_config_reload,config_reload>>. +
Ако се не наведе функција повратног позива, програм WeeChat ће позвати своју интерну функцију за поновно учитавање, тако да ће се конфигурациони фајл поново учитати у свим случајевима.

Повратна вредност:

* показивач на нови конфигурациони фајл, NULL у случају грешке

[NOTE]
Ова функција НЕ креира фајл на диску. Фајл ће се креирати позивом функције <<_config_write,config_write>>. Ово функцију би требало да позовете само након додавања неких одељака (са <<_config_new_section,config_new_section>>) и опција (са <<_config_new_option,config_new_option>>).

Приоритет подразумеваних конфигурационих фајлова:

include::{autogendir}/autogen_api_config_priority.sr.adoc[tag=config_priority]

C пример:

[source,c]
----
int
my_config_reload_cb (const void *pointer, void *data,
                     struct t_config_file *config_file)
{
    /* ... */

    return WEECHAT_RC_OK;
}

struct t_config_file *config_file = weechat_config_new ("test",
                                                        &my_config_reload_cb,
                                                        NULL, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def config_new(name: str, callback_reload: str, callback_reload_data: str) -> str: ...

# пример
def my_config_reload_cb(data: str, config_file: str) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

config_file = weechat.config_new("test", "my_config_reload_cb", "")
----

==== config_set_version

_WeeChat ≥ 4.0.0._

Поставља верзију конфигурационог фајла и функцију повратног позива за ажурирање конфигурационих
одељака/опција у лету, док се чита конфигурација.

Прототип:

[source,c]
----
int config_file_set_version (struct t_config_file *config_file,
                             int version,
                             struct t_hashtable *(*callback_update)(const void *pointer,
                                                                    void *data,
                                                                    struct t_config_file *config_file,
                                                                    int version_read,
                                                                    struct t_hashtable *data_read),
                             const void *callback_update_pointer,
                             void *callback_update_data);
----

Аргументи:

* _config_file_: показивач на конфигурациони фајл
* _version_: верзија, мора бити ≥ 2
* _callback_update_: функција која се позива када се чита конфигурациони фајл, за сваки
  одељак и сваку опцију, ако је прочитана верзија мања од очекиване верзије,
  (није обавезно, ноже да буде NULL, погледајте испод), аргументи и повратна вредност:
** _const void *pointer_: показивач
** _void *data_: показивач
** _struct t_config_file *config_file_: показивач на конфигурациони фајл
** _int version_read_: верзија прочитана у конфигурационом фајлу (подразумевано 1)
** _struct t_hashtable *data_read_: хеш табела са подацима прочитаним из конфигурационом
   фајлу (погледајте испод)
** повратна вредност:
*** или „data_read” показивач (довршена хеш табелом), или показивача на нову
    хеш табелу (коју је креирала функција повратног позива, са кључевима и вредностима типа „string”)
* _callback_update_pointer_: показивач који се прослеђује функцији повратног позива када је
  позове WeeChat
* _callback_update_data_: показивач који се прослеђује функцији повратног позива када је
  позове WeeChat; ако није NULL, мора да је алоциран са malloc (или сличном функцијом)
  и аутоматски се ослобађа када се ослободи конфигурациони фајл

Функција повратног позива за ажурирање:

* Функција повратног озива прихвата хеш табелу са подацима прочитаним из конфигурационог фајла:

[width="100%",cols="1m,2,8",options="header"]
|===
| Кључ       | Доступност      | Вредност
| config     | Увек постављено | Име конфигурационог фајла, без екстензије (нпр.: `weechat`)
| section    | Увек постављено | Име одељка који се чита
| option     | Само за опцију  | Име опције
| value      | Само за опцију  | Вредност опције (ако није NULL)
| value_null | Само за опцију  | Опција као NULL вредност (вредност је увек `1`)
|===

* Функција повратног позива може да ажурира „section” за линију са одељком и „option”, „value”
  и „value_null” за линију са опцијом.
* Ако је функција повратног позива поставила „option” на празан стринг, игнорише се линија
  прочитана из конфигурационог фајла.
* Поље „value_null” се поставља да би се за опцију форсирала NULL вредност.

Повратна вредност:

* 1 ако је OK, 0 у случају грешке

C пример:

[source,c]
----
struct t_hashtable *
my_config_update_cb (const void *pointer, void *data,
                     struct t_config_file *config_file,
                     int version_read,
                     struct t_hashtable *data_read)
{
    const char *ptr_section, *ptr_option;

    /* врати се сад ако је верзија већ ажурна */
    if (version_read >= 2)
        return NULL;

    ptr_section = hashtable_get (data_read, "section");
    ptr_option = hashtable_get (data_read, "option");

    /* промени име одељка „abc” на „def” */
    if (ptr_section && !ptr_option && (strcmp (ptr_section, "abc") == 0))
    {
        hashtable_set (data_read, "section", "def");
        return data_read;
    }

    /* ограничи остале измене на одељак „test” */
    if (!ptr_section || !ptr_option || (strcmp (ptr_section, "test") != 0))
        return NULL;

    /* промени име опције „test1” на „test2” */
    if (strcmp (ptr_option, "test1") == 0)
    {
        hashtable_set (data_read, "option", "test2");
        return data_read;
    }

    /* постави вредност опције „test” на „xxx” */
    if (strcmp (ptr_option, "test") == 0)
    {
        hashtable_set (data_read, "value", "xxx");
        return data_read;
    }

    /* постави вредност опције „test_null” на NULL */
    if (strcmp (ptr_option, "test_null") == 0)
    {
        hashtable_set (data_read, "value_null", "1");
        return data_read;
    }

    /* нема измена */
    return NULL;
}

struct t_config_file *config_file = weechat_config_new ("test", NULL, NULL, NULL);
weechat_config_set_version (config_file, 2, &my_config_update_cb, NULL, NULL);
weechat_config_read (config_file);
----

Скрипта (Python):

[source,python]
----
# прототип
def config_set_version(config_file: str, version: int, callback_update: str, callback_update_data: str) -> int: ...

# пример
def my_config_update_cb(data: str, config_file: str, version_read: int, data_read: Dict[str, str]) -> Dict[str, str]:
    # врати се сад ако је верзија већ ажурна
    if version_read >= 2:
        return {}

    section = data_read.get("section")
    option = data_read.get("option")

    # промени име одељка „abc” на „def”
    if section and not option and section == "abc":
        data_read["section"] = "def"
        return data_read

    # ограничи остале измене на одељак „test”
    if not section or not option or section != "test":
        return {}

    # промени име опције „test1” на „test2” */
    if option == "test1":
        data_read["option"] = "test2"
        return data_read

    # set value to "xxx" for option "test"
    if option == "test":
        data_read["value"] = "xxx"
        return data_read

    # постави вредност опције „test_null” на NULL
    if option == "test_null":
        data_read["value_null"] = "1"
        return data_read

    # no changes
    return {}

config_file = weechat.config_new("test", "", "")
weechat.config_set_version(config_file, 2, "my_config_update_cb", "")
weechat.config_read(config_file)
----

==== config_new_section

_Ажурирано у верзији 1.5._

Креира нови одељак у конфигурационом фајлу.

Прототип:

[source,c]
----
struct t_config_section *weechat_config_new_section (
    struct t_config_file *config_file,
    const char *name,
    int user_can_add_options,
    int user_can_delete_options,
    int (*callback_read)(const void *pointer,
                         void *data,
                         struct t_config_file *config_file,
                         struct t_config_section *section,
                         const char *option_name,
                         const char *value),
    const void *callback_read_pointer,
    void *callback_read_data,
    int (*callback_write)(const void *pointer,
                          void *data,
                          struct t_config_file *config_file,
                          const char *section_name),
    const void *callback_write_pointer,
    void *callback_write_data,
    int (*callback_write_default)(const void *pointer,
                                  void *data,
                                  struct t_config_file *config_file,
                                  const char *section_name),
    const void *callback_write_default_pointer,
    void *callback_write_default_data,
    int (*callback_create_option)(const void *pointer,
                                  void *data,
                                  struct t_config_file *config_file,
                                  struct t_config_section *section,
                                  const char *option_name,
                                  const char *value),
    const void *callback_create_option_pointer,
    void *callback_create_option_data,
    int (*callback_delete_option)(const void *pointer,
                                  void *data,
                                  struct t_config_file *config_file,
                                  struct t_config_section *section,
                                  struct t_config_option *option),
    const void *callback_delete_option_pointer,
    void *callback_delete_option_data);
----

Аргументи:

* _config_file_: показивач на конфигурациони фајл
* _name_: име одељка
* _user_can_add_options_: 1 ако корисник у одељку може да креира нове опције, или 0 ако је то забрањено
* _user_can_delete_options_: 1 ако корисник може да брише опције у одељку, или 0 ако је то забрањено
* _callback_read_: функција која се позива када се опција у одељку прочита са диска (у већини случајева би требало да буде NULL, осим ако опције у одељку захтевају прилагођену функцију), аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _struct t_config_file *config_file_: показивач на конфигурациони фајл
** _struct t_config_section *section_: показивач на одељак
** _const char *option_name_: име опције
** _const char *value_: вредност
** повратна вредност:
*** _WEECHAT_CONFIG_OPTION_SET_OK_CHANGED_
*** _WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE_
*** _WEECHAT_CONFIG_OPTION_SET_ERROR_
*** _WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND_
* _callback_read_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_read_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се ослободи одељак
* _callback_write_: функција која се позива када се одељак уписује у фајл (у већини случајева би требало да буде NULL, осим ако је потребно да се одељак упише прилагођеном функцијом), аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _struct t_config_file *config_file_: показивач на конфигурациони фајл
** _struct t_config_section *section_: показивач на одељак
** _const char *section_name_: име одељка
** повратна вредност:
*** _WEECHAT_CONFIG_WRITE_OK_
*** _WEECHAT_CONFIG_WRITE_ERROR_
*** _WEECHAT_CONFIG_WRITE_MEMORY_ERROR_
* _callback_write_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_write_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се ослободи одељак
* _callback_write_default_: функција која се позива када у фајл мора да се упишу подразумеване опције за одељак, аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _struct t_config_file *config_file_: показивач на конфигурациони фајл
** _const char *section_name_: име одељка
** повратна вредност:
*** _WEECHAT_CONFIG_WRITE_OK_
*** _WEECHAT_CONFIG_WRITE_ERROR_
*** _WEECHAT_CONFIG_WRITE_MEMORY_ERROR_
* _callback_write_default_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_write_default_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се одељак ослободи
* _callback_create_option_: функција која се позива када се у одељку креира нова опција (NULL ако одељак не дозвољава креирање нових опција), аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _struct t_config_file *config_file_: показивач на конфигурациони фајл
** _struct t_config_section *section_: показивач на одељак
** _const char *option_name_: име опције
** _const char *value_: вредност
** повратна вредност:
*** _WEECHAT_CONFIG_OPTION_SET_OK_CHANGED_
*** _WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE_
*** _WEECHAT_CONFIG_OPTION_SET_ERROR_
*** _WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND_
* _callback_create_option_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_create_option_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се ослободи одељак
* _callback_delete_option_: функција која се позива када се у одељку обрише опција (NULL ако одељак не дозвољава брисање опција), аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _struct t_config_file *config_file_: показивач на конфигурациони фајл
** _struct t_config_section *section_: показивач на одељак
** _struct t_config_option *option_: показивач на опцију
** повратна вредност:
*** _WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET_
*** _WEECHAT_CONFIG_OPTION_UNSET_OK_RESET_
*** _WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED_
*** _WEECHAT_CONFIG_OPTION_UNSET_ERROR_
* _callback_delete_option_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_delete_option_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или слична функција) и аутоматски се ослобађа када се ослободи одељак

Повратна вредност:

* показивач на нови одељак у конфигурационом фајлу, NULL у случају грешке

C пример:

[source,c]
----
int
my_section_read_cb (const void *pointer, void *data,
                    struct t_config_file *config_file,
                    struct t_config_section *section,
                    const char *option_name,
                    const char *value)
{
    /* ... */

    return WEECHAT_CONFIG_OPTION_SET_OK_CHANGED;
    /* return WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE; */
    /* return WEECHAT_CONFIG_OPTION_SET_ERROR; */
    /* return WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND; */
}

int
my_section_write_cb (const void *pointer, void *data,
                     struct t_config_file *config_file,
                     const char *section_name)
{
    /* ... */

    return WEECHAT_CONFIG_WRITE_OK;
    /* return WEECHAT_CONFIG_WRITE_ERROR; */
    /* return WEECHAT_CONFIG_WRITE_MEMORY_ERROR; */
}

int
my_section_write_default_cb (const void *pointer, void *data,
                             struct t_config_file *config_file,
                             const char *section_name)
{
    /* ... */

    return WEECHAT_CONFIG_WRITE_OK;
    /* return WEECHAT_CONFIG_WRITE_ERROR; */
    /* return WEECHAT_CONFIG_WRITE_MEMORY_ERROR; */
}

int
my_section_create_option_cb (const void *pointer, void *data,
                             struct t_config_file *config_file,
                             struct t_config_section *section,
                             const char *option_name,
                             const char *value)
{
    /* ... */

    return WEECHAT_CONFIG_OPTION_SET_OK_CHANGED;
    /* return WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE; */
    /* return WEECHAT_CONFIG_OPTION_SET_ERROR; */
    /* return WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND; */
}

int
my_section_delete_option_cb (const void *pointer, void *data,
                             struct t_config_file *config_file,
                             struct t_config_section *section,
                             struct t_config_option *option)
{
    /* ... */

    return WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED;
    /* return WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET; */
    /* return WEECHAT_CONFIG_OPTION_UNSET_OK_RESET; */
    /* return WEECHAT_CONFIG_OPTION_UNSET_ERROR; */
}

/* стандардни одељак, корисник не може да додаје/брише опције */
struct t_config_section *new_section1 =
    weechat_config_new_section (config_file, "section1", 0, 0,
                                NULL, NULL, NULL,
                                NULL, NULL, NULL,
                                NULL, NULL, NULL,
                                NULL, NULL, NULL,
                                NULL, NULL, NULL);

/* специјални одељак, корисник може да додаје/брише опције и за упис/читање
   опција је потребна функција повратног позива */
struct t_config_section *new_section2 =
    weechat_config_new_section (config_file, "section2", 1, 1,
                                &my_section_read_cb, NULL, NULL,
                                &my_section_write_cb, NULL, NULL,
                                &my_section_write_default_cb, NULL, NULL,
                                &my_section_create_option_cb, NULL, NULL,
                                &my_section_delete_option_cb, NULL, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def config_new_section(config_file: str, name: str,
                       user_can_add_options: int, user_can_delete_options: int,
                       callback_read: str, callback_read_data: str,
                       callback_write: str, callback_write_data: str,
                       callback_write_default: str, callback_write_default_data: str,
                       callback_create_option: str, callback_create_option_data: str,
                       callback_delete_option: str, callback_delete_option_data: str) -> str: ...

# пример
def my_section_read_cb(data: str, config_file: str, section: str, option_name: str, value: Union[str, None]) -> int:
    # ...
    return weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED
    # return weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE
    # return weechat.WEECHAT_CONFIG_OPTION_SET_ERROR
    # return weechat.WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND

def my_section_write_cb(data: str, config_file: str, section_name: str) -> int:
    # ...
    return weechat.WEECHAT_CONFIG_WRITE_OK
    # return weechat.WEECHAT_CONFIG_WRITE_ERROR
    # return weechat.WEECHAT_CONFIG_WRITE_MEMORY_ERROR

def my_section_write_default_cb(data: str, config_file: str, section_name: str) -> int:
    # ...
    return weechat.WEECHAT_CONFIG_WRITE_OK
    # return weechat.WEECHAT_CONFIG_WRITE_ERROR
    # return weechat.WEECHAT_CONFIG_WRITE_MEMORY_ERROR

def my_section_create_option_cb(data: str, config_file: str, section: str, option_name: str, value: Union[str, None]) -> int:
    # ...
    return weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED
    # return weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE
    # return weechat.WEECHAT_CONFIG_OPTION_SET_ERROR
    # return weechat.WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND

def my_section_delete_option_cb(data: str, config_file: str, section: str, option: str) -> int:
    # ...
    return weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED
    # return weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET
    # return weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_RESET
    # return weechat.WEECHAT_CONFIG_OPTION_UNSET_ERROR

section = weechat.config_new_section(config_file, "section1", 1, 1,
    "my_section_read_cb", "",
    "my_section_write_cb", "",
    "my_section_write_default_cb", "",
    "my_section_create_option_cb", "",
    "my_section_delete_option_cb", "")
----

==== config_search_section

Тражи одељак у конфигурационом фајлу.

Прототип:

[source,c]
----
struct t_config_section *weechat_config_search_section (
    struct t_config_file *config_file,
    const char *section_name);
----

Аргументи:

* _config_file_: показивач на конфигурациони фајл
* _section_name_: име одељка који се тражи

Повратна вредност:

* показивач на пронађени одељак, NULL у случају да се одељак не пронађе

C пример:

[source,c]
----
struct t_config_section *section = weechat_config_search_section (config_file,
                                                                  "section");
----

Скрипта (Python):

[source,python]
----
# прототип
def config_search_section(config_file: str, section_name: str) -> str: ...

# пример
section = weechat.config_search_section(config_file, "section")
----

==== config_new_option

_Ажурирано у верзији 1.5, 4.1.0._

Креира нову опцију у одељку конфигурационог фајла.

Прототип:

[source,c]
----
struct t_config_option *weechat_config_new_option (
    struct t_config_file *config_file,
    struct t_config_section *section,
    const char *name,
    const char *type,
    const char *description,
    const char *string_values,
    int min,
    int max,
    const char *default_value,
    const char *value,
    int null_value_allowed,
    int (*callback_check_value)(const void *pointer,
                                void *data,
                                struct t_config_option *option,
                                const char *value),
    const void *callback_check_value_pointer,
    void *callback_check_value_data,
    void (*callback_change)(const void *pointer,
                            void *data,
                            struct t_config_option *option),
    const void *callback_change_pointer,
    void *callback_change_data,
    void (*callback_delete)(const void *pointer,
                            void *data,
                            struct t_config_option *option),
    const void *callback_delete_pointer,
    void *callback_delete_data);
----

Аргументи:

* _config_file_: показивач на конфигурациони фајл
* _section_: показивач на одељак
* _name_: име опције; у програм у WeeChat верзије ≥ 1.4, име може да укључи и име родитељске опције (у случају да је ова опција „null”, вредност родитељске опције ће се приказати у излазу команде `/set`), тада је синтакса: „име << фајл.одељак.опција”
* _type_: тип опције:
** _boolean_: логичка вредност (on/off)
** _integer_: целобројна вредност
** _string_: стринг вредност
** _color_: боја
** _enum_: листа стринг вредности (интерно се чува као цео број)
* _description_: опис опције
* _string_values_: вредности као стринг (раздвојене са `+|+`) (није обавезно, потребно је
  за тип _enum_)
* _min_: минимална вредност (за _integer_ тип)
* _max_: максимална вредност (за _integer_ тип)
* _default_value_: подразумевана вредност опције (користи се када се опција ресетује)
* _value_: вредност за опцију
* _null_value_allowed_: 1 ако се за опцију дозвољава _null_ (недефинисана вредност), у супротном 0
* _callback_check_value_: функција која се позива за проверу нове вредности опције (није обавезна), аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _struct t_config_option *option_: показивач на опцију
** _const char *value_: нова вредност опције
** повратна вредност:
*** 1 ако је вредност ОК
*** 0 ако је вредност неважећа
* _callback_check_value_pointer_: показивач који се прослеђује check_value функцији повратног позива када је позове програм WeeChat
* _callback_check_value_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се ослободи опција
* _callback_change_: функција која се позива када се промени вредност опције (није обавезна), аргументи су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _struct t_config_option *option_: показивач на опцију
* _callback_change_pointer_: показивач који се прослеђује change функцији повратног позива када је позове програм WeeChat
* _callback_change_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се ослободи опција
* _callback_delete_: функција која се позива када се опција брише (није обавезна), аргументи су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _struct t_config_option *option_: показивач на опцију
* _callback_delete_pointer_: показивач који се прослеђује delete функцији повратног позива када је позове програм WeeChat
* _callback_delete_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или слична функција) и аутоматски се ослобађа када се ослободи опција

Повратна вредност:

* показивач на нову опцију у одељку, NULL у случају грешке

C пример:

[source,c]
----
/* логичка */
struct t_config_option *option_bool =
    weechat_config_new_option (config_file, section, "option_bool", "boolean",
                               "My option, type boolean",
                               NULL,
                               0, 0,
                               "on",
                               "on",
                               0,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL);

/* целобројна */
struct t_config_option *option_int =
    weechat_config_new_option (config_file, section, "option_int", "integer",
                               "My option, type integer",
                               NULL,
                               0, 100,
                               "15",
                               "15",
                               0,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL);

/* стринг */
struct t_config_option *option_str =
    weechat_config_new_option (config_file, section, "option_str", "string",
                               "My option, type string",
                               NULL,
                               0, 0,
                               "test",
                               "test",
                               1,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL);

/* боја */
struct t_config_option *option_col =
    weechat_config_new_option (config_file, section, "option_col", "color",
                               "My option, type color",
                               NULL,
                               0, 0,
                               "lightblue",
                               "lightblue",
                               0,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL);

/* целобројна (са стринг вредностима) */
struct t_config_option *option_enum =
    weechat_config_new_option (config_file, section, "option_enum", "enum",
                               "My option, type enum",
                               "top|bottom|left|right",
                               0, 0,
                               "bottom",
                               "bottom",
                               0,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def config_new_option(config_file: str, section: str, name: str, type: str, description: str,
                      string_values: str, min: int, max: int,
                      default_value: Union[str, None], value: Union[str, None], null_value_allowed: int,
                      callback_check_value: str, callback_check_value_data: str,
                      callback_change: str, callback_change_data: str,
                      callback_delete: str, callback_delete_data: str) -> str: ...

# пример
def option_str_check_value_cb(data: str, option: str, value: str) -> int:
    # ...
    return 1
    # return 0

def option_str_change_cb(data: str, option: str) -> None:
    # ...

def option_str_delete_cb(data: str, option: str) -> None:
    # ...

option_bool = weechat.config_new_option(config_file, section, "option_bool", "boolean",
    "My option, type boolean",
    "", 0, 0, "on", "on", 0,
    "", "",
    "", "",
    "", "")

option_int = weechat.config_new_option(config_file, section, "option_int", "integer",
    "My option, type integer",
    "", 0, 100, "15", "15", 0,
    "", "",
    "", "",
    "", "")

option_str = weechat.config_new_option(config_file, section, "option_str", "string",
    "My option, type string",
    "", 0, 0, "test", "test", 1,
    "option_str_check_value_cb", "",
    "option_str_change_cb", "",
    "option_str_delete_cb", "")

option_col = weechat.config_new_option(config_file, section, "option_col", "color",
    "My option, type color",
    "", 0, 0, "lightblue", "lightblue", 0,
    "", "",
    "", "",
    "", "")

option_enum = weechat.config_new_option(config_file, section, "option_enum", "enum",
    "My option, type enum",
    "top|bottom|left|right",
    0, 0, "bottom", "bottom", 0,
    "", "",
    "", "",
    "", "")
----

[NOTE]
У језику Ruby, 3 функције повратног позива + подаци (6 стрингова) морају да се наведу у низу од 6 стрингова (услед Ruby ограничења од 15 аргумената по функцији), за више информација, погледајте link:++weechat_scripting.sr.html#_ruby++[WeeChat водич за скриптовање ^↗^^] _(исправљено у верзији 0.4.1)_.

==== config_search_option

Тражи опцију у одељку конфигурационог фајла.

Прототип:

[source,c]
----
struct t_config_option *weechat_config_search_option (
    struct t_config_file *config_file,
    struct t_config_section *section,
    const char *option_name);
----

Аргументи:

* _config_file_: показивач на конфигурациони фајл
* _section_: показивач на одељак
* _name_: име опције која се тражи

Повратна вредност:

* показивач на нађену опцију, NULL у случају да се опција не нађе

C пример:

[source,c]
----
struct t_config_option *option =
    weechat_config_search_option (config_file, section, "option");
----

Скрипта (Python):

[source,python]
----
# прототип
def config_search_option(config_file: str, section: str, option_name: str) -> str: ...

# пример
option = weechat.config_search_option(config_file, section, "option")
----

==== config_search_section_option

Тражи одељак и опцију у конфигурационом фајлу или одељку.

Прототип:

[source,c]
----
void weechat_config_search_section_option (struct t_config_file *config_file,
                                           struct t_config_section *section,
                                           const char *option_name,
                                           struct t_config_section **section_found,
                                           struct t_config_option **option_found);
----

Аргументи:

* _config_file_: показивач на конфигурациони фајл
* _section_: показивач на одељак
* _option_name_: име опције
* _section_found_: показивач на показивач одељка, ако се пронађе, поставиће се на одељак опције
* _option_found_: показивач на показивач опције, ако се пронађе, поставиће се на показивач опције

C пример:

[source,c]
----
struct t_config_section *ptr_section;
struct t_config_option *ptr_option;

weechat_config_search_section_option(config_file,
                                     section,
                                     "option",
                                     &ptr_section,
                                     &ptr_option);
if (ptr_option)
{
    /* опција је пронађена */
}
else
{
    /* опција није пронађена */
}
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== config_search_with_string

Враћа инфо о фајлу/одељку/опцији опције са пуним именом.

Прототип:

[source,c]
----
void weechat_config_search_with_string (const char *option_name,
                                        struct t_config_file **config_file,
                                        struct t_config_section **section,
                                        struct t_config_option **option,
                                        char **pos_option_name);
----

Аргументи:

* _option_name_: пуно име опције (у формату: „фајл.одељак.опција”)
* _config_file_: показивач на показивач конфигурационог фајла, ако се опција пронађе, поставиће се на показивач конфигурационог фајла
* _section_: показивач на показивач одељка, ако се пронађе, поставиће се на одељак у коме је опција
* _option_: показивач на показивач опције, ако се пронађе, поставиће се на показивач опције
* _pos_option_name_: показивач на показивач стринга, ако се пронађе, поставиће се на показивач имена опције

C пример:

[source,c]
----
struct t_config_file *ptr_config_file;
struct t_config_section *ptr_section;
struct t_config_option *ptr_option;
char *option_name;

weechat_config_search_with_string ("file.section.option",
                                   &ptr_config_file,
                                   &ptr_section,
                                   &ptr_option,
                                   &option_name);
if (ptr_option)
{
    /* опција је пронађена */
}
else
{
    /* опција није пронађена */
}
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== config_string_to_boolean

Проверава да ли је текст „true” или „false”, као логичка вредност.

Прототип:

[source,c]
----
int weechat_config_string_to_boolean (const char *text);
----

Аргументи:

* _text_: текст који се анализира

Повратна вредност:

* 1 ако је текст „true” („on”, „yes”, „y”, „true”, „t”, „1”)
* 0 ако је текст „false” („off”, „no”, „n”, „false”, „f”, „0”)

C пример:

[source,c]
----
if (weechat_config_string_to_boolean (option_value))
{
    /* вредност је "true" */
}
else
{
    /* вредност је "false" */
}
----

Скрипта (Python):

[source,python]
----
# прототип
def config_string_to_boolean(text: str) -> int: ...

# пример
if weechat.config_string_to_boolean(text):
    # ...
----

==== config_option_reset

Ресетује опцију на њену подразумевану вредности.

Прототип:

[source,c]
----
int weechat_config_option_reset (struct t_config_option *option,
                                 int run_callback);
----

Аргументи:

* _option_: показивач на опцију
* _run_callback_: 1 за позив функције повратног позива ако је вредност опције промењена, у супротном 0

Повратна вредност:

* _WEECHAT_CONFIG_OPTION_SET_OK_CHANGED_ ако је вредност опције ресетована
* _WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE_ ако вредност није измењена
* _WEECHAT_CONFIG_OPTION_SET_ERROR_ ако је дошло до грешке

C пример:

[source,c]
----
switch (weechat_config_option_reset (option, 1))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* .... */
        break;
}
----

Скрипта (Python):

[source,python]
----
# прототип
def config_option_reset(option: str, run_callback: int) -> int: ...

# пример
rc = weechat.config_option_reset(option, 1)
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----

==== config_option_set

Поставља нову вредност опције.

Прототип:

[source,c]
----
int weechat_config_option_set (struct t_config_option *option,
                               const char *value, int run_callback);
----

Аргументи:

* _option_: показивач на опцију
* _value_: нова вредност опције, могуће су и специјалне вредности које зависе од типа опције:
** _boolean_:
*** `toggle`: пребацује текућу вредност
** _integer_, _color_ или _enum_:
*** `++N`: додаје `N` (било који цео број) на текућу вредност
*** `--N`: одузима `N` (било који цео број) од текуће вредности
* _run_callback_: 1 за позив change функције повратног позива ако је вредност измењена, у супротном 0

Повратна вредност:

* _WEECHAT_CONFIG_OPTION_SET_OK_CHANGED_ ако је вредност опције измењена
* _WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE_ ако вредност није измењена
* _WEECHAT_CONFIG_OPTION_SET_ERROR_ ако је дошло до грешке

C пример:

[source,c]
----
switch (weechat_config_option_set (option, "new_value", 1))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* .... */
        break;
}
----

Скрипта (Python):

[source,python]
----
# прототип
def config_option_set(option: str, value: str, run_callback: int) -> int: ...

# пример
rc = weechat.config_option_set(option, "new_value", 1)
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----

==== config_option_set_null

Поставља опцију на null (недефинисану вредност).

Прототип:

[source,c]
----
int weechat_config_option_set_null (struct t_config_option *option,
                                    int run_callback);
----

Аргументи:

* _option_: показивач на опцију
* _run_callback_: 1 за позив change функције повратног позива ако је вредност опције измењена, у супротном 0

[NOTE]
Вредност можете да поставите на null само ако је то дозвољено за опцију (погледајте <<_config_new_option,config_new_option>>).

Повратна вредност:

* _WEECHAT_CONFIG_OPTION_SET_OK_CHANGED_ ако је вредност опције измењена
* _WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE_ ако вредност није измењена
* _WEECHAT_CONFIG_OPTION_SET_ERROR_ ако је дошло до грешке

C пример:

[source,c]
----
switch (weechat_config_option_set_null (option, 1))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* .... */
        break;
}
----

Скрипта (Python):

[source,python]
----
# прототип
def config_option_set_null(option: str, run_callback: int) -> int: ...

# пример
rc = weechat.config_option_set_null(option, 1)
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----

==== config_option_unset

Уклања/ресетује опцију.

Прототип:

[source,c]
----
int weechat_config_option_unset (struct t_config_option *option);
----

Аргументи:

* _option_: показивач на опцију

Повратна вредност:

* _WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET_ ако вредност опције није ресетована
* _WEECHAT_CONFIG_OPTION_UNSET_OK_RESET_ ако је вредност опције ресетована
* _WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED_ ако је опција уклоњена
* _WEECHAT_CONFIG_OPTION_UNSET_ERROR_ ако је дошло до грешке

C пример:

[source,c]
----
switch (weechat_config_option_unset (option))
{
    case WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_ERROR:
        /* .... */
        break;
}
----

Скрипта (Python):

[source,python]
----
# прототип
def config_option_unset(option: str) -> int: ...

# пример
rc = weechat.config_option_unset(option)
if rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_ERROR:
    # ...
----

==== config_option_rename

Мења име опције.

Прототип:

[source,c]
----
void weechat_config_option_rename (struct t_config_option *option,
                                   const char *new_name);
----

Аргументи:

* _option_: показивач на опцију
* _new_name_: ново име опције

C пример:

[source,c]
----
weechat_config_option_rename (option, "new_name");
----

Скрипта (Python):

[source,python]
----
# прототип
def config_option_rename(option: str, new_name: str) -> int: ...

# пример
weechat.config_option_rename(option, "new_name")
----

==== config_option_get_string

_WeeChat ≥ 1.9._

Враћа стринг вредност особине опције.

Прототип:

[source,c]
----
const char *weechat_config_option_get_string (struct t_config_option *option,
                                              const char *property);
----

Аргументи:

* _option_: показивач на опцију
* _property_: име особине:
** _config_name_: име фајла
** _section_name_: име одељка
** _name_: име опције
** _parent_name_: име родитељске опције
** _type_: тип опције, једно од:
*** _boolean_
*** _integer_
*** _string_
*** _color_
*** _enum_
** _description_: опис опције

Повратна вредност:

* стринг вредност особине

C пример:

[source,c]
----
const char *type = weechat_config_option_get_string (option, "type");
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== config_option_get_pointer

Враћа показивач на особину опције.

Прототип:

[source,c]
----
void *weechat_config_option_get_pointer (struct t_config_option *option,
                                         const char *property);
----

Аргументи:

* _option_: показивач на опцију
* _property_: име особине:
** _config_file_: показивач на конфигурациони фајл (_struct t_config_file *_)
** _section_: показивач на одељак (_struct t_config_section *_)
** _name_: име опције (_char *_)
** _parent_name_: име родитељске опције (_char *_) _(WeeChat ≥ 1.4)_
** _type_: тип опције (_int *_)
** _description_: опис опције (_char *_)
** _string_values_: стринг вредности (_char *_)
** _min_: минимална вредност (_int *_)
** _max_: максимална вредност (_int *_)
** _default_value_: подразумевана вредност (зависи од типа)
** _value_: текућа вредност (зависи од типа)
** _prev_option_: показивач на претходну опцију (_struct t_config_option *_)
** _next_option_: показивач на наредну опцију (_struct t_config_option *_)

Повратна вредност:

* показивач на тражену опцију

C пример:

[source,c]
----
char *description = weechat_config_option_get_pointer (option, "description");
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== config_option_is_null

Проверава да ли је опција „null” (недефинисана вредност).

Прототип:

[source,c]
----
int weechat_config_option_is_null (struct t_config_option *option);
----

Аргументи:

* _option_: показивач на опцију

Повратна вредност:

* 1 ако је вредност опције „null”
* 0 ако вредност опције није „null”

C пример:

[source,c]
----
if (weechat_config_option_is_null (option))
{
    /* вредност је "null" */
}
else
{
    /* вредност није "null" */
}
----

Скрипта (Python):

[source,python]
----
# пример
def config_option_is_null(option: str) -> int: ...
    # ...

# пример
if weechat.config_option_is_null(option):
    # ...
----

==== config_option_default_is_null

Проверава да ли је подразумевана вредност опције „null” (недефинисана вредност).

Прототип:

[source,c]
----
int weechat_config_option_default_is_null (struct t_config_option *option);
----

Аргументи:

* _option_: показивач на опцију

Повратна вредност:

* 1 ако је подразумевана вредност опције „null”
* 0 ако подразумевана вредност опције није „null”

C пример:

[source,c]
----
if (weechat_config_option_default_is_null (option))
{
    /* подразумевана вредност је "null" */
}
else
{
    /* подразумевана вредност није "null" */
}
----

Скрипта (Python):

[source,python]
----
# пример
def config_option_default_is_null(option: str) -> int: ...

# пример
if weechat.config_option_default_is_null(option):
    # ...
----

==== config_boolean

Враћа логичку вредност опције.

Прототип:

[source,c]
----
int weechat_config_boolean (struct t_config_option *option);
----

Аргументи:

* _option_: показивач на опцију

Повратна вредност, зависи од типа опције:

* _boolean_: логичка вредност опције (0 или 1)
* _integer_: 0
* _string_: 0
* _color_: 0
* _enum_: 0

C пример:

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
if (weechat_config_boolean (option))
{
    /* вредност је "true" */
}
else
{
    /* вредност је "false" */
}
----

Скрипта (Python):

[source,python]
----
# прототип
def config_boolean(option: str) -> int: ...

# пример
option = weechat.config_get("plugin.section.option")
if weechat.config_boolean(option):
    # ...
----

==== config_boolean_default

Враћа подразумевану логичку вредност опције.

Прототип:

[source,c]
----
int weechat_config_boolean_default (struct t_config_option *option);
----

Аргументи:

* _option_: показивач на опцију

Повратна вредност, зависи од типа опције:

* _boolean_: подразумевана логичка вредност опције (0 или 1)
* _integer_: 0
* _string_: 0
* _color_: 0
* _enum_: 0

C пример:

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
if (weechat_config_boolean_default (option))
{
    /* вредност је "true" */
}
else
{
    /* вредност је "false" */
}
----

Скрипта (Python):

[source,python]
----
# прототип
def config_boolean_default(option: str) -> int: ...

# пример
option = weechat.config_get("plugin.section.option")
if weechat.config_boolean_default(option):
    # ...
----

==== config_boolean_inherited

_WeeChat ≥ 4.3.0._

Враћа наслећену логичку вредност опције: вредност опције ако није NULL,
или вредност опције-родитеља (ако опција наслеђује вредност од друге опције). +
Ако се не пронађе опција-родитељ, враћа се подразумевана вредност опције. +
Ако је вредност опције-родитеља NULL, враћа се подразумевана вредност опције-родитеља.

Прототип:

[source,c]
----
int weechat_config_boolean_inherited (struct t_config_option *option);
----

Аргументи:

* _option_: показивач на опцију

Повратна вредност: погледајте функције <<_config_boolean,config_boolean>> и
<<_config_boolean_default,config_boolean_default>>.

C пример:

[source,c]
----
struct t_config_option *option = weechat_config_get ("irc.server.libera.autoconnect");
int autoconnect = weechat_config_boolean_inherited (option);
----

Скрипта (Python):

[source,python]
----
# прототип
def config_boolean_inherited(option: str) -> int: ...

# пример
option = weechat.config_get("irc.server.libera.autoconnect")
autoconnect = weechat.config_boolean_inherited(option)
----

==== config_integer

Return integer value of option.

Прототип:

[source,c]
----
int weechat_config_integer (struct t_config_option *option);
----

Аргументи:

* _option_: показивач на опцију

Повратна вредност, у зависности од типа опције:

* _boolean_: логичка вредност опције (0 or 1)
* _integer_: целобројна вредност опције
* _string_: 0
* _color_: индекс боје
* _enum_: целобројна вредност опције (индекс enum вредности)

C пример:

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
int value = weechat_config_integer (option);
----

Скрипта (Python):

[source,python]
----
# прототип
def config_integer(option: str) -> int: ...

# пример
option = weechat.config_get("plugin.section.option")
value = weechat.config_integer(option)
----

==== config_integer

Враћа целобројну вредност опције.

Прототип:

[source,c]
----
int weechat_config_integer (struct t_config_option *option);
----

Аргументи:

* _option_: показивач на опцију

Повратна вредност, зависи од типа опције:

* _boolean_: логичка вредност опције (0 или 1)
* _integer_: целобројна вредност опције
* _string_: 0
* _color_: индекс боје
* _enum_: целобројна вредност опције (индекс enum вредности)

C пример:

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
int value = weechat_config_integer (option);
----

Скрипта (Python):

[source,python]
----
# прототип
def config_integer(option: str) -> int: ...

# пример
option = weechat.config_get("plugin.section.option")
value = weechat.config_integer(option)
----

==== config_integer_default

Враћа подразумевану целобројну вредност опције.

Прототип:

[source,c]
----
int weechat_config_integer_default (struct t_config_option *option);
----

Аргументи:

* _option_: показивач на опцију

Повратна вредност, зависи од типа опције:

* _boolean_: подразумевана логичка вредност опције (0 или 1)
* _integer_: подразумевана целобројна вредност опције
* _string_: 0
* _color_: подразумевани индекс боје
* _enum_: подразумевана целобројна вредност опције (индекс enum вредности)

C пример:

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
int value = weechat_config_integer_default (option);
----

Скрипта (Python):

[source,python]
----
# прототип
def config_integer_default(option: str) -> int: ...

# пример
option = weechat.config_get("plugin.section.option")
value = weechat.config_integer_default(option)
----

==== config_integer_inherited

_WeeChat ≥ 4.3.0._

Враћа наслеђену целобројну вредност опције: вредност опције ако није NULL,
или вредност опције-родитеља (ако опција наслеђује вредност од друге опције). +
Ако се не пронађе опција-родитељ, враћа се подразумевана вредност опције. +
Ако је вредност опције-родитељ NULL, враћа подразумевану вредност опције-родитеља.

Прототип:

[source,c]
----
int weechat_config_integer_inherited (struct t_config_option *option);
----

Аргументи:

* _option_: показивач на опцију

Повратна вредност: погледајте функције <<_config_integer,config_integer>> и
<<_config_integer_default,config_integer_default>>.

C пример:

[source,c]
----
struct t_config_option *option = weechat_config_get ("irc.server.libera.autojoin_delay");
int delay = weechat_config_integer_inherited (option);
----

Скрипта (Python):

[source,python]
----
# прототип
def config_integer_inherited(option: str) -> int: ...

# пример
option = weechat.config_get("irc.server.libera.autojoin_delay")
delay = weechat.config_integer_inherited(option)
----

==== config_string

Враћа стринг вредност опције.

Прототип:

[source,c]
----
const char *weechat_config_string (struct t_config_option *option);
----

Аргументи:

* _option_: показивач на опцију

Повратна вредност, зависи од типа опције:

* _boolean_: „on” ако је вредност истинита, у супротном „off”
* _integer_: NULL
* _string_: стринг вредност опције
* _color_: име боје
* _enum_: стринг вредност опције

C пример:

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
const char *value = weechat_config_string (option);
----

Скрипта (Python):

[source,python]
----
# прототип
def config_string(option: str) -> str: ...

# пример
option = weechat.config_get("plugin.section.option")
value = weechat.config_string(option)
----

==== config_string_default

Враћа подразумевану стринг вредност опције.

Прототип:

[source,c]
----
const char *weechat_config_string_default (struct t_config_option *option);
----

Аргументи:

* _option_: показивач на опцију

Повратна вредност, зависи од типа опције:

* _boolean_: „on” ако је подразумевана вредност истинита, у супротном „off”
* _integer_: NULL
* _string_: подразумевана стринг вредност опције
* _color_: име подразумеване боје
* _enum_: подразумевана стринг вредност опције

C пример:

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
const char *value = weechat_config_string_default (option);
----

Скрипта (Python):

[source,python]
----
# прототип
def config_string_default(option: str) -> str: ...

# пример
option = weechat.config_get("plugin.section.option")
value = weechat.config_string_default(option)
----

==== config_string_inherited

_WeeChat ≥ 4.3.0._

Враћа наслеђену стринг вредност опције: вредност опције ако није NULL,
или вредност опције-родитеља (ако опција наслеђује вредност од друге опције). +
Ако се не пронађе опција-родитељ, враћа се подразумевана вредност опције. +
Ако је вредност опције-родитељ NULL, враћа подразумевану вредност опције-родитеља.

Прототип:

[source,c]
----
const char *weechat_config_string_inherited (struct t_config_option *option);
----

Аргументи:

* _option_: показивач на опцију

Повратна вредност: погледај функције <<_config_string,config_string>> и
<<_config_string_default,config_string_default>>.

C пример:

[source,c]
----
struct t_config_option *option = weechat_config_get ("irc.server.libera.msg_quit");
const char *msg_quit = weechat_config_string_inherited (option);
----

Скрипта (Python):

[source,python]
----
# прототип
def config_string_inherited(option: str) -> str: ...

# пример
option = weechat.config_get("irc.server.libera.msg_quit")
msg_quit = weechat.config_string_inherited(option)
----

==== config_color

Враћа вредност опције као боју.

Прототип:

[source,c]
----
const char *weechat_config_color (struct t_config_option *option);
----

Аргументи:

* _option_: показивач на опцију

Повратна вредност, зависи од типа опције:

* _boolean_: NULL
* _integer_: NULL
* _string_: NULL
* _color_: име боје
* _enum_: NULL

C пример:

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
const char *color = weechat_config_color (option);
----

Скрипта (Python):

[source,python]
----
# прототип
def config_color(option: str) -> str: ...

# пример
option = weechat.config_get("plugin.section.option")
color = weechat.config_color(option)
----

==== config_color_default

Враћа подразумевану вредност опције као боју.

Прототип:

[source,c]
----
const char *weechat_config_color_default (struct t_config_option *option);
----

Аргументи:

* _option_: показивач на опцију

Повратна вредност, зависи од типа опције:

* _boolean_: NULL
* _integer_: NULL
* _string_: NULL
* _color_: име подразумеване боје
* _enum_: NULL

C пример:

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
const char *color = weechat_config_color_default (option);
----

Скрипта (Python):

[source,python]
----
# прототип
def config_color_default(option: str) -> str: ...

# пример
option = weechat.config_get("plugin.section.option")
color = weechat.config_color_default(option)
----

==== config_color_inherited

_WeeChat ≥ 4.3.0._

Враћа наслеђену вредност боје опције: вредност опције ако није NULL,
или вредност опције-родитеља (ако опција наслеђује вредност од друге опције). +
Ако се не пронађе опција-родитељ, враћа се подразумевана вредност опције. +
Ако је вредност опције-родитељ NULL, враћа подразумевану вредност опције-родитеља.

Прототип:

[source,c]
----
const char *weechat_config_color_inherited (struct t_config_option *option);
----

Аргументи:

* _option_: показивач на опцију

Повратна вредност: погледајте функције <<_config_color,config_color>> и
<<_config_color_default,config_color_default>>.

C пример:

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
const char *color = weechat_config_color_inherited (option);
----

Скрипта (Python):

[source,python]
----
# прототип
def config_color_inherited(option: str) -> str: ...

# пример
option = weechat.config_get("plugin.section.option")
color = weechat.config_color_inherited(option)
----

==== config_enum

_WeeChat ≥ 4.1.0._

Враћа enum вредност опције, као цео број.

Прототип:

[source,c]
----
int weechat_config_enum (struct t_config_option *option);
----

Аргументи:

* _option_: показивач на опцију

Враћена вредност, у зависности од типа опције:

* _boolean_: логичка вредност опције (0 или 1)
* _integer_: целобројна вредност опције
* _string_: 0
* _color_: индекс боје
* _enum_: целобројна вредност опције (индекс enum вредности)

C пример:

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
int value = weechat_config_enum (option);
----

Скрипта (Python):

[source,python]
----
# прототип
def config_enum(option: str) -> int: ...

# пример
option = weechat.config_get("plugin.section.option")
value = weechat.config_enum(option)
----

==== config_enum_default

_WeeChat ≥ 4.1.0._

Враћа подразумевану enum вредност опције, као цео број.

Прототип:

[source,c]
----
int weechat_config_enum_default (struct t_config_option *option);
----

Аргументи:

* _option_: показивач на опцију

Повратна вредност, у зависности од типа опције:

* _boolean_: подразумевана логичка вредност опције (0 или 1)
* _integer_: подразумевана целобројна вредност опције
* _string_: 0
* _color_: подразумевани индекс боје
* _enum_: подразумевана целобројна вредност опције (индекс enum вредности)

C пример:

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
int value = weechat_config_enum_default (option);
----

Скрипта (Python):

[source,python]
----
# прототип
def config_enum_default(option: str) -> int: ...

# пример
option = weechat.config_get("plugin.section.option")
value = weechat.config_enum_default(option)
----

==== config_enum_inherited

_WeeChat ≥ 4.3.0._

Враћа наслеђену enum вредност опције: вредност опције ако није NULL,
или вредност опције-родитеља (ако опција наслеђује вредност од друге опције). +
Ако се не пронађе опција-родитељ, враћа се подразумевана вредност опције. +
Ако је вредност опције-родитељ NULL, враћа подразумевану вредност опције-родитеља.

Прототип:

[source,c]
----
int weechat_config_enum_inherited (struct t_config_option *option);
----

Аргументи:

* _option_: показивач на опцију

Повратна вредност: погледајте функције <<_config_enum,config_enum>> и
<<_config_enum_default,config_enum_default>>.

C пример:

[source,c]
----
struct t_config_option *option = weechat_config_get ("irc.server.libera.sasl_fail");
int sasl_fail = weechat_config_enum_inherited (option);
----

Скрипта (Python):

[source,python]
----
# прототип
def config_enum_inherited(option: str) -> int: ...

# пример
option = weechat.config_get("irc.server.libera.sasl_fail")
sasl_fail = weechat.config_enum_inherited(option)
----

==== config_write_option

Уписује линију у конфигурациони фајл са опцијом и њеном вредности (ова функција би требало да се позове само у „write” или „write_default” функцијама повратног позива за одељак).

Прототип:

[source,c]
----
void weechat_config_write_option (struct t_config_file *config_file,
                                  struct t_config_option *option);
----

Аргументи:

* _config_file_: показивач на конфигурациони фајл
* _option_: показивач на опцију

C пример:

[source,c]
----
int
my_section_write_cb (const void *pointer, void *data,
                     struct t_config_file *config_file,
                     const char *section_name)
{
    weechat_config_write_line (config_file, "my_section", NULL);

    weechat_config_write_option (config_file, option);

    return WEECHAT_RC_OK;
}
----

Скрипта (Python):

[source,python]
----
# прототип
def config_write_option(config_file: str, option: str) -> int: ...

# пример
def my_section_write_cb(data: str, config_file: str, section_name: str) -> int:
    weechat.config_write_line(config_file, "my_section", "")
    weechat.config_write_option(config_file, option)
    return weechat.WEECHAT_RC_OK
----

==== config_write_line

Уписује линију у конфигурациони фајл (ова функција би требало да се позива само у „write” или „write_default” функцијама повратног позива за одељак).

Прототип:

[source,c]
----
void weechat_config_write_line (struct t_config_file *config_file,
                                const char *option_name,
                                const char *value, ...);
----

Аргументи:

* _config_file_: показивач на конфигурациони фајл
* _option_name_: име опције
* _value_: вредност (ако је NULL, онда се уписује линија са именом одељка, на пример: "[section]")

C пример:

[source,c]
----
int
my_section_write_cb (const void *pointer, void *data,
                     struct t_config_file *config_file,
                     const char *section_name)
{
    weechat_config_write_line (config_file, "my_section", NULL);

    weechat_config_write_line (config_file, "option", "%s;%d",
                               "value", 123);

    return WEECHAT_RC_OK;
}
----

Скрипта (Python):

[source,python]
----
# прототип
def config_write_line(config_file: str, option_name: str, value: str) -> int: ...

# пример
def my_section_write_cb(data: str, config_file: str, section_name: str) -> int:
    weechat.config_write_line(config_file, "my_section", "")
    weechat.config_write_line(config_file, "option", "value")
    return weechat.WEECHAT_RC_OK
----

==== config_write

Уписује конфигурациони фајл на диск.

Прототип:

[source,c]
----
int weechat_config_write (struct t_config_file *config_file);
----

Аргументи:

* _config_file_: показивач на конфигурациони фајл

Повратна вредност:

* _WEECHAT_CONFIG_WRITE_OK_ ако је конфигурација уписана
* _WEECHAT_CONFIG_WRITE_MEMORY_ERROR_ ако није било довољно слободне меморије
* _WEECHAT_CONFIG_WRITE_ERROR_ ако је дошло до неке друге грешке

C пример:

[source,c]
----
switch (weechat_config_write (config_file))
{
    case WEECHAT_CONFIG_WRITE_OK:
        /* ... */
        break;
    case WEECHAT_CONFIG_WRITE_MEMORY_ERROR:
        /* ... */
        break;
    case WEECHAT_CONFIG_WRITE_ERROR:
        /* ... */
        break;
}
----

Скрипта (Python):

[source,python]
----
# прототип
def config_write(config_file: str) -> int: ...

# пример
rc = weechat.config_write(config_file)
if rc == weechat.WEECHAT_CONFIG_WRITE_OK:
    # ...
elif rc == weechat.WEECHAT_CONFIG_WRITE_MEMORY_ERROR:
    # ...
elif rc == weechat.WEECHAT_CONFIG_WRITE_ERROR:
    # ...
----

==== config_read

Чита конфигурациони фајл са диска.

Прототип:

[source,c]
----
int weechat_config_read (struct t_config_file *config_file);
----

Аргументи:

* _config_file_: показивач на конфигурациони фајл

Повратна вредност:

* _WEECHAT_CONFIG_READ_OK_ ако је конфигурација учитана
* _WEECHAT_CONFIG_READ_MEMORY_ERROR_ ако није било довољно слободне меморије
* _WEECHAT_CONFIG_READ_FILE_NOT_FOUND_ ако фајл није пронађен

C пример:

[source,c]
----
switch (weechat_config_read (config_file))
{
    case WEECHAT_CONFIG_READ_OK:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_MEMORY_ERROR:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
        /* ... */
        break;
}
----

Скрипта (Python):

[source,python]
----
# прототип
def config_read(config_file: str) -> int: ...

# пример
rc = weechat.config_read(config_file)
if rc == weechat.WEECHAT_CONFIG_READ_OK:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_MEMORY_ERROR:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
    # ...
----

==== config_reload

Поново учитава конфигурацију са диска.

Прототип:

[source,c]
----
int weechat_config_reload (struct t_config_file *config_file);
----

Аргументи:

* _config_file_: показивач на конфигурациони фајл

Повратна вредност:

* _WEECHAT_CONFIG_READ_OK_ ако је конфигурација поново учитана
* _WEECHAT_CONFIG_READ_MEMORY_ERROR_ ако није било довољно слободне меморије
* _WEECHAT_CONFIG_READ_FILE_NOT_FOUND_ ако фајл није пронађен

C пример:

[source,c]
----
switch (weechat_config_reload (config_file))
{
    case WEECHAT_CONFIG_READ_OK:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_MEMORY_ERROR:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
        /* ... */
        break;
}
----

Скрипта (Python):

[source,python]
----
# прототип
def config_reload(config_file: str) -> int: ...

# пример
rc = weechat.config_reload(config_file)
if rc == weechat.WEECHAT_CONFIG_READ_OK:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_MEMORY_ERROR:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
    # ...
----

==== config_option_free

Ослобађа меморију коју заузима опција.

Прототип:

[source,c]
----
void weechat_config_option_free (struct t_config_option *option);
----

Аргументи:

* _option_: показивач на опцију

C пример:

[source,c]
----
weechat_config_option_free (option);
----

Скрипта (Python):

[source,python]
----
# прототип
def config_option_free(option: str) -> int: ...

# пример
weechat.config_option_free(option)
----

==== config_section_free_options

Ослобађа меморију коју заузимају све опцију у одељку.

Прототип:

[source,c]
----
void weechat_config_section_free_options (struct t_config_section *section);
----

Аргументи:

* _section_: показивач на одељак

C пример:

[source,c]
----
weechat_config_section_free_options (section);
----

Скрипта (Python):

[source,python]
----
# прототип
def config_section_free_options(section: str) -> int: ...

# пример
weechat.config_section_free_options(section)
----

==== config_section_free

Ослобађа меморију коју заузима одељак.

Прототип:

[source,c]
----
void weechat_config_section_free (struct t_config_section *section);
----

Аргументи:

* _section_: показивач на одељак

C пример:

[source,c]
----
weechat_config_section_free (section);
----

Скрипта (Python):

[source,python]
----
# прототип
def config_section_free(section: str) -> int: ...

# пример
weechat.config_section_free(section)
----

==== config_free

Ослобађа меморију коју заузима конфигурациони фајл.

Прототип:

[source,c]
----
void weechat_config_free (struct t_config_file *config_file);
----

Аргументи:

* _config_file_: показивач на конфигурациони фајл

C пример:

[source,c]
----
weechat_config_free (config_file);
----

Скрипта (Python):

[source,python]
----
# прототип
def config_free(config_file: str) -> int: ...

# пример
weechat.config_free(config_file)
----

==== config_get

Тражи опцију према пуном имену.

Прототип:

[source,c]
----
struct t_config_option *weechat_config_get (const char *option_name);
----

Аргументи:

* _option_name_: пуно име опције (у формату: „фајл.одељак.опција”)

Повратна вредност:

* показивач на нађену опцију, NULL у случају да се опција не нађе

C пример:

[source,c]
----
struct t_config_option *option = weechat_config_get ("weechat.look.item_time_format");
----

Скрипта (Python):

[source,python]
----
# прототип
def config_get(option_name: str) -> str: ...

# пример
option = weechat.config_get("weechat.look.item_time_format")
----

==== config_get_plugin

Тражи опцију у конфигурационом фајлу додатака (plugins.conf).

Прототип:

[source,c]
----
const char *weechat_config_get_plugin (const char *option_name);
----

Аргументи:

* _option_name_: име опције, програм WeeChat ће додати префикс „plugins.var.xxx.”(где је „xxx” име текућег додатка)

Повратна вредност:

* вредност пронађене опције, NULL у случају да се опција не пронађе

C пример:

[source,c]
----
/* ако је текући додатак „test”, онда се у фајлу plugins.conf
   тражи вредност опције „plugins.var.test.option” */
char *value = weechat_config_get_plugin ("option");
----

Скрипта (Python):

[source,python]
----
# прототип
def config_get_plugin(option_name: str) -> str: ...

# пример
value = weechat.config_get_plugin("option")
----

==== config_is_set_plugin

Проверава да ли је опција постављена у конфигурационом фајлу додатака (plugins.conf).

Прототип:

[source,c]
----
int weechat_config_is_set_plugin (const char *option_name);
----

Аргументи:

* _option_name_: име опције, програм WeeChat ће додати префикс „plugins.var.xxx.”(где је „xxx” име текућег додатка)

Повратна вредност:

* 1 ако је опција постављена, 0 ако опција не постоји

C пример:

[source,c]
----
if (weechat_config_is_set_plugin ("option"))
{
    /* опција је постављена */
}
else
{
    /* опција не постоји */
}
----

Скрипта (Python):

[source,python]
----
# прототип
def config_is_set_plugin(option_name: str) -> int: ...

# пример
if weechat.config_is_set_plugin("option"):
    # опција је постављена
    # ...
else:
    # опција не постоји
    # ...
----

==== config_set_plugin

Поставља нову вредност опције у конфигурационом фајлу додатака (plugins.conf).

Прототип:

[source,c]
----
int weechat_config_set_plugin (const char *option_name, const char *value);
----

Аргументи:

* _option_name_: име опције, програм WeeChat ће додати префикс „plugins.var.xxx.”(где је „xxx” име текућег додатка)
* _value_: нова вредност опције

Повратна вредност:

* _WEECHAT_CONFIG_OPTION_SET_OK_CHANGED_ ако је вредност опције измењена
* _WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE_ ако вредност није измењена
* _WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND_ ако опција није пронађена
* _WEECHAT_CONFIG_OPTION_SET_ERROR_ ако је дошло до неке друге грешке

C пример:

[source,c]
----
switch (weechat_config_set_plugin ("option", "test_value"))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* ... */
        break;
}
----

Скрипта (Python):

[source,python]
----
# прототип
def config_set_plugin(option_name: str, value: str) -> int: ...

# пример
rc = weechat.config_set_plugin("option", "test_value")
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----

==== config_set_desc_plugin

_WeeChat ≥ 0.3.5._

Поставља опис за опцију у конфигурационом фајлу додатака (plugins.conf).

Прототип:

[source,c]
----
void weechat_config_set_desc_plugin (const char *option_name,
                                     const char *description);
----

Аргументи:

* _option_name_: име опције, програм WeeChat ће додати префикс „plugins.desc.xxx.”(где је „xxx” име текућег додатка)
* _description_: опис опције

[NOTE]
Ако опција (plugins.var.xxx.име_опције) не постоји, то не представља проблем. Будуће креирање опције под овим именом ће употребити овај опис.

C пример:

[source,c]
----
weechat_config_set_desc_plugin ("option", "description of option");
----

Скрипта (Python):

[source,python]
----
# прототип
def config_set_desc_plugin(option_name: str, description: str) -> int: ...

# пример
version = weechat.info_get("version_number", "") or 0
if int(version) >= 0x00030500:
    weechat.config_set_desc_plugin("option", "description of option")
----

==== config_unset_plugin

Брише опцију из конфигурационог фајла додатака (plugins.conf).

Прототип:

[source,c]
----
int weechat_config_unset_plugin (const char *option_name);
----

Аргументи:

* _option_name_: име опције, програм WeeChat ће додати префикс „plugins.var.xxx.”(где је „xxx” име текућег додатка)

Повратна вредност:

* _WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET_ ако вредност опције није ресетована
* _WEECHAT_CONFIG_OPTION_UNSET_OK_RESET_ ако је вредност опције ресетована
* _WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED_ ако је опција уклоњена
* _WEECHAT_CONFIG_OPTION_UNSET_ERROR_ ако је дошло до грешке

C пример:

[source,c]
----
switch (weechat_config_unset_plugin ("option"))
{
    case WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_ERROR:
        /* ... */
        break;
}
----

Скрипта (Python):

[source,python]
----
# прототип
def config_unset_plugin(option_name: str) -> int: ...

# пример
rc = weechat.config_unset_plugin("option")
if rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_ERROR:
    # ...
----

[[key_bindings]]
=== Тастерске пречице

Функције за тастерске пречице.

==== key_bind

_WeeChat ≥ 0.3.6, ажурирано у верзији 1.8._

Додаје нове тастерске пречице.

[NOTE]
За разлику од команде `/key bind`, ова функција никада неће изменити постојећу тастерску пречицу, може само да креира нове. Ако желите да уклоните тастерску пречицу, употребите <<_key_unbind,key_unbind>>.

Прототип:

[source,c]
----
int weechat_key_bind (const char *context, struct t_hashtable *keys);
----

:key_bind_quiet: __quiet

Аргументи:

* _context_: контекст за тастере:
** _default_: подразумевани контекст (уобичајене акције)
** _search_: контекст претраге (када се тражи текст у баферу)
** _cursor_: слободно померање курсора по екрану
** _mouse_: тастери за догађаје миша
* _keys_: хеш табела са тастерским пречицама; може да садржи следеће специјалне кључеве:
** _{key_bind_quiet}_: не приказују се пречице додате у _core_ бафер _(WeeChat ≥ 1.8)_

Повратна вредност:

* број додатих тастерских пречица

C пример:

[source,c]
----
struct t_hashtable *keys = weechat_hashtable_new (8,
                                                  WEECHAT_HASHTABLE_STRING,
                                                  WEECHAT_HASHTABLE_STRING,
                                                  NULL,
                                                  NULL);
if (keys)
{
    weechat_hashtable_set (keys, "@chat(plugin.buffer):button1", "hsignal:test_mouse");
    weechat_hashtable_set (keys, "@chat(plugin.buffer):wheelup", "/mycommand up");
    weechat_hashtable_set (keys, "@chat(plugin.buffer):wheeldown", "/mycommand down");
    weechat_key_bind ("mouse", keys);
    weechat_hashtable_free (keys);
}
----

Скрипта (Python):

[source,python]
----
# прототип
def key_bind(context: str, keys: Dict[str, str]) -> int: ...

# пример
keys = {"@chat(python.test):button1": "hsignal:test_mouse",
        "@chat(python.test):wheelup": "/mycommand up",
        "@chat(python.test):wheeldown": "/mycommand down"}
weechat.key_bind("mouse", keys)
----

==== key_unbind

_WeeChat ≥ 0.3.6, ажурирано у верзији 2.0._

Уклања тастерску пречицу (или више њих).

[CAUTION]
Када се ова функција позива, обезбедите да не уклоните корисникове тастерске пречице.

Прототип:

[source,c]
----
int weechat_key_unbind (const char *context, const char *key);
----

Аргументи:

* _context_: контекст за тастере (погледајте <<_key_bind,key_bind>>)
* _key_: тастер који се уклања или специјална вредност „area:XXX” којом се уклањају све пречице које имају _XXX_ као први или други део; ако тастер почиње са „quiet:”, тастери који се уклањају се неће приказати у _core_ баферу _(WeeChat ≥ 2.0)_.

Повратна вредност:

* број уклоњених тастерских пречица

C примери:

[source,c]
----
/* уклања једну тастерску пречицу */
weechat_key_unbind ("mouse", "@chat(plugin.buffer):button1");

/* уклања све тастере са делом "chat(plugin.buffer)" */
weechat_key_unbind ("mouse", "area:chat(plugin.buffer)");
----

Скрипта (Python):

[source,python]
----
# прототип
def key_unbind(context: str, key: str) -> int: ...

# примери

# уклања једну тастерску пречицу
weechat.key_unbind("mouse", "@chat(plugin.buffer):button1")

# уклања све тастере са делом "chat(python.test)"
weechat.key_unbind("mouse", "area:chat(python.test)")
----

[[display]]
=== Приказ

Функције које приказују текст у баферима.

==== prefix

Враћа префикс.

Прототип:

[source,c]
----
const char *weechat_prefix (const char *prefix);
----

Аргументи:

* _prefix_: име префикса (погледајте табелу испод)

Повратна вредност:

* вредност префикса (стринг са префиксом и кодовима боја), празан стринг ако се префикс не пронађе

Листа префикса:

[width="100%", cols="^2m,^1,^3,5", options="header"]
|===
| Префикс  | Вредност | Боја       | Опис
| error    | `+=!=+`  | yellow     | Порука о грешки.
| network  | `+--+`   | magenta    | Порука са мреже.
| action   | `+*+`    | white      | Сопствена акција.
| join     | `+-->+`  | lightgreen | Неко се придружио текућем разговору.
| quit     | `+<--+`  | lightred   | Неко напушта текући разговор.
|===

[NOTE]
Командом `/set` могу да се прилагоде вредности и боје.

C пример:

[source,c]
----
weechat_printf (NULL, "%sОво је грешка...", weechat_prefix ("error"));
----

Скрипта (Python):

[source,python]
----
# прототип
def prefix(prefix: str) -> str: ...

# пример
weechat.prnt("", "%sОво је грешка..." % weechat.prefix("error"))
----

==== color

Враћа стринг кода боје за приказ.

Прототип:

[source,c]
----
const char *weechat_color (const char *color_name);
----

Аргументи:

* _color_name_: име боје, једно од::
** Име опције WeeChat боје (из weechat.color.xxx), на пример _chat_delimiters_
** име опције (у формату: фајл.одељак.опција), на пример _irc.color.message_quit_ _(WeeChat ≥ 1.2)_
** боја са необавезним атрибутима/позадином (погледајте испод)
** атрибут:
*** _blink_: поставља трептање
*** _-blink_: уклања трептање
*** _dim_: поставља „dim” (затамњено)
*** _-dim_: уклања „dim” (затамњено)
*** _bold_: поставља подебљан испис
*** _-bold_: уклања подебљан испис
*** _reverse_: поставља обрнути приказ
*** _-reverse_: уклања обрнути приказ
*** _italic_: поставља испис у курзиву
*** _-italic_: уклања испис у курзиву
*** _underline_: поставља подвучени испис
*** _-underline_: уклања подвучени испис
*** _emphasis_: пребацује активност наглашавања текста (напомена: ово би требало да се користи само у тракама, јер програм WeeChat користи наглашавање текста када претражује текст у баферу) _(WeeChat ≥ 0.4.2)_
** име боје траке:
*** _bar_fg_: боја предњег плана траке
*** _bar_delim_: боја граничника за траку
*** _bar_bg_: боја позадине за траку
** ресет:
*** _reset_: ресетује боје и атрибуте
*** _resetcolor_: ресетује боју (задржава атрибуте) _(WeeChat ≥ 0.3.6)_

Формат боје је: атрибути (није обавезно) + име боје + ",позадина" (није обавезно). Могући су следећи атрибути:

* `+%+`: трептање
* `+.+`: „dim” (затамњено)
* `+*+`: подебљани текст
* `+!+`: обрнути видео
* `+/+`: курзив
* `+_+`: подвучен текст
* `+|+`: задржава атрибуте: када се мења боја, не ресетују се подебљано/обрнуто/курзив/подвучено _(WeeChat ≥ 0.3.6)_

Примери:

* `+yellow+`: жуто
* `+_green+`: подвучено зелено
* `+*214+`: подебљано наранџасто
* `+yellow,red+`: жуто на црвеном
* `+|cyan+`: цијан (и задржава било које атрибуте постављена раније)

Повратна вредност:

* стринг са кодом боје, или празан стринг ако се боја не пронађе

C пример:

[source,c]
----
weechat_printf (NULL, "Color: %sblue %sdefault color %syellow on red",
                weechat_color ("blue"),
                weechat_color ("chat"),
                weechat_color ("yellow,red"));
----

Скрипта (Python):

[source,python]
----
# прототип
def color(color_name: str) -> str: ...

# пример
weechat.prnt("", "Color: %sblue %sdefault color %syellow on red"
    % (weechat.color("blue"), weechat.color("chat"), weechat.color("yellow,red")))
----

==== printf

Приказује поруку у баферу.

Прототип:

[source,c]
----
void weechat_printf (struct t_gui_buffer *buffer, const char *message, ...);
----

Ова функција је пречица за функцију printf_datetime_tags. +
Следећа два позива дају потпуно исти резултат:

[source,c]
----
weechat_printf (buffer, "message");
weechat_printf_datetime_tags (buffer, 0, 0, NULL, "message");
----

Аргументи:

* _buffer_: показивач на бафер, ако је NULL, порука се приказује у WeeChat баферу
* _message_: порука која треба да се прикаже

[NOTE]
Први табулатор у поруци („\t”) се користи за раздвајање префикса од поруке. +
Ако ваша порука садржи табове и не желите префикс, онда користите размак, па таб, па онда поруку (погледајте пример испод): ово ће да искључи префикс (размак пре таба се неће приказивати).

[NOTE]
Ако постоје два таба („\t”) на почетку поруке, време се неће приказивати и порука неће имати поравнање. Уз то, датум у поруци ће се поставити на 0.

C пример:

[source,c]
----
weechat_printf (NULL, "Hello on WeeChat buffer");
weechat_printf (buffer, "Hello on this buffer");
weechat_printf (buffer, "%sThis is an error!", weechat_prefix ("error"));
weechat_printf (buffer, " \tMessage without prefix but with \t some \t tabs");
weechat_printf (buffer, "\t\tMessage without time/alignment");
weechat_printf (buffer, "\t\t");  /* empty line (without time) */
----

Скрипта (Python):

[source,python]
----
# прототип
def prnt(buffer: str, message: str) -> int: ...

# пример
weechat.prnt("", "Здраво на WeeChat баферу")
weechat.prnt(buffer, "Здраво на овом баферу")
weechat.prnt(buffer, "%sОво је грешка!" % weechat.prefix("error"))
weechat.prnt(buffer, " \tПорука без префикса, али са \t мало \t табова")
weechat.prnt(buffer, "\t\tПорука без времена/поравнања")
weechat.prnt(buffer, "\t\t")  # празна линија (без времена)
----

[NOTE]
У скриптама се функција зове „print” („prnt” у језику Python).

==== printf_date_tags

Приказује поруку у баферу, уз употребу прилагођеног датума и ознака.

Прототип:

[source,c]
----
void weechat_printf_date_tags (struct t_gui_buffer *buffer, time_t date,
                               const char *tags, const char *message, ...);
----

Ова функција је пречица за функцију printf_datetime_tags. +
Следећа два позива дају потпуно исти резултат:

[source,c]
----
weechat_printf_date_tags (buffer, 0, NULL, "message");
weechat_printf_datetime_tags (buffer, 0, 0, NULL, "message");
----

Аргументи:

* _buffer_: показивач на бафер, ако је NULL, порука се приказује у WeeChat баферу
* _date_: датум за поруку (0 значи текући датум/време)
* _tags_: листа ознака раздвојених запетама (NULL значи да нема ознака)
* _message_: порука која треба да се прикаже

За листу ознака које се уобичјаено користе у програму WeeChat, погледајте link:weechat_user.sr.html#lines_tags[Корисничко упутство / Ознаке линија ^↗^^].

C пример:

[source,c]
----
weechat_printf_date_tags (NULL, time (NULL) - 120, "notify_message",
                          "Message 2 minutes ago, with a tag 'notify_message'");
----

Скрипта (Python):

[source,python]
----
# прототип
def prnt_date_tags(buffer: str, date: int, tags: str, message: str) -> int: ...

# пример
time = int(time.time())
weechat.prnt_date_tags("", time - 120, "notify_message",
    "Message 2 minutes ago, with a tag 'notify_message'")
----

[NOTE]
Функција се у скриптама зове „print_date_tags” („prnt_date_tags” у језику Python).

==== printf_datetime_tags

_WeeChat ≥ 4.2.0._

Приказује поруку у баферу, користећи произвољни датум/време (са микросекундама)
и ознаке.

Прототип:

[source,c]
----
void weechat_printf_datetime_tags (struct t_gui_buffer *buffer, time_t date,
                                   int date_usec, const char *tags, const char *message, ...);
----

Аргументи:

* _buffer_: показивач на бафер, ако је NULL, порука се приказује у WeeChat баферу
* _date_: датум за поруку (0 значи текући датум/време)
* _date_usec_: микросекунде датума (између 0 и 999999)
* _tags_: листа ознака раздвојених запетама (NULL значи да нема ознака)
* _message_: порука која треба да се прикаже

За листу ознака које се уобичјаено користе у програму WeeChat, погледајте link:weechat_user.sr.html#lines_tags[Корисничко упутство / Ознаке линија ^↗^^].

C пример:

[source,c]
----
struct timeval tv_now;

gettimeofday (&tv_now, NULL);
weechat_printf_datetime_tags (NULL, tv_now.tv_sec - 120, tv_now.tv_usec,
                              "notify_message",
                              "Message 2 minutes ago, with a tag 'notify_message'");
----

Скрипта (Python):

[source,python]
----
# прототип
def prnt_datetime_tags(buffer: str, date: int, date_usec: int, tags: str, message: str) -> int: ...

# пример
now = time.time()
time_sec = int(now)
time_usec = int((now * 1000000) % 1000000)
weechat.prnt_datetime_tags("", time_sec - 120, time_usec, "notify_message",
                           "Message 2 minutes ago, with a tag 'notify_message'")
----

[NOTE]
Функција се у скриптама зове „print_datetime_tags” („prnt_datetime_tags” у језику Python).

==== printf_y

Приказује поруку на линији бафера са слободним садржајем.

Прототип:

[source,c]
----
void weechat_printf_y (struct t_gui_buffer *buffer, int y, const char *message, ...);
----

Ова функција је скраћеница за функцију printf_y_datetime_tags. +
Следећа два позива враћају потпуно исти резултат:

[source,c]
----
weechat_printf_y (buffer, 0, "порука");
weechat_printf_y_datetime_tags (buffer, 0, 0, 0, NULL, "порука");
----

Аргументи:

* _buffer_: показивач на бафер
* _y_: број линије (прва линија је 0); негативна вредност додаје линију иза последње приказане линије: апсолутна вредност _y_ је број линија након последње линије (на пример -1 је непосредно након последње линије, -2 је 2 линије након последње линије) _(WeeChat ≥ 1.0)_
* _message_: порука која треба да се прикаже

C пример:

[source,c]
----
weechat_printf_y (buffer, 2, "Моја порука на трећој линији");
----

Скрипта (Python):

[source,python]
----
# прототип
def prnt_y(buffer: str, y: int, message: str) -> int: ...

# пример
weechat.prnt_y("", 2, "Моја порука на трећој линији")
----

[NOTE]
У скриптама се функција зове „print_y” („prnt_y” у језику Python).

==== printf_y_date_tags

_WeeChat ≥ 3.5._

Приказује поруку на линији бафера са произвољним садржајем, користећи
прилагођене ознаке времена и датума.

Прототип:

[source,c]
----
void weechat_printf_y_date_tags (struct t_gui_buffer *buffer, int y, time_t date,
                                 const char *tags, const char *message, ...);
----

Ова функција је скраћеница за функцију printf_y_datetime_tags. +
Следећа два позива враћају потпуно исти резултат:

[source,c]
----
weechat_printf_y_date_tags (buffer, 0, 0, NULL, "порука");
weechat_printf_y_datetime_tags (buffer, 0, 0, 0, NULL, "порука");
----

Аргументи:

* _buffer_: показивач на бафер
* _y_: број линије (прва линија је 0); негативна вредност додаје линију иза последње приказане линије: апсолутна вредност _y_ је број линија након последње линије (на пример -1 је непосредно након последње линије, -2 је 2 линије након последње линије)
* _date_: датум за поруку (0 значи текући датум/време)
* _tags_: листа ознака раздвојених запетама (NULL значи да нема ознака)
* _message_: порука која треба да се прикаже

C пример:

[source,c]
----
weechat_printf_y_date_tags (buffer, 2, 0, "my_tag", "My message on third line with a tag");
----

Скрипта (Python):

[source,python]
----
# прототип
def prnt_y_date_tags(buffer: str, y: int, date: int, tags: str, message: str) -> int: ...

# пример
weechat.prnt_y_date_tags("", 2, 0, "my_tag", "My message on third line with a tag")
----

[NOTE]
У скриптама се функција зове „print_y_date_tags” („prnt_y_date_tags” у језику Python).

==== printf_y_datetime_tags

_WeeChat ≥ 4.2.0._

Приказује поруку на линији бафера са произвољним садржајем, користећи произвољни
датум/време (са микросекундама) и ознакама.

Прототип:

[source,c]
----
void weechat_printf_y_datetime_tags (struct t_gui_buffer *buffer, int y, time_t date,
                                     int date_usec, const char *tags, const char *message, ...);
----

Аргументи:

* _buffer_: показивач на бафер
* _y_: број линије (прва линија је 0); негативна вредност додаје линију иза последње приказане линије: апсолутна вредност _y_ је број линија након последње линије (на пример -1 је непосредно након последње линије, -2 је 2 линије након последње линије)
* _date_: датум за поруку (0 значи текући датум/време)
* _date_usec_: микросекунде датума (између 0 и 999999)
* _tags_: листа ознака раздвојених запетама (NULL значи да нема ознака)
* _message_: порука која треба да се прикаже

C пример:

[source,c]
----
weechat_printf_y_datetime_tags (buffer, 2, 0, 0, "my_tag", "My message on third line with a tag");
----

Скрипта (Python):

[source,python]
----
# прототип
def prnt_y_datetime_tags(buffer: str, y: int, date: int, date_usec: int, tags: str, message: str) -> int: ...

# пример
weechat.prnt_y_datetime_tags("", 2, 0, 0, "my_tag", "My message on third line with a tag")
----

[NOTE]
У скриптама се функција зове „print_y_datetime_tags” („prnt_y_datetime_tags” у језику Python).

==== log_printf

Уписује поруку у WeeChat лог фајл (weechat.log).

Прототип:

[source,c]
----
void weechat_log_printf (const char *message, ...);
----

Аргументи:

* _message_: порука која треба да се упише

C пример:

[source,c]
----
weechat_log_printf ("Моја порука у лог фајлу");
----

Скрипта (Python):

[source,python]
----
# прототип
def log_print(message: str) -> int: ...

# пример
weechat.log_print("Моја порука у лог фајлу")
----

[NOTE]
Функција се у скриптама зове „log_print”.

[[hooks]]
=== Куке

[[hook_priority]]
[float]
==== Приоритет куке

_WeeChat ≥ 0.3.4._

У неким кукама можете да поставите приоритет. Кука са вишим приоритетом се налази при почетку листе кука, тако да ће се пронаћи и извршити пре осталих кука. Корисно је за модификаторе, јер је за њих битан редослед извршавања.

Да бисте поставили приоритет, морате да користите следећу синтаксу за аргумент за који је дозвољен приоритет: `nnn|име` где је `nnn` позитиван цео број са приоритетом, а `име` је име аргумента (приоритет се не појављује у имену, он се аутоматски уклања из стринга). +
Дозвољен је само један приоритет по куки.

Подразумевани приоритет је 1000.

C примери:

[source,c]
----
/* модификатор кука са приоритетом = 2000 */
/* високи приоритет: позива се пре осталих функција повратног позива модификатора */
weechat_hook_modifier ("2000|input_text_display", &modifier_cb, NULL, NULL);

/* качи се на два сигнала са приоритетом = 3000 */
/* високи приоритет: позива се пре осталих функција повратног позива сигнала */
weechat_hook_signal ("3000|quit;upgrade", &signal_cb, NULL, NULL);

/* качи се на линије које се исписују у форматираним баферима са приоритетом = 500 */
/* низак приоритет: позива се након осталих функција повратног позива линија */
weechat_hook_line ("500|formatted", "*", NULL, &line_cb, NULL, NULL);
----

Приоритет дозвољавају следећи типови кука:

* <<_hook_command,command>>
* <<_hook_completion,completion>>
* <<_hook_command_run,command_run>>
* <<_hook_line,line>>
* <<_hook_signal,signal>>
* <<_hook_hsignal,hsignal>>
* <<_hook_config,config>>
* <<_hook_modifier,modifier>>
* <<_hook_info,info>>
* <<_hook_info_hashtable,info_hashtable>>
* <<_hook_infolist,infolist>>
* <<_hook_hdata,hdata>>
* <<_hook_focus,focus>>

==== hook_command

_Ажурирано у верзијама 1.5, 1.7._

Качи се на команду.

Прототип:

[source,c]
----
struct t_hook *weechat_hook_command (const char *command,
                                     const char *description,
                                     const char *args,
                                     const char *args_description,
                                     const char *completion,
                                     int (*callback)(const void *pointer,
                                                     void *data,
                                                     struct t_gui_buffer *buffer,
                                                     int argc,
                                                     char **argv,
                                                     char **argv_eol),
                                     const void *callback_pointer,
                                     void *callback_data);
----

Аргументи:

* _command_: име команде (након команде се дозвољава приоритет, погледајте напомену у вези са <<hook_priority,приоритетима>>)
* _description_: опис команде (приказује се са `/help команда`)
* _args_: аргументи за команду (приказује се са `/help команда`)
* _args_description_: опис аргумената (приказује се са `/help команда`)
* _completion_: шаблон довршавања за команду (погледајте формат испод)
* _callback_: функција која се позива када се употреби команда, аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _struct t_gui_buffer *buffer_: бафер у коме се извршава команда
** _int argc_: број аргумената дат уз команду
** _char **argv_: аргументи дати уз команду
** _char **argv_eol_: аргументи дати за команду (све до краја линије за сваки аргумент)
** повратна вредност:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се кука обрише

_completion_ шаблон је листа довршавања за сваки аргумент, раздвојен размацима. За један аргумент је могуће више довршавања која се раздвајају са `+|+`. За исту команду може да постоји више шаблона који се раздвајају са `+||+`.

Формат довршавања може да буде:

* _%(име)_: довршавање _име_
* _%(име:аргументи)_: довршавање _име_ са _аргументи_ који се шаљу функцији повратног позива _(WeeChat ≥ 1.7)_
* било који стринг: користи се у довршавању без икаквих измена

На пример, шаблон `list || add %(filters_names) || del %(filters_names)|-all` ће у аргументима команде да довршава са следећим вредностима:

* први аргумент: `list`, `add` и `del`
* други аргумент, зависно од првог аргумента:
** `list`: ништа
** `add`: имена филтера
** `del`: имена филтера и `-all`

Подразумевани кодови довршавања су:

include::{autogendir}/autogen_api_completions.sr.adoc[tag=completions]

Специјални кодови:

* `+%%команда+`: поновна употреба шаблона довршавања из команде _команда_
* `+%-+`: заустављање довршавања
* `+%*+`: понављање последњег довршавања

Повратна вредност:

* показивач на нову куку, NULL у случају грешке

C пример:

[source,c]
----
int
my_command_cb (const void *pointer, void *data, struct t_gui_buffer *buffer,
               int argc, char **argv, char **argv_eol)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* овај пример је инспирисан командом /filter */
struct t_hook *my_command_hook =
    weechat_hook_command ("мојфилтер",
                          "опис за myfilter",
                          "[list] | [enable|disable|toggle [име]] | "
                          "[add име plugin.buffer tags regex] | "
                          "[del име|-all]",
                          "опис аргумената...",
                          "list"
                          " || enable %(filters_names)"
                          " || disable %(filters_names)"
                          " || toggle %(filters_names)"
                          " || add %(filters_names) %(buffers_plugins_names)|*"
                          " || del %(filters_names)|-all",
                          &my_command_cb, NULL, NULL);
----

На пример, ако је команда која се позива `/command abc def ghi`, онда _argv_ и _argv_eol_ имају следеће вредности:

* _argv_:
** _argv[0]_ == "/command"
** _argv[1]_ == "abc"
** _argv[2]_ == "def"
** _argv[3]_ == "ghi"
* _argv_eol_:
** _argv_eol[0]_ == "/command abc def ghi"
** _argv_eol[1]_ == "abc def ghi"
** _argv_eol[2]_ == "def ghi"
** _argv_eol[3]_ == "ghi"

У скриптама, _args_ има вредност "abc def ghi".

Скрипта (Python):

[source,python]
----
# прототип
def hook_command(command: str, description: str, args: str, args_description: str,
                 completion: str, callback: str, callback_data: str) -> str: ...

# пример
def my_command_cb(data: str, buffer: str, args: str) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_command("мојфилтер", "опис за мојфилтер",
    "[list] | [enable|disable|toggle [име]] | [add име plugin.buffer tags regex] | [del име|-all]",
    "опис аргумената...",
    "list"
    " || enable %(filters_names)"
    " || disable %(filters_names)"
    " || toggle %(filters_names)"
    " || add %(filters_names) %(buffers_plugins_names)|*"
    " || del %(filters_names)|-all",
    "my_command_cb", "")
----

==== hook_completion

_Ажурирано у верзијама 1.5, 1.7._

Качи се на довршавање.

Прототип:

[source,c]
----
struct t_hook *weechat_hook_completion (const char *completion_item,
                                        const char *description,
                                        int (*callback)(const void *pointer,
                                                        void *data,
                                                        const char *completion_item,
                                                        struct t_gui_buffer *buffer,
                                                        struct t_gui_completion *completion),
                                        const void *callback_pointer,
                                        void *callback_data);
----

Аргументи:

* _completion_item_: име ставке довршавања, након ње у закаченој команди (аргумент _completion_) можете да користите _%(име)_ (или _%(име:аргументи)_ у WeeChat ≥ 1.7) (након ставке довршавања се дозвољава приоритет, погледајте напомену у вези са <<hook_priority,приоритетима>>)
* _description_: опис довршавања
* _callback_: функција се позива када се употреби ставка довршавања (корисник нешто довршава употребом ове ставке), аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _const char *completion_item_: име ставке довршавања (у WeeChat ≥ 1.7 може да укључи и аргументе у формату: _име:аргументи_)
** _struct t_gui_buffer *buffer_: бафер у коме се врши довршавање
** _struct t_gui_completion *completion_: структура која се користи за додавање речи довршавања (погледајте <<_completion_list_add,completion_list_add>>)
** повратна вредност:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се кука обрише

[NOTE]
Имена довршавања су глобална (програм WeeChat и додаци их заједнички користе). Тако да се препоручује да изаберете име са јединственим префиксом, као што је „plugin_xxx” (где је „xxx” име ваше ставке).

[IMPORTANT]
Функција повратног позива сме да се позива само функције довршавања као што је <<_completion_list_add,completion_list_add>> и *НЕ* сме да ажурира командну линију. +
Да бисте ажурирали командну линију када се притисне kbd:[Tab], употребите функцију <<_hook_command_run,hook_command_run>> са командом: `+/input complete_next+` (а ако ваша функција повратног позива успешно ажурира командну линију, морате да вратите _WEECHAT_RC_OK_EAT_, тако да програм WeeChat не изврши довршавање).

Повратна вредност:

* показивач на нову куку, NULL у случају грешке

C пример:

[source,c]
----
int
my_completion_cb (const void *pointer, void *data, const char *completion_item,
                  struct t_gui_buffer *buffer,
                  struct t_gui_completion *completion)
{
    weechat_completion_list_add (completion, "реч1", 0, WEECHAT_LIST_POS_SORT);
    weechat_completion_list_add (completion, "тест_реч2", 0, WEECHAT_LIST_POS_SORT);
    return WEECHAT_RC_OK;
}

struct t_hook *my_completion_hook = weechat_hook_completion ("plugin_ставка",
                                                             "моје лично довршавање!",
                                                             &my_completion_cb, NULL, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def hook_completion(completion_item: str, description: str, callback: str, callback_data: str) -> str: ...

# пример
def my_completion_cb(data: str, completion_item: str, buffer: str, completion: str) -> int:
    weechat.completion_list_add(completion, "реч1", 0, weechat.WEECHAT_LIST_POS_SORT)
    weechat.completion_list_add(completion, "тест_реч2", 0, weechat.WEECHAT_LIST_POS_SORT)
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_completion("plugin_ставка", "моје лично довршавање!",
                               "my_completion_cb", "")
----

==== hook_completion_get_string

_WeeChat ≥ 0.3.4._

*Застарело од WeeChat верзије 2.9* (још увек постоји из разлога компатибилности). +
Ову функцију је заменила <<_completion_get_string,completion_get_string>>.

==== hook_completion_list_add

*Застарело од WeeChat верзије 2.9* (још увек постоји из разлога компатибилности). +
Ову функцију је заменила <<_completion_list_add,completion_list_add>>.

==== hook_command_run

_Ажурирано у верзији 1.5._

Закачи се на команду када је програм WeeChat покрене.

Прототип:

[source,c]
----
struct t_hook *weechat_hook_command_run (const char *command,
                                         int (*callback)(const void *pointer,
                                                         void *data,
                                                         struct t_gui_buffer *buffer,
                                                         const char *command),
                                         const void *callback_pointer,
                                         void *callback_data);
----

Аргументи:

* _command_: команда која се качи (дозвољен је џокер `+*+`) (након команде се дозвољава приоритет, погледајте напомену у вези са <<hook_priority,приоритетима>>)
* _callback_: функција која се позива када се команда покрене, аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _struct t_gui_buffer *buffer_: бафер у коме се извршава команда
** _const char *command_: команда која се извршава, са својим аргументима
** повратна вредност:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_OK_EAT_: након функције повратног позива, програм WeeChat неће извршити команду
*** _WEECHAT_RC_ERROR_
* _callback_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се кука обрише

Повратна вредност:

* показивач на нову куку, NULL у случају грешке

C пример:

[source,c]
----
int
my_command_run_cb (const void *pointer, void *data,
                   struct t_gui_buffer *buffer, const char *command)
{
    weechat_printf (NULL, "Трошим довршавање!");
    return WEECHAT_RC_OK_EAT;
}

struct t_hook *my_command_run_hook =
    weechat_hook_command_run ("/input complete*",
                              &my_command_run_cb, NULL, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def hook_command_run(command: str, callback: str, callback_data: str) -> str: ...

# пример
def my_command_run_cb(data: str, buffer: str, command: str) -> int:
    weechat.prnt("", "Трошим довршавање!")
    return weechat.WEECHAT_RC_OK_EAT

hook = weechat.hook_command_run("/input complete*", "my_command_run_cb", "")
----

==== hook_timer

_Ажурирано у верзији 1.5._

Качи се на тајмер.

Прототип:

[source,c]
----
struct t_hook *weechat_hook_timer (long interval,
                                   int align_second,
                                   int max_calls,
                                   int (*callback)(const void *pointer,
                                                   void *data,
                                                   int remaining_calls),
                                   const void *callback_pointer,
                                   void *callback_data);
----

Аргументи:

* _interval_: интервал између два позива (у милисекундама, па је 1000 = 1 секунда)
* _align_second_: поравнање на секундама. На пример, ако је текуће време 09:00, а интервал = 60000 (60 секунди) и align_second = 60, онда се тајмер позива сваког минута у 0 секунди
* _max_calls_: колико пута ће се позвати тајмер (ако је 0, онда тајмер не стаје)
* _callback_: функција која се позива када се достигне време, аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _int remaining_calls_: број преосталих позива (-1 ако тајмер не стаје)
** повратна вредност:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се кука обрише

Повратна вредност:

* показивач на нову куку, NULL у случају грешке

C пример:

[source,c]
----
int
my_timer_cb (const void *pointer, void *data, int remaining_calls)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* тајмер се позива сваких 20 секунди */
struct t_hook *my_timer_hook =
    weechat_hook_timer (20 * 1000, 0, 0, &my_timer_cb, NULL, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def hook_timer(interval: int, align_second: int, max_calls: int, callback: str, callback_data: str) -> str: ...

# пример
def my_timer_cb(data: str, remaining_calls: int) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

# тајмер се позива сваких 20 секунди
hook = weechat.hook_timer(20 * 1000, 0, 0, "my_timer_cb", "")
----

==== hook_fd

_Ажурирано у верзијама 1.3, 1.5, 2.0._

Качи се на фајл дескриптор (фајла или сокета).

Прототип:

[source,c]
----
struct t_hook *weechat_hook_fd (int fd,
                                int flag_read,
                                int flag_write,
                                int flag_exception,
                                int (*callback)(const void *pointer,
                                                void *data,
                                                int fd),
                                const void *callback_pointer,
                                void *callback_data);
----

Аргументи:

* _fd_: фајл дескриптор
* _flag_read_: 1 = хвата се догађај читања, 0 = игнорише се
* _flag_write_: 1 = хвата се догађај уписа, 0 = игнорише се
* _flag_exception_: 1 = хвата се догађај изузетка, 0 = игнорише се (_WeeChat ≥ 1.3_: овај аргумент се игнорише и више се не користи)
* _callback_: функција која се позива када се за фајл (или сокет) догоди изабрани догађај, аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _int fd_: фајл дескриптор
** повратна вредност:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се кука обрише

Повратна вредност:

* показивач на нову куку, NULL у случају грешке

[IMPORTANT]
У скриптама, са програмом WeeChat ≥ 2.0, аргумент функције повратног позива _fd_ је цео број (у WeeChat ≤ 1.9, био је стринг). +
Да би постојала компатибилност са свим верзијама, препоручује се да пре употребе конвертујете аргумент у цео број, на пример у језику Python: `int(fd)`.

C пример:

[source,c]
----
int
my_fd_cb (const void *pointer, void *data, int fd)
{
    /* ... */
    return WEECHAT_RC_OK;
}

int sock = socket (AF_INET, SOCK_STREAM, 0);
/* set socket options */
/* ... */
struct t_hook *my_fd_hook = weechat_hook_fd (sock, 1, 0, 0, &my_fd_cb, NULL, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def hook_fd(fd: int, flag_read: int, flag_write: int, flag_exception: int, callback: str, callback_data: str) -> str: ...

# пример
def my_fd_cb(data: str, fd: int) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

sock = ...
hook = weechat.hook_fd(sock, 1, 0, 0, "my_fd_cb", "")
----

==== hook_process

_Ажурирано у верзији 1.5._

Качи се на процес (покренут рачвањем), и хвата његов излаз.

[NOTE]
Почевши од верзије 0.3.9.2, за извршавање команде се више не користи командно окружење. Програм WeeChat аутоматски раздваја команду и њене аргументе (на исти начин на који то ради командно окружење). +
Ако подела није исправна (у зависности од знакова навода у вашој команди), или ако желите да користите командно окружење, употребите функцију <<_hook_process_hashtable,hook_process_hashtable>> са аргументима у хеш табели _options_ _(WeeChat ≥ 0.4.0)_.

Прототип:

[source,c]
----
struct t_hook *weechat_hook_process (const char *command,
                                     int timeout,
                                     int (*callback)(const void *pointer,
                                                     void *data,
                                                     const char *command,
                                                     int return_code,
                                                     const char *out,
                                                     const char *err),
                                     const void *callback_pointer,
                                     void *callback_data);
----

Аргументи:

* _command_: команда која се покреће у дете процесу, URL _(WeeChat ≥ 0.3.7)_ или функција _(WeeChat ≥ 1.5)_ (погледајте испод)
* _timeout_: тајмаут за команду (у милисекундама): када овај тајмаут истекне, дете процес се убија (0 значи да нема тајмаута)
* _callback_: функција која се позива када су доступни подаци из дете процеса, или када се дете процес заврши, аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _const char *command_: команда коју извршава дете
** _int return_code_: повратни кôд:
*** _≥ 0_: повратни кôд детета за команду, а за URL су могуће следеће вредности:
**** _0_: трансфер OK
**** _1_: неважећи URL
**** _2_: грешка трансфера
**** _3_: нема довољно слободне меморије
**** _4_: грешка са фајлом
*** _< 0_:
**** _WEECHAT_HOOK_PROCESS_RUNNING_ (-1): подаци су доступни, али се дете још увек извршава
**** _WEECHAT_HOOK_PROCESS_ERROR_ (-2): грешка приликом покретања команде
**** _WEECHAT_HOOK_PROCESS_CHILD_ (-3): у дете процесу је позвана функција повратног позива
     (користи се само у C API, не у скриптинг API)
** _out_: стандардни излаз команде (stdout)
** _err_: излаз грешака команде (stderr)
** повратна вредност:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
*** повратни кôд дете процеса (у случају функције са „func:” у команди)
* _callback_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се кука обрише

Повратна вредност:

* показивач на нову куку, NULL у случају грешке

Када се команда заврши, или ако истекне тајмаут, програм WeeChat ће аутоматски да откачи куку (и убити процес ако се још увек иззвршава).

Команда може да буде URL у следећем формату: „url:https://www.example.com”, за преузимање садржаја URL адресе _(WeeChat ≥ 0.3.7)_. За URL могу да се користе опције функцијом <<_hook_process_hashtable,hook_process_hashtable>>.

Команда такође може да буде и име функције у формату: „func:име”, чиме се извршава функција „име” _(WeeChat ≥ 1.5)_. Ова функција прихвата један аргумент (_data_) и мора да врати стринг, који се прослеђује функцији повратног позива. +
У C API, функција повратног позива се позива са повратним кодом постављеним на _WEECHAT_HOOK_PROCESS_CHILD_, што значи да се функција повратног позива извршава у дете процесу (након рачвања). +
У API скриптовања, функција _име_ се директно позива и њен резултат (стринг) се прослеђује функцији повратног позива (као и излаз спољне команде.)

[TIP]
Ако желите да добијете информације у вези са WeeChat (као што је текућа стабилна верзија,
последњи гит комит, итд.), можете да употребите URL адресе на
https://weechat.org/dev/info/[овој страници ^↗^^].

[NOTE]
Величина бафера за слање података је 64KB (постоји 2 бафера: један за stdout и једна за stderr). Ако је излаз из дете процеса (stdout или stderr) дужи од 64KB, функција повратног позива ће се позивати више пута.

[IMPORTANT]
Чак и ако се у највећем броју случајева ваша функција повратног позива зове само једном, у свом коду морате обезбедити да нема проблема са вишеструким позивањем: морате да спајате податке примљене у више позива и да податке употребљавате само када повратни кôд није негативан.

C пример:

[source,c]
----
/* пример са спољном командом */
int
my_process_cb (const void *pointer, void *data, const char *command,
               int return_code, const char *out, const char *err)
{
    if (return_code == WEECHAT_HOOK_PROCESS_ERROR)
    {
        weechat_printf (NULL, "Грешка у команди ’%s’", command);
        return WEECHAT_RC_OK;
    }

    if (return_code >= 0)
    {
        weechat_printf (NULL, "return_code = %d", return_code);
    }

    if (out)
    {
        weechat_printf (NULL, "stdout: %s", out);
    }

    if (err)
    {
        weechat_printf (NULL, "stderr: %s", err);
    }

    return WEECHAT_RC_OK;
}

struct t_hook *my_process_hook = weechat_hook_process ("ls", 5000,
                                                       &my_process_cb, NULL, NULL);

/* пример са функцијом повратног позива која се зове у дете процесу */
int
my_process_func_cb (const void *pointer, void *data, const char *command,
                    int return_code, const char *out, const char *err)
{
    if (return_code == WEECHAT_HOOK_PROCESS_CHILD)
    {
        /* одради нешто блокирајуће... */
        /* ... */

        /* stdout ће се послати као "out" и функцији повратног позива родитеља */
        printf ("ово је резултат");

        /* повратни кôд процеса */
        return 0;
    }
    else
    {
        if (return_code == WEECHAT_HOOK_PROCESS_ERROR)
        {
            weechat_printf (NULL, "Грешка у команди ’%s’", command);
            return WEECHAT_RC_OK;
        }

        if (return_code >= 0)
        {
            weechat_printf (NULL, "return_code = %d", return_code);
        }

        if (out)
        {
            weechat_printf (NULL, "stdout: %s", out);
        }

        if (err)
        {
            weechat_printf (NULL, "stderr: %s", err);
        }

        return WEECHAT_RC_OK;
    }
}

struct t_hook *my_process_hook = weechat_hook_process ("func:get_status", 5000,
                                                       &my_process_func_cb, NULL, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def hook_process(command: str, timeout: int, callback: str, callback_data: str) -> str: ...

# пример са спољном командом
def my_process_cb(data: str, command: str, return_code: int, out: str, err: str) -> int:
    if return_code == weechat.WEECHAT_HOOK_PROCESS_ERROR:
        weechat.prnt("", "Грешка у команди ’%s’" % command)
        return weechat.WEECHAT_RC_OK
    if return_code >= 0:
        weechat.prnt("", "return_code = %d" % return_code)
    if out:
        weechat.prnt("", "stdout: %s" % out)
    if err:
        weechat.prnt("", "stderr: %s" % err)
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_process("ls", 5000, "my_process_cb", "")

# пример са скрипт функцијом
def get_status(data: str) -> str:
    # одради нешто блокирајуће...
    # ...
    return "ово је резултат"

def my_process_cb(data: str, command: str, return_code: int, out: str, err: str) -> int:
    if return_code == weechat.WEECHAT_HOOK_PROCESS_ERROR:
        weechat.prnt("", "Грешка у команди ’%s’" % command)
        return weechat.WEECHAT_RC_OK
    if return_code >= 0:
        weechat.prnt("", "return_code = %d" % return_code)
    if out:
        weechat.prnt("", "stdout: %s" % out)
    if err:
        weechat.prnt("", "stderr: %s" % err)
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_process("func:get_status", 5000, "my_process_cb", "")
----

==== hook_process_hashtable

_WeeChat ≥ 0.3.7, ажурирано у верзији 1.5._

Качи се на процес (покренут рачвањем) користећи опције у хеш табели и хвата излаз.

Прототип:

[source,c]
----
struct t_hook *weechat_hook_process_hashtable (const char *command,
                                               struct t_hashtable *options,
                                               int timeout,
                                               int (*callback)(const void *pointer,
                                                               void *data,
                                                               const char *command,
                                                               int return_code,
                                                               const char *out,
                                                               const char *err),
                                               const void *callback_pointer,
                                               void *callback_data);
----

Аргументи су исти као за функцију <<_hook_process,hook_process>>, уз један додатни аргумент:

* _options_: опције за команду која се извршава; хеш табела се дуплира у функцији, тако да након овог позива безбедно можете да ослободите меморију коју заузима

За стандардну команду (која не почиње са „url:”), можете користите следеће опције:

[width="100%", cols="^1,^1,1,1,5", options="header"]
|===
| Опција | Мин WeeChat | Вредност | Подразумевана | Опис

| argN (N ≥ 1) | 0.4.0 | било који стринг | без аргумената
| Аргументи команде; ако се овим опцијама не наведе ниједан аргумент,
  команда се аутоматски дели на начин на који то ради командно окружење
  (па се онда аргументи команде учитавају у _command_ аргумент).

| stdin | 0.4.3 | (не користи се) | без stdin
| Креира пајп за упис података на стандардни улаз (stdin) дете процеса
  (погледајте функцију <<_hook_set,hook_set>>).

| buffer_flush | 1.0 | број бајтова | 65536
| Минимални број бајтова након којег се испира stdout/stderr (да се излаз
  пошаље функцији повратног позива), између 1 и 65536. Ако је вредност 1,
  излаз се тренутно шаље функцији повратног позива.

| detached | 1.0 | (не користи се) | нема одвајања
| Процес се покреће у одвојеном режиму: stdout и stderr се преусмеравају на
  _/dev/null_.
|===

За команду "url:...", погледајте доступне опције у функцији <<_hook_url,hook_url>>.

Повратна вредност:

* показивач на нову куку, NULL у случају грешке

C пример:

[source,c]
----
int
my_process_cb (const void *pointer, void *data, const char *command,
               int return_code, const char *out, const char *err)
{
    if (return_code == WEECHAT_HOOK_PROCESS_ERROR)
    {
        weechat_printf (NULL, "Грешка у команди ’%s’", command);
        return WEECHAT_RC_OK;
    }

    if (return_code >= 0)
    {
        weechat_printf (NULL, "return_code = %d", return_code);
    }

    if (out)
    {
        weechat_printf (NULL, "stdout: %s", out);
    }

    if (err)
    {
        weechat_printf (NULL, "stderr: %s", err);
    }

    return WEECHAT_RC_OK;
}

/* пример 1: преузимање URL */
struct t_hashtable *options_url1 = weechat_hashtable_new (8,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          NULL,
                                                          NULL);
if (options_url1)
{
    weechat_hashtable_set (options_url1, "file_out", "/tmp/weechat.org.html");
    struct t_hook *my_process_hook = weechat_hook_process_hashtable ("url:https://weechat.org/",
                                                                     options_url1,
                                                                     20000,
                                                                     &my_process_cb, NULL, NULL);
    weechat_hashtable_free (options_url1);
}

/* пример 2: отварање URL са прилагођеним HTTP заглављима */
struct t_hashtable *options_url2 = weechat_hashtable_new (8,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          NULL,
                                                          NULL);
if (options_url2)
{
    weechat_hashtable_set (options_url2, "httpheader",
                           "Header1: value1\n"
                           "Header2: value2");
    struct t_hook *my_process_hook = weechat_hook_process_hashtable ("url:http://localhost:8080/",
                                                                     options_url2,
                                                                     20000,
                                                                     &my_process_cb, NULL, NULL);
    weechat_hashtable_free (options_url2);
}

/* пример 3: извршавање обавештавања програма са поруком која је пристигла од некога */
struct t_hashtable *options_cmd1 = weechat_hashtable_new (8,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          NULL,
                                                          NULL);
if (options_cmd1)
{
    weechat_hashtable_set (options_cmd1, "arg1", "-from");
    weechat_hashtable_set (options_cmd1, "arg2", nick);
    weechat_hashtable_set (options_cmd1, "arg3", "-msg");
    weechat_hashtable_set (options_cmd1, "arg4", message);  /* аргумент којем се не верује */
    struct t_hook *my_process_hook = weechat_hook_process_hashtable ("my-notify-command",
                                                                     options_cmd1,
                                                                     20000,
                                                                     &my_process_cb, NULL, NULL);
    weechat_hashtable_free (options_cmd1);
}

/* пример 4: позив командног окружења да изврши команду (команда мора бити БЕЗБЕДНА) */
struct t_hashtable *options_cmd2 = weechat_hashtable_new (8,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          NULL,
                                                          NULL);
if (options_cmd2)
{
    weechat_hashtable_set (options_cmd2, "arg1", "-c");
    weechat_hashtable_set (options_cmd2, "arg2", "ls -l /tmp | grep something");
    struct t_hook *my_process_hook = weechat_hook_process_hashtable ("sh",
                                                                     options_cmd2,
                                                                     20000,
                                                                     &my_process_cb, NULL, NULL);
    weechat_hashtable_free (options_cmd2);
}
----

Скрипта (Python):

[source,python]
----
# прототип
def hook_process_hashtable(command: str, options: Dict[str, str], timeout: int, callback: str, callback_data: str) -> str: ...

# пример
def my_process_cb(data: str, command: str, return_code: int, out: str, err: str) -> int:
    if return_code == weechat.WEECHAT_HOOK_PROCESS_ERROR:
        weechat.prnt("", "Грешка у команди ’%s’" % command)
        return weechat.WEECHAT_RC_OK
    if return_code >= 0:
        weechat.prnt("", "return_code = %d" % return_code)
    if out:
        weechat.prnt("", "stdout: %s" % out)
    if err:
        weechat.prnt("", "stderr: %s" % err)
    return weechat.WEECHAT_RC_OK

# пример 1: преузимање URL
hook1 = weechat.hook_process_hashtable("url:https://weechat.org/",
                                       {"file_out": "/tmp/weechat.org.html"},
                                       20000, "my_process_cb", "")

# пример 2: отварање URL са прилагођеним HTTP заглављима
options = {
    "httpheader": "\n".join([
        "Header1: value1",
        "Header2: value2",
    ]),
}
hook2 = weechat.hook_process_hashtable("url:http://localhost:8080/",
                                       options,
                                       20000, "my_process_cb", "")

# пример 3: извршавање обавештавања програма са поруком која је пристигла од некога
hook3 = weechat.hook_process_hashtable("my-notify-command",
                                       {"arg1": "-from",
                                        "arg2": nick,
                                        "arg3": "-msg",
                                        "arg4": message},  # аргумент којем се не верује
                                       20000, "my_process_cb", "")

# пример 4: позив командног окружења да изврши команду (команда мора бити БЕЗБЕДНА)
hook4 = weechat.hook_process_hashtable("sh",
                                       {"arg1": "-c",
                                        "arg2": "ls -l /tmp | grep something"},
                                       20000, "my_process_cb", "")
----

==== hook_url

_WeeChat ≥ 4.1.0._

URL трансфер.

// TRANSLATION MISSING
This function is similar to <<_hook_process,hook_process>> and
<<_hook_process_hashtable,hook_process_hashtable>> with command "url:..."
but it uses a thread instead of new process, making it more lightweight
and thus recommended for this usage.

Прототип:

[source,c]
----
struct t_hook *weechat_hook_url (const char *url,
                                 struct t_hashtable *options,
                                 int timeout,
                                 int (*callback)(const void *pointer,
                                                 void *data,
                                                 const char *url,
                                                 struct t_hashtable *options,
                                                 struct t_hashtable *output),
                                 const void *callback_pointer,
                                 void *callback_data);
----

Аргументи:

* _url_: URL
* _options_: опције URL трансфера (погледајте испод); хеш табела се дуплира у функцији, тако да након овог позива безбедно можете да ослободите меморију коју заузима
* _timeout_: истек времена URL трансфера (у милисекундама): након овог периода,
  трансфер се зауставља (0 значи без истека времена)
* _callback_: функција која се позива када се заврши трансфер, аргументи и повратна
  вредност:
** _const void *pointer_: показивач
** _void *data_: показивач
** _const char *url_: URL
** _struct t_hashtable *options_: опције
** _struct t_hashtable *output_: резултат (кључеви и вредности су стрингови), који може
   да садржи следеће кључеве:
*** _response_code_: HTTP кôд одзива
*** _headers_: HTTP заглавља у одзиву
*** _output_: стандардни излаз (поставља се само ако у опцијама није постављено _file_out_)
*** _error_: порука о грешки (поставља се само у случају грешке)
** повратна вредност:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се кука обрише

Доступне су следеће Curl опције (погледајте `+man curl_easy_setopt+` за
опис сваке од опција):

include::{autogendir}/autogen_api_url_options.sr.adoc[tag=url_options]

[NOTE]
^(1)^ За опције типа „mask”, формат је: „вредност1+вредност2+вредност3”; за опције типа „list”, ставке листе морају да се раздвоје преломом линије (`\n`). +
^(2)^ Ако су доступне константе, оне морају да се користе као вредност опције.

За улазни/излазни фајл су дозвољене следеће две додатне опције (стрингови):

[width="100%",cols="2,^1,7",options="header"]
|===
| Опција   | Тип    | Опис
| file_in  | string | фајл који се чита и шаље URL адресама (post фајл)
| file_out | string | преузети URL/фајл се уписује у овај фајл (уместо на стандардни излаз)
|===

Повратна вредност:

* показивач на нову куку, NULL у случају грешке

C пример:

[source,c]
----
int
my_url_cb (const void *pointer, void *data, const char *url,
           struct t_hashtable *options, struct t_hashtable *output)
{
    weechat_printf (NULL, "response_code: %s", weechat_hashtable_get (output, "response_code"));
    weechat_printf (NULL, "headers: %s", weechat_hashtable_get (output, "headers"));
    weechat_printf (NULL, "output: %s", weechat_hashtable_get (output, "output"));
    weechat_printf (NULL, "error: %s", weechat_hashtable_get (output, "error"));
    return WEECHAT_RC_OK;
}

/* example 1: output to a file */
struct t_hashtable *options_url1 = weechat_hashtable_new (8,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          NULL,
                                                          NULL);
if (options_url1)
{
    weechat_hashtable_set (options_url1, "file_out", "/tmp/weechat.org.html");
    struct t_hook *my_url_hook = weechat_hook_url ("https://weechat.org/",
                                                   options_url1,
                                                   20000,
                                                   &my_url_cb, NULL, NULL);
    weechat_hashtable_free (options_url1);
}

/* example 2: custom HTTP headers, output sent to callback */
struct t_hashtable *options_url2 = weechat_hashtable_new (8,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          NULL,
                                                          NULL);
if (options_url2)
{
    weechat_hashtable_set (options_url2, "httpheader",
                           "Header1: value1\n"
                           "Header2: value2");
    struct t_hook *my_url_hook = weechat_hook_url ("http://localhost:8080/",
                                                   options_url2,
                                                   20000,
                                                   &my_url_cb, NULL, NULL);
    weechat_hashtable_free (options_url2);
}
----

Скрипта (Python):

[source,python]
----
# прототип
def hook_url(url: str, options: Dict[str, str], timeout: int, callback: str, callback_data: str) -> str: ...

# пример
def my_url_cb(data: str, url: str, options: Dict[str, str], output: Dict[str, str]) -> int:
    weechat.prnt("", "output: %s" % output)
    return weechat.WEECHAT_RC_OK

# пример 1: излаз у фајл
hook1 = weechat.hook_url("https://weechat.org/",
                         {"file_out": "/tmp/weechat.org.html"},
                         20000, "my_url_cb", "")

# пример 2: произвољна HTTP заглавља, излаз се шаље функцији повратног позива
options = {
    "httpheader": "\n".join([
        "Header1: value1",
        "Header2: value2",
    ]),
}
hook2 = weechat.hook_url("http://localhost:8080/", options, 20000, "my_url_cb", "")
----

==== hook_connect

_Ажурирано у верзијама 1.5, 2.0, 4.4.0._

Качи се на везу (везу у позадини са удаљеним хостом).

Прототип:

[source,c]
----
struct t_hook *weechat_hook_connect (const char *proxy,
                                     const char *address,
                                     int port,
                                     int ipv6,
                                     int retry,
                                     void *gnutls_sess,
                                     void *gnutls_cb,
                                     int gnutls_dhkey_size,
                                     const char *gnutls_priorities,
                                     const char *local_hostname,
                                     int (*callback)(const void *pointer,
                                                     void *data,
                                                     int status,
                                                     int gnutls_rc,
                                                     int sock,
                                                     const char *error,
                                                     const char *ip_address),
                                     const void *callback_pointer,
                                     void *callback_data);
----

Аргументи:

* _proxy_: име проксија који се користи за везу (није обавезно, NULL значи да је веза без проксија)
* _address_: име или IP адреса са којом се повезује
* _port_: број порта
* _ipv6_:
** `WEECHAT_HOOK_CONNECT_IPV6_DISABLE` ^(1)^: искључује IPv6 (користи се само IPv4)
** `WEECHAT_HOOK_CONNECT_IPV6_AUTO` ^(1)^: користи се IPv6 са преласком на IPv4 по потреби
** `WEECHAT_HOOK_CONNECT_IPV6_FORCE` ^(1)^: форсира се IPv6 (не користи се IPv4) _(WeeChat ≥ 4.4.0)_
* _retry_: број поновних покушаја, користи се за прелаз на IPv4 хостове ако се IPv6 хостови успостављају везу али онда не прихватају клијента
* _gnutls_sess_: GnuTLS сесија (није обавезна)
* _gnutls_cb_: GnuTLS функција повратног позива (није обавезна)
* _gnutls_dhkey_size_: величина кључа који се користи током Дифи-Хелман размене кључева (GnuTLS)
* _gnutls_priorities_: приоритети за gnutls (у вези синтаксе, погледајте документацију функције _gnutls_priority_init_ у gnutls упутству), основне вредности су следеће:
** _PERFORMANCE_
** _NORMAL_ (подразумевано)
** _SECURE128_
** _SECURE256_
** _EXPORT_
** _NONE_
* _local_hostname_: име локалног хоста које ће се користити за везу (није обавезно)
* _callback_: функција која се позива када је веза OK или не успе да се успостави, аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _int status_: статус везе ^(2)^:
*** _WEECHAT_HOOK_CONNECT_OK_: веза је OK
*** _WEECHAT_HOOK_CONNECT_ADDRESS_NOT_FOUND_: адреса није пронађена
*** _WEECHAT_HOOK_CONNECT_IP_ADDRESS_NOT_FOUND_: IP адреса није пронађена
*** _WEECHAT_HOOK_CONNECT_CONNECTION_REFUSED_: повезивање је одбијено
*** _WEECHAT_HOOK_CONNECT_PROXY_ERROR_: грешка са проксијем
*** _WEECHAT_HOOK_CONNECT_LOCAL_HOSTNAME_ERROR_: грешка са именом локалног хоста
*** _WEECHAT_HOOK_CONNECT_GNUTLS_INIT_ERROR_: GnuTLS init грешка
*** _WEECHAT_HOOK_CONNECT_GNUTLS_HANDSHAKE_ERROR_: грешка код GnuTLS руковања
*** _WEECHAT_HOOK_CONNECT_MEMORY_ERROR_: нема довољно слободне меморије
*** _WEECHAT_HOOK_CONNECT_TIMEOUT_: тајмаут
*** _WEECHAT_HOOK_CONNECT_SOCKET_ERROR_: сокет није могао да се креира
** _gnutls_rc_: повратна вредност функције _gnutls_handshake()_ ^(2)^
** _sock_: сокет који се употребљен за везу ^(2)^
** _const char *error_: повратна вредност _gnutls_strerror(gnutls_rc)_
** _const char *ip_address_: IP адреса није нађена
** повратна вредност:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се кука обрише

[NOTE]
^(1)^ Констате за параметар _ipv6_ су доступне почевши од WeeChat 4.4.0. +
У старијим издањима су дозвољене вредности `1` (користи се IPv6 са преласком на IPv4 у случају потребе) и
`0` (искључује се IPv6, користи се само IPv4). +
^(2)^ У скриптама и програмом WeeChat ≥ 2.0, аргументи функције повратног позива _status_, _gnutls_rc_ и _sock_ су цели бројеви (у програму WeeChat ≤ 1.9, били су стрингови). +
Да би се одржала компатибилност са свим верзијама, препоручује се да аргумент пре употребе конвертујете у цео број, на пример у језику Python: `int(sock)`.

Повратна вредност:

* показивач на нову куку, NULL у случају грешке

C пример:

[source,c]
----
int
my_connect_cb (const void *pointer, void *data, int status, int gnutls_rc,
               int sock, const char *error, const char *ip_address)
{
    switch (status)
    {
        case WEECHAT_HOOK_CONNECT_OK:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_ADDRESS_NOT_FOUND:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_IP_ADDRESS_NOT_FOUND:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_CONNECTION_REFUSED:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_PROXY_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_LOCAL_HOSTNAME_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_GNUTLS_INIT_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_GNUTLS_HANDSHAKE_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_MEMORY_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_TIMEOUT:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_SOCKET_ERROR:
            /* ... */
            break;
    }
    return WEECHAT_RC_OK;
}

struct t_hook *my_connect_hook = weechat_hook_connect (NULL,
                                                       "my.server.org", 1234,
                                                       WEECHAT_HOOK_CONNECT_IPV6_AUTO,
                                                       0,
                                                       NULL, NULL, 0,  /* GnuTLS */
                                                       NULL,
                                                       &my_connect_cb, NULL, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def hook_connect(proxy: str, address: str, port: int, ipv6: int, retry: int, local_hostname: str,
                 callback: str, callback_data: str) -> str: ...

# пример
def my_connect_cb(data: str, status: int, gnutls_rc: int, sock: int, error: str, ip_address: str) -> int:
    if status == weechat.WEECHAT_HOOK_CONNECT_OK:
        # ...
    elif status == weechat.WEECHAT_HOOK_CONNECT_ADDRESS_NOT_FOUND:
        # ...
    elif status == weechat.WEECHAT_HOOK_CONNECT_IP_ADDRESS_NOT_FOUND:
        # ...
    elif status == weechat.WEECHAT_HOOK_CONNECT_CONNECTION_REFUSED:
        # ...
    elif status == weechat.WEECHAT_HOOK_CONNECT_PROXY_ERROR:
        # ...
    elif status == weechat.WEECHAT_HOOK_CONNECT_LOCAL_HOSTNAME_ERROR:
        # ...
    elif status == weechat.WEECHAT_HOOK_CONNECT_GNUTLS_INIT_ERROR:
        # ...
    elif status == weechat.WEECHAT_HOOK_CONNECT_GNUTLS_HANDSHAKE_ERROR:
        # ...
    elif status == weechat.WEECHAT_HOOK_CONNECT_MEMORY_ERROR:
        # ...
    elif status == weechat.WEECHAT_HOOK_CONNECT_TIMEOUT:
        # ...
    elif status == weechat.WEECHAT_HOOK_CONNECT_SOCKET_ERROR:
        # ...
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_connect("", "my.server.org", 1234,
                            weechat.WEECHAT_HOOK_CONNECT_IPV6_AUTO, 0, "",
                            "my_connect_cb", "")
----

==== hook_line

_WeeChat ≥ 2.3, ажурирано у 4.2.0._

Качи се на линију која треба да се испише у бафер.

Када линија треба да се испише у бафер, куке се позивају у следећем редоследу:

* <<_hook_line,кука линије>> (ова кука): може да промени бафер, префикс, поруку, ознаке, ниво обавештавања, … (погледајте испод)
* <<_hook_modifier,кука модификатора>> „<<hook_modifier_weechat_print,weechat_print>>”: може да промени префикс и поруку у баферу са форматираним садржајем.
* <<_hook_print,кука исписа>>: позива се када се у бафер са форматираним садржајем дода линија (овом куком ништа директно не може да се измени).

[NOTE]
„line” (кука линије) је једина од ове три куке која може да ради над баферима са слободним садржајем.

Прототип:

[source,c]
----
struct t_hook *weechat_hook_line (const char *buffer_type,
                                  const char *buffer_name,
                                  const char *tags,
                                  struct t_hashtable *(*callback)(const void *pointer,
                                                                  void *data,
                                                                  struct t_hashtable *line),
                                  const void *callback_pointer,
                                  void *callback_data);
----

Аргументи:

* _buffer_type_: хвата линије у наведеном типу бафера (ако је NULL или празан стринг, подразумева се _formatted_)
  (_WeeChat ≥ 3.7_: пре типа бафера се дозвољава приоритет, погледајте белешку у вези са
  <<hook_priority,приоритетима>>):
** _formatted_: хвата линије само у форматираним баферима (подразумевано)
** _free_: хвата линије само у баферима са слободним садржајем
** _*_: хвата линије у баферима свих типова
* _buffer_name_: листа маски бафера раздвојених запетама (погледајте <<_buffer_match_list,buffer_match_list>>); NULL, празан стринг или „*” се подудара са било којим бафером
* _tags_: хвата само поруке које имају наведене ознаке (није обавезно): листа ознака раздвојених запетама
   које морају да се налазе у поруци (логичко „или”); можете да комбинујете више ознака у релацији логичко „и” граничником `+++`; у ознакама је дозвољена употреба џокера `+*+`
* _callback_: функција која се позива када се линија дода у бафер, аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _struct t_hashtable *line_: хеш табела са инфо о линији, кључеви и вредности су стрингови (погледајте табелу испод)
** return value: хеш табела са новим вредностима (погледајте табелу испод)
* _callback_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се кука обрише

Повратна вредност:

* показивач на нову куку, NULL у случају грешке

Подаци линије се прослеђују функцији повратног позива у хеш табели која има следеће вредности (кључеви и вредности су стрингови):

[width="100%", cols="^1,3,3,2", options="header"]
|===
| Кључ | Вредност (форматирани бафер) | Вредност (слободни бафер) | Примери

| buffer
| Показивач на бафер.
| Показивач на бафер.
| `+0x1234abcd+`

| buffer_name
| Име бафера.
| Име бафера.
| `+core.weechat+` +
  `+irc.server.libera+` +
  `+irc.libera.#weechat+`

| buffer_type
| "formatted"
| "free"
| `+formatted+` +
  `+free+`

| y
| Нема ("-1").
| Број линије (≥ "0").
| `+-1+` +
  `+8+`

| date
| Датум линије (временска ознака).
| Нема ("0").
| `+1533792000+`

| date_usec
| Микросекунде датума линије (између 0 и 999999).
| N/A ("0").
| `+123456+`

| date_printed
| Датум када је линија била приказана (временска ознака).
| Нема ("0").
| `+1533792012+`

| date_usec_printed
| Микросекунде датума када је линија била приказана (између 0 и 999999).
| N/A ("0").
| `+654321+`

| str_time
| Датум за приказ (са могућим кодовима боја у себи).
| Нема (празан стринг).
| `+09:07:20+`

| tags_count
| Број ознака у линији (≥ "0").
| Нема ("0").
| `+2+`

| tags
| Листа ознака раздвојених запетама.
| Нема (празан стринг).
| `+irc_join,nick_test+`

| displayed
| "0" = линија је филтрирана (скривена је) +
  "1" = линија није филтрирана (приказана је).
| "0" = линија је филтрирана (скривена је) +
  "1" = линија није филтрирана (приказана је).
| `+0+` +
  `+1+`

| notify_level
| "-1" = без обавештавања +
  "0" = низак ниво +
  "1" = порука +
  "2" = приватна порука +
  "3" = истицање
| Нема ("0").
| `+2+`

| highlight
| "0" = без истицања +
  "1" = линија има истицање.
| Нема ("0").
| `+0+` +
  `+1+`

| prefix
| Префикс линије.
| Нема (празан стринг).
| `+-->+`

| message
| Порука у линији.
| Порука у линији.
| `+test (~test@example.com) је приступио у #channel+`
|===

Функција повратног позива може да врати хеш табелу са неким измењеним пољима како би се линија ажурирала. Програм WeeChat било коју неважећу вредност у пољу игнорише без упозорења.

У хеш табелу могу да се поставе следећи кључеви (кључеви и вредности у овој хеш табели су стрингови):

[width="100%", cols="^1,2,2,5", options="header"]
|===
| Кључ | Дозвољена вредност (форматирани бафер) | Дозвољена вредност (слободни бафер) | Резултат

| buffer
| Показивач на бафер са форматираним садржајем.
| Показивач на бафер са слободним садржајем.
| Линија се приказује у овом баферу. +
  Ако је вредност празна, линија се брише (тада се све остало у хеш табели
  игнорише); наредне куке типа „line” се не позивају.

| buffer_name
| Име бафера са форматираним садржајем.
| Име бафера са слободним садржајем.
| Линија се приказује у овом баферу. +
  Ако је и `buffer` постављено, вредност `+buffer_name+` има виши приоритет и она се користи. +
  Ако је вредност празна, линија се брише (тада се све остало у хеш табели
  игнорише); наредне куке типа „line” се не позивају.

| y
| Нема.
| Цео број (≥ „0”).
| Број линије се поставља на ову вредност.

| date
| Временска ознака.
| Нема.
| Датум се поставља на ову вредност. +
  Сагласно овоме се поставља и вредност `+str_time+`.

| date_usec
| Цео број ("0" до "999999").
| Нема.
| Микросекунде датума линије се постављају на ову вредност. +
  Сагласно овоме се поставља и вредност `+str_time+`.

| date_printed
| Временска ознака.
| Нема.
| Датум се поставља на ову временску ознаку (не приказује се).

| date_usec_printed
| Цео број ("0" до "999999").
| Нема.
| Микросекунде исписаног датума се постављају на ову вредност.

| str_time
| Стринг.
| Нема.
| Овај стринг се користи за приказ датума линије. +
  Ако је и `date` постављено, вредност `+str_time+` има виши приоритет и она се користи.

| tags
| Стринг.
| Нема.
| Ознаке линије се замењују овом листом ознака раздвојених запетама. +
  Сагласно њој се ажурирају `+notify_level+` и `highlight`.

| notify_level
| Цео број („-1” до „3”).
| Нема.
| Ниво обавештавања се поставља на ову вредност. Када се линија дода у бафер,
  сагласно овој вредности се ажурира врућа листа. +
  Вредност `highlight` се ажурира сагласно са овом вредности. +
  Ако је и `tags` постављено, вредност `+notify_level+` има виши приоритет и она се користи.

| highlight
| Цео број („0” или „1”).
| Нема.
| „0” искључује истицање у линији, „1” форсира истицање у линији. +
  Ако су постављени `tags` или `+notify_level+`, вредност `highlight` има виши
  приоритет и она се користи.

| prefix
| Стринг.
| N/A.
| Префикс линије се поставља на ову вредност.

| message
| Стринг.
| Стринг.
| Порука линије се поставља на ову вредност.
|===

C пример:

[source,c]
----
int
my_line_cb (const void *pointer, void *data, struct t_hashtable *line)
{
    struct t_hashtable *hashtable;

    hashtable = weechat_hashtable_new (8,
                                       WEECHAT_HASHTABLE_STRING,
                                       WEECHAT_HASHTABLE_STRING,
                                       NULL,
                                       NULL);
    /* force a highlight on the line */
    weechat_hashtable_set (hashtable, "highlight", "1");
    return hashtable;
}

/* хвата линије са ознаком „irc_join” */
struct t_hook *my_line_hook =
    weechat_hook_line ("", "", "irc_join", &my_line_cb, NULL, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def hook_line(buffer_type: str, buffer_name: str, tags: str, callback: str, callback_data: str) -> str: ...

# пример
def my_line_cb(data: str, line: Dict[str, str]) -> Dict[str, str]:
    # force a highlight on the line
    return {"highlight": "1"}

# хвата линије са ознаком „irc_join”
hook = weechat.hook_line("", "", "irc_join", "my_line_cb", "")
----

==== hook_print

_Ажурирано у верзијама 0.4.3, 1.0, 1.5, 4.2.0._

Качи се на поруку која се исписује. Позива се када се у бафер са форматираним садржајем дода линија.

За више информација о кукама које се позивају када се линија исписује, погледајте <<_hook_line,hook_line>>.

Прототип:

[source,c]
----
struct t_hook *weechat_hook_print (struct t_gui_buffer *buffer,
                                   const char *tags,
                                   const char *message,
                                   int strip_colors,
                                   int (*callback)(const void *pointer,
                                                   void *data,
                                                   struct t_gui_buffer *buffer,
                                                   time_t date,
                                                   int date_usec,
                                                   int tags_count,
                                                   const char **tags,
                                                   int displayed,
                                                   int highlight,
                                                   const char *prefix,
                                                   const char *message),
                                   const void *callback_pointer,
                                   void *callback_data);
----

Аргументи:

* _buffer_: показивач на бафер, ако је NULL, хватају се поруке из било ког бафера
* _tags_: хватају се само поруке са наведеним ознакама (није обавезно):
** у WeeChat ≥ 0.4.3: листа ознака раздвојених запетама које морају да се налазе у поруци (логичко „или”); више ознака могу да се комбинују у релацији логичко „и” граничником `+++`; у ознакама је дозвољен џокер `+*+`
** у WeeChat ≤ 0.4.2: листа ознака раздвојених запетама које морају све да се налазе у поруци (логичко „и”)
* _message_: хватају се само поруке са овим стрингом (није обавезно, не прави се разлика у величини слова)
* _strip_colors_: ако је 1, пре позива функције повратног позива, из поруке се уклањају боје
* _callback_: функција која се позива када се порука исписује, аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _struct t_gui_buffer *buffer_: показивач на бафер
** _time_t date_: датум
** _int date_usec_: микросекунде датума
** _int tags_count_: број ознака за линију
** _const char **tags_: низ са ознакама за линију
** _int displayed_: 1 ако се линија приказује, 0 ако је филтрирана (скривена)
** _int highlight_: 1 ако линија има истицање, у супротном 0
** _const char *prefix_: префикс
** _const char *message_: порука
** повратна вредност:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се кука обрише

Повратна вредност:

* показивач на нову куку, NULL у случају грешке

[IMPORTANT]
У скриптама, са програмом WeeChat ≥ 1.0, аргументи функције повратног позива _displayed_ и _highlight_ су цели бројеви (у WeeChat ≤ 0.4.3, били су стрингови). +
Да би се обезбедила компатибилност са свим верзијама, препоручује се да пре употребе аргумент конвертујете у цео број, на пример у језику Python: `if int(highlight):`.

C пример:

[source,c]
----
int
my_print_cb (const void *pointer, void *data, struct t_gui_buffer *buffer,
             time_t date, int date_usec, int tags_count, const char **tags,
             int displayed, int highlight,
             const char *prefix, const char *message)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* хвата све поруке у свим баферима, без боје */
struct t_hook *my_print_hook =
    weechat_hook_print (NULL, NULL, NULL, 1, &my_print_cb, NULL, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def hook_print(buffer: str, tags: str, message: str, strip_colors: int, callback: str, callback_data: str) -> str: ...

# пример
def my_print_cb(data: str, buffer: str, date: str, tags: str, displayed: int, highlight: int, prefix: str, message: str) -> int:
    if highlight:
        # ...
    return weechat.WEECHAT_RC_OK

# хвата све поруке у свим баферима, без боје
hook = weechat.hook_print("", "", "", 1, "my_print_cb", "")
----

==== hook_signal

_Ажурирано у верзији 1.5, 3.6._

Качи се на сигнал.

Прототип:

[source,c]
----
struct t_hook *weechat_hook_signal (const char *signal,
                                    int (*callback)(const void *pointer,
                                                    void *data,
                                                    const char *signal,
                                                    const char *type_data,
                                                    void *signal_data),
                                    const void *callback_pointer,
                                    void *callback_data);
----

Аргументи:

* _signal_: сигнал који се хвата, дозвољава се џокер `+*+`, више сигнала може
  да се раздвоји тачка запетама
  (испред једног или више сигнала се дозвољава приоритет, погледајте напомену у вези са <<hook_priority,приоритетима>>)
  (погледајте табелу испод)
* _callback_: функција која се позива када се прими сигнал, аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _const char *signal_: примљени сигнал
** _const char *type_data_: туп података који су послати уз сигнал:
*** _WEECHAT_HOOK_SIGNAL_STRING_: стринг
*** _WEECHAT_HOOK_SIGNAL_INT_: цео број
*** _WEECHAT_HOOK_SIGNAL_POINTER_: показивач
** _void *signal_data_: подаци послати уз сигнал
** повратна вредност:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_OK_EAT_ (тренутно прекида слање сигнала) _(WeeChat ≥ 0.4.0)_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се кука обрише

Повратна вредност:

* показивач на нову куку, NULL у случају грешке

Листа сигнала који шаљу програм WeeChat и додаци:

[width="100%", cols="^2,^4,^1,6,9", options="header"]
|===
| Додатак | Сигнал | Мин WeeChat | Аргументи | Опис

| guile | [[hook_signal_guile_script_loaded]] guile_script_loaded | 0.3.9
| Стринг: путања до скрипте.
| Учитана је Scheme скрипта.

| guile | [[hook_signal_guile_script_unloaded]] guile_script_unloaded | 0.3.9
| Стринг: путања до скрипте.
| Scheme скрипта је уклоњена из меморије.

| guile | [[hook_signal_guile_script_installed]] guile_script_installed | 0.3.9
| Стринг: листа путања инсталираних скрипти раздвојених запетама.
| Инсталиран(а/е) Scheme скрипт(а/е).

| guile | [[hook_signal_guile_script_removed]] guile_script_removed | 0.3.9
| Стринг: листа уклоњених скрипти раздвојених запетама.
| Уклоњен(а/е) Scheme скрипт(а/е).

| irc | [[hook_signal_xxx_irc_in_yyy]] xxx,irc_in_yyy ^(1)^ |
| Стринг: порука.
| IRC порука од сервера (пре него што је употреби irc додатак,
  сигнал се шаље само ако се порука *не* игнорише). +
  Почевши од верзије 2.2, шаље се комплетна IRC порука, заједно са ознакама. +
  Ако је повратни код функције повратног позива _WEECHAT_RC_OK_EAT_, онда се IRC
  порука одмах брише и не обрађује се _(WeeChat ≥ 3.3)_.

| irc | [[hook_signal_xxx_irc_in2_yyy]] xxx,irc_in2_yyy ^(1)^ |
| Стринг: порука.
| IRC порука од сервера (након што је употреби irc додатак,
  сигнал се шаље само ако се порука *не* игнорише). +
  Почевши од верзије 2.2, шаље се комплетна IRC порука, заједно са ознакама.

| irc | [[hook_signal_xxx_irc_raw_in_yyy]] xxx,irc_raw_in_yyy ^(1)^ | 0.3.2
| Стринг: порука.
| IRC порука од сервера (пре него што је употреби irc додатак,
  сигнал се шаље чак и када се порука игнорише). +
  Почевши од верзије 2.2, шаље се комплетна IRC порука, заједно са ознакама. +
  Ако је повратни кôд функције повратног позива _WEECHAT_RC_OK_EAT_, онда се IRC
  порука одмах брише и обрађује се _(WeeChat ≥ 3.3)_.

| irc | [[hook_signal_xxx_irc_raw_in2_yyy]] xxx,irc_raw_in2_yyy ^(1)^ | 0.3.2
| Стринг: порука.
| IRC порука од сервера (након што је употреби irc додатак,
  сигнал се шаље чак и када се порука игнорише). +
  Почевши од верзије 2.2, шаље се комплетна IRC порука, заједно са ознакама.

| irc | [[hook_signal_xxx_irc_out1_yyy]] xxx,irc_out1_yyy ^(1)^ | 0.3.7
| Стринг: порука.
| IRC порука која се шаље серверу пре аутоматске поделе
  (да стане у 512 бајтова, подразумевано).

| irc | [[hook_signal_xxx_irc_out_yyy]] xxx,irc_out_yyy ^(1)^ |
| Стринг: порука.
| IRC порука која се шаље серверу након аутоматске поделе
  (да стане у 512 бајтова, подразумевано).
  *Упозорење:* стринг може да садржи неважеће UTF-8 податке.
  Уместо овог, препоручује се употреба сигнала „xxx,irc_out1_yyy”.

| irc | [[hook_signal_xxx_irc_outtags_yyy]] xxx,irc_outtags_yyy ^(1)^ | 0.3.4
| Стринг: ознаке + „;” + порука.
| Ознаке + IRC порука која се шаље серверу. +
  *Упозорење:* стринг може да садржи неважеће UTF-8 податке.
  Уместо овог, препоручује се употреба сигнала „xxx,irc_out1_yyy”.

| irc | [[hook_signal_irc_ctcp]] irc_ctcp |
| Стринг: порука.
| Примљена је CTCP.

| irc | [[hook_signal_irc_dcc]] irc_dcc |
| Стринг: порука.
| Нови DCC.

| irc | [[hook_signal_irc_pv]] irc_pv |
| Стринг: порука.
| Примљена је приватна порука.

| irc | [[hook_signal_irc_channel_opened]] irc_channel_opened |
| Показивач: бафер.
| Отворен је канал.

| irc | [[hook_signal_irc_pv_opened]] irc_pv_opened |
| Показивач: бафер.
| Отворен је приватни бафер.

| irc | [[hook_signal_irc_server_opened]] irc_server_opened | 0.3.7
| Показивач: бафер.
| Отворен је серверски бафер.

| irc | [[hook_signal_irc_server_connecting]] irc_server_connecting |
| Стринг: име сервера.
| Повезивање са сервером.

| irc | [[hook_signal_irc_server_connected]] irc_server_connected |
| Стринг: име сервера.
| Успостављена је веза са сервером.

| irc | [[hook_signal_irc_server_disconnected]] irc_server_disconnected |
| Стринг: име сервера.
| Прекинута је веза са сервером.

| irc | [[hook_signal_irc_server_lag_changed]] irc_server_lag_changed | 1.8
| Стринг: име сервера.
| Променило се кашњење у комуникацији са сервером.

| irc | [[hook_signal_irc_ignore_removing]] irc_ignore_removing |
| Показивач: игнорисање.
| Уклања се игнорисање.

| irc | [[hook_signal_irc_ignore_removed]] irc_ignore_removed |
| - |
Уклоњено је игнорисање.

| irc | [[hook_signal_irc_notify_join]] irc_notify_join | 0.3.8
| Стринг: име сервера + „,” + надимак.
| Надимак из листе обавештавања се прикључио серверу.

| irc | [[hook_signal_irc_notify_quit]] irc_notify_quit | 0.3.8
| Стринг: име сервера + „,” + надимак.
| Надимак из листе обавештавања је напустио сервер.

| irc | [[hook_signal_irc_notify_away]] irc_notify_away | 0.3.8
| Стринг: име сервера + „,” + надимак + „,” + порука о одсутности.
| Надимак из листе обавештавања је сада одсутан са сервера.

| irc | [[hook_signal_irc_notify_still_away]] irc_notify_still_away | 0.3.8
| Стринг: име сервера + „,” + надимак + „,” + порука о одсутности.
| Надимак из листе обавештавања је још увек одсутан са сервера (промењена је порука о одсутности).

| irc | [[hook_signal_irc_notify_back]] irc_notify_back | 0.3.8
| Стринг: име сервера + „,” + надимак.
| Надимак из листе обавештавања се вратио (уклоњен је статус одсутности).

| javascript | [[hook_signal_javascript_script_loaded]] javascript_script_loaded | 1.2
| Стринг: путања до скрипте.
| Учитана је JavaScript скрипта.

| javascript | [[hook_signal_javascript_script_unloaded]] javascript_script_unloaded | 1.2
| String: path to script.
| JavaScript скрипта је уклоњена из меморије.

| javascript | [[hook_signal_javascript_script_installed]] javascript_script_installed | 1.2
| Стринг: листа путања до инсталираних скрипти раздвојених запетама.
| Инсталиран(а/е) JavaScript скрипт(а/е).

| javascript | [[hook_signal_javascript_script_removed]] javascript_script_removed | 1.2
| Стринг: листа уклоњених скрипти раздвојених запетама.
| Уклоњен(а/е) JavaScript скрипт(а/е).

| logger | [[hook_signal_logger_start]] logger_start |
| Показивач: бафер.
| Почиње логовање бафера.

| logger | [[hook_signal_logger_stop]] logger_stop |
| Показивач: бафер.
| Престаје логовање бафера.

| logger | [[hook_signal_logger_backlog]] logger_backlog |
| Показивач: бафер.
| Приказивање ранијих линија из бафера.

| lua | [[hook_signal_lua_script_loaded]] lua_script_loaded | 0.3.9
| Стринг: путања до скрипте.
| Учитана је Lua скрипта.

| lua | [[hook_signal_lua_script_unloaded]] lua_script_unloaded | 0.3.9
| Стринг: путања до скрипте.
| Lua скрипта је уклоњена из меморије.

| lua | [[hook_signal_lua_script_installed]] lua_script_installed | 0.3.9
| Стринг: листа путања до инсталираних скрипти раздвојених запетама.
| Инсталиран(а/е) Lua скрипт(а/е).

| lua | [[hook_signal_lua_script_removed]] lua_script_removed | 0.3.9
| Стринг: листа уклоњених скрипти раздвојених запетама.
| Уклоњен(а/е) Lua скрипт(а/е).

| perl | [[hook_signal_perl_script_loaded]] perl_script_loaded | 0.3.9
| Стринг: путања до скрипте.
| Учитана је Perl скрипта.

| perl | [[hook_signal_perl_script_unloaded]] perl_script_unloaded | 0.3.9
| Стринг: путања до скрипте.
| Perl скрипта је уклоњена из меморије.

| perl | [[hook_signal_perl_script_installed]] perl_script_installed | 0.3.9
| Стринг: листа путања до инсталираних скрипти раздвојених запетама.
| Инсталиран(а/е) Perl скрипт(а/е).

| perl | [[hook_signal_perl_script_removed]] perl_script_removed | 0.3.9
| Стринг: листа уклоњених скрипти раздвојених запетама.
| Уклоњен(а/е) Perl скрипт(а/е).

| php | [[hook_signal_php_script_loaded]] php_script_loaded | 2.0
| Стринг: путања до скрипте.
| Учитана је PHP скрипта.

| php | [[hook_signal_php_script_unloaded]] php_script_unloaded | 2.0
| Стринг: путања до скрипте.
| PHP скрипта је уклоњена из меморије.

| php | [[hook_signal_php_script_installed]] php_script_installed | 2.0
| Стринг: листа путања до инсталираних скрипти раздвојених запетама.
| Инсталиран(а/е) PHP скрипт(а/е).

| php | [[hook_signal_php_script_removed]] php_script_removed | 2.0
| Стринг: листа уклоњених скрипти раздвојених запетама.
| Уклоњен(а/е) PHP скрипт(а/е).

| python | [[hook_signal_python_script_loaded]] python_script_loaded | 0.3.9
| Стринг: путања до скрипте.
| Учитана је Python скрипта.

| python | [[hook_signal_python_script_unloaded]] python_script_unloaded | 0.3.9
| Стринг: путања до скрипте.
| Python скрипта је уклоњена из меморије.

| python | [[hook_signal_python_script_installed]] python_script_installed | 0.3.9
| Стринг: листа путања до инсталираних скрипти раздвојених запетама.
| Инсталиран(а/е) Python скрипт(а/е).

| python | [[hook_signal_python_script_removed]] python_script_removed | 0.3.9
| Стринг: листа уклоњених скрипти раздвојених запетама.
| Уклоњен(а/е) Python скрипт(а/е).

| relay | [[hook_signal_relay_client_connecting]] relay_client_connecting | 1.0
| Показивач: релеј клијент.
| Релеј клијент се повезује.

| relay | [[hook_signal_relay_client_waiting_auth]] relay_client_waiting_auth | 1.0
| Показивач: релеј клијент.
| Чека се на аутентификацију релеј клијента.

| relay | [[hook_signal_relay_client_auth_ok]] relay_client_auth_ok | 1.0
| Показивач: релеј клијент.
| Успешна аутентификација релеј клијента.

| relay | [[hook_signal_relay_client_connected]] relay_client_connected | 1.0
| Показивач: релеј клијент.
| Релеј клијент се повезао.

| relay | [[hook_signal_relay_client_auth_failed]] relay_client_auth_failed | 1.0
| Показивач: релеј клијент.
| Аутентификација релеј клијента није успела.

| relay | [[hook_signal_relay_client_disconnected]] relay_client_disconnected | 1.0
| Показивач: релеј клијент.
| Прекинута је веза релеј клијентом.

| ruby | [[hook_signal_ruby_script_loaded]] ruby_script_loaded | 0.3.9
| Стринг: путања до скрипте.
| Учитана је Ruby скрипта.

| ruby | [[hook_signal_ruby_script_unloaded]] ruby_script_unloaded | 0.3.9
| Стринг: путања до скрипте.
| Ruby скрипта је уклоњена из меморије.

| ruby | [[hook_signal_ruby_script_installed]] ruby_script_installed | 0.3.9
| Стринг: листа путања до инсталираних скрипти раздвојених запетама.
| Инсталиран(а/е) Ruby скрипт(а/е).

| ruby | [[hook_signal_ruby_script_removed]] ruby_script_removed | 0.3.9
| Стринг: листа уклоњених скрипти раздвојених запетама.
| Уклоњен(а/е) Ruby скрипт(а/е).

| spell | [[hook_signal_spell_suggest]] spell_suggest | 2.4
| Показивач: бафер.
| Нови предлог за погрешно написану реч.

| tcl | [[hook_signal_tcl_script_loaded]] tcl_script_loaded | 0.3.9
| Стринг: путања до скрипте.
| Учитана је Tcl скрипта.

| tcl | [[hook_signal_tcl_script_unloaded]] tcl_script_unloaded | 0.3.9
| Стринг: путања до скрипте.
| Tcl скрипта је уклоњена из меморије.

| tcl | [[hook_signal_tcl_script_installed]] tcl_script_installed | 0.3.9
| Стринг: листа путања до инсталираних скрипти раздвојених запетама.
| Инсталран(а/е) Tcl скрипт(а/е).

| tcl | [[hook_signal_tcl_script_removed]] tcl_script_removed | 0.3.9
| Стринг: листа уклоњених скрипти раздвојених запетама.
| Уклоњен(а/е) Tcl скрипт(а/е).

| typing | [[hook_signal_typing_self_typing]] typing_self_typing | 3.3
| Показивач: бафер.
| Корисник куца поруку (шаље typing додатак, користи irc додатак).

| typing | [[hook_signal_typing_self_paused]] typing_self_paused | 3.3
| Показивач: бафер.
| Корисник је застао током куцања поруке (шаље typing додатак, користи irc додатак).

| typing | [[hook_signal_typing_self_cleared]] typing_self_cleared | 3.3
| Показивач: бафер.
| Корисник је обрисао унос и није послао поруку (шаље typing додатак, користи irc додатак).

| typing | [[hook_signal_typing_self_sent]] typing_self_sent | 3.3
| Показивач: бафер.
| Порука (не команда) је послата баферу (шаље typing додатак, користи irc додатак).

| typing | [[hook_signal_typing_set_nick]] typing_set_nick | 3.3
| Стринг: показивач на бафер + ";" + стање (једно од: "off", "typing", "paused",
  "cleared") + ";" + надимак.
| Поставља стање куцања за надимак у баферу (шаље irc додатак, обрађује typing додатак).

| typing | [[hook_signal_typing_reset_buffer]] typing_reset_buffer | 3.3
| Показивач: бафер.
| Уклања стање куцања за све надимке у баферу (шаље irc додатак, обрађује typing додатак).

| weechat | [[hook_signal_buffer_opened]] buffer_opened |
| Показивач: бафер.
| Отворен је бафер.

| weechat | [[hook_signal_buffer_closing]] buffer_closing |
| Показивач: бафер.
| Бафер се затвара.

| weechat | [[hook_signal_buffer_closed]] buffer_closed |
| Показивач: бафер.
| Бафер је затворен.

| weechat | [[hook_signal_buffer_cleared]] buffer_cleared |
| Показивач: бафер.
| Бафер је очишћен.

| weechat | [[hook_signal_buffer_filters_enabled]] buffer_filters_enabled | 2.0
| Показивач: бафер.
| У баферу су укључени филтери.

| weechat | [[hook_signal_buffer_filters_disabled]] buffer_filters_disabled | 2.0
| Показивач: бафер.
| У баферу су искључени филтери.

| weechat | [[hook_signal_buffer_hidden]] buffer_hidden |
| Показивач: бафер.
| Бафер је скривен.

| weechat | [[hook_signal_buffer_unhidden]] buffer_unhidden |
| Показивач: бафер.
| Бафер је откривен.

| weechat | [[hook_signal_buffer_line_added]] buffer_line_added | 0.3.7
| Показивач: линија.
| У бафер је додата линија.

| weechat | [[hook_signal_buffer_line_data_changed]] buffer_line_data_changed | 4.4.0
| Показивач: подаци линије.
| У баферу су ажурирани подаци линије.

| weechat | [[hook_signal_buffer_lines_hidden]] buffer_lines_hidden |
| Показивач: бафер.
| У баферу су сакривене линије.

| weechat | [[hook_signal_buffer_localvar_added]] buffer_localvar_added |
| Показивач: бафер.
| Додата је локална променљива.

| weechat | [[hook_signal_buffer_localvar_changed]] buffer_localvar_changed |
| Показивач: бафер.
| Измењена је локална променљива.

| weechat | [[hook_signal_buffer_localvar_removed]] buffer_localvar_removed |
| Показивач: бафер.
| Уклоњена је локална променљива.

| weechat | [[hook_signal_buffer_merged]] buffer_merged |
| Показивач: бафер.
| Бафер је спојен.

| weechat | [[hook_signal_buffer_unmerged]] buffer_unmerged |
| Показивач: бафер.
| Бафер је раздвојен.

| weechat | [[hook_signal_buffer_moved]] buffer_moved |
| Показивач: бафер.
| Бафер је померен.

| weechat | [[hook_signal_buffer_renamed]] buffer_renamed |
| Показивач: бафер.
| Баферу је промењено име.

| weechat | [[hook_signal_buffer_switch]] buffer_switch |
| Показивач: бафер.
| Прелази се на други бафер.

| weechat | [[hook_signal_buffer_title_changed]] buffer_title_changed |
| Показивач: бафер.
| Промењен је наслов бафера.

| weechat | [[hook_signal_buffer_modes_changed]] buffer_modes_changed | 4.3.0
| Показивач: бафер.
| Промењени су режими бафера.

| weechat | [[hook_signal_buffer_time_for_each_line_changed]] buffer_time_for_each_line_changed | 4.4.0
| Показивач: бафер.
| Време приказа за сваку измењену линију.

| weechat | [[hook_signal_buffer_type_changed]] buffer_type_changed |
| Показивач: бафер.
| Промењен је тип бафера.

| weechat | [[hook_signal_buffer_zoomed]] buffer_zoomed | 0.4.3
| Показивач: бафер.
| Зумиран је спојени бафер.

| weechat | [[hook_signal_buffer_unzoomed]] buffer_unzoomed | 0.4.3
| Показивач: бафер.
| Одзумиран је спојени бафер.

| weechat | [[hook_signal_buffer_user_input_xxx]] buffer_user_input_xxx ^(2)^ | 3.8
| Стринг: текст који се шаље у бафер.
| Текст који се шаље у кориснички бафер као улаз (шаље се само за бафере креиране са `/buffer add`). +
  Ако је повратни код функције повратног позива _WEECHAT_RC_OK_EAT_, онда стринг „q” више не може да
  се користи за затварање бафера.

| weechat | [[hook_signal_buffer_user_closing_xxx]] buffer_user_closing_xxx ^(2)^ | 3.8
| -
| Корсинички бафер се затвара (шаље се само за бафере креиране са `/buffer add`).

| weechat | [[hook_signal_cursor_start]] cursor_start | 3.2
| - |
Почетак режима померања курсора.

| weechat | [[hook_signal_cursor_end]] cursor_end | 3.2
| - |
Крај режима померања курсора.

| weechat | [[hook_signal_day_changed]] day_changed | 0.3.2
| Стринг: нови датум, формат је: "2010-01-31".
| Променио се системски датум.

| weechat | [[hook_signal_debug_dump]] debug_dump |
| Стринг: име додатка.
| Захтев за испис.

| weechat | [[hook_signal_debug_libs]] debug_libs |
| - |
Приказује спољне библиотеке које се користе.

| weechat | [[hook_signal_filter_added]] filter_added |
| Показивач: филтер.
| Додат је филтер.

| weechat | [[hook_signal_filter_removing]] filter_removing |
| Показивач: филтер.
| Уклањање филтера.

| weechat | [[hook_signal_filter_removed]] filter_removed |
| - |
Филтер је уклоњен.

| weechat | [[hook_signal_filters_enabled]] filters_enabled |
| - |
Укључени су филтери.

| weechat | [[hook_signal_filters_disabled]] filters_disabled |
| - |
Искључени су филтери.

| weechat | [[hook_signal_hotlist_changed]] hotlist_changed |
| Показивач: бафер (може да буде NULL).
| Променила се врућа листа.

| weechat | [[hook_signal_input_paste_pending]] input_paste_pending |
| - |
Чека се на налепљивање.

| weechat | [[hook_signal_input_search]] input_search |
| Показивач: бафер.
| Претрага текста у баферу.

| weechat | [[hook_signal_input_prompt_changed]] input_prompt_changed | 4.3.0
| Показивач: бафер.
| Промењено је питање уноса.

| weechat | [[hook_signal_input_text_changed]] input_text_changed |
| Показивач: бафер.
| Променио се текст уноса.

| weechat | [[hook_signal_input_text_cursor_moved]] input_text_cursor_moved |
| Показивач: бафер.
| Померио се курсор текста уноса.

| weechat | [[hook_signal_key_bind]] key_bind |
| Стринг: тастер.
| Додата је пречица.

| weechat | [[hook_signal_key_unbind]] key_unbind |
| Стринг: тастер.
| Уклоњена је пречица.

| weechat | [[hook_signal_key_pressed]] key_pressed |
| Стринг: притиснути тастер.
| Притиснут је тастер.

| weechat | [[hook_signal_key_combo_default]] key_combo_default | 1.0
| Стринг: комбинација тастера.
| Комбинација тастера у _default_ контексту.

| weechat | [[hook_signal_key_combo_search]] key_combo_search | 1.0
| Стринг: комбинација тастера.
| Комбинација тастера у _search_ контексту.

| weechat | [[hook_signal_key_combo_cursor]] key_combo_cursor | 1.0
| Стринг: комбинација тастера.
| Комбинација тастера у _cursor_ контексту.

| weechat | [[hook_signal_layout_buffers_applied]] layout_buffers_applied | 4.4.0
| Стринг: име распореда.
| Распоред који се примењује за бафере.

| weechat | [[hook_signal_layout_windows_applied]] layout_windows_applied | 4.4.0
| Стринг: име распореда.
| Распоред који се примењује за прозоре.

| weechat | [[hook_signal_mouse_enabled]] mouse_enabled | 1.1
| - |
Укључен је миш.

| weechat | [[hook_signal_mouse_disabled]] mouse_disabled | 1.1
| - |
Искључен је миш.

| weechat | [[hook_signal_nicklist_group_added]] nicklist_group_added | 0.3.2
| Стринг: показивач на бафер + „,” + име групе.
| У листу надимака је додата група.

| weechat | [[hook_signal_nicklist_group_changed]] nicklist_group_changed | 0.3.4
| Стринг: показивач на бафер + „,” + име групе.
| У листи надимака је измењена група.

| weechat | [[hook_signal_nicklist_group_removing]] nicklist_group_removing | 0.4.1
| Стринг: показивач на бафер + „,” + име надимка.
| Уклања се група из листе надимака.

| weechat | [[hook_signal_nicklist_group_removed]] nicklist_group_removed | 0.3.2
| Стринг: показивач на бафер + „,” + име надимка.
| Група је уклоњена из листе надимака.

| weechat | [[hook_signal_nicklist_nick_added]] nicklist_nick_added | 0.3.2
| Стринг: показивач на бафер + „,” + име надимка.
| Додат је надимак у листу надимака.

| weechat | [[hook_signal_nicklist_nick_changed]] nicklist_nick_changed | 0.3.4
| Стринг: показивач на бафер + „,” + име надимка.
| У листи надимака је промењен надимак.

| weechat | [[hook_signal_nicklist_nick_removing]] nicklist_nick_removing | 0.4.1
| Стринг: показивач на бафер + „,” + име надимка.
| Уклањање надимка из листе надимака.

| weechat | [[hook_signal_nicklist_nick_removed]] nicklist_nick_removed | 0.3.2
| Стринг: показивач на бафер + „,” + име надимка.
| Надимак је уклоњен из листе надимака.

| weechat | [[hook_signal_partial_completion]] partial_completion |
| - |
Догодило се делимично довршавање.

| weechat | [[hook_signal_plugin_loaded]] plugin_loaded | 0.3.9
| Стринг: путања до учитаног додатка.
| Учитан је додатак.

| weechat | [[hook_signal_plugin_unloaded]] plugin_unloaded | 0.3.9
| Стринг: име додатка који се уклања из меморије (пример: „irc”).
| Додатак је уклоњен из меморије.

| weechat | [[hook_signal_quit]] quit |
| Стринг: аргументи за /quit.
| Корисник је задао команду `/quit`.

| weechat | [[hook_signal_signal_sighup]] signal_sighup | 1.3
| - |
Примљен је сигнал SIGHUP.

| weechat | [[hook_signal_signal_sigquit]] signal_sigquit | 1.2
| - |
Примљен је сигнал SIGQUIT (захтев за излаз са core исписом).

| weechat | [[hook_signal_signal_sigterm]] signal_sigterm | 1.2
| - |
Примљен је сигнал SIGTERM (складно прекидање WeeChat процеса).

| weechat | [[hook_signal_signal_sigwinch]] signal_sigwinch | 0.4.3
| - |
Примљен је сигнал SIGWINCH (промењена је величина терминала).

| weechat | [[hook_signal_upgrade]] upgrade |
| Стринг: „quit” ако је уз /upgrade наведен аргумент „-quit”, „save”
  ако је уз /upgrade  наведен аргумент „-save”, у супротном NULL.
| Корисник је задао команду `/upgrade`.

| weechat | [[hook_signal_upgrade_ended]] upgrade_ended | 0.3.4
| - |
Завршетак процеса ажурирања (команда `/upgrade`).

| weechat | [[hook_signal_weechat_highlight]] weechat_highlight |
| Стринг: порука са префиксом.
| Догодило се истицање.

| weechat | [[hook_signal_weechat_pv]] weechat_pv |
| Стринг: порука са префиксом.
| Приказана је приватна порука.

| weechat | [[hook_signal_window_closing]] window_closing | 0.3.6
| Показивач: прозор.
| Затварање прозора.

| weechat | [[hook_signal_window_closed]] window_closed | 0.3.6
| Показивач: прозор.
| Прозор је затворен.

| weechat | [[hook_signal_window_opened]] window_opened | 0.4.1
| Показивач: прозор.
| Прозор је отворен.

| weechat | [[hook_signal_window_scrolled]] window_scrolled |
| Показивач: прозор.
| Скроловање у прозору.

| weechat | [[hook_signal_window_switch]] window_switch | 0.3.7
| Показивач: прозор.
| Прелазак на други прозор.

| weechat | [[hook_signal_window_zoom]] window_zoom |
| Показивач: текући прозор.
| Зумирање прозора.

| weechat | [[hook_signal_window_zoomed]] window_zoomed |
| Показивач: текући прозор.
| Прозор је зумиран.

| weechat | [[hook_signal_window_unzoom]] window_unzoom |
| Показивач: текући прозор.
| Одзумирање прозора.

| weechat | [[hook_signal_window_unzoomed]] window_unzoomed |
| Показивач: текући прозор.
| Прозор је одзумиран.

| xfer | [[hook_signal_xfer_add]] xfer_add |
| Показивач: инфолиста са xfer информацијама.
| Нови xfer.

| xfer | [[hook_signal_xfer_send_ready]] xfer_send_ready |
| Показивач: инфолиста са xfer информацијама.
| Xfer је спреман.

| xfer | [[hook_signal_xfer_accept_resume]] xfer_accept_resume |
| Показивач: инфолиста са xfer информацијама.
| Прихватање наставка xfer.

| xfer | [[hook_signal_xfer_send_accept_resume]] xfer_send_accept_resume |
| Показивач: инфолиста са xfer информацијама.
| Xfer је настављен.

| xfer | [[hook_signal_xfer_start_resume]] xfer_start_resume |
| Показивач: инфолиста са xfer информацијама.
| Почетак наставка.

| xfer | [[hook_signal_xfer_resume_ready]] xfer_resume_ready |
| Показивач: инфолиста са xfer информацијама.
| Xfer наставак је спреман.

| xfer | [[hook_signal_xfer_ended]] xfer_ended | 0.3.2
| Показивач: инфолиста са xfer информацијама.
| Xfer се завршио.
|===

[NOTE]
^(1)^ _xxx_ је име IRC сервера, _yyy_ је име IRC команде. +
^(2)^ _xxx_ је име бафера.

C пример:

[source,c]
----
int
my_signal_cb (const void *pointer, void *data, const char *signal,
              const char *type_data, void *signal_data)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* хвата сигнале „quit” и „upgrade” */
struct t_hook *my_signal_hook = weechat_hook_signal ("quit;upgrade",
                                                     &my_signal_cb, NULL, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def hook_signal(signal: str, callback: str, callback_data: str) -> str: ...

# пример
def my_signal_cb(data: str, signal: str, signal_data: str) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

# хвата сигнале „quit” и „upgrade”
hook = weechat.hook_signal("quit;upgrade", "my_signal_cb", "")
----

==== hook_signal_send

_Ажурирано у верзији 1.0, 4.5.0._

Шаље сигнал.

Прототип:

[source,c]
----
int weechat_hook_signal_send (const char *signal, const char *type_data,
                              void *signal_data);
----

Аргументи:

// TRANSLATION MISSING
* _signal_: сигнал који се шаље; flags are allowed before the signal name (see below)
  _(WeeChat ≥ 4.5.0)_
* _type_data_: тип података који се шаљу уз сигнал (погледајте <<_hook_signal,hook_signal>>)
* _signal_data_: подаци који се шаљу уз сигнал

// TRANSLATION MISSING
The signal name can contain flags with the following format: `[flags:xxx,yyy]signal`
where `xxx` and `yyy` are names of flags, and `signal` the signal name. +
The following flags are supported:

* _stop_on_error_: exit immediately if a callback returns WEECHAT_RC_ERROR
  (remaining callbacks are then NOT executed) _(WeeChat ≥ 4.5.0)_
* _ignore_eat_: consider any callback returning WEECHAT_RC_OK_EAT is in fact
  WEECHAT_RC_OK and execute remaining callbacks _(WeeChat ≥ 4.5.0)_

Повратна вредност _(WeeChat ≥ 1.0)_:

* повратни кôд последње извршене функције повратног позива (_WEECHAT_RC_OK_ ако ниједна функција повратног позива није била извршена):
** _WEECHAT_RC_OK_
** _WEECHAT_RC_OK_EAT_
** _WEECHAT_RC_ERROR_

C пример:

[source,c]
----
int rc = weechat_hook_signal_send ("my_signal", WEECHAT_HOOK_SIGNAL_STRING, my_string);
int rc2 = weechat_hook_signal_send ("[flags:stop_on_error,ignore_eat]my_signal2",
                                    WEECHAT_HOOK_SIGNAL_STRING, my_string);
----

Скрипта (Python):

[source,python]
----
# прототип
def hook_signal_send(signal: str, type_data: str, signal_data: str) -> int: ...

# примери
rc = weechat.hook_signal_send("my_signal", weechat.WEECHAT_HOOK_SIGNAL_STRING, my_string)
rc2 = weechat.hook_signal_send("[flags:stop_on_error,ignore_eat]my_signal2",
                               weechat.WEECHAT_HOOK_SIGNAL_STRING, my_string)
----

[[signal_logger_backlog]]
===== Сигнал logger_backlog

Сигнал „logger_backlog” може да се пошаље ако желите да се прикажу раније линије (историја разговора) из бафера (на пример, ако отворите сопствени бафер у вашем додатку/скрипти).

Аргумент је показивач на бафер.

C пример:

[source,c]
----
weechat_hook_signal_send ("logger_backlog", WEECHAT_HOOK_SIGNAL_POINTER, buffer);
----

Скрипта (Python):

[source,python]
----
weechat.hook_signal_send("logger_backlog", weechat.WEECHAT_HOOK_SIGNAL_POINTER, buffer)
----

[[signals_xxx_script_install]]
===== Сигнали xxx_script_install

За инсталацију скрипте може да се пошаље један од осам сигнала, у зависности од језика:

* _perl_script_install_
* _python_script_install_
* _ruby_script_install_
* _lua_script_install_
* _tcl_script_install_
* _guile_script_install_
* _javascript_script_install_
* _php_script_install_

Када прими сигнал, функција повратног позива ће одрадити следеће акције:

. Учитавање и уклањање из меморије инсталиране скрипте.
. Померање нове скрипте у директоријум _~/.local/share/weechat/xxx/_ (где је _xxx_ језик).
. Креирање линка на нову скрипту у директоријуму _~/.local/share/weechat/xxx/autoload/_ (само ако је скрипта веђ била аутоучитана, или ако је за нову скрипту укључена опција _script.scripts.autoload_).
. Учитавање нове скрипте (ако је скрипта била учитана).

Ове сигнале користи _script_ додатак приликом инсталације скрипти.

Аргумент је стринг са путањом до скрипте која се инсталира.

C пример:

[source,c]
----
weechat_hook_signal_send ("python_script_install", WEECHAT_HOOK_SIGNAL_STRING, "/путања/до/test.py");
----

Скрипта (Python):

[source,python]
----
weechat.hook_signal_send("python_script_install", WEECHAT_HOOK_SIGNAL_STRING, "/путања/до/test.py")
----

[[signals_xxx_script_remove]]
===== Сигнали xxx_script_remove

За уклањање листе скрипти може да се пошаље један од осам сигнала, у зависности од језика:

* _perl_script_remove_
* _python_script_remove_
* _ruby_script_remove_
* _lua_script_remove_
* _tcl_script_remove_
* _guile_script_remove_
* _javascript_script_remove_
* _php_script_remove_

За сваку скрипту из листе, функција повратног позива ће скрипту прво уклонити из меморије, па ће је затим обрисати

Додатак _script_ користи ове сигнале за уклањање скрипти.

Аргумент је стринг са листом скрипти за уклањање раздвојених запетама (скрипта је име без путање, на пример _script.py_).

C пример:

[source,c]
----
/* уклањање из меморије и брисање скрипти test.py и script.py */
weechat_hook_signal_send ("python_script_remove", WEECHAT_HOOK_SIGNAL_STRING,
                          "test.py,script.py");
----

Скрипта (Python):

[source,python]
----
# уклањање из меморије и брисање скрипти test.py и script.py
weechat.hook_signal_send("python_script_remove", WEECHAT_HOOK_SIGNAL_STRING,
                         "test.py,script.py")
----

[[signal_irc_input_send]]
===== Сигнал irc_input_send

_WeeChat ≥ 0.3.4, ажурирано у верзији 1.5._

Сигнал „irc_input_send” може да се пошаље да би се симулирао унос у irc бафер (сервера, канала или приватни).

Аргумент је стринг у следећем формату:

* интерно име сервера (обавезно)
* тачка зарез
* име канала (није обавезно)
* тачка зарез
* листа опција раздвојених запетама (није обавезна):
** _priority_high_: ред са високим приоритетом (као што су корисничке поруке); ово је подразумевани приоритет
** _priority_low_: ред са ниским приоритетом (као што су поруке које аутоматски шаље програм WeeChat)
** _user_message_: форсира корисничку поруку (не извршава команду)
* тачка зарез
* листа ознака које се користе када се шаље порука раздвојених запетама (није обавезна)
* тачка зарез
* текст или команда (обавезан)

C примери:

[source,c]
----
/* реци "Здраво!" на libera серверу, #weechat каналу */
weechat_hook_signal_send ("irc_input_send", WEECHAT_HOOK_SIGNAL_STRING,
                          "libera;#weechat;priority_high,user_message;;Здраво!");

/* шаље команду "/whois FlashCode" на libera сервер, са ниским приоритетом */
weechat_hook_signal_send ("irc_input_send", WEECHAT_HOOK_SIGNAL_STRING,
                          "libera;;priority_low;;/whois FlashCode");
----

Скрипта (Python):

[source,python]
----
# реци "Здраво!" на libera серверу, #weechat каналу
weechat.hook_signal_send("irc_input_send", weechat.WEECHAT_HOOK_SIGNAL_STRING,
                         "libera;#weechat;priority_high,user_message;;Здраво!")

# шаље команду "/whois FlashCode" на libera сервер, са ниским приоритетом
weechat.hook_signal_send("irc_input_send", weechat.WEECHAT_HOOK_SIGNAL_STRING,
                         "libera;;priority_low;;/whois FlashCode")
----

==== hook_hsignal

_WeeChat ≥ 0.3.4, ажурирано у верзији 1.5, 3.6._

Качи се на hsignal (сигнал са хеш табелом).

Прототип:

[source,c]
----
struct t_hook *weechat_hook_hsignal (const char *signal,
                                     int (*callback)(const void *pointer,
                                                     void *data,
                                                     const char *signal,
                                                     struct t_hashtable *hashtable),
                                     const void *callback_pointer,
                                     void *callback_data);
----

Аргументи:

* _signal_: сигнал који се хвата, дозвољава се џокер `+*+`, више сигнала може да се
  раздвоји двотачкама
  (испред једног или више сигнала се дозвољава приоритет, погледајте напомену у вези са <<hook_priority,приоритетима>>)
  (погледајте табелу испод)
* _callback_: функција која се позива када се прими сигнал, аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _const char *signal_: примљени сигнал
** _struct t_hashtable *hashtable_: хеш табела
** повратна вредност:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_OK_EAT_ (тренутно прекида слање сигнала) _(WeeChat ≥ 0.4.0)_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се кука обрише

Повратна вредност:

* показивач на нову куку, NULL у случају грешке

Листа hsignalа:

[width="100%", cols="^1,^3,^1,5,5", options="header"]
|===
| Додатак | Сигнал | Мин WeeChat | Аргументи | Опис

| irc | [[hook_hsignal_irc_redirection_xxx_yyy]] irc_redirection_xxx_yyy ^(1)^ | 0.3.4
| Погледајте <<hsignal_irc_redirect_command,hsignal_irc_redirect_command>>
| Преусмеравање излаза.

| weechat | [[hook_hsignal_nicklist_group_added]] nicklist_group_added | 0.4.1
| _buffer_ (_struct t_gui_buffer *_): бафер +
  _parent_group_ (_struct t_gui_nick_group *_): родитељ група +
  _group_ (_struct t_gui_nick_group *_): група
| У листу надимака је додата група.

| weechat | [[hook_hsignal_nicklist_nick_added]] nicklist_nick_added | 0.4.1
| _buffer_ (_struct t_gui_buffer *_): бафер +
  _parent_group_ (_struct t_gui_nick_group *_): родитељ група +
  _nick_ (_struct t_gui_nick *_): надимак
| Надимак је додат у листу надимака.

| weechat | [[hook_hsignal_nicklist_group_removing]] nicklist_group_removing | 0.4.1
| _buffer_ (_struct t_gui_buffer *_): бафер +
  _parent_group_ (_struct t_gui_nick_group *_): родитељ група +
  _group_ (_struct t_gui_nick_group *_): група
| Уклањање групе из листе надимака.

| weechat | [[hook_hsignal_nicklist_nick_removing]] nicklist_nick_removing | 0.4.1
| _buffer_ (_struct t_gui_buffer *_): бафер +
  _parent_group_ (_struct t_gui_nick_group *_): родитељ група +
  _nick_ (_struct t_gui_nick *_): надимак
| Уклањање надимка из листе надимака.

| weechat | [[hook_hsignal_nicklist_group_changed]] nicklist_group_changed | 0.4.1
| _buffer_ (_struct t_gui_buffer *_): бафер +
  _parent_group_ (_struct t_gui_nick_group *_): родитељ група +
  _group_ (_struct t_gui_nick_group *_): група
| У листи надимака је измењена група.

| weechat | [[hook_hsignal_nicklist_nick_changed]] nicklist_nick_changed | 0.4.1
| _buffer_ (_struct t_gui_buffer *_): бафер +
  _parent_group_ (_struct t_gui_nick_group *_): родитељ група +
  _nick_ (_struct t_gui_nick *_): надимак
| Надимак је промењен у листи надимака.
|===

[NOTE]
^(1)^ _xxx_ је аргумент сигнала који се користи у преусмеравању, _yyy_ је шаблон преусмеравања.

C пример:

[source,c]
----
int
my_hsignal_cb (const void *pointer, void *data, const char *signal,
               struct t_hashtable *hashtable)
{
    /* ... */
    return WEECHAT_RC_OK;
}

struct t_hook *my_hsignal_hook = weechat_hook_hsignal ("test",
                                                       &my_hsignal_cb, NULL, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def hook_hsignal(signal: str, callback: str, callback_data: str) -> str: ...

# пример
def my_hsignal_cb(data: str, signal: str, hashtable: Dict[str, str]) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_hsignal("test", "my_hsignal_cb", "")
----

==== hook_hsignal_send

_WeeChat ≥ 0.3.4, ажурирано у верзији 1.0, 4.5.0._

Шаље hsignal (сигнал са хеш табелом).

Прототип:

[source,c]
----
int weechat_hook_hsignal_send (const char *signal, struct t_hashtable *hashtable);
----

Аргументи:

// TRANSLATION MISSING
* _signal_: сигнал који се шаље; flags are allowed before the signal name
  (see function <<_hook_signal_send,hook_signal_send>>) _(WeeChat ≥ 4.5.0)_
* _hashtable_: хеш табела

Повратна вредност _(WeeChat ≥ 1.0)_:

* повратни кôд последње извршене функције повратног позива (_WEECHAT_RC_OK_ ако ниједна функција повратног позива није била извршена):
** _WEECHAT_RC_OK_
** _WEECHAT_RC_OK_EAT_
** _WEECHAT_RC_ERROR_

C пример:

[source,c]
----
int rc, rc2;
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
if (hashtable)
{
    weechat_hashtable_set (hashtable, "key", "value");
    rc = weechat_hook_hsignal_send ("my_hsignal", hashtable);
    rc2 = weechat_hook_hsignal_send ("[flags:stop_on_error,ignore_eat]my_hsignal2", hashtable);
    weechat_hashtable_free (hashtable);
}
----

Скрипта (Python):

[source,python]
----
# прототип
def hook_hsignal_send(signal: str, hashtable: Dict[str, str]) -> int: ...

# примери
rc = weechat.hook_hsignal_send("my_hsignal", {"key": "value"})
rc2 = weechat.hook_hsignal_send("[flags:stop_on_error,ignore_eat]my_hsignal2", {"key": "value"})
----

[[hsignal_irc_redirect_command]]
===== Hsignal irc_redirect_command

_WeeChat ≥ 0.3.4._

„irc_redirect_command” hsignal се шаље када желите да излаз irc команде преусмерите у функцију повратног позива.

Аргумент је хеш табела са следећим ставкама (кључеви и вредности су стрингови):

* _server_: интерно име сервера (обавезно)
* _pattern_: шаблон за преусмеравање који треба да се користи (обавезан), или подразумевани (који дефинише irc додатак), или кориснички шаблон (погледајте <<hsignal_irc_redirect_pattern>>), подразумевани шаблони су:
** _ison_
** _list_
** _mode_channel_
** _mode_channel_ban_ ("mode #channel b")
** _mode_channel_ban_exception_ ("mode #channel e")
** _mode_channel_invite_ ("mode #channel I")
** _mode_user_
** _monitor_
** _names_
** _ping_
** _time_
** _topic_
** _userhost_
** _who_
** _whois_
** _whowas_
* _signal_: име сигнала (обавезно)
* _count_: колико пута ће преусмеравање радити (није обавезно, подразумевано је 1)
* _string_: стринг који мора бити у примљеној irc поруци (није обавезно, али се препоручује, ако поруке могу да се идентификују стрингом)
* _timeout_: тајмаут за преусмеравање, у секундама (није обавезан, подразумевано је 60)
* _cmd_filter_: листа irc команди које се филтирају, раздвојене запетама (само ове команде ће се слати функцијама повратног позива, остале ће се игнорисати) (није обавезно)

Чим пошаљете овај hsignal, морате послати команду irc серверу и преусмеравање ће се употребити за ту команду.

Када се прими комплетан одговор на вашу команду, послаће се hsignal. Овај hsignal има име _irc_redirection_xxx_yyy_ где је _xxx_ _signal_, а_yyy_ употребљени _pattern_.

Хеш табела која се шаље у hsignal има следећи садржај (кључеви и вредности су стрингови):

* _output_: излаз команде (поруке се раздвајају са „\n”)
* _output_size_: број бајтова у _output_ (као стринг)
* _error_: стринг грешке (у случају да је дошло до грешке):
** _timeout_: преусмеравање је прекинуто након истека тајмаута
* _server_: интерно име сервера
* _pattern_: шаблон преусмеравања
* _signal_: име сигнала
* _command_: преусмерена команда

C пример:

[source,c]
----
int
test_whois_cb (const void *pointer, void *data, const char *signal,
               struct t_hashtable *hashtable)
{
    weechat_printf (NULL, "error = %s", weechat_hashtable_get (hashtable, "error"));
    weechat_printf (NULL, "output = %s", weechat_hashtable_get (hashtable, "output"));
    return WEECHAT_RC_OK;
}

weechat_hook_hsignal ("irc_redirection_test_whois", &test_whois_cb, NULL, NULL);
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
if (hashtable)
{
    weechat_hashtable_set (hashtable, "server", "libera");
    weechat_hashtable_set (hashtable, "pattern", "whois");
    weechat_hashtable_set (hashtable, "signal", "test");
    weechat_hashtable_set (hashtable, "string", "FlashCode");
    weechat_hook_hsignal_send ("irc_redirect_command", hashtable);
    weechat_hook_signal_send ("irc_input_send", WEECHAT_HOOK_SIGNAL_STRING,
                              "libera;;2;;/whois FlashCode");
    weechat_hashtable_free (hashtable);
}
----

Скрипта (Python):

[source,python]
----
def test_whois_cb(data: str, signal: str, hashtable: Dict[str, str]) -> int:
    weechat.prnt("", "error = %s" % hashtable["error"])
    weechat.prnt("", "output = %s" % hashtable["output"])
    return weechat.WEECHAT_RC_OK

weechat.hook_hsignal("irc_redirection_test_whois", "test_whois_cb", "")
weechat.hook_hsignal_send("irc_redirect_command",
                          {"server": "libera", "pattern": "whois", "signal": "test",
                           "string": "FlashCode"})
weechat.hook_signal_send("irc_input_send", weechat.WEECHAT_HOOK_SIGNAL_STRING,
                         "libera;;2;;/whois FlashCode")
----

[[hsignal_irc_redirect_pattern]]
===== Hsignal irc_redirect_pattern

_WeeChat ≥ 0.3.4._

Hsignal „irc_redirect_pattern” може да се пошаље када желите да креирате шаблон за irc преусмеравање (погледајте <<hsignal_irc_redirect_command>>).

Аргумент је хеш табела са следећим ставкама (кључеви и вредности су стрингови):

* _pattern_: име шаблона (обавезно)
* _timeout_: подразумевани тајмаут за шаблон, у секундама (није обавезан, подразумевано је 60)
* _cmd_start_: листа команди које покрећу преусмеравање раздвојених запетама (није обавезна)
* _cmd_stop_: листа команди које заустављају преусмеравање раздвојених запетама (обавезна)
* _cmd_extra_: листа команди које могу да се приме након команди заустављања раздвојених запетама (није обавезна)

За сваку команду у _cmd_start_, _cmd_stop_ и _cmd_extra_ може да се зада цео број са позицијом „стринга” који мора да се нађе у примљеној поруци, на пример:

----
352:1,354,401:1
----

За команде 352 и 401, „string” мора да се пронађе у примљеној поруци као први аргумент.

[IMPORTANT]
Када се употреби за преусмеравање, шаблон се уништава. Ако вам је потребан шаблон за више преусмеравања, морате да га креирате пре сваког преусмеравања.

C пример:

[source,c]
----
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
if (hashtable)
{
    weechat_hashtable_set (hashtable, "pattern", "my_whois");
    weechat_hashtable_set (hashtable, "timeout", "30");
    weechat_hashtable_set (hashtable, "cmd_start", "311:1");
    weechat_hashtable_set (hashtable, "cmd_stop", "318:1,401:1,402:1,431:1,461");
    weechat_hashtable_set (hashtable, "cmd_extra", "318:1");
    weechat_hook_hsignal_send ("irc_redirect_pattern", hashtable);
    /*
     * now redirect irc whois command with hsignal irc_redirect_command,
     * using pattern "my_whois"
     */
    /* ... */
    weechat_hashtable_free (hashtable);
}
----

Скрипта (Python):

[source,python]
----
weechat.hook_hsignal_send("irc_redirect_pattern",
                          {"pattern": "my_whois", "timeout": "30",
                           "cmd_start": "311:1",
                           "cmd_stop": "318:1,401:1,402:1,431:1,461",
                           "cmd_extra": "318:1"})
# сада преусмерите irc whois команду са hsignal irc_redirect_command
# користећи шаблон "my_whois"
# ...
----

==== hook_config

_Ажурирано у верзији 1.5._

Качи се на опцију конфигурације.

Прототип:

[source,c]
----
struct t_hook *weechat_hook_config (const char *option,
                                    int (*callback)(const void *pointer,
                                                    void *data,
                                                    const char *option,
                                                    const char *value),
                                    const void *callback_pointer,
                                    void *callback_data);
----

Аргументи:

* _option_: опција, формат је пуно име, као што се користи у команди `/set` на пример: `+weechat.look.item_time_format+`), дозвољава се џокер `+*+` (испред опције се дозвољава приоритет, погледајте напомену у вези са <<hook_priority,приоритетима>>)
* _callback_: функција која се позива када се измени опција конфигурације, аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _const char *option_: име опције
** _const char *value_: нова вредност опције
** повратна вредност:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се кука обрише

Повратна вредност:

* показивач на нову куку, NULL у случају грешке

C пример:

[source,c]
----
int
my_config_cb (const void *pointer, void *data, const char *option,
              const char *value)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* хвата измене опције „weechat.look.item_time_format” */
struct t_hook *my_config_hook = weechat_hook_config ("weechat.look.item_time_format",
                                                     &my_config_cb, NULL, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def hook_config(option: str, callback: str, callback_data: str) -> str: ...

# пример
def my_config_cb(data: str, option: str, value: str) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

# хвата измене опције „weechat.look.item_time_format”
hook = weechat.hook_config("weechat.look.item_time_format", "my_config_cb", "")
----

==== hook_modifier

_Ажурирано у верзији 1.5._

Качи се на модификатор.

Прототип:

[source,c]
----
struct t_hook *weechat_hook_modifier (const char *modifier,
                                      char *(*callback)(const void *pointer,
                                                        void *data,
                                                        const char *modifier,
                                                        const char *modifier_data,
                                                        const char *string),
                                      const void *callback_pointer,
                                      void *callback_data);
----

Аргументи:

* _modifier_: modifier name (испред модификатора се дозвољава приоритет, погледајте напомену у вези са <<hook_priority,приоритетима>>)
  (погледајте табелу испод)
* _callback_: функција која се позива када се употреби модификатор, аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _const char *modifier_: име модификатора
** _const char *modifier_data_: подаци за модификатор
** _const char *string_: стринг који се модификује
** return value: нови стринг
* _callback_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се кука обрише

Повратна вредност:

* показивач на нову куку, NULL у случају грешке

Листа модификатора које користе програм WeeChat и додаци:

[width="100%", cols="^2,^1,3,4,4", options="header"]
|===
| Модификатор | Мин WeeChat | Подаци модификатора | Стринг | Излаз

| [[hook_modifier_irc_batch]] irc_batch | 4.0.0
| Име сервера + "," + тип пакета + "," + параметри пакета
| Садржај више порука, раздвојен карактером новог реда („\n”).
| Нов садржај порука (број може да се разликује), празан стринг одбацује
  све поруке у пакету.

| [[hook_modifier_irc_cap_sync_req]] irc_cap_sync_req | 4.0.0
| Име сервера + "," + подржане могућности сервера (раздвојене размацима)
| Могућности које се захтевају (раздвојене размацима).
| Нов садржај могућности које се захтевају (раздвојен размацима).

| [[hook_modifier_irc_in_xxx]] irc_in_xxx ^(1)^ |
| Име сервера
| Садржај поруке примљене са IRC сервера (пре декодирања скупа карактера). +
  *Упозорење:* стринг може да садржи неважеће UTF-8 податке; користите га само
  за сирове операције над поруком.
  Уместо њега се препоручује употреба <<hook_modifier_irc_in2_xxx,irc_in2_xxx>>.
| Нови садржај поруке.

| [[hook_modifier_irc_in2_xxx]] irc_in2_xxx ^(1)^ | 0.3.5
| Име сервера
| Садржај поруке примљене са IRC сервера (након декодирања скупа карактера).
| Нови садржај поруке.

| [[hook_modifier_irc_out1_xxx]] irc_out1_xxx ^(1)^ | 0.3.7
| Име сервера
| Садржај поруке које треба да се пошаље IRC серверу пре аутоматске поделе
  (да стане у 512 подразумевано).
| Нови садржај поруке.

| [[hook_modifier_irc_out_xxx]] irc_out_xxx ^(1)^ |
| Име сервера
| Садржај поруке које треба да се пошаље IRC серверу након аутоматске поделе
  (да стане у 512 подразумевано).
| Нови садржај поруке.

| [[hook_modifier_relay_client_irc_in]] relay_client_irc_in | 4.0.0
| Стринг са показивачем на релеј клијента (нпр. "0x1234abcd")
| Садржај поруке примљене од релеј IRC клијента.
| Нови садржај поруке.

| [[hook_modifier_relay_client_irc_out1]] relay_client_irc_out1 | 4.0.0
| Стринг са показивачем на релеј клијента (нпр. "0x1234abcd")
| Садржај поруке која треба да се пошаље релеј IRC клијенту пре аутоматске поделе
  (тако да стане у подразумевано 512 бајтова).
| Нови садржај поруке.

| [[hook_modifier_relay_client_irc_out]] relay_client_irc_out | 4.0.0
| Стринг са показивачем на релеј клијента (нпр. "0x1234abcd")
| Садржај поруке која треба да се пошаље релеј IRC клијенту након аутоматске поделе
  (тако да стане у подразумевано 512 бајтова).
| Нови садржај поруке.

| [[hook_modifier_bar_condition_yyy]] bar_condition_yyy ^(2)^ |
| Стринг са показивачем на прозор (нпр: "0x1234abcd")
| Празан стринг.
| "1" да се прикаже трака, "0" да се сакрије.

| [[hook_modifier_history_add]] history_add | 0.3.2
| Стринг са показивачем на бафер (нпр: "0x1234abcd")
| Садржај командне линије која треба да се дода у историју команди (бафера и глобалну).
| Стринг који се додаје у историју команди.

| [[hook_modifier_input_text_content]] input_text_content |
| Стринг са показивачем на бафер (нпр: "0x1234abcd")
| Садржај командне линије.
| Нови садржај командне линије.

| [[hook_modifier_input_text_display]] input_text_display |
| Стринг са показивачем на бафер (нпр: "0x1234abcd")
| Садржај командне линије, без ознаке курсора.
| Нови стринг, само за приказ (командна линија се не мења).

| [[hook_modifier_input_text_display_with_cursor]] input_text_display_with_cursor |
| Стринг са показивачем на бафер (нпр: "0x1234abcd")
| Садржај командне линије, са ознаком курсора.
| Нови стринг, само за приказ (командна линија се не мења).

| [[hook_modifier_input_text_for_buffer]] input_text_for_buffer | 0.3.7
| Стринг са показивачем на бафер (нпр: "0x1234abcd")
| Садржај командне линије која се шаље у бафер (текст или команда).
| Нови садржај командне линије који се шаље у бафер.

| [[hook_modifier_weechat_print]] weechat_print |
| показивач на бафер (нпр: "0x1234abcd") + ";" + ознаке ^(3)^
| Порука која се исписује.
| Нова порука која се исписује. +
  За више информација о кукама које се позивају када се линија исписује,
  погледајте <<_hook_line,hook_line>>.
|===

[NOTE]
^(1)^ _xxx_ је име IRC команде. +
^(2)^ _yyy_ је име траке. +
^(3)^ У верзијама програма WeeChat ≤ 2.8, формат је био: додатак + ";" + buffer_name + ";" + ознаке.

C пример:

[source,c]
----
char *
my_modifier_cb (const void *pointer, void *data, const char *modifier,
                const char *modifier_data,
                const char *string)
{
    char *result;
    int length;

    if (!string)
        return NULL;

    length = strlen (string) + 5;
    result = malloc (length);
    if (result)
    {
        /* додаје „xxx” у било коју поруку која се исписује */
        snprintf (result, length, "%s xxx", string);
    }

    return result;
}

struct t_hook *my_modifier_hook = weechat_hook_modifier ("weechat_print",
                                                         &my_modifier_cb, NULL, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def hook_modifier(modifier: str, callback: str, callback_data: str) -> str: ...

# пример
def my_modifier_cb(data: str, modifier: str, modifier_data: str, string: str) -> str:
    return "%s xxx" % string

hook = weechat.hook_modifier("weechat_print", "my_modifier_cb", "")
----

==== hook_modifier_exec

Извршава модификатор(е)

Прототип:

[source,c]
----
char *weechat_hook_modifier_exec (const char *modifier,
                                  const char *modifier_data,
                                  const char *string);
----

Аргументи:

* _modifier_: име модификатора
* _modifier_data_: подаци модификатора
* _string_: стринг који треба да се измени

Повратна вредност:

* измењени стринг, NULL у случају грешке

Листа модификатора за употребу које дефинишу програм WeeChat и додаци:

[width="100%", cols="^2,^1,3,4,4", options="header"]
|===
| Модификатор | Мин WeeChat | Подаци модификатора | Стринг | Излаз

| [[hook_modifier_charset_decode]] charset_decode |
| plugin.buffer_name
| Било који стринг.
| Стринг декодиран из скупа карактера пронађеног за додатак/бафер у UTF-8.

| [[hook_modifier_charset_encode]] charset_encode |
| plugin.buffer_name
| Било који стринг.
| Стринг кодиран из UTF-8 у скуп карактера пронађен за додатак/бафер.

| [[hook_modifier_irc_color_decode]] irc_color_decode |
| "1" да се боје задрже, "0" да се боје уклоне
| Било који стринг.
| Стринг у којем су IRC боје конвертоване у WeeChat боје (или су уклоњене IRC боје).

| [[hook_modifier_irc_color_encode]] irc_color_encode |
| "1" да се боје задрже, "0" да се боје уклоне
| Било који стринг.
| Стринг са IRC бојама (или са уклоњеним IRC бојама).

| [[hook_modifier_irc_color_decode_ansi]] irc_color_decode_ansi | 1.0
| "1" да се боје задрже, "0" да се боје уклоне
| Било који стринг.
| Стринг у којем су ANSI боје конвертоване у IRC боје (или су уклоњене ANSI боје).

| [[hook_modifier_irc_command_auth]] irc_command_auth | 0.4.1
| Име сервера
| Команда аутентификације (на пример: `+/msg nickserv identify лозинка+`).
| Команда са скривеном лозинком (на пример: `+/msg nickserv identify ********+`).

| [[hook_modifier_irc_message_auth]] irc_message_auth | 0.4.1
| Име сервера
| Порука која се приказује након што се `/msg` пошаље nickserv боту.
| Порука са скривеном лозинком.

| [[hook_modifier_irc_tag_escape_value]] irc_tag_escape_value | 3.3
| -
| Било који стринг.
| Стринг са означеном вредности IRC ознаке,
  погледајте https://ircv3.net/specs/extensions/message-tags#escaping-values[ову страницу ^↗^^].

| [[hook_modifier_irc_tag_unescape_value]] irc_tag_unescape_value | 3.3
| -
| Било који стринг.
| Стринг са неозначеном вредности IRC ознаке,
  погледајте https://ircv3.net/specs/extensions/message-tags#escaping-values[ову страницу ^↗^^].

| [[hook_modifier_color_decode]] color_decode | 4.3.0
| Стринг замене за уклоњене боје
| Било који стринг.
| Стринг са WeeChat бојама се претвара у стринг замене
  (боје се уклањају ако је стринг замене празан).

| [[hook_modifier_color_decode_ansi]] color_decode_ansi | 1.0
| "1" да се боје задрже, "0" да се боје уклоне
| Било који стринг.
| Стринг у којем су ANSI боје конвертоване у WeeChat боје (или су уклоњене WeeChat боје).

| [[hook_modifier_color_encode_ansi]] color_encode_ansi | 2.7
| - |
Било који стринг. |
Стринг са WeeChat бојама конвертованим у ANSI боје.

| [[hook_modifier_eval_path_home]] eval_path_home | 2.7
| Није обавезно: `directory=xxx` где `xxx` може бити: `config`, `data`, `cache`, `runtime`
| Било који стринг.
| Израчуната путања, резултат функције
  <<_string_eval_path_home,string_eval_path_home>>.
|===

C пример:

[source,c]
----
char *new_string = weechat_hook_modifier_exec ("my_modifier",
                                               my_data, my_string);
----

Скрипта (Python):

[source,python]
----
# прототип
def hook_modifier_exec(modifier: str, modifier_data: str, string: str) -> str: ...

# пример
weechat.hook_modifier_exec("my_modifier", my_data, my_string)
----

==== hook_info

_Ажурирано у верзијама 1.5, 2.5._

Качи се на информацију (функција поратног позива узима и враћа стринг).

Прототип:

[source,c]
----
struct t_hook *weechat_hook_info (const char *info_name,
                                  const char *description,
                                  const char *args_description,
                                  char *(*callback)(const void *pointer,
                                                    void *data,
                                                    const char *info_name,
                                                    const char *arguments),
                                  const void *callback_pointer,
                                  void *callback_data);
----

Аргументи:

* _info_name_: име инфо (пре имена инфо се дозвољава приоритет, погледајте напомену у вези са <<hook_priority,приоритетима>>)
* _description_: опис
* _args_description_: опис аргумената (није обавезан, може да буде NULL)
* _callback_: функција која се позива када се затражи инфо, аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _const char *info_name_: име инфо
** _const char *arguments_: додатни аргументи, у зависности од инфо
** return value: вредност тражене инфо
* _callback_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се кука обрише

Повратна вредност:

* показивач на нову куку, NULL у случају грешке

[NOTE]
У програму WeeChat ≥ 2.5, функција повратног позива враћа алоцирани стринг (у WeeChat ≤ 2.4 је то био показивач на статички стринг).

C пример:

[source,c]
----
char *
my_info_cb (const void *pointer, void *data, const char *info_name,
            const char *arguments)
{
    /* ... */
    return strdup ("some_info");
}

/* додаје инфо „my_info” */
struct t_hook *my_info_hook = weechat_hook_info ("my_info",
                                                 "Нека инфо",
                                                 "Инфо о аргументима",
                                                 &my_info_cb, NULL, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def hook_info(info_name: str, description: str, args_description: str,
              callback: str, callback_data: str) -> str: ...

# пример
def my_info_cb(data: str, info_name: str, arguments: str) -> str:
    return „some_info”

hook = weechat.hook_info("my_info", "Нека инфо", "Инфо о аргументима",
                         "my_info_cb", "")
----

==== hook_info_hashtable

_WeeChat ≥ 0.3.4, ажурирано у верзији 1.5._

Качи се на информацију (функција повратног позива узима и враћа хеш табелу).

Прототип:

[source,c]
----
struct t_hook *weechat_hook_info_hashtable (const char *info_name,
                                            const char *description,
                                            const char *args_description,
                                            const char *output_description,
                                            struct t_hashtable *(*callback)(const void *pointer,
                                                                            void *data,
                                                                            const char *info_name,
                                                                            struct t_hashtable *hashtable),
                                            const void *callback_pointer,
                                            void *callback_data);
----

Аргументи:

* _info_name_: име инфо (пре имена инфо се дозвољава приоритет, погледајте напомену у вези са <<hook_priority,приоритетима>>)
* _description_: опис
* _args_description_: опис очекиване хеш табеле (није обавезан, може да буде NULL)
* _output_description_: опис хеш табеле коју враћа функција повратног позива (није обавезно, може да буде NULL)
* _callback_: функција која се позива када се затражи инфо, аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _const char *info_name_: име инфо
** _struct t_hashtable *hashtable_: хеш табела, зависно од информација
** повратна вредност: тражена хеш табела
* _callback_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се кука обрише

Повратна вредност:

* показивач на нову куку, NULL у случају грешке

C пример:

[source,c]
----
struct t_hashtable *
my_info_hashtable_cb (const void *pointer, void *data, const char *info_name,
                      struct t_hashtable *hashtable)
{
    /* ... */
    return pointer_to_new_hashtable;
}

/* додаје инфо "my_info_hashtable" */
struct t_hook *my_info_hook = weechat_hook_info_hashtable ("my_info_hashtable",
                                                           "Нека инфо",
                                                           "Инфо о улазној хеш табели",
                                                           "Инфо о излазној хеш табели",
                                                           &my_info_hashtable_cb, NULL, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def hook_info_hashtable(info_name: str, description: str, args_description: str,
                        output_description: str, callback: str, callback_data: str) -> str: ...

# пример
def my_info_hashtable_cb(data: str, info_name: str, hashtable: Dict[str, str]) -> Dict[str, str]:
    return {"test_key": "test_value"}

hook = weechat.hook_info_hashtable("my_info_hashtable", "Нека инфо",
                                   "Инфо о улазној хеш табели",
                                   "Инфо о излазној хеш табели",
                                   "my_info_hashtable_cb", "")
----

==== hook_infolist

_Ажурирано у верзији 1.5._

Качи се на инфолисту: функција повратног позива ће вратити показивач на тражену инфолисту.

Прототип:

[source,c]
----
struct t_hook *weechat_hook_infolist (const char *infolist_name,
                                      const char *description,
                                      const char *pointer_description,
                                      const char *args_description,
                                      struct t_infolist *(*callback)(const void *pointer,
                                                                     void *data,
                                                                     const char *infolist_name,
                                                                     void *obj_pointer,
                                                                     const char *arguments),
                                      const void *callback_pointer,
                                      void *callback_data);
----

Аргументи:

* _infolist_name_: име инфолисте (пре имена инфолисте се дозвољава приоритет, погледајте напомену у вези са <<hook_priority,приоритетима>>)
* _description_: опис
* _pointer_description_: опис показивача (није обавезно, може да буде NULL)
* _args_description_: опис аргумената (није обавезан, може да буде NULL)
* _callback_: функција која се позива када се затражи инфолиста, аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _const char *infolist_name_: име инфолисте
** _void *pointer_: показивач на објекат који инфолиста мора да врати (да би се добила само једна ставка у инфолисти)
** _const char *arguments_: додатни аргументи, зависно од инфолисте
** повратна вредност: тражена инфолиста
* _callback_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се кука обрише

Повратна вредност:

* показивач на нову куку, NULL у случају грешке

C пример:

[source,c]
----
struct t_infolist *
my_infolist_cb (const void *pointer, void *data, const char *infolist_name,
                void *obj_pointer, const char *arguments)
{
    struct t_infolist *my_infolist;

    /* изградња инфолисте */
    /* ... */

    return my_infolist;
}

/* додаје инфолисту "my_infolist" */
struct t_hook *my_infolist = weechat_hook_infolist ("my_infolist",
                                                    "Инфолиста са неким подацима",
                                                    "Инфо о показивачу",
                                                    "Инфо о аргументима",
                                                    &my_infolist_cb, NULL, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def hook_infolist(infolist_name: str, description: str, pointer_description: str,
                  args_description: str, callback: str, callback_data: str) -> str: ...

# пример
def my_infolist_cb(data: str, infolist_name: str, pointer: str, arguments: str) -> str:
    # изградња инфолисте
    # ...
    return my_infolist

hook = weechat.hook_infolist("my_infolist", "Инфолиста са неким подацима",
                             "Инфо о показивачу", "Инфо о аргументима",
                             "my_infolist_cb", "")
----

==== hook_hdata

_Ажурирано у верзији 1.5._

Качи се на hdata: функција повратног позива ће вратити показивач на тражени.

Прототип:

[source,c]
----
struct t_hook *weechat_hook_hdata (const char *hdata_name,
                                   const char *description,
                                   struct t_hdata *(*callback)(const void *pointer,
                                                               void *data,
                                                               const char *hdata_name),
                                   const void *callback_pointer,
                                   void *callback_data);
----

Аргументи:

* _hdata_name_: име hdata (испред имена hdata се дозвољава приоритет, погледајте напомену у вези са <<hook_priority,приоритетима>>)
* _description_: опис
* _callback_: функција која се позива када се затражи hdata, аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _const char *hdata_name_: име hdata
** повратна вредност: тражени hdata
* _callback_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се кука обрише

Повратна вредност:

* показивач на нову куку, NULL у случају грешке

C пример:

[source,c]
----
struct t_hdata *
my_hdata_cb (const void *pointer, void *data, const char *hdata_name)
{
    struct t_hdata *my_hdata;

    /* изградња hdata */
    /* ... */

    return my_hdata;
}

/* додаје hdata "my_hdata" */
struct t_hook *my_hdata = weechat_hook_hdata ("my_hdata",
                                              "Hdata за моју структуру",
                                              &my_hdata_cb, NULL, NULL);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== hook_focus

_Ажурирано у верзији 1.5, 4.0.0, 4.1.0._

Качи се на фокус: догађај миша или тастер притиснут у режиму померања курсора.

Прототип:

[source,c]
----
struct t_hook *weechat_hook_focus (const char *area,
                                   struct t_hashtable *(*callback)(const void *pointer,
                                                                   void *data,
                                                                   struct t_hashtable *info),
                                   const void *callback_pointer,
                                   void *callback_data);
----

Аргументи:

* _area_: „chat” за површину чета (разговора), или име ставке траке (испред површине се дозвољава приоритет, погледајте напомену у вези са <<hook_priority,приоритетима>>)
* _callback_: функција која се позива када се направи фокус, аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _struct t_hashtable *info_: хеш табела са инфо о фокусу у стрингови које су вратили остали позиви фокус функција повратног позива (са вишим приоритетом) (погледате табелу испод)
** повратна вредност: или показивач на „info” (завршену хеш табелу), или показивач на нову хеш табелу (коју је креирала функција повратног позива, са кључевима и вредностима типа „стринг”), садржај ове нове хеш табеле ће се додати у _info_ за остале позиве фокус функције повратног позива
* _callback_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се кука обрише

[IMPORTANT]
У случају гестикулације мишем, ваша функција повратног позива ће се позвати два пута: први пута када се тастер притисне (овде се површина увек подудара са вашом површином), а други пут када се тастер отпусти, па тада је могуће да се површина не подудара са вашом површином: зато у својој функцији повратног позива *увек* морате да тестирате да ли се површина подудара пре него што употребите инфо из хеш табеле.

Садржај хеш табеле која се шаље функцији повратног позива (кључеви и вредности су типа „стринг”):

[width="100%", cols="5,5,8,3", options="header"]
|===
| Кључ ^(1)^ | Опис | Примери вредности | Вредност ако нема

| _x | Колона на екрану.
| "0" ... "n" |

| _y | Линија на екрану.
| "0" ... "n" |

| _key | Догађај тастера или миша.
| "button1", "button2-gesture-left", ... |

| _window | Показивач на прозор.
| "0x1234abcd" | ""

| _window_number | Број прозора.
| "1" ... "n" | "*"

| _buffer | Показивач на бафер.
| "0x1234abcd" | ""

| _buffer_number | Број бафера.
| "1" ... "n" | "-1"

| _buffer_plugin | Име додатка бафера.
| "core", "irc", ... | ""

| _buffer_name | Име бафера.
| "weechat", "libera.#weechat", ... | ""

| _buffer_full_name  | Пуно име бафера.
| "core.weechat", "irc.libera.#weechat", ... | ""

| _buffer_localvar_XXX ^(2)^ | Локалне променљиве бафера.
| any value | not set

| _chat | Индикатор површине разговора.
| "0" or "1" | "0"

| _chat_line | Показивач на линију _(WeeChat ≥ 1.2)_.
| "0x1234abcd" | ""

| _chat_line_x | Колона у линији ^(3)^.
| "0" ... "n" | "-1"

| _chat_line_y | Број линије ^(3)^.
| "0" ... "n" | "-1"

| _chat_line_date | Датум/време линије.
| "1313237175" | "0"

| _chat_line_date_usec | Микросекунде датума/времена линије.
| "123456" | "0"

| _chat_line_date_printed | Датум/време линије ^(4)^.
| "1313237175" | "0"

| _chat_line_date_usec_printed | Микросекунде датума/времемна приказа линије ^(4)^.
| "123456" | "0"

| _chat_line_time | Приказано време.
| "14:06:15" | ""

| _chat_line_tags | Ознаке линије.
| "irc_privmsg,nick_flashy,log1" | ""

| _chat_line_nick | Надимак линије.
| "FlashCode" | ""

| _chat_line_prefix | Префикс линије.
| "@FlashCode" | ""

| _chat_line_message | Порука линије.
| "Hello world!" | ""

| _chat_focused_line | Линија на (x, y) _(WeeChat ≥ 4.0.0)_.
| "Здраво свима!" | ""

| _chat_focused_line_bol | Текст од почетка линије до (x-1, y) _(WeeChat ≥ 4.1.0)_.
| "Здраво" | ""

| _chat_focused_line_eol | Текст од (x, y) до краја линије _(WeeChat ≥ 4.1.0)_.
| "аво свима!" | ""

| _chat_word | Реч на (x,y).
| "Здраво" | ""

| _chat_bol | Текст од почетка поруке до (x-1, y).
| "Зд" | ""

| _chat_eol | Текст од (x, y) до краја поруке.
| "раво свете!" | ""

| _bar_name | Име траке.
| "title", "nicklist", ... | ""

| _bar_filling | Испуна траке.
| "horizontal", "vertical", ... | ""

| _bar_item_name | Име ставке траке.
| "buffer_nicklist", "hotlist", ... | ""

| _bar_item_line | Линија у ставки траке.
| "0" ... "n" | "-1"

| _bar_item_col | Колона у ставки траке.
| "0" ... "n" | "-1"

| _bar_window | Показивач на прозор траке _(WeeChat ≥ 2.9)_.
| "0x1234abcd" | ""
|===

[NOTE]
^(1)^ Постоје исти кључеви са суфиксом „2” (тј: „_x2”, „_y2”, „_window2”, ...) са инфо о другој тачки (корисно је само за гестикулације мишем, како бисте знали где је отпуштен тастер миша). +
^(2)^ `XXX` је име локалне променљиве у баферу. +
^(3)^ Поставља се само за бафере са слободним садржајем. +
^(4)^ То је датум када је програм WeeChat додао линију у бафер (веће или једнако од „_chat_line_date”).

Додатне инфо за ставку траке „buffer_nicklist”:

[width="100%", cols="^1,^1,5", options="header"]
|===
| Додатак ^(1)^ | Кључ     | Опис
| irc           | irc_nick | Показивач на IRC надимак _(WeeChat ≥ 3.0)_.
| irc           | irc_host | Хост за надимак (ако се зна).
| weechat       | nick     | Име надимка.
| weechat       | prefix   | Префикс за надимак.
| weechat       | group    | Име групе.
|===

[NOTE]
^(1)^ Име додатка које дефинише hook_focus за враћање инфо о овој ставки траке (на пример, ако је додатак „irc”, инфо о томе ће бити доступна само за irc бафере).

Повратна вредност:

* показивач на нову куку, NULL у случају грешке

C пример:

[source,c]
----
struct t_hashtable *
my_focus_nicklist_cb (const void *pointer, void *data, struct t_hashtable *info)
{
    /* додавање стрингова у хеш табелу */
    /* ... */

    return info;
}

/* додаје фокус на nicklist */
struct t_hook *my_focus = weechat_hook_focus ("buffer_nicklist",
                                              &my_focus_nicklist_cb, NULL, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def hook_focus(area: str, callback: str, callback_data: str) -> str: ...

# пример
def my_focus_nicklist_cb(data: str, info: Dict[str, str]) -> Dict[str, str]:
    # изградња dict
    # ...
    return my_dict

hook = weechat.hook_focus("buffer_nicklist", "my_focus_nicklist_cb", "")
----

==== hook_set

_WeeChat ≥ 0.3.9 (скрипте: WeeChat ≥ 0.4.3)._

Поставља стринг вредност особине куке.

Прототип:

[source,c]
----
void weechat_hook_set (struct t_hook *hook, const char *property,
                       const char *value);
----

Аргументи:

* _hook_: нешто за шта се прикачила „weechat_hook_xxx()”
* _property_: име особине (погледајте табелу испод)
* _value_: нова вредност за особину

Особине:

[width="100%", cols="^1,^1,2,2,5", options="header"]
|===
| Име | Мин WeeChat | Тип куке | Вредност | Опис

| subplugin | | било који тип
| било који стринг
| Име под додатка (обично је то име скрипте које се приказује у
  `/help команда` за куку типа _command_).

// TRANSLATION MISSING
| keep_spaces_right | 4.6.0 | _command_, _command_run_
| "0" or "1"
| Keep trailing spaces in command arguments when it is executed.

| stdin | 0.4.3 | _process_, _process_hashtable_ | било који стринг
| Шаље податке на стандардни улаз (_stdin_) дете процеса.

| stdin_close | 0.4.3 | _process_, _process_hashtable_ | (не користи се)
| Затвара пајп који се користи за слање података на стандардни улаз (_stdin_) дете процеса.

| signal | 1.0 | _process_, _process_hashtable_
| број сигнала или једно од следећих имена: `hup`, `int`, `quit`, `kill`, `term`,
  `usr1`, `usr2`
| Шаље сигнал дете процесу.
|===

C пример:

[source,c]
----
struct t_hook *my_command_hook =
    weechat_hook_command ("abcd", "опис",
                          "args", "опис аргумената",
                          "", &my_command_cb, NULL, NULL);
weechat_hook_set (my_command_hook, "subplugin", "test");
----

Скрипта (Python):

[source,python]
----
# прототип
def hook_set(hook: str, property: str, value: str) -> int: ...

# пример
def my_process_cb(data: str, command: str, return_code: int, out: str, err: str) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_process_hashtable("/путања/до/команде", {"stdin": "1"},
                                      20000, "my_process_cb", "")
weechat.hook_set(hook, "stdin", "подаци који се шаљу на stdin дете процеса")
weechat.hook_set(hook, "stdin_close", "")  # није обавезно
----

==== unhook

Откачи се са нечега на шта је прикачено.

Прототип:

[source,c]
----
void weechat_unhook (struct t_hook *hook);
----

Аргументи:

* _hook_: нешто за шта се прикачила „weechat_hook_xxx()”

C пример:

[source,c]
----
struct t_hook *my_hook = weechat_hook_command ( /* ... */ );
/* ... */
weechat_unhook (my_hook);
----

Скрипта (Python):

[source,python]
----
# прототип
def unhook(hook: str) -> int: ...

# пример
weechat.unhook(my_hook)
----

==== unhook_all

_Ажурирано у верзији 1.5._

Откачи се са свега на шта се закачио текући додатак.

Прототип:

[source,c]
----
void weechat_unhook_all (const char *subplugin);
----

Аргументи:

* _subplugin_: ако није NULL, откаче се само куке које имају постављен овај „subplugin” (овај аргумент није доступан у API скриптовања)

C пример:

[source,c]
----
weechat_unhook_all (NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def unhook_all() -> int: ...

# пример
weechat.unhook_all()
----

[[buffers]]
=== Бафери

Функције за креирање/упит/затварање бафера.

==== buffer_new

_Ажурирано у верзији 1.5._

Отвара нови бафер.

[NOTE]
Ако желите да тренутно поставите особине бафера (тип бафера, локалне променљиве, тастерске
пречице, итд.), онда је боље да упторебите функцију <<_buffer_new_props,buffer_new_props>>
која ове особине поставља током креирања бафера, пре слања сигнала
<<hook_signal_buffer_opened,buffer_opened>>.

Прототип:

[source,c]
----
struct t_gui_buffer *weechat_buffer_new (const char *name,
                                         int (*input_callback)(const void *pointer,
                                                               void *data,
                                                               struct t_gui_buffer *buffer,
                                                               const char *input_data),
                                         const void *input_callback_pointer,
                                         void *input_callback_data,
                                         int (*close_callback)(const void *pointer,
                                                               void *data,
                                                               struct t_gui_buffer *buffer),
                                         const void *close_callback_pointer,
                                         void *close_callback_data);
----

Аргументи:

* _name_: име бафера (мора бити јединствено за додатак)
* _input_callback_: функција која се позива када се унесе текст уноса за бафер, аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _struct t_gui_buffer *buffer_: показивач на бафер
** _const char *input_data_: подаци уноса
** повратна вредност:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _input_callback_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _input_callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се бафер затвори
* _close_callback_: функција која се позива када се затвори бафер, аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _struct t_gui_buffer *buffer_: показивач на бафер
** повратна вредност:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _close_callback_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _close_callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се затвори бафер

Повратна вредност:

* показивач на нови бафер, NULL у случају грешке

C пример:

[source,c]
----
int
my_input_cb (const void *pointer, void *data,
             struct t_gui_buffer *buffer, const char *input_data)
{
    weechat_printf (buffer, "Текст: %s", input_data);
    return WEECHAT_RC_OK;
}

int
my_close_cb (const void *pointer, void *data, struct t_gui_buffer *buffer)
{
    weechat_printf (NULL, "Затвориће се бафер ’%s’!",
                    weechat_buffer_get_string (buffer, "name"));
    return WEECHAT_RC_OK;
}

struct t_gui_buffer *my_buffer = weechat_buffer_new ("my_buffer",
                                                     &my_input_cb, NULL, NULL,
                                                     &my_close_cb, NULL, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def buffer_new(name: str, input_callback: str, input_callback_data: str,
               close_callback: str, close_callback_data: str) -> str: ...

# пример
def my_input_cb(data: str, buffer: str, input_data: str) -> int:
    weechat.prnt(buffer, "Текст: %s" % input_data)
    return weechat.WEECHAT_RC_OK

def my_close_cb(data: str, buffer: str) -> int:
    weechat.prnt("", "Затвориће се бафер ’%s’!" % weechat.buffer_get_string(buffer, "name"))
    return weechat.WEECHAT_RC_OK

buffer = weechat.buffer_new("my_buffer", "my_input_cb", "", "my_close_cb", "")
----

==== buffer_new_props

_WeeChat ≥ 3.5._

Отвара нови бафер и поставља особине.

Прототип:

[source,c]
----
struct t_gui_buffer *weechat_buffer_new_props (const char *name,
                                               struct t_hashtable *properties,
                                               int (*input_callback)(const void *pointer,
                                                                     void *data,
                                                                     struct t_gui_buffer *buffer,
                                                                     const char *input_data),
                                               const void *input_callback_pointer,
                                               void *input_callback_data,
                                               int (*close_callback)(const void *pointer,
                                                                     void *data,
                                                                     struct t_gui_buffer *buffer),
                                               const void *close_callback_pointer,
                                               void *close_callback_data);
----

Аргументи:

* _name_: име бафера (мора бити јединствено за додатак)
* _properties_: особине које треба да се примене
  (за дозвољене особине погледајте функцију <<_buffer_set,buffer_set>>)
* _input_callback_: функција која се позива када се унесе текст уноса за бафер, аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _struct t_gui_buffer *buffer_: показивач на бафер
** _const char *input_data_: подаци уноса
** повратна вредност:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _input_callback_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _input_callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се бафер затвори
* _close_callback_: функција која се позива када се затвори бафер, аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _struct t_gui_buffer *buffer_: показивач на бафер
** повратна вредност:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _close_callback_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _close_callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се затвори бафер

Повратна вредност:

* показивач на нови бафер, NULL у случају грешке

C пример:

[source,c]
----
int
my_input_cb (const void *pointer, void *data,
             struct t_gui_buffer *buffer, const char *input_data)
{
    weechat_printf (buffer, "Текст: %s", input_data);
    return WEECHAT_RC_OK;
}

int
my_close_cb (const void *pointer, void *data, struct t_gui_buffer *buffer)
{
    weechat_printf (NULL, "Затвориће се бафер ’%s’!",
                    weechat_buffer_get_string (buffer, "name"));
    return WEECHAT_RC_OK;
}

struct t_hashtable *properties = weechat_hashtable_new (8,
                                                        WEECHAT_HASHTABLE_STRING,
                                                        WEECHAT_HASHTABLE_STRING,
                                                        NULL,
                                                        NULL);
/* бафер са произвољним садржајем */
weechat_hashtable_set (properties, "type", "free");
/* овај бафер се не логује */
weechat_hashtable_set (properties, "localvar_set_no_log", "1");
/* везивање пречице alt-c за овај бафер */
weechat_hashtable_set (properties, "key_bind_meta-c", "/my_command");

struct t_gui_buffer *my_buffer = weechat_buffer_new_props ("my_buffer",
                                                           properties,
                                                           &my_input_cb, NULL, NULL,
                                                           &my_close_cb, NULL, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def buffer_new_props(name: str, properties: Dict[str, str],
                     input_callback: str, input_callback_data: str,
                     close_callback: str, close_callback_data: str) -> str: ...

# пример
def my_input_cb(data: str, buffer: str, input_data: str) -> int:
    weechat.prnt(buffer, "Текст: %s" % input_data)
    return weechat.WEECHAT_RC_OK

def my_close_cb(data: str, buffer: str) -> int:
    weechat.prnt("", "Затвориће се бафер ’%s’!" % weechat.buffer_get_string(buffer, "name"))
    return weechat.WEECHAT_RC_OK

properties = {
    "type": "free",                    # бафер са произвољним садржајем
    "localvar_set_no_log": "1",        # овај бафер се не логује
    "key_bind_meta-c": "/my_command",  # везивање пречице alt-c за овај бафер
}
buffer = weechat.buffer_new_props("my_buffer", properties, "my_input_cb", "", "my_close_cb", "")
----

==== current_buffer

Враћа показивач на текући бафер (бафер који се приказује у текућем прозору).

Прототип:

[source,c]
----
struct t_gui_buffer *weechat_current_buffer ();
----

Повратна вредност:

* показивач на текући бафер

C пример:

[source,c]
----
weechat_printf (weechat_current_buffer (), "Текст у текућем баферу");
----

Скрипта (Python):

[source,python]
----
# прототип
def current_buffer() -> str: ...

# пример
weechat.prnt(weechat.current_buffer(), "Текст у текућем баферу")
----

==== buffer_search

_Ажурирано у верзији 1.0, 4.3.0._

Претражује бафер на додатак/име, пуно име или јединствени идентификатор (`id`).

Прототип:

[source,c]
----
struct t_gui_buffer *weechat_buffer_search (const char *plugin,
                                            const char *name);
----

Аргументи:

* _plugin_: име додатка, доступне су следеће специјалне вредности:
** `+==+`: име које се користи је пуно име бафера (на пример: `irc.libera.#weechat` уместо `libera.#weechat`) _(WeeChat ≥ 1.0)_
** `+==id+`: име које се користи је јединствени идентификатор бафера (`id`) _(WeeChat ≥ 4.3.0)_
* _name_: име бафера, ако је NULL или празан стринг, враћа се текући бафер (бафер који се приказује у текућем прозору); ако име почиње са `(?i)`, претрага не прави разлику у величини слова _(WeeChat ≥ 1.0)_

Повратна вредност:

* показивач на пронађени бафер, или NULL ако се бафер не пронађе

C примери:

[source,c]
----
struct t_gui_buffer *buffer1 = weechat_buffer_search ("irc", "libera.#weechat");
struct t_gui_buffer *buffer2 = weechat_buffer_search ("==", "irc.libera.#test");  /* WeeChat ≥ 1.0 */
struct t_gui_buffer *buffer3 = weechat_buffer_search ("==id", "1709797810942688");  /* WeeChat ≥ 4.3.0 */
----

Скрипта (Python):

[source,python]
----
# прототип
def buffer_search(plugin: str, name: str) -> str: ...

# пример
buffer = weechat.buffer_search("my_plugin", "my_buffer")
----

==== buffer_search_main

Тражи главни бафер програма WeeChat (_core_ бафер, први бафер који се прикаже када се покреће програм WeeChat).

Прототип:

[source,c]
----
struct t_gui_buffer *weechat_buffer_search_main ();
----

Повратна вредност:

* показивач на главни бафер програма WeeChat (_core_ бафер)

C пример:

[source,c]
----
struct t_gui_buffer *weechat_buffer = weechat_buffer_search_main ();
----

Скрипта (Python):

[source,python]
----
# прототип
def buffer_search_main() -> str: ...

# пример
buffer = weechat.buffer_search_main()
----

==== buffer_clear

Чисти садржај бафера.

Прототип:

[source,c]
----
void weechat_buffer_clear (struct t_gui_buffer *buffer);
----

Аргументи:

* _buffer_: показивач на бафер

C пример:

[source,c]
----
struct t_gui_buffer *my_buffer = weechat_buffer_search ("my_plugin",
                                                        "my_buffer");
if (my_buffer)
{
    weechat_buffer_clear (my_buffer);
}
----

Скрипта (Python):

[source,python]
----
# прототип
def buffer_clear(buffer: str) -> int: ...

# пример
buffer = weechat.buffer_search("my_plugin", "my_buffer")
if buffer:
    weechat.buffer_clear(buffer)
----

==== buffer_close

Затвара бафер.

Прототип:

[source,c]
----
void weechat_buffer_close (struct t_gui_buffer *buffer);
----

Аргументи:

* _buffer_: показивач на бафер

C пример:

[source,c]
----
struct t_gui_buffer *my_buffer = weechat_buffer_new ("my_buffer",
                                                     &my_input_cb, NULL,
                                                     &my_close_cb, NULL);
/* ... */
weechat_buffer_close (my_buffer);
----

Скрипта (Python):

[source,python]
----
# прототип
def buffer_close(buffer: str) -> int: ...

# пример
buffer = weechat.buffer_new("my_buffer", "my_input_cb", "", "my_close_cb", "")
# ...
weechat.buffer_close(buffer)
----

==== buffer_merge

Спаја бафер у неки други бафер: оба бафера и даље постоје одвојено, али под истим бројем и програм WeeChat ће исписивати линије из оба бафера (мешане линије).

Прототип:

[source,c]
----
void weechat_buffer_merge (struct t_gui_buffer *buffer,
                           struct t_gui_buffer *target_buffer);
----

Аргументи:

* _buffer_: показивач на бафер
* _target_buffer_: циљни бафер, онај са којим се бафер спаја

C пример:

[source,c]
----
/* merge current buffer with weechat "core" buffer */
weechat_buffer_merge (weechat_current_buffer (),
                      weechat_buffer_search_main ());
----

Скрипта (Python):

[source,python]
----
# прототип
def buffer_merge(buffer: str, target_buffer: str) -> int: ...

# пример
# спаја текући бафер са WeeChat „core” бафером
weechat.buffer_merge(weechat.current_buffer(), weechat.buffer_search_main())
----

==== buffer_unmerge

Издваја бафер из групе спојених бафера.

Прототип:

[source,c]
----
void weechat_buffer_unmerge (struct t_gui_buffer *buffer,
                             int number);
----

Аргументи:

* _buffer_: показивач на бафер
* _number_: циљни број за издвојени бафер, ако је < 1, онда ће се бафер померити на број _buffer_ + 1

C пример:

[source,c]
----
weechat_buffer_unmerge (weechat_current_buffer (), 1);
----

Скрипта (Python):

[source,python]
----
# прототип
def buffer_unmerge(buffer: str, number: int) -> int: ...

# пример
weechat.buffer_unmerge(weechat.current_buffer(), 1)
----

==== buffer_get_integer

Враћа целобројну вредност особине бафера.

Прототип:

[source,c]
----
int weechat_buffer_get_integer (struct t_gui_buffer *buffer,
                                const char *property);
----

Аргументи:

* _buffer_: показивач на бафер
* _property_: име особине:
** _opening_: 1 ако се бафер отвара, у супротном 0 _(WeeChat ≥ 4.2.0)_
** _number_: број бафера (почиње се од 1)
** _layout_number_: број бафера сачуван у распореду
** _layout_number_merge_order_: редослед у спајању за распоред
** _type_: тип бафера (0: форматиран, 1: слободни садржај)
** _notify_: ниво обавештавања за бафер
** _num_displayed_: број прозора који приказују бафер
** _active_: 2 ако је то једини активни бафер (спојен), 1 ако је бафер активан, 0 ако је бафер спојен и није изабран
** _hidden_: 1 ако је бафер скривен, у супротном 0 _(WeeChat ≥ 1.0)_
** _zoomed_: 1 ако је бафер спојен и зумиран, у супротном 0 _(WeeChat ≥ 1.0)_
** _print_hooks_enabled_: 1 ако су укључене print куке, у супротном 0
** _day_change_: 1 ако су приказују поруке о промени дана, у супротном 0 _(WeeChat ≥ 0.4.3)_
** _clear_: 1 ако бафер може да се очисти командом `/buffer clear`, у супротном 0 _(WeeChat ≥ 1.0)_
** _filter_: 1 ако су у баферу укључени филтери, у успротном 0 _(WeeChat ≥ 1.0)_
** _closing_: 1 ако се бафер затвара, у супротном 0 _(WeeChat ≥ 1.0)_
** _lines_hidden_: 1 ако је у баферу скривена бар једна линија (филтрирана), или 0 ако се приказују све линије
** _prefix_max_length_: максимална дужина префикса у овом баферу
** _next_line_id_: id следеће линије у баферу _(WeeChat ≥ 3.8)_
** _time_for_each_line_: 1 ако се време приказује са сваку линију у баферу (подразумевано), у супротном 0
** _nicklist_: 1 ако је укључена листа надимака, у супротном 0
** _nicklist_case_sensitive_: 1 ако се у надимцима прави разлика у величини слова, у супротном 0
** _nicklist_max_length_: максимална дужина надимка
** _nicklist_display_groups_: 1 ако се приказују групе, у супротном 0
** _nicklist_count_: број надимака и група у листи надимака
** _nicklist_visible_count_: број приказаних надимака/група
** _nicklist_groups_count_: број група у листи надимака
** _nicklist_groups_visible_count_: број приказаних група
** _nicklist_nicks_count_: број надимака у листи надимака
** _nicklist_nicks_visible_count_: број приказаних надимака
** _input_: 1 ако је укључен унос, у супротном 0
** _input_get_any_user_data_: 1 ако се било који кориснички подаци, укљуљчујући команде, шаљу функцији повратног позива уноса, иначе 0
** _input_get_unknown_commands_: 1 ако се непознате команде шаљу функцији повратног позива уноса, у супротном 0
** _input_get_empty_: 1 ако се функцији повратног позива уноса шаље празан унос, у супротном 0
** _input_multiline_: 1 ако се више линија шаље као једна порука функцији повратног позива уноса, у супротном 0
** _input_size_: величина уноса (у бајтовима)
** _input_length_: дужина уноса (број карактера)
** _input_pos_: позиција курсора у баферу уноса
** _input_1st_display_: први карактер приказан на екрану
** _num_history_: број команди у историји
** _text_search_: тип претраге текста:
*** 0: у овом тренутку нема претраге
*** 1: претрага у линијама бафера
*** 2: претрага у историји команди
** _text_search_direction_: смер претраге:
*** 0: претрага уназад (смер: најстарије поруке/команде)
*** 1: претрага унапред (смер: најновије поруке/команде)
** _text_search_exact_: 1 ако претрага текста прави разлику у величини слова
** _text_search_regex_: 1 ако се претражује регуларним изразом
** _text_search_where_:
*** 0: у овом тренутку нема претраге
*** 1: претрага у поруци
*** 2: претрага у префиксу
*** 3: претрага у префиксу и поруци
** _text_search_history_:
*** 0: у овом тренутку нема претраге
*** 1: претрага у локалној историји бафера
*** 2: претрага у глобалној историји
** _text_search_found_: 1 ако се текст пронађе, у супротном 0

Повратна вредност:

* целобројна вредност особине

C пример:

[source,c]
----
weechat_printf (NULL, "број мог бафера је: %d",
                weechat_buffer_get_integer (my_buffer, "number"));
----

Скрипта (Python):

[source,python]
----
# прототип
def buffer_get_integer(buffer: str, property: str) -> int: ...

# пример
weechat.prnt("", "број мог бафера је: %d" % weechat.buffer_get_integer(my_buffer, "number"))
----

==== buffer_get_string

Враћа стринг вредност особине бафера.

Прототип:

[source,c]
----
const char *weechat_buffer_get_string (struct t_gui_buffer *buffer,
                                       const char *property);
----

Аргументи:

* _buffer_: показивач на бафер
* _property_: име особине:
** _id_: јединствени идентификатор _(WeeChat ≥ 4.3.0)_
** _plugin_: име додатка који је креирао овај бафер („core” за главни бафер програма WeeChat)
** _name_: име бафера
** _full_name_: пуно име бафера („додатак.име”) _(WeeChat ≥ 0.3.7)_
** _old_full_name_: старо пуно име бафера („додатак.име”), постављено пре промене имена бафера _(WeeChat ≥ 2.8)_
** _short_name_: кратко име бафера (напомена: користи се само за приказ и корисник може да га промени, ово не сме да се употребљава за проналажење имена бафера, уместо њега употребите _name_, _full_name_ или локалну променљиву _channel_)
** _type_: тип бафера: „formatted” или „free” _(WeeChat ≥ 4.2.0)_
** _title_: наслов бафера
** _modes_: режими _(WeeChat ≥ 4.3.0)_
** _nicklist_last_id_assigned_: последњи јединствени идентификатор употребљен у овом баферу за групу или надимак _(WeeChat ≥ 4.3.0)_
** _input_prompt_: питање уноса _(WeeChat ≥ 4.3.0)_
** _input_: текст уноса
** _text_search_input_: сачувани унос пре претраге текста
** _highlight_words_: листа речи које се истичу
** _highlight_disable_regex_: POSIX прооширени регуларни израз за искључивање истицања
** _highlight_regex_: POSIX проширени регуларни израз за истицање
** _highlight_tags_restrict_: ограничава истицање само на поруке са наведеним ознакама
** _highlight_tags_: истицање се форсира за поруке са наведеним ознакама
** _hotlist_max_level_nicks_: максимални ниво вруће листе за неке надимке
** _localvar_xxx_: враћа садржај локалне променљиве „xxx” (замените „xxx” са именом локалне променљиве коју желите да прочитате)

Повратна вредност:

* стринг вредност особине

C пример:

[source,c]
----
weechat_printf (NULL, "име / кратко име бафера су: %s / %s",
                weechat_buffer_get_string (my_buffer, "name"),
                weechat_buffer_get_string (my_buffer, "short_name"));
----

Скрипта (Python):

[source,python]
----
# прототип
def buffer_get_string(buffer: str, property: str) -> str: ...

# пример
weechat.prnt("", "име / кратко име бафера су: %s / %s"
    % (weechat.buffer_get_string(my_buffer, "name"),
    weechat.buffer_get_string(my_buffer, "short_name")))
----

==== buffer_get_pointer

Враћа вредност показивача на особину бафера.

Прототип:

[source,c]
----
void *weechat_buffer_pointer (struct t_gui_buffer *buffer,
                              const char *property);
----

Аргументи:

* _buffer_: показивач на бафер
* _property_: име особине:
** _plugin_: показивач на додатак који је креирао овај бафер (NULL за главни бафер програма WeeChat)
** _text_search_regex_compiled_: компајлирани регуларни израз
** _text_search_ptr_history_: пронађена историја
** _highlight_disable_regex_compiled_: компајлиран регуларни израз _highlight_disable_regex_
** _highlight_regex_compiled_: компајлиран регуларни израз _highlight_regex_

Повратна вредност:

* вредност показивача на особину

C пример:

[source,c]
----
weechat_printf (NULL, "показивач на додатак мог бафера: %p",
                weechat_buffer_get_pointer (my_buffer, "plugin"));
----

Скрипта (Python):

[source,python]
----
# прототип
def buffer_get_pointer(buffer: str, property: str) -> str: ...

# пример
weechat.prnt("", "показивач на додатак мог бафера: %s" % weechat.buffer_get_pointer(my_buffer, "plugin"))
----

==== buffer_set

Поставља стринг вредност особине бафера.

Прототип:

[source,c]
----
void weechat_buffer_set (struct t_gui_buffer *buffer, const char *property,
                         const char *value);
----

Аргументи:

* _buffer_: показивач на бафер
* _property_: име особине (погледајте табелу испод)
* _value_: нова вредност за особину

Особине:

[width="100%", cols="^2,^1,4,8", options="header"]
|===
| Име | Мин WeeChat | Вредност | Опис

| hotlist | | "+", "-", WEECHAT_HOTLIST_LOW, WEECHAT_HOTLIST_MESSAGE,
  WEECHAT_HOTLIST_PRIVATE, WEECHAT_HOTLIST_HIGHLIGHT, "-1"
| "+": укључује врућу листу (глобално подешавање, не користи се показивач на бафер) +
  "-": искључује врућу листу (глобално подешавање, не користи се показивач на бафер) +
  приоритет: бафер се на врућу листу додаје са овим приоритетом
  (услови дефинисани у опцији _weechat.look.hotlist_add_conditions_
  се *НЕ* проверавају) +
  "-1": уклања бафер из вруће листе _(WeeChat ≥ 1.0)_.

| hotlist_conditions | 4.5.0 | WEECHAT_HOTLIST_LOW, WEECHAT_HOTLIST_MESSAGE,
  WEECHAT_HOTLIST_PRIVATE, WEECHAT_HOTLIST_HIGHLIGHT
| приоритет: бафер се на врућу листу додаје са овим приоритетом
  (услови дефинисани у опцији _weechat.look.hotlist_add_conditions_
  се проверавају).

| completion_freeze | | "0" или "1"
| "0": нема замрзавања довршавања (подразумевана вредност)
  (глобално подешавање, не користи се показивач на бафер) +
  "1": довршавање се не зауставља када се ажурира командна линија
  (глобално подешавање, не користи се показивач на бафер).

| unread | | празан стринг, "0", "+N", "-N" или "N" (N је цео број)
| празан стринг: поставља ознаку непрочитано након последње линије бафера +
  "0": уклања ознаку непрочитано из бафера +
  "N": помера ознаку непрочитано N линија од краја према првој линији бафера +
  "-N": помера ознаку непрочитано N линија према првој линији бафера +
  "+N": помера ознаку непрочитано N линија према последњој линији бафера.

| display | | "1" или "auto"
| "1": прелазак на овај бафер у текућем прозору +
  "auto": прелазак на овај бафер у текућем прозору, не ресетује се маркер прочитаних линија.

| hidden | 1.0 | "0" или "1"
| "0": бафер се открива +
  "1": бафер се скрива.

| number | | број
| Помера бафер на наведени број.

| name | | било који стринг
| Поставља ново име бафера.

| short_name | | било који стринг
| Поставља ново кратко име бафера.

| type | | "formatted" или "free"
| Поставља тип бафера: "formatted" (за приказ порука разговора), или "free" (за
  слободни садржај); када је вредност "free", особина _clear_ се форсира на "0"
  _(WeeChat ≥ 1.0)_.

| notify | | "0", "1", "2", "3"
| Поставља ниво обавештавања за овај бафер: "0" = никада се не додаје на врућу листу,
  "1" = додаје само за истицања, "2" = додаје за истицања и поруке, "3" = додаје
  за све поруке.

| print_hooks_enabled | | "0" или "1"
| "0" да се искључе print куке, "1" да се укључе (подразумевано за нови бафер).

| day_change | 0.4.3 | "0" или "1"
| "0" да се скривају поруке о измени дана, "1" да се приказују
  (подразумевано за нови бафер).

| clear | 1.0 | "0" или "1"
| "0" да се спречи могућност да корисник очисти бафер командом `/buffer clear`,
  "1" да се дозволи кориснику да очисти бафер (подразумевано за нови бафер)
   (напомена: чак и када се постави на "0", бафер још увек може да се очисти
   функцијом <<_buffer_clear,buffer_clear>>).

| filter | 1.0 | "0" или "1"
| "0": искључује филтере у баферу +
  "1": укључује филтере у баферу.

| title | | било који стринг
| Поставља нови наслов бафера.

| modes | 4.3.0 | било који стринг
| Поставља нове режиме за бафер.

| time_for_each_line | | "0" или "1"
| "0" да се скрива време у свим линијама бафера, "1" да се приказује у свим
  линијама (подразумевано за нови бафер).

| nicklist | | "0" или "1"
| "0" да се листа надимака уклони из бафера, "1" да се у бафер дода листа надимака.

| nicklist_case_sensitive | | "0" или "1"
| "0" да листа надимака не прави разлику у величини слова, "1" да листа надимака
  прави разлику у величини слова.

| nicklist_display_groups | | "0" или "1"
| "0" да се сакрију групе у листи надимака, "1" да се приказују групе у листи надимака.

| highlight_words | | "-" или листа речи раздвојених запетама
| "-" је специјална вредност која искључује било какво истицање у овом баферу, или
  листа речи за истицање у баферу раздвојених запетама, на пример:
  "abc,def,ghi".

| highlight_words_add | | листа речи раздвојених запетама
| Лист речи раздвојених запетама које се истичу у овом баферу, ове речи се
  додају на постојеће речи које се истичу у баферу.

| highlight_words_del | | листа речи раздвојених запетама
| Лист речи раздвојених запетама које треба да се уклоне из речи које се истичу у овом баферу.

| highlight_disable_regex | | било који стринг
| POSIX проширени регуларни израз за искључивање истицања.

| highlight_regex | | било који стринг
| POSIX проширени регуларни израз за истицање.

| highlight_tags_restrict | | листа речи или ознака раздвојених запетама
| Ограничава истицање порука у овом баферу само на поруке са наведеним ознакама
  (граничником „+” је могуће комбиновање више ознака у релацији логичко „и”, на
   пример: "nick_toto+irc_action").

| highlight_tags | | листа речи или ознака раздвојених запетама
| Форсира истицање порука са наведеним ознакама у овом баферу (
  (граничником „+” је могуће комбиновање више ознака у релацији логичко „и”, на
   пример: "nick_toto+irc_action").

| hotlist_max_level_nicks | | листа „надимак:ниво” раздвојена запетама
| Листа надимака са максималним нивоом вруће листе раздвојених запетама за овај бафер
  (ниво може бити: -1: никада у врућој листи, 0: низак, 1: порука, 2: приватна,
  3: истицање), на пример: „joe:2,mike:-1,robert:-1” (joe никада неће изазвати
  истицање у баферу, mike и robert никада неће изменити врућу листу).

| hotlist_max_level_nicks_add | | листа „надимак:ниво” раздвојена запетама
| Листа надимака са максималним нивоом вруће листе раздвојених запетама, ови
  надимци се додају на постојеће надимке у баферу.

| hotlist_max_level_nicks_del | | листа надимака раздвојених запетама
| Листа надимака раздвојених запетама који треба да се уклоне из максималних нивоа вруће листе.

| key_bind_xxx | | било који стринг
| Прави нову тастерску пречицу _xxx_, специфичну за овај бафер, вредност је команда
  која се извршава за тај тастер.

| key_unbind_xxx | | -
| Уклања тастерску пречицу _xxx_ за овај бафер.

| input_prompt | 4.3.0 | било који стринг
| Поставља нову вредност за питање уноса.

| input | | било који стринг
| Поставља нову вредност за унос у бафер.

| input_pos | | позиција
| Поставља позицију курсора у уносу бафера.

| input_get_any_user_data | 4.3.0 | "0" или "1"
| "0" да се прихвате само корисничке поруке (подразумевано понашање), "1" да се прихвати све,
  укључујући и команде.

| input_get_unknown_commands | | "0" или "1"
| "0" да се за овај бафер искључе непознате команде (подразумевано понашање), "1" да
  се прихвате непознате команде, на пример ако корисник откуца „/unknowncmd”, бафер ће
  то да прихвати (без исписа грешке о непознатој команди).

| input_get_empty | | "0" или "1"
| "0" да се искључи празан унос у овај бафер (подразумевано понашање), "1" да се
  прихвати празан унос.

| input_multiline | | "0" или "1"
| "0" да се овом баферу свака линија шаље одвојено (подразумевано понашање), "1" да
  се више линија пошаље као једна порука.

| localvar_set_xxx | | било који стринг
| Поставља нову вредност локалне променљиве _xxx_ (променљива се креира ако не постоји).

| localvar_del_xxx | | -
| Уклања локалну променљиву _xxx_.
|===

C пример:

[source,c]
----
/* искључивање вруће листе (за све бафере) */
weechat_buffer_set (NULL, "hotlist", "-");

/* поновно укључивање вруће листе */
weechat_buffer_set (NULL, "hotlist", "+");

/* промена имена бафера
weechat_buffer_set (my_buffer, "name", "my_new_name");

/* додавање нове локалне променљиве „toto” са вредности „abc” */
weechat_buffer_set (my_buffer, "localvar_set_toto", "abc");

/* уклањање локалне променљиве „toto” */
weechat_buffer_set (my_buffer, "localvar_del_toto", "");
----

Скрипта (Python):

[source,python]
----
# прототип
def buffer_set(buffer: str, property: str, value: str) -> int: ...

# примери

# искључује врућу листу (за све бафере)
weechat.buffer_set("", "hotlist", "-")

# поново укључује врућу листу
weechat.buffer_set("", "hotlist", "+")

# промена имена бафера
weechat.buffer_set(my_buffer, "name", "my_new_name")

# додаје нову локалну променљиву „toto” са вредношћу „abc”
weechat.buffer_set(my_buffer, "localvar_set_toto", "abc")

# уклања локалну променљиву „toto”
weechat.buffer_set(my_buffer, "localvar_del_toto", "")
----

==== buffer_set_pointer

Поставља вредност показивача на особину бафера.

Прототип:

[source,c]
----
void weechat_buffer_set_pointer (struct t_gui_buffer *buffer, const char *property,
                                 void *pointer);
----

Аргументи:

* _buffer_: показивач на бафер
* _property_: име особине:
** _close_callback_: поставља функцију повратног позива затварања
** _close_callback_data_: поставља податке за функцију повратног позива затварања
** _input_callback_: поставља функцију повратног позива уноса
** _input_callback_data_: поставља податке за функцију повратног позива уноса
** _nickcmp_callback_: поставља функцију повратног позива за поређење надимака (ова функција повратног позива се зове када се у листи надимака тражи надимак) _(WeeChat ≥ 0.3.9)_
** _nickcmp_callback_data_: поставља податке за функцију повратног позива за поређење надимака _(WeeChat ≥ 0.3.9)_
* _pointer_: нова вредност показивача за особину

Прототипи за функције повратног позива:

[source,c]
----
int close_callback (const void *pointer, void *data,
                    struct t_gui_buffer *buffer);

int input_callback (const void *pointer, void *data,
                    struct t_gui_buffer *buffer, const char *input_data);

int nickcmp_callback (const void *pointer, void *data,
                      struct t_gui_buffer *buffer,
                      const char *nick1, const char *nick2);
----

C пример:

[source,c]
----
int
my_close_cb (const void *pointer, void *data, struct t_gui_buffer *buffer)
{
    /* ... */
    return WEECHAT_RC_OK;
}

weechat_buffer_set_pointer (my_buffer, "close_callback", &my_close_cb);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== buffer_string_replace_local_var

Замењује локалне променљиве у стрингу својим вредностима, користећи бафер локалне променљиве.

Прототип:

[source,c]
----
char *weechat_buffer_string_replace_local_var (struct t_gui_buffer *buffer,
                                               const char *string);
----

Аргументи:

* _buffer_: показивач на бафер
* _string_: стринг са текстом и локалним променљивама у формату „$пром”

Повратна вредност:

* стринг са вредностима локалних променљивих

C пример:

[source,c]
----
weechat_buffer_set (my_buffer, "localvar_set_toto", "abc");

char *str = weechat_buffer_string_replace_local_var (my_buffer,
                                                     "тест са $toto");
/* str садржи „тест са abc” */
----

Скрипта (Python):

[source,python]
----
# прототип
def buffer_string_replace_local_var(buffer: str, string: str) -> str: ...

# пример
weechat.buffer_set(my_buffer, "localvar_set_toto", "abc")
str = weechat.buffer_string_replace_local_var(my_buffer, "тест са $toto")
# str садржи „тест са abc”
----

==== buffer_match_list

_WeeChat ≥ 0.3.5, ажурирано у верзији 4.0.0._

Проверава да ли се бафер подудара са листом бафера.

Прототип:

[source,c]
----
int weechat_buffer_match_list (struct t_gui_buffer *buffer, const char *string);
----

Аргументи:

* _buffer_: показивач на бафер
* _string_: листа бафера раздвојених запетама:
** `+*+` значи сви бафери
** име које почиње са `+!+` се не узима у обзир
** у имену је дозвољен џокер `+*+`

[NOTE]
Од верзије 4.0.0, поређење имена бафера прави разлику у величини слова.

Повратна вредност:

* 1 ако се бафер подудара са листом бафера, 0 у супротном

C пример:

[source,c]
----
struct t_gui_buffer *buffer = weechat_buffer_search ("irc", "libera.#weechat");
if (buffer)
{
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "*"));                    /* 1 */
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "*,!*#weechat*"));        /* 0 */
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "irc.libera.*"));         /* 1 */
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "irc.oftc.*,python.*"));  /* 0 */
}
----

Скрипта (Python):

[source,python]
----
# прототип
def buffer_match_list(buffer: str, string: str) -> int: ...

# пример
buffer = weechat.buffer_search("irc", "libera.#weechat")
if buffer:
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "*"))                    # 1
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "*,!*#weechat*"))        # 0
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "irc.libera.*"))         # 1
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "irc.oftc.*,python.*"))  # 0
----

[[buffer_lines]]
=== Линије бафера

Функције за линије бафера.

==== line_search_by_id

_WeeChat ≥ 4.4.0._

Претрага линије у баферу по идентификатору.

Прототип:

[source,c]
----
struct t_gui_line *weechat_line_search_by_id (struct t_gui_buffer *buffer, int id);
----

Повратна вредност:

* показивач на пронађену линију, NULL ако се не пронађе

C пример:

[source,c]
----
struct t_gui_line *line = weechat_line_search_by_id (buffer, 123);
----

Скрипта (Python):

[source,python]
----
# прототип
def line_search_by_id(buffer: str, line_id: int) -> str: ...

# пример
line = weechat.line_search_by_id(buffer, 123)
----

[[windows]]
=== Прозори

Функције за упите о прозорима.

==== current_window

Враћа показивач на текући прозор.

Прототип:

[source,c]
----
struct t_gui_window *weechat_current_window ();
----

Повратна вредност:

* показивач на текући прозор

C пример:

[source,c]
----
struct t_gui_window *current_window = weechat_current_window ();
----

Скрипта (Python):

[source,python]
----
# прототип
def current_window() -> str: ...

# пример
current_window = weechat.current_window()
----

==== window_search_with_buffer

_WeeChat ≥ 0.3.5._

Враћа показивач на прозор који приказује бафер.

Прототип:

[source,c]
----
struct t_gui_window *weechat_window_search_with_buffer (struct t_gui_buffer *buffer);
----

Аргументи:

* _buffer_: показивач на бафер

Повратна вредност:

* показивач на прозор који приказује бафер (NULL ако ниједан прозор не приказује бафер)

C пример:

[source,c]
----
weechat_printf (NULL,
                "прозор који приказује core бафер: %p",
                weechat_window_search_with_buffer (weechat_buffer_search_main ()));
----

Скрипта (Python):

[source,python]
----
# прототип
def window_search_with_buffer(buffer: str) -> str: ...

# пример
weechat.prnt("", "прозор који приказује core бафер: %s"
    % weechat.window_search_with_buffer(weechat.buffer_search_main()))
----

==== window_get_integer

Враћа целобројну вредност особине прозора.

Прототип:

[source,c]
----
int weechat_window_get_integer (struct t_gui_window *window,
                                const char *property);
----

Аргументи:

* _window_: показивач на прозор
* _property_: име особине:
** _number_: број прозора (почиње од 1)
** _win_x_: X позиција прозора у терминалу (прва колона је 0)
** _win_y_: Y позиција прозора у терминалу (прва линија је 0)
** _win_width_: ширина прозора у карактерима
** _win_height_: висина прозора у карактерима
** _win_width_pct_: процентуална величина, у односу на родитељски прозор (на пример, 50 значи половина величине)
** _win_height_pct_: процентуална величина, у односу на родитељски прозор (на пример, 50 значи половина величине)
** _win_chat_x_: X позиција прозора разговора у терминалу (прва колона је 0)
** _win_chat_y_: Y позиција прозора разговора у терминалу (прва линија је 0)
** _win_chat_width_: ширина прозора за разговор у карактерима
** _win_chat_height_: висина прозора за разговор у карактерима
** _first_line_displayed_: 1 ако је на екрану приказана прва линија бафера, у супротном 0
** _scrolling_: 1 ако је у прозору активно скроловање (не приказује се последња линија)
** _lines_after_: број линија које се не приказују након последње приказане (када се скролује)

Повратна вредност:

* целобројна вредност особине

C пример:

[source,c]
----
weechat_printf (NULL, "current window is at position (x,y): (%d,%d)",
                weechat_window_get_integer (weechat_current_window (), "win_x"),
                weechat_window_get_integer (weechat_current_window (), "win_y"));
----

Скрипта (Python):

[source,python]
----
# прототип
def window_get_integer(window: str, property: str) -> int: ...

# пример
weechat.prnt("", "текући прозор је на позицији (x,y): (%d,%d)"
    % (weechat.window_get_integer(weechat.current_window(), "win_x"),
    weechat.window_get_integer(weechat.current_window(), "win_y")))
----

==== window_get_string

Враћа стринг вредност особине прозора.

[NOTE]
Ова функција се сада не користи, резервисана је будућу верзију.

Прототип:

[source,c]
----
const char *weechat_window_get_string (struct t_gui_window *window,
                                       const char *property);
----

Аргументи:

* _window_: показивач на прозор
* _property_: име особине

Повратна вредност:

* стринг вредност особине

Скрипта (Python):

[source,python]
----
# прототип
def window_get_string(window: str, property: str) -> str: ...
----

==== window_get_pointer

Враћа вредност показивача на особину прозора.

Прототип:

[source,c]
----
void *weechat_window_get_pointer (struct t_gui_window *window,
                                  const char *property);
----

Аргументи:

* _window_: показивач на прозор
* _property_: име особине:
** _current_: показивач на текући прозор
** _buffer_: показивач на бафер који се приказује у прозору

Повратна вредност:

* вредност показивача на особину

C пример:

[source,c]
----
weechat_printf (NULL,
                "бафер који се приказује у текућем прозору: %p",
                weechat_window_get_pointer (weechat_current_window (), "buffer"));
----

Скрипта (Python):

[source,python]
----
# прототип
def window_get_pointer(window: str, property: str) -> str: ...

# пример
weechat.prnt("", "бафер који се приказује у текућем прозору: %s"
    % weechat.window_get_pointer(weechat.current_window(), "buffer"))
----

==== window_set_title

Поставља наслов за терминал.

Прототип:

[source,c]
----
void weechat_window_set_title (const char *title);
----

Аргументи:

* _title_: нови наслов за терминал (NULL ако желите да ресетујете наслов); стринг се израчунава, тако да је могуће коришћење променљивих као што је `${info:version}` (погледајте <<_string_eval_expression,string_eval_expression>>)

C пример:

[source,c]
----
weechat_window_set_title ("овде иде нови наслов");
----

Скрипта (Python):

[source,python]
----
# прототип
def window_set_title(title: str) -> int: ...

# пример
weechat.window_set_title("овде иде нови наслов")
----

[[nicklist]]
=== Листа надимака

Функције за листу надимака бафера.

==== nicklist_add_group

Додаје групу у листу надимака.

Прототип:

[source,c]
----
struct t_gui_nick_group *weechat_nicklist_add_group (struct t_gui_buffer *buffer,
                                                     struct t_gui_nick_group *parent_group,
                                                     const char *name,
                                                     const char *color,
                                                     int visible);
----

Аргументи:

* _buffer_: показивач на бафер
* _parent_group_: показивач на родитеља групе, NULL ако група нема родитеља (корен листе надимака)
* _name_: име групе
* _color_: име опције боја:
** Име WeeChat опције, на пример _weechat.color.nicklist_group_
** поја са необавезном позадином, на пример _yellow_ или _yellow,red_
** име боје траке:
*** _bar_fg_: боја предњег плана траке
*** _bar_delim_: боја граничника за траку
*** _bar_bg_: боја позадине за траку
* _visible_:
** _1_: групе и подгрупе/надимци су видљиви
** _0_: групе и подгрупе/надимци су скривени

[NOTE]
Име групе може да почне једном или две цифре, иза којих долази вертикална црта, па име групе. Када се на почетку наиђе на овакав стринг, он се користи за сортирање група у листи надимака. На пример, групе „1|test” и „2|abc” ће се приказати у том редоследу: прво „test”, па „abc”.

Повратна вредност:

* показивач на нову групу, NULL у случају грешке

C пример:

[source,c]
----
struct t_gui_nick_group *my_group =
    weechat_nicklist_add_group (my_buffer,
                                my_parent_group,
                                "test_group",
                                "weechat.color.nicklist_group",
                                1);
----

Скрипта (Python):

[source,python]
----
# прототип
def nicklist_add_group(buffer: str, parent_group: str, name: str, color: str, visible: int) -> str: ...

# пример
group = weechat.nicklist_add_group(my_buffer, my_parent_group, "test_group",
    "weechat.color.nicklist_group", 1)
----

==== nicklist_search_group

_Ажурирано у верзији 4.3.0._

Претражује групу у листи надимака по имену или јединственом идентификатору (`id`).

Прототип:

[source,c]
----
struct t_gui_nick_group *weechat_nicklist_search_group (struct t_gui_buffer *buffer,
                                                        struct t_gui_nick_group *from_group,
                                                        const char *name);
----

Аргументи:

* _buffer_: показивач на бафер
* _from_group_: тражи само од ове групе, ако је NULL, онда се претражује цела листа надимака
* _name_: име групе која се тражи; са WeeChat ≥ 4.3.0, јединствени идентификатор може да се
  наведе у следећем формату: `==id:xxx` (где је `xxx` идентификатор)

Повратна вредност:

* показивач на пронађену групу, NULL ако се не пронађе

C пример:

[source,c]
----
struct t_gui_nick_group *ptr_group1 = weechat_nicklist_search_group (my_buffer,
                                                                     NULL, "test_group");
struct t_gui_nick_group *ptr_group2 = weechat_nicklist_search_group (my_buffer,
                                                                     NULL, "==id:1714382231198764");
----

Скрипта (Python):

[source,python]
----
# прототип
def nicklist_search_group(buffer: str, from_group: str, name: str) -> str: ...

# пример
group1 = weechat.nicklist_search_group(my_buffer, "", "test_group")
group2 = weechat.nicklist_search_group(my_buffer, "", "==id:1714382231198764")
----

==== nicklist_add_nick

Додаје надимак у групу.

Прототип:

[source,c]
----
struct t_gui_nick *weechat_nicklist_add_nick (struct t_gui_buffer *buffer,
                                              struct t_gui_nick_group *group,
                                              const char *name,
                                              const char *color,
                                              const char *prefix,
                                              const char *prefix_color,
                                              int visible);
----

Аргументи:

* _buffer_: показивач на бафер
* _group_: показивач на групу
* _name_: име надимка
* _color_: име опције боја:
*** Име WeeChat опције (из weechat.color.xxx), на пример _chat_delimiters_
*** поја са необавезном позадином, на пример _yellow_ или _yellow,red_
*** име боје траке:
**** _bar_fg_: боја предњег плана траке
**** _bar_delim_: боја граничника за траку
**** _bar_bg_: боја позадине за траку
* _prefix_: префикс који се приказује испред надимка
* _prefix_color_: име опције боја:
** Име WeeChat опције (из weechat.color.xxx), на пример _chat_delimiters_
** поја са необавезном позадином, на пример _yellow_ или _yellow,red_
** име боје траке:
*** _bar_fg_: боја предњег плана траке
*** _bar_delim_: боја граничника за траку
*** _bar_bg_: боја позадине за траку
* _visible_:
** _1_: надимак је видљив
** _0_: надимак је скривен

Повратна вредност:

* показивач на нови надимак, NULL у случају грешке

C пример:

[source,c]
----
struct t_gui_nick *my_nick =
    weechat_nicklist_add_nick (my_buffer, my_group,
                               "test_nick",
                               (nick_away) ? "weechat.color.nicklist_away" : "bar_fg",
                               "@", "lightgreen",
                               1);
----

Скрипта (Python):

[source,python]
----
# прототип
def nicklist_add_nick(buffer: str, group: str, name: str, color: str, prefix: str, prefix_color: str, visible: int) -> str: ...

# пример
if nick_away:
    color = "weechat.color.nicklist_away"
else:
    color = "bar_fg"
nick = weechat.nicklist_add_nick(my_buffer, my_group, "test_nick", color, "@", "lightgreen", 1)
----

==== nicklist_search_nick

_Ажурирано у верзији 4.3.0._

Претражује надимак у листи надимака по имену или јединственом идентификатору (`id`).

Прототип:

[source,c]
----
struct t_gui_nick *weechat_nicklist_search_nick (struct t_gui_buffer *buffer,
                                                 struct t_gui_nick_group *from_group,
                                                 const char *name);
----

Аргументи:

* _buffer_: показивач на бафер
* _from_group_: тражи само од ове групе, ако је NULL, онда се претражује цела листа надимака
* _name_: име надимка који се тражи; са WeeChat ≥ 4.3.0, јединствени идентификатор може да се
  наведе у следећем формату: `==id:xxx` (где је `xxx` идентификатор)

Повратна вредност:

* показивач на пронађени надимак, NULL ако се не пронађе

C пример:

[source,c]
----
struct t_gui_nick *ptr_nick1 = weechat_nicklist_search_nick (my_buffer,
                                                             NULL, "test_nick");
struct t_gui_nick *ptr_nick2 = weechat_nicklist_search_nick (my_buffer,
                                                             NULL, "==id:1714382252187496");
----

Скрипта (Python):

[source,python]
----
# прототип
def nicklist_search_nick(buffer: str, from_group: str, name: str) -> str: ...

# пример
nick1 = weechat.nicklist_search_nick(my_buffer, "", "test_nick")
nick2 = weechat.nicklist_search_nick(my_buffer, "", "==id:1714382252187496")
----

==== nicklist_remove_group

Уклања групу из листе надимака.

Прототип:

[source,c]
----
void weechat_nicklist_remove_group (struct t_gui_buffer *buffer,
                                    struct t_gui_nick_group *group);
----

Аргументи:

* _buffer_: показивач на бафер
* _group_: показивач на групу која треба да се уклони (уклониће се и све подгрупе/надимци)

C пример:

[source,c]
----
weechat_nicklist_remove_group (my_buffer, my_group);
----

Скрипта (Python):

[source,python]
----
# прототип
def nicklist_remove_group(buffer: str, group: str) -> int: ...

# пример
weechat.nicklist_remove_group(my_buffer, my_group)
----

==== nicklist_remove_nick

Уклања надимак из листе надимака.

Прототип:

[source,c]
----
void weechat_nicklist_remove_nick (struct t_gui_buffer *buffer,
                                   struct t_gui_nick *nick);
----

Аргументи:

* _buffer_: показивач на бафер
* _nick_: показивач на надимак који треба да се уклони

C пример:

[source,c]
----
weechat_nicklist_remove_nick (my_buffer, my_nick);
----

Скрипта (Python):

[source,python]
----
# прототип
def nicklist_remove_nick(buffer: str, nick: str) -> int: ...

# пример
weechat.nicklist_remove_nick(my_buffer, my_nick)
----

==== nicklist_remove_all

Уклања све групе/надимке из листе надимака.

Прототип:

[source,c]
----
void weechat_nicklist_remove_all (struct t_gui_buffer *buffer);
----

Аргументи:

* _buffer_: показивач на бафер

C пример:

[source,c]
----
weechat_nicklist_remove_all (my_buffer);
----

Скрипта (Python):

[source,python]
----
# прототип
def nicklist_remove_all(buffer: str) -> int: ...

# пример
weechat.nicklist_remove_all(my_buffer)
----

==== nicklist_get_next_item

_WeeChat ≥ 0.3.7._

Враћа наредну групу или надимак из листе надимака (углавном се користи код приказа листе надимака).

Прототип:

[source,c]
----
void weechat_nicklist_get_next_item (struct t_gui_buffer *buffer,
                                     struct t_gui_nick_group **group,
                                     struct t_gui_nick **nick);
----

Аргументи:

* _buffer_: показивач на бафер
* _group_: показивач на показивач групе
* _nick_: показивач на показивач надимка

C пример:

[source,c]
----
struct t_gui_nick_group *ptr_group;
struct t_gui_nick *ptr_nick;

ptr_group = NULL;
ptr_nick = NULL;
weechat_nicklist_get_next_item (buffer, &ptr_group, &ptr_nick);
while (ptr_group || ptr_nick)
{
    if (ptr_nick)
    {
        /* надимак */
        /* ... */
    }
    else
    {
        /* група */
        /* ... */
    }
    weechat_nicklist_get_next_item (buffer, &ptr_group, &ptr_nick);
}
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== nicklist_group_get_integer

_WeeChat ≥ 0.3.4._

Враћа целобројну вредност особине групе.

Прототип:

[source,c]
----
int weechat_nicklist_group_get_integer (struct t_gui_buffer *buffer,
                                        struct t_gui_nick_group *group,
                                        const char *property);
----

Аргументи:

* _buffer_: показивач на бафер
* _group_: показивач на групу
* _property_: име особине:
** _visible_: 1 ако је група видљива, у супротном 0
** _level_: ниво групе (корен је 0)

Повратна вредност:

* целобројна вредност особине

C пример:

[source,c]
----
int visible = weechat_nicklist_group_get_integer (buffer, group, "visible");
----

Скрипта (Python):

[source,python]
----
# прототип
def nicklist_group_get_integer(buffer: str, group: str, property: str) -> int: ...

# пример
visible = weechat.nicklist_group_get_integer(buffer, group, "visible")
----

==== nicklist_group_get_string

_WeeChat ≥ 0.3.4._

Враћа стринг вредност особине групе.

Прототип:

[source,c]
----
const char *weechat_nicklist_group_get_string (struct t_gui_buffer *buffer,
                                               struct t_gui_nick_group *group,
                                               const char *property);
----

Аргументи:

* _buffer_: показивач на бафер
* _group_: показивач на групу
* _property_: име особине:
** _id_: јединствени идентификатор _(WeeChat ≥ 4.3.0)_
** _name_: име групе
** _color_: боја групе у листи надимака

Повратна вредност:

* стринг вредност особине

C пример:

[source,c]
----
const char *color = weechat_nicklist_group_get_string (buffer, group, "color");
----

Скрипта (Python):

[source,python]
----
# прототип
def nicklist_group_get_string(buffer: str, group: str, property: str) -> str: ...

# пример
color = weechat.nicklist_group_get_string(buffer, group, "color")
----

==== nicklist_group_get_pointer

_WeeChat ≥ 0.3.4._

Враћа вредност показивача на особину групе.

Прототип:

[source,c]
----
void *weechat_nicklist_group_get_pointer (struct t_gui_buffer *buffer,
                                          struct t_gui_nick_group *group,
                                          const char *property);
----

Аргументи:

* _buffer_: показивач на бафер
* _group_: показивач на групу
* _property_: име особине:
** _parent_: показивач на родитељску групу

Повратна вредност:

* вредност показивача на особину

C пример:

[source,c]
----
struct t_gui_nick_group *parent = weechat_nicklist_group_get_pointer (buffer, group, "parent");
----

Скрипта (Python):

[source,python]
----
# прототип
def nicklist_group_get_pointer(buffer: str, group: str, property: str) -> str: ...

# пример
parent = weechat.nicklist_group_get_pointer(buffer, group, "parent")
----

==== nicklist_group_set

_WeeChat ≥ 0.3.4, ажурирано у верзији 4.3.0._

Поставља стринг вредност особине групе.

Прототип:

[source,c]
----
void weechat_nicklist_group_set (struct t_gui_buffer *buffer,
                                 struct t_gui_nick_group *group,
                                 const char *property,
                                 const char *value);
----

Аргументи:

* _buffer_: показивач на бафер
* _group_: показивач на групу
* _property_: име особине (погледајте табелу испод)
* _value_: нова вредност за особину

Особине:

[width="100%", cols="^2,^1,4,8", options="header"]
|===
| Име | Мин WeeChat | Вредност | Опис

| id | 4.3.0 | long long integer ≥ 0
| Нови id за групу (мора да биде јединствен за бафер). +
  Напомена: не препоручује се да мењате овај идентификатор.

| color | | Име опције WeeChat боје
| Погледајте аргумент „color” функције <<_nicklist_add_group,nicklist_add_group>>.

| visible | | "0", "1"
| "0" = скривена група, "1" = видљива група.
|===

C примери:

[source,c]
----
/* мења боју групе на "bar_fg" */
weechat_nicklist_group_set (buffer, group, "color", "bar_fg");

/* мења боју групе на жуту */
weechat_nicklist_group_set (buffer, group, "color", "yellow");

/* скрива групу у листи надимака */
weechat_nicklist_group_set (buffer, group, "visible", "0");
----

Скрипта (Python):

[source,python]
----
# прототип
def nicklist_group_set(buffer: str, group: str, property: str, value: str) -> int: ...

# примери

# мења боју групе на "bar_fg"
weechat.nicklist_group_set(buffer, group, "color", "bar_fg")

# мења боју групе на жуту
weechat.nicklist_group_set(buffer, group, "color", "yellow")

# скрива групу у листи надимака
weechat.nicklist_group_set(buffer, group, "visible", "0")
----

==== nicklist_nick_get_integer

_WeeChat ≥ 0.3.4._

Враћа целобројну вредност особине надимка.

Прототип:

[source,c]
----
int weechat_nicklist_nick_get_integer (struct t_gui_buffer *buffer,
                                       struct t_gui_nick *nick,
                                       const char *property);
----

Аргументи:

* _buffer_: показивач на бафер
* _nick_: показивач на надимак
* _property_: име особине:
** _visible_: 1 ако је надимак видљив, у супротном 0

Повратна вредност:

* целобројна вредност особине

C пример:

[source,c]
----
int visible = weechat_nicklist_nick_get_integer (buffer, nick, "visible");
----

Скрипта (Python):

[source,python]
----
# прототип
def nicklist_nick_get_integer(buffer: str, nick: str, property: str) -> int: ...

# пример
visible = weechat.nicklist_nick_get_integer(buffer, nick, "visible")
----

==== nicklist_nick_get_string

_WeeChat ≥ 0.3.4._

Враћа стринг вредност особине надимка.

Прототип:

[source,c]
----
const char *weechat_nicklist_nick_get_string (struct t_gui_buffer *buffer,
                                              struct t_gui_nick *nick,
                                              const char *property);
----

Аргументи:

* _buffer_: показивач на бафер
* _nick_: показивач на надимак
* _property_: име особине:
** _id_: јединствени идентификатор _(WeeChat ≥ 4.3.0)_
** _name_: име надимка
** _color_: боја надимка у листи надимака
** _prefix_: префикс надимка
** _prefix_color_: боја префикса у листи надимака

Повратна вредност:

* стринг вредност особине

C пример:

[source,c]
----
const char *color = weechat_nicklist_nick_get_string (buffer, nick, "color");
----

Скрипта (Python):

[source,python]
----
# прототип
def nicklist_nick_get_string(buffer: str, nick: str, property: str) -> str: ...

# пример
color = weechat.nicklist_nick_get_string(buffer, nick, "color")
----

==== nicklist_nick_get_pointer

_WeeChat ≥ 0.3.4._

Враћа вредност показивача на особину надимка.

Прототип:

[source,c]
----
void *weechat_nicklist_nick_get_pointer (struct t_gui_buffer *buffer,
                                         struct t_gui_nick *nick,
                                         const char *property);
----

Аргументи:

* _buffer_: показивач на бафер
* _nick_: показивач на надимак
* _property_: име особине:
** _group_: показивач на групу у којој се налази овај надимак

Повратна вредност:

* вредност показивача на особину

C пример:

[source,c]
----
struct t_gui_nick_group *group = weechat_nicklist_nick_get_pointer (buffer, nick, "group");
----

Скрипта (Python):

[source,python]
----
# прототип
def nicklist_nick_get_pointer(buffer: str, nick: str, property: str) -> str: ...

# пример
group = weechat.nicklist_nick_get_pointer(buffer, nick, "group")
----

==== nicklist_nick_set

_WeeChat ≥ 0.3.4, ажурирано у верзији 4.3.0._

Поставља стринг вредност особине надимка.

Прототип:

[source,c]
----
void weechat_nicklist_nick_set (struct t_gui_buffer *buffer,
                                struct t_gui_nick *nick,
                                const char *property,
                                const char *value);
----

Аргументи:

* _buffer_: показивач на бафер
* _nick_: показивач на надимак
* _property_: име особине (погледајте табелу испод)
* _value_: нова вредност за особину

Особине:

[width="100%", cols="^2,^1,4,8", options="header"]
|===
| Име | Мин WeeChat | Вредност | Опис

| id | 4.3.0 | long long integer ≥ 0
| Нови id за надимак (мора да буде јединствен за бафер). +
  Напомена: не препоручује се да мењате овај идентификатор.

| color | | име опције WeeChat боје
| Погледајте аргумент „color” функције <<_nicklist_add_nick,nicklist_add_nick>>.

| prefix | | било који стринг
| Префикс надимка.

| prefix_color | | име опције WeeChat боје
| Погледајте аргумент „prefix_color” функције <<_nicklist_add_nick,nicklist_add_nick>>.

| visible | | "0", "1"
| "0" = скривени надимак, "1" = видљиви надимак.
|===

C примери:

[source,c]
----
/* мења боју надимка у цијан */
weechat_nicklist_nick_set (buffer, nick, "color", "cyan");

/* мења префикс на „+” */
weechat_nicklist_nick_set (buffer, nick, "prefix", "+");

/* мења боју префикса у жуту */
weechat_nicklist_nick_set (buffer, nick, "prefix_color", "yellow");

/* скрива надимак у листи надимака */
weechat_nicklist_nick_set (buffer, nick, "visible", "0");
----

Скрипта (Python):

[source,python]
----
# прототип
def nicklist_nick_set(buffer: str, nick: str, property: str, value: str) -> int: ...

# примери

# мења боју надимка у цијан
weechat.nicklist_nick_set(buffer, nick, "color", "cyan")

# мења префикс у „+”
weechat.nicklist_nick_set(buffer, nick, "prefix", "+")

# мења боју префикса у жуту
weechat.nicklist_nick_set(buffer, nick, "prefix_color", "yellow")

# скрива надимак у листи надимака
weechat.nicklist_nick_set(buffer, nick, "visible", "0")
----

[[bars]]
=== Траке

Функције за траке.

==== bar_item_search

Тражи ставку траке.

Прототип:

[source,c]
----
struct t_gui_bar_item *weechat_bar_item_search (const char *name);
----

Аргументи:

* _name_: име ставке траке

Повратна вредност:

* показивач на пронађену ставку траке, NULL ако се ставка траке не пронађе

C пример:

[source,c]
----
struct t_gui_bar_item *bar_item = weechat_bar_item_search ("myitem");
----

Скрипта (Python):

[source,python]
----
# прототип
def bar_item_search(name: str) -> str: ...

# пример
bar_item = weechat.bar_item_search("myitem")
----

==== bar_item_new

_Ажурирано у верзијама 0.4.2, 1.5._

Креира нову ставку траке.

Прототип:

[source,c]
----
struct t_gui_bar_item *weechat_bar_item_new (const char *name,
                                             char *(*build_callback)(const void *pointer,
                                                                     void *data,
                                                                     struct t_gui_bar_item *item,
                                                                     struct t_gui_window *window,
                                                                     struct t_gui_buffer *buffer,
                                                                     struct t_hashtable *extra_info),
                                             const void *build_callback_pointer,
                                             void *build_callback_data);
----

Аргументи:

* _name_: име ставке траке
* _build_callback_: функција која се позива када се изгради нова ставка траке, аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _struct t_gui_bar_item *item_: показивач на ставку
** _struct t_gui_window *window_: показивач на прозор (NULL када се позове за корену траку)
** _struct t_gui_buffer *buffer_: бафер који се приказује у прозору (ако је прозор NULL, онда је то текући бафер) или бафер наведен у ставки траке према синтакси: „@бафер:ставка” _(WeeChat ≥ 0.4.2)_
** _struct t_hashtable *extra_info_: увек је NULL (аргумент је резервисан за будуће верзије) _(WeeChat ≥ 0.4.2)_
** повратна вредност: садржај ставке траке
* _build_callback_pointer_: показивач који се прослеђује функцији повратног позива изградње, када је позове програм WeeChat
* _build_callback_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако није NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се уклони ставка траке

Повратна вредност:

* показивач на нову ставку траке, NULL ако је дошло до грешке

C пример:

[source,c]
----
char *
my_build_callback (const void *pointer, void *data,
                   struct t_gui_bar_item *item,
                   struct t_gui_window *window,
                   struct t_gui_buffer *buffer,
                   struct t_hashtable *extra_info)
{
    return strdup ("my content");
}

struct t_gui_bar_item *my_item = weechat_bar_item_new ("myitem",
                                                       &my_build_callback,
                                                       NULL, NULL);
----

Скрипта (Python):

[IMPORTANT]
Из разлога компатибилности за верзијама ≤ 0.4.1, подразумевана функција повратног позива има само 3 аргумента: _data_, _item_ и _window_ (нема _buffer_ и _extra_info_). +
Ако желите да користите функцију повратног позива са свим аргументима, морате додати „(extra)” испред имена, погледајте пример испод (подржано је само у WeeChat ≥ 0.4.2).

[source,python]
----
# прототип
def bar_item_new(name: str, build_callback: str, build_callback_data: str) -> str: ...

# пример (функција повратног позива без „buffer” и „extra_info”)
def my_build_callback(data: str, item: str, window: str) -> str:
    return "my content"

bar_item = weechat.bar_item_new("myitem", "my_build_callback", "")

# пример (функција повратног позива са свим аргументима, за WeeChat ≥ 0.4.2)
def my_build_callback2(data: str, item: str, window: str, buffer: str, extra_info: Dict[str, str]) -> str:
    return "my content"

bar_item2 = weechat.bar_item_new("(extra)myitem2", "my_build_callback2", "")  # WeeChat ≥ 0.4.2
----

==== bar_item_update

Ажурира садржај ставке траке, позивањем њене функције повратног позива изградње.

Прототип:

[source,c]
----
void weechat_bar_item_update (const char *name);
----

Аргументи:

* _name_: име ставке траке

C пример:

[source,c]
----
weechat_bar_item_update ("myitem");
----

Скрипта (Python):

[source,python]
----
# прототип
def bar_item_update(name: str) -> int: ...

# пример
weechat.bar_item_update("myitem")
----

==== bar_item_remove

Уклања ставку траке.

Прототип:

[source,c]
----
void weechat_bar_item_remove (struct t_gui_bar_item *item);
----

Аргументи:

* _item_: показивач на ставку траке

C пример:

[source,c]
----
weechat_bar_item_remove (&my_item);
----

Скрипта (Python):

[source,python]
----
# прототип
def bar_item_remove(item: str) -> int: ...

# пример
weechat.bar_item_remove(myitem)
----

==== bar_search

Тражи траку.

Прототип:

[source,c]
----
struct t_gui_bar *weechat_bar_search (const char *name);
----

Аргументи:

* _name_: име траке

Повратна вредност:

* показивач на пронађену траку, NULL ако се трака не пронађе

C пример:

[source,c]
----
struct t_gui_bar *bar = weechat_bar_search ("mybar");
----

Скрипта (Python):

[source,python]
----
# прототип
def bar_search(name: str) -> str: ...

# пример
bar = weechat.bar_search("mybar")
----

==== bar_new

_Ажурирано у верзији 2.9, 4.0.0._

Креира нову траку.

Прототип:

[source,c]
----
struct t_gui_bar *weechat_bar_new (const char *name,
                                   const char *hidden,
                                   const char *priority,
                                   const char *type,
                                   const char *condition,
                                   const char *position,
                                   const char *filling_top_bottom,
                                   const char *filling_left_right,
                                   const char *size,
                                   const char *size_max,
                                   const char *color_fg,
                                   const char *color_delim,
                                   const char *color_bg,
                                   const char *color_bg_inactive,
                                   const char *separator,
                                   const char *items);
----

Аргументи:

* _name_: име траке
* _hidden_:
** _on_: трака је скривена
** _off_: трака је видљива
* _priority_: приоритет траке (цео број)
* _type_:
** _root_: трака је приказана једном, ван прозора
** _window_: трака се приказује у сваком прозору
* _condition_: услов за приказивање траке:
** _active_: трака се приказује само у активном прозору
** _inactive_: трака се приказује само у неактивним прозорима
** _nicklist_: трака се приказује у прозорима са листом надимака
** израчунати услови: погледајте link:weechat_user.sr.html#bar_conditions[WeeChat Корисничко упутство / Услови трака ^↗^^].
* _position_: _top_, _bottom_, _left_ или _right_
* _filling_top_bottom_:
** _horizontal_: ставке се попуњавају хоризонтално (размак након сваке ставке)
** _vertical_: ставке се попуњавају вертикално (прелом линије након сваке ставке)
** _columns_horizontal_: ставке се попуњавају хоризонтално, приказане по колонама
** _columns_vertical_: ставке се попуњавају вертикално, приказане по колонама
* _filling_left_right_:
** _horizontal_: ставке се попуњавају хоризонтално (размак након сваке ставке)
** _vertical_: ставке се попуњавају вертикално (прелом линије након сваке ставке)
** _columns_horizontal_: ставке се попуњавају хоризонтално, приказане по колонама
** _columns_vertical_: ставке се попуњавају вертикално, приказане по колонама
* _size_: величина траке у карактерима (0 значи аутоматска величина)
* _size_max_: максимална величина траке (0 значи без ограничења)
* _color_fg_: боја текста у траци
* _color_delim_: боја граничника у траци
* _color_bg_: боја позадине траке
* _color_bg_inactive_: боја позадине за траку прозора која се не приказује у активном прозору
* _separator_:
** _on_: трака има граничну линију са осталим прозорима/тракама
** _off_: нема граничника
* _items_: листа ставки у траци раздвојених запетама (за размак између ставки), или са „+” (за спојене ставке)

Повратна вредност:

* показивач на нову траку, NULL у случају грешке

[NOTE]
Почевши од верзије 4.0.0, ако трака већ постоји, WeeChat примљене вредности као
подразумеване вредности опција траке и уместо NULL враћа показивач на траку.

C пример:

[source,c]
----
struct t_gui_bar *my_bar = weechat_bar_new (
    "mybar", "off", "100", "window", "", "top", "horizontal", "vertical",
    "0", "5", "default", "cyan", "blue", "darkgray", "off",
    "time,buffer_number+buffer_name");
----

Скрипта (Python):

[source,python]
----
# прототип
def bar_new(name: str, hidden: str, priority: str, type: str, condition: str, position: str,
            filling_top_bottom: str, filling_left_right: str, size: str, size_max: str,
            color_fg: str, color_delim: str, color_bg: str, color_bg_inactive: str,
            separator: str, items: str) -> str: ...

# пример
bar = weechat.bar_new("mybar", "off", "100", "window", "", "top", "horizontal", "vertical",
    "0", "5", "default", "cyan", "blue", "darkgray", "off", "time,buffer_number+buffer_name")
----

[NOTE]
У програму WeeChat верзије ≥ 2.9, у језику Ruby, 4 боје (color_fg, color_delim, color_bg, color_bg_inactive) морају да се наведу у низу од 4 стринга (услед ограничења језика Ruby од 15 аргумената по функцији), за више информација погледајте link:++weechat_scripting.sr.html#_ruby++[WeeChat водич за скриптовање ^↗^^].

==== bar_set

Поставља нову вредност особине траке.

Прототип:

[source,c]
----
int weechat_bar_set (struct t_gui_bar *bar, const char *property,
                     const char *value);
----

Аргументи:

* _bar_: показивач на траку
* _property_: name, hidden, priority, conditions, position, filling_top_bottom, filling_left_right, size, size_max, color_fg, color_delim, color_bg, separator, items (погледајте <<_bar_new,bar_new>>)
* _value_: нова вредност за особину

Повратна вредност:

* 1 ако је нова вредност постављена, 0 у случају грешке

C пример:

[source,c]
----
weechat_bar_set (mybar, "position", "bottom");
----

Скрипта (Python):

[source,python]
----
# прототип
def bar_set(bar: str, property: str, value: str) -> int: ...

# пример
weechat.bar_set(my_bar, "position", "bottom")
----

==== bar_update

Освежава садржај траке на екрану.

Прототип:

[source,c]
----
void weechat_bar_update (const char *name);
----

Аргументи:

* _name_: име траке

C пример:

[source,c]
----
weechat_bar_update ("mybar");
----

Скрипта (Python):

[source,python]
----
# прототип
def bar_update(name: str) -> int: ...

# пример
weechat.bar_update("mybar")
----

==== bar_remove

Уклања траку.

Прототип:

[source,c]
----
void weechat_bar_remove (struct t_gui_bar *bar);
----

Аргументи:

* _bar_: показивач на траку

C пример:

[source,c]
----
weechat_bar_remove (mybar);
----

Скрипта (Python):

[source,python]
----
# прототип
def bar_remove(bar: str) -> int: ...

# пример
weechat.bar_remove(my_bar)
----

[[commands]]
=== Команде

Функције за извршавање WeeChat команди.

==== command

_Ажурирано у верзији 1.1, ажурирано у верзији 4.0.0._

Извршава команду или шаље текст у бафер.

Прототип:

[source,c]
----
int weechat_command (struct t_gui_buffer *buffer, const char *command);
----

Аргументи:

* _buffer_: показивач на бафер (команда се извршава у овом баферу, употребите NULL за текући бафер)
* _command_: команда која се извршава (ако почиње са „/”), или текст који се шаље у бафер

[NOTE]
За бафер којем је `input_multiline` постављено на `0` (подразумевано), извршава се само прва
команда (пре првог карактера прелома реда: `\n`).

Повратна вредност _(WeeChat ≥ 1.1)_:

* _WEECHAT_RC_OK_ ако је успешно
* _WEECHAT_RC_ERROR_ ако је дошло до грешке

C пример:

[source,c]
----
int rc;
rc = weechat_command (weechat_buffer_search ("irc", "libera.#weechat"),
                      "/whois FlashCode");
----

Скрипта (Python):

[source,python]
----
# прототип
def command(buffer: str, command: str) -> int: ...

# пример
rc = weechat.command(weechat.buffer_search("irc", "libera.#weechat"), "/whois FlashCode")
----

==== command_options

_WeeChat ≥ 2.5, ажурирано у верзији 4.0.0, 4.5.0._

Извршава команду или шаље текст у бафер са опцијама.

Прототип:

[source,c]
----
int weechat_command_options (struct t_gui_buffer *buffer, const char *command,
                             struct t_hashtable *options);
----

Аргументи:

* _buffer_: показивач на бафер (команда се извршава у овом баферу, употребите NULL за текући бафер)
* _command_: команда која се извршава (ако почиње са `/` или командним карактером), или текст који се шаље у бафер
* _options_: хеш табела са неким опцијама (кључеви и вредности морају бити стринг) (може да буде NULL):
** _commands_: листа команди које смеју да се изврше током овог позива раздвојене запетама
   (за формат, погледајте функцију <<_string_match_list,string_match_list>>);
   специјална вредност `-` (цртица-минус) искључује извршавање команди
   и стрингу _command_ се шаље у бафер онакав какав је (_WeeChat ≥ 4.5.0_)
** _delay_: пауза за извршавање команде, у милисекундама
** _split_newline_: `1` да се команде поделе на карактеру прелома линије (`\n`) (_WeeChat ≥ 4.0.0_)

Повратна вредност:

* _WEECHAT_RC_OK_ ако је успешно
* _WEECHAT_RC_ERROR_ ако је дошло до грешке

C пример:

[source,c]
----
/* дозвољава се било која команда одим /exec, команда се извршава у року од 2 секунде */
int rc;
struct t_hashtable *options = weechat_hashtable_new (8,
                                                     WEECHAT_HASHTABLE_STRING,
                                                     WEECHAT_HASHTABLE_STRING,
                                                     NULL,
                                                     NULL);
weechat_hashtable_set (options, "commands", "*,!exec");
weechat_hashtable_set (options, "delay", "2000");
rc = weechat_command_options (NULL, "/some_command arguments", options);
----

Скрипта (Python):

[source,python]
----
# прототип
def command_options(buffer: str, command: str, options: Dict[str, str]) -> int: ...

# пример: дозвољава се било која команда осим /exec
rc = weechat.command_options("", "/some_command arguments", {"commands": "*,!exec", "delay": "2000"})
----

[[completion]]
=== Довршавање

Функције за довршавање командне линије.

==== completion_new

_WeeChat ≥ 2.9._

Креира ново довршавање.

Прототип:

[source,c]
----
struct t_gui_completion *weechat_completion_new (struct t_gui_buffer *buffer);
----

Аргументи:

* _buffer_: показивач на бафер

Повратна вредност:

* показивач на ново довршавање

C пример:

[source,c]
----
struct t_gui_completion *completion = weechat_completion_new (weechat_buffer_search_main ());
----

Скрипта (Python):

[source,python]
----
# прототип
def completion_new(buffer: str) -> str: ...

# пример
completion = weechat.completion_new(weechat.buffer_search_main())
----

==== completion_search

_WeeChat ≥ 2.9._

Тражи могуће речи на датој позицији у стрингу, у контексту довршавања.

Прототип:

[source,c]
----
int weechat_completion_search (struct t_gui_completion *completion, const char *data,
                               int position, int direction);
----

Аргументи:

* _completion_: показивач на довршавање
* _data_: стринг који треба да се доврши
* _position_: индекс карактера у стрингу за довршавање (почиње од 0)
* _direction_: 1 за наредно довршавање, -1 за претходно довршавање

Повратна вредност:

* 1 ако је све OK, 0 у случају грешке

C пример:

[source,c]
----
struct t_gui_completion *completion = weechat_completion_new (weechat_buffer_search_main ());
if (weechat_completion_search (completion, "/help filt", 10, 1))
{
    /* ... */
}
----

Скрипта (Python):

[source,python]
----
# прототип
def completion_search(completion: str, data: str, position: int, direction: int) -> int: ...

# пример
completion = weechat.completion_new(weechat.buffer_search_main())
if weechat.completion_search(completion, "/help filt", 10, 1):
    # ...
----

==== completion_get_string

_WeeChat ≥ 2.9._

Враћа особину довршавања као стринг.

Прототип:

[source,c]
----
const char *weechat_completion_get_string (struct t_gui_completion *completion,
                                           const char *property);
----

Аргументи:

* _completion_: показивач на довршавање
* _property_: име особине:
** _base_command_: команда која се користи за довршавање
** _base_word_: реч која се довршава
** _args_: аргументи команде (укључујући и базну реч)

C пример:

[source,c]
----
int
my_completion_cb (const void *pointer, void *data, const char *completion_item,
                  struct t_gui_buffer *buffer,
                  struct t_gui_completion *completion)
{
    /* добијање аргумената команде */
    const char *args = weechat_completion_get_string (completion, "args");

    /* довршавање које зависи од args */
    /* ... */

    return WEECHAT_RC_OK;
}
----

Скрипта (Python):

[source,python]
----
# прототип
def completion_get_string(completion: str, property: str) -> str: ...

# пример
def my_completion_cb(data: str, completion_item: str, buffer: str, completion: str) -> int:
    # добавља аргументе команде
    args = weechat.completion_get_string(completion, "args")
    # довршавање у зависности од args
    # ...
    return weechat.WEECHAT_RC_OK
----

==== completion_set

_WeeChat ≥ 4.6.0._

// TRANSLATION MISSING
Set a completion property.

Прототип:

[source,c]
----
void weechat_completion_get_string (struct t_gui_completion *completion,
                                    const char *property,
                                    const char *value);
----

Аргументи:

* _completion_: показивач на довршавање
* _property_: име особине (погледајте табелу испод)
* _value_: нова вредност за особину

Особине:

[width="100%",cols="^2,^1,4,8",options="header"]
|===
| Име | Мин WeeChat | Вредност | Опис

// TRANSLATION MISSING
| add_space | 4.6.0 | "0" or "1"
| "0": do not add space after completion +
  "1": add space after completion (default).
|===

C пример:

[source,c]
----
int
my_completion_cb (const void *pointer, void *data, const char *completion_item,
                  struct t_gui_buffer *buffer,
                  struct t_gui_completion *completion)
{
    /* do not add space after completion */
    weechat_completion_set (completion, "add_space", "0");

    /* ... */

    return WEECHAT_RC_OK;
}
----

Скрипта (Python):

[source,python]
----
# прототип
def completion_set(completion: str, property: str, value: str) -> int: ...

# пример
def my_completion_cb(data: str, completion_item: str, buffer: str, completion: str) -> int:
    # do not add space after completion
    weechat.completion_set(completion, "add_space", "0")
    # ...
    return weechat.WEECHAT_RC_OK
----

==== completion_list_add

_WeeChat ≥ 2.9._

Додаје реч за довршавање.

Прототип:

[source,c]
----
void weechat_completion_list_add (struct t_gui_completion *completion,
                                  const char *word,
                                  int nick_completion,
                                  const char *where);
----

Аргументи:

* _completion_: показивач на довршавање
* _word_: реч која се додаје
* _nick_completion_: 1 ако је реч надимак, у супротном 0
* _where_: позиција у листи на коју ће се уметнути реч:
** _WEECHAT_LIST_POS_SORT_: било која позиција, да листа остане сортирана
** _WEECHAT_LIST_POS_BEGINNING_: почетак листе
** _WEECHAT_LIST_POS_END_: крај листе

C пример: погледајте <<_hook_completion,hook_completion>>.

Скрипта (Python):

[source,python]
----
# прототип
def completion_list_add(completion: str, word: str, nick_completion: int, where: str) -> int: ...

# пример: погледајте функцију hook_completion
----

==== completion_free

_WeeChat ≥ 2.9._

Ослобађа меморију коју користи довршавање.

Прототип:

[source,c]
----
void weechat_completion_free (struct t_gui_completion *completion);
----

Аргументи:

* _completion_: показивач на довршавање

C пример:

[source,c]
----
weechat_completion_free (completion);
----

Скрипта (Python):

[source,python]
----
# прототип
def completion_free(completion: str) -> int: ...

# пример
weechat.completion_free(completion)
----

[[network]]
=== Мрежа

Мрежне функције.

==== network_pass_proxy

Успоставља везу/аутентификацију са проксијем.

[IMPORTANT]
Ова функција је блокирајућа на позиву функције connect(), тако да једино сме да се позове из рачваног процеса па да не блокира програм WeeChat.

Прототип:

[source,c]
----
int weechat_network_pass_proxy (const char *proxy,
                                int sock,
                                const char *address,
                                int port);
----

Аргументи:

* _proxy_: име проксија који треба да се користи
* _sock_: сокет који треба да се користи
* _address_: адреса (име хоста или IP адреса)
* _port_: порт

Повратна вредност:

* 1 ако је веза OK, 0 у случају да је дошло до грешке

C пример:

[source,c]
----
if (weechat_network_pass_proxy ("my_proxy", sock, "irc.libera.chat", 6667))
{
    /* OK */
}
else
{
    /* грешка */
}
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== network_connect_to

_Ажурирано у верзији 0.4.3._

Успоставља везу са удаљеним хостом.

[IMPORTANT]
Ова функција је блокирајућа на позиву функције connect(), тако да једино сме да се позове из рачваног процеса па да не блокира програм WeeChat.

Прототип:

[source,c]
----
int weechat_network_connect_to (const char *proxy,
                                struct sockaddr *address,
                                socklen_t address_length);
----

Аргументи:

* _proxy_: име проксија који треба да се користи
* _address_: адреса са којом се повезује (са портом)
* _address_length_: дужина аргумента _address_

Повратна вредност:

* број сокета (≥ 0) ако је веза OK, -1 у случају да је дошло до грешке

C пример:

[source,c]
----
struct sockaddr *addr;
socklen_t length;
int sock;

/* алоцирање/постављање адресе и порта у _addr_, постављање _length_ */
/* ... */

sock = weechat_network_connect_to (NULL, addr, length);
if (sock >= 0)
{
    /* OK */
}
else
{
    /* грешка */
}
----

[NOTE]
Ова функција није доступна у API скриптовања.

[[infos]]
=== Информације

Функције које враћају информације.

==== info_get

_Ажурирано у верзији 2.5._

Враћа инфо као стринг, из програма WeeChat или из додатка.

Прототип:

[source,c]
----
char *weechat_info_get (const char *info_name, const char *arguments);
----

Аргументи:

* _info_name_: име инфо који желите да прочитате (погледајте табелу испод)
* _arguments_: аргументи тражене инфо (није обавезно, NULL у случају да није потребан аргумент)

Повратна вредност:

* стринг са траженом инфо, NULL у случају да је дошло до грешке (након употребе мора да се ослободи позивом „free”)

[NOTE]
У програму WeeChat ≥ 2.5, враћена вредност је алоцирани стринг (у WeeChat ≤ 2.4, то је био показивач на статички стринг).

Информације:

include::{autogendir}/autogen_api_infos.sr.adoc[tag=infos]

C пример:

[source,c]
----
char *version = weechat_info_get ("version", NULL);
char *date = weechat_info_get ("date", NULL);
weechat_printf (NULL, "Тренутна WeeChat верзија је: %s (компајлирана %s)",
                version, date);
if (version)
    free (version);
if (date)
    free (date);

char *weechat_config_dir = weechat_info_get ("weechat_config_dir", NULL);
weechat_printf (NULL, "WeeChat конфиг директоријум је: %s", weechat_config_dir);
if (weechat_config_dir)
    free (weechat_config_dir);
----

Скрипта (Python):

[source,python]
----
# прототип
def info_get(info_name: str, arguments: str) -> str: ...

# пример
weechat.prnt("", "Текућа WeeChat везија је: %s (компајлирана %s)"
    % (weechat.info_get("version", ""), weechat.info_get("date", ""))
weechat.prnt("", "WeeChat конфиг директоријум је: %s" % weechat.info_get("weechat_config_dir", ""))
----

==== info_get_hashtable

_WeeChat ≥ 0.3.4._

Враћа инфо као хеш табелу, из програма WeeChat или из додатка.

Прототип:

[source,c]
----
struct t_hashtable *weechat_info_get_hashtable (const char *info_name,
                                                struct t_hashtable *hashtable);
----

Аргументи:

* _info_name_: име инфо који желите да прочитате (погледајте табелу испод)
* _hashtable_: хеш табела са аргументима (зависи од тражене инфо) (није обавезна, NULL у случају да аргумент није потребан)

Повратна вредност:

* хеш табела са траженом инфо, NULL у случају да је дошло до грешке (након
  употребе мора да се ослободи позивом <<_hashtable_free,hashtable_free>>)

Информације:

include::{autogendir}/autogen_api_infos_hashtable.sr.adoc[tag=infos_hashtable]

C пример:

[source,c]
----
struct t_hashtable *hashtable_in, *hashtable_out;

hashtable_in = weechat_hashtable_new (8,
                                      WEECHAT_HASHTABLE_STRING,
                                      WEECHAT_HASHTABLE_STRING,
                                      NULL,
                                      NULL);
if (hashtable_in)
{
    weechat_hashtable_set (
        hashtable_in,
        "message",
        "@time=2015-06-27T16:40:35.000Z;tag2=value\\sspace :nick!user@host PRIVMSG #weechat :Hello world!");
    hashtable_out = weechat_info_get_hashtable ("irc_message_parse",
                                                hashtable_in);
    /*
     * сада hashtable_out има следеће кључеве/вредности:
     *   "tags"                : "time=2015-06-27T16:40:35.000Z;tag2=value\\sspace"
     *   "tag_time"            : "2015-06-27T16:40:35.000Z"
     *   "tag_tag2"            : "value space"
     *   "message_without_tags": ":nick!user@host PRIVMSG #weechat :Hello world!"
     *   "nick"                : "nick"
     *   "user"                : "user"
     *   "host"                : "nick!user@host"
     *   "command"             : "PRIVMSG"
     *   "channel"             : "#weechat"
     *   "arguments"           : "#weechat :Hello world!"
     *   "text"                : "Hello world!"
     *   "param1"              : "#weechat"
     *   "param2"              : "Hello world!"
     *   "num_params"          : "2"
     *   "pos_command"         : "65"
     *   "pos_arguments"       : "73"
     *   "pos_channel"         : "73"
     *   "pos_text"            : "83"
     */
    weechat_hashtable_free (hashtable_in);
    weechat_hashtable_free (hashtable_out);
}
----

[NOTE]
Погледајте link:weechat_scripting.sr.html#irc_message_parse[WeeChat водич за скриптовање / Парсирање поруке ^↗^^] за више информација у вези излаза „irc_message_parse”.

Скрипта (Python):

[source,python]
----
# прототип
def info_get_hashtable(info_name: str, dict_in: Dict[str, str]) -> Dict[str, str]: ...

# пример
dict_in = {"message": ":nick!user@host PRIVMSG #weechat :message here"}
weechat.prnt("", "message parsed: %s"
             % weechat.info_get_hashtable("irc_message_parse", dict_in))
----

[[infolists]]
=== Инфолисте

Инфолиста је листа „ставки”. Свака ставка садржи променљиве.

На пример, инфолиста „irc_server” има N ставки (N је број дефинисаних IRC сервера). За сваку ставку постоје променљиве као што су „name”, „buffer”, „is_connected”...

Свака променљива има тип и вредност. Могући типови су:

* _integer_: било која целобројна вредност
* _string_: било која стринг вредност
* _pointer_: било који показивач
* _buffer_: бафер фиксне величине, може да садржи било какве податке
* _time_: временска вредност

==== infolist_new

Креира нову инфолисту.

Прототип:

[source,c]
----
struct t_infolist *weechat_infolist_new ();
----

Повратна вредност:

* показивач на нову инфолисту

C пример:

[source,c]
----
struct t_infolist *infolist = weechat_infolist_new ();
----

Скрипта (Python):

[source,python]
----
# прототип
def infolist_new() -> str: ...

# пример
infolist = weechat.infolist_new()
----

==== infolist_new_item

Додаје ставку и инфолисту.

Прототип:

[source,c]
----
struct t_infolist_item *weechat_infolist_new_item (struct t_infolist *infolist);
----

Аргументи:

* _infolist_: показивач на инфо листу

Повратна вредност:

* показивач на нову ставку

C пример:

[source,c]
----
struct t_infolist_item *item = weechat_infolist_new_item (infolist);
----

Скрипта (Python):

[source,python]
----
# прототип
def infolist_new_item(infolist: str) -> str: ...

# пример
item = weechat.infolist_new_item(infolist)
----

==== infolist_new_var_integer

Додаје целобројну променљиву у ставку инфолисте.

Прототип:

[source,c]
----
struct t_infolist_var *weechat_infolist_new_var_integer (struct t_infolist_item *item,
                                                         const char *name,
                                                         int value);
----

Аргументи:

* _item_: показивач на ставку инфолисте
* _name_: име променљиве
* _value_: целобројна вредност

Повратна вредност:

* показивач на нову променљиву

C пример:

[source,c]
----
struct t_infolist_var *var = weechat_infolist_new_var_integer (item,
                                                               "my_integer",
                                                               123);
----

Скрипта (Python):

[source,python]
----
# прототип
def infolist_new_var_integer(item: str, name: str, value: int) -> str: ...

# пример
var = weechat.infolist_new_var_integer(item, "my_integer", 123)
----

==== infolist_new_var_string

Додаје стринг променљиву у ставку инфолисте.

Прототип:

[source,c]
----
struct t_infolist_var *weechat_infolist_new_var_string (struct t_infolist_item *item,
                                                        const char *name,
                                                        const char *value);
----

Аргументи:

* _item_: показивач на ставку инфолисте
* _name_: име променљиве
* _value_: стринг вредност

Повратна вредност:

* показивач на нову променљиву

C пример:

[source,c]
----
struct t_infolist_var *var = weechat_infolist_new_var_string (item,
                                                              "my_string",
                                                              "value");
----

Скрипта (Python):

[source,python]
----
# прототип
def infolist_new_var_string(item: str, name: str, value: str) -> str: ...

# пример
var = weechat.infolist_new_var_string(item, "my_string", "value")
----

==== infolist_new_var_pointer

Додаје показивач променљиву у ставку инфолисте.

Прототип:

[source,c]
----
struct t_infolist_var *weechat_infolist_new_var_pointer (struct t_infolist_item *item,
                                                         const char *name,
                                                         void *pointer);
----

Аргументи:

* _item_: показивач на ставку инфолисте
* _name_: име променљиве
* _pointer_: показивач

Повратна вредност:

* показивач на нову променљиву

C пример:

[source,c]
----
struct t_infolist_var *var = weechat_infolist_new_var_pointer (item,
                                                               "my_pointer",
                                                               &pointer);
----

Скрипта (Python):

[source,python]
----
# прототип
def infolist_new_var_pointer(item: str, name: str, pointer: str) -> str: ...

# пример
var = weechat.infolist_new_var_pointer(item, "my_pointer", pointer)
----

==== infolist_new_var_buffer

Додаје бафер променљиву у ставку инфолисте.

Прототип:

[source,c]
----
struct t_infolist_var *weechat_infolist_new_var_buffer (struct t_infolist_item *item,
                                                        const char *name,
                                                        void *pointer,
                                                        int size);
----

Аргументи:

* _item_: показивач на ставку инфолисте
* _name_: име променљиве
* _pointer_: показивач на бафер
* _size_: величина бафера

Повратна вредност:

* показивач на нову променљиву

C пример:

[source,c]
----
char buffer[256];
/* ... */
struct t_infolist_var *var = weechat_infolist_new_var_buffer (item,
                                                              "my_buffer",
                                                              &buffer,
                                                              sizeof (buffer));
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== infolist_new_var_time

Додаје временску променљиву у ставку инфолисте.

Прототип:

[source,c]
----
struct t_infolist_var *weechat_infolist_new_var_time (struct t_infolist_item *item,
                                                      const char *name,
                                                      time_t time);
----

Аргументи:

* _item_: показивач на ставку инфолисте
* _name_: име променљиве
* _time_: временска вредност

Повратна вредност:

* показивач на нову променљиву

C пример:

[source,c]
----
struct t_infolist_var *var = weechat_infolist_new_var_time (item,
                                                            "my_time",
                                                            time (NULL));
----

Скрипта (Python):

[source,python]
----
# прототип
def infolist_new_var_time(item: str, name: str, time: int) -> str: ...

# пример
var = weechat.infolist_new_var_time(item, "my_time", int(time.time()))
----

==== infolist_get

Враћа инфолисту из програма WeeChat или из додатка.

[IMPORTANT]
Садржај инфолисте је копија актуелних података. Тако да ако тражите инфолисту са доста информација (као што је „buffer_lines”), програм WeeChat ће алоцирати меморију да дуплира све податке, а то може одузети доста времена. +
Уместо да да користите велику инфолисту, пожељно је да користите hdata (мада инфолиста може да садржи више информација од hdata, који представља сирове податке), погледајте <<hdata,hdata>>.

Прототип:

[source,c]
----
struct t_infolist *weechat_infolist_get (const char *infolist_name,
                                         void *pointer,
                                         const char *arguments);
----

Аргументи:

* _infolist_name_: име инфолисте коју желите да прочитате (погледајте табелу испод)
* _pointer_: показивач на ставку, ако желите само ову ставку из инфолисте (није обавезан, може да буде NULL)
* _arguments_: аргументи тражене инфолисте (нису обавезни, NULL ако аргументи нису потребни)

Повратна вредност:

* показивач на инфолисту, NULL у случају да је дошло до грешке

Инфолисте:

include::{autogendir}/autogen_api_infolists.sr.adoc[tag=infolists]

C пример:

[source,c]
----
struct t_infolist *infolist = weechat_infolist_get ("irc_server", NULL, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def infolist_get(infolist_name: str, pointer: str, arguments: str) -> str: ...

# пример
infolist = weechat.infolist_get("irc_server", "", "")
----

==== infolist_next

Помера „курсор” на наредну ставку у инфолисти. Први позив ове функције за неку инфолисту помера курсор на прву ставку те инфолисте.

Прототип:

[source,c]
----
int weechat_infolist_next (struct t_infolist *infolist);
----

Аргументи:

* _infolist_: показивач на инфо листу

Повратна вредност:

* 1 ако се курсор померио на наредну ставку, 0 у случају да је достигнут крај листе

C пример:

[source,c]
----
if (weechat_infolist_next (infolist))
{
    /* читање променљивих из ставке... */
}
else
{
    /* нема више ниједне ставке */
}
----

Скрипта (Python):

[source,python]
----
# прототип
def infolist_next(infolist: str) -> int: ...

# пример
rc = weechat.infolist_next(infolist)
if rc:
    # читање променљивих из ставке...
else:
    # нема више ниједне ставке
----

==== infolist_prev

Помера „курсор” на претходну ставку у инфолисти. Први позив ове функције над инфолистом помера курсор на крај те инфолисте.

Прототип:

[source,c]
----
int weechat_infolist_prev (struct t_infolist *infolist);
----

Аргументи:

* _infolist_: показивач на инфо листу

Повратна вредност:

* 1 ако се курсор померио на претходну ставку, 0 у случају да је достигнут почетак листе

C пример:

[source,c]
----
if (weechat_infolist_prev (infolist))
{
    /* читање променљивих у ставки... */
}
else
{
    /* нема више ниједне ставке */
}
----

Скрипта (Python):

[source,python]
----
# прототип
def infolist_prev(infolist: str) -> int: ...

# пример
rc = weechat.infolist_prev(infolist)
if rc:
    # читање променљивих из ставке...
else:
    # нема више ниједне ставке
----

==== infolist_reset_item_cursor

Ресетује „курсор” за инфолисту.

Прототип:

[source,c]
----
void weechat_infolist_reset_item_cursor (struct t_infolist *infolist);
----

Аргументи:

* _infolist_: показивач на инфо листу

C пример:

[source,c]
----
weechat_infolist_reset_item_cursor (infolist);
----

Скрипта (Python):

[source,python]
----
# прототип
def infolist_reset_item_cursor(infolist: str) -> int: ...

# пример
weechat.infolist_reset_item_cursor(infolist)
----

==== infolist_search_var

_WeeChat ≥ 0.4.3._

Тражи променљиву у текућој ставки инфолисте.

Прототип:

[source,c]
----
struct t_infolist_var *weechat_infolist_search_var (struct t_infolist *infolist,
                                                    const char *name);
----

Аргументи:

* _infolist_: показивач на инфо листу
* _name_: име променљиве

Повратна вредност:

* показивач на пронађену променљиву, NULL у случају да се променљива не пронађе

C пример:

[source,c]
----
if (weechat_infolist_search_var (infolist, "name"))
{
    /* променљива „name” постоји */
    /* ... */
}
----

Скрипта (Python):

[source,python]
----
# прототип
def infolist_search_var(infolist: str, name: str) -> str: ...

# пример
if weechat.infolist_search_var(infolist, "name"):
    # променљива „name” постоји
    # ...
----

==== infolist_fields

Враћа листу поља текуће ставке инфолисте.

Прототип:

[source,c]
----
const char *weechat_infolist_fields (struct t_infolist *infolist);
----

Аргументи:

* _infolist_: показивач на инфо листу

Повратна вредност:

* стринг са листом поља текуће ставке инфолисте. Листа је раздвојена запетама и садржи слово за тип, након кога следи име променљиве. Типови су: „i” (integer), „s” (string), „p” (pointer), „b” (buffer), „t” (time).

C пример:

[source,c]
----
const char *fields = weechat_infolist_fields (infolist);
/* поља садрже нешто слично овоме:
   „i:my_integer,s:my_string,p:my_pointer,b:my_buffer,t:my_time” */
----

Скрипта (Python):

[source,python]
----
# прототип
def infolist_fields(infolist: str) -> str: ...

# пример
fields = weechat.infolist_fields(infolist)
# поља садрже нешто слично овоме:
# „i:my_integer,s:my_string,p:my_pointer,b:my_buffer,t:my_time”
----

==== infolist_integer

Враћа вредност целобројне променљиве из текуће ставке инфолисте.

Прототип:

[source,c]
----
int weechat_infolist_integer (struct t_infolist *infolist, const char *var);
----

Аргументи:

* _infolist_: показивач на инфо листу
* _var_: име променљиве (мора бити типа „integer”)

Повратна вредност:

* целобројна вредност променљиве

C пример:

[source,c]
----
weechat_printf (NULL, "integer = %d",
                weechat_infolist_integer (infolist, "my_integer"));
----

Скрипта (Python):

[source,python]
----
# прототип
def infolist_integer(infolist: str, var: str) -> int: ...

# пример
weechat.prnt("", "integer = %d" % weechat.infolist_integer(infolist, "my_integer"))
----

==== infolist_string

Враћа вредност стринг променљиве из текуће ставке инфолисте.

Прототип:

[source,c]
----
const char *weechat_infolist_string (struct t_infolist *infolist, const char *var);
----

Аргументи:

* _infolist_: показивач на инфо листу
* _var_: име променљиве (мора бити типа „string”)

Повратна вредност:

* стринг вредност променљиве

C пример:

[source,c]
----
weechat_printf (NULL, "string = %s",
                weechat_infolist_string (infolist, "my_string"));
----

Скрипта (Python):

[source,python]
----
# прототип
def infolist_string(infolist: str, var: str) -> str: ...

# пример
weechat.prnt("", "string = %s" % weechat.infolist_string(infolist, "my_string"))
----

==== infolist_pointer

Враћа вредност показивач променљиве из текуће ставке инфолисте.

Прототип:

[source,c]
----
void *weechat_infolist_pointer (struct t_infolist *infolist, const char *var);
----

Аргументи:

* _infolist_: показивач на инфо листу
* _var_: име променљиве (мора бити типа „pointer”)

Повратна вредност:

* показивач вредност променљиве

C пример:

[source,c]
----
weechat_printf (NULL, "pointer = %p", weechat_infolist_pointer (infolist, "my_pointer"));
----

Скрипта (Python):

[source,python]
----
# прототип
def infolist_pointer(infolist: str, var: str) -> str: ...

# пример
weechat.prnt("", "pointer = 0x%s" % weechat.infolist_pointer(infolist, "my_pointer"))
----

==== infolist_buffer

Враћа вредност бафер променљиве из текуће ставке инфолисте.

Прототип:

[source,c]
----
void *weechat_infolist_buffer (struct t_infolist *infolist, const char *var,
                               int *size);
----

Аргументи:

* _infolist_: показивач на инфо листу
* _var_: име променљиве (мора бити типа „buffer”)
* _size_: показивач на целобројну променљиву, поставиће се на величину бафера

Повратна вредност:

* показивач на бафер

C пример:

[source,c]
----
int size;
void *pointer = weechat_infolist_buffer (infolist, "my_buffer", &size);
weechat_printf (NULL, "buffer = %p, size = %d", pointer, size);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== infolist_time

Враћа вредност временске променљиве из текуће ставке инфолисте.

Прототип:

[source,c]
----
time_t weechat_infolist_time (struct t_infolist *infolist, const char *var);
----

Аргументи:

* _infolist_: показивач на инфо листу
* _var_: име променљиве (мора бити типа „time”)

Повратна вредност:

* временска вредност променљиве

C пример:

[source,c]
----
weechat_printf (NULL, "time = %ld",
                weechat_infolist_time (infolist, "my_time"));
----

Скрипта (Python):

[source,python]
----
# прототип
def infolist_time(infolist: str, var: str) -> int: ...

# пример
weechat.prnt("", "time = %d" % weechat.infolist_time(infolist, "my_time"))
----

==== infolist_free

Ослобађа меморију коју заузима инфолиста.

Прототип:

[source,c]
----
void weechat_infolist_free (struct t_infolist *infolist);
----

Аргументи:

* _infolist_: показивач на инфо листу

C пример:

[source,c]
----
weechat_infolist_free (infolist);
----

Скрипта (Python):

[source,python]
----
# прототип
def infolist_free(infolist: str) -> int: ...

# пример
weechat.infolist_free(infolist)
----

[[hdata]]
=== Hdata

Функције за hdata (сирови приступ подацима програма WeeChat или подацима додатака).

[IMPORTANT]
Hdata обезбеђује приступ за подацима у режиму само-за-читање. *ИЗРИЧИТО ЈЕ ЗАБРАЊЕНО* да се било шта уписује у меморију на коју показују hdata променљиве. +
Једини начин за ажурирање података је позив функције <<_hdata_update,hdata_update>>.

==== hdata_new

_WeeChat ≥ 0.3.6, ажурирано у верзијама 0.3.9 и 0.4.0._

Креира нови hdata.

[NOTE]
.hdata у односу на инфолисту
====
Hdata је брз начин за читање података из програма WeeChat или из додатака. Слично је са инфолистом, али постоје неке разлике:

* Брже је и користи мање меморије: директно читање без дуплирања.
* Може да садржи различите податке у односу на инфолисту: садржи само сирове податке у структурама (инфолиста може додати неке додатне податке из разлога једноставније употребе).
====

Прототип:

[source,c]
----
struct t_hdata *weechat_hdata_new (const char *hdata_name, const char *var_prev, const char *var_next,
                                   int create_allowed, int delete_allowed,
                                   int (*callback_update)(void *data,
                                                          struct t_hdata *hdata,
                                                          void *pointer,
                                                          struct t_hashtable *hashtable),
                                   void *callback_update_data);
----

Аргументи:

* _hdata_name_: име hdata
* _var_prev_: име променљиве у структури која је показивач на претходни елемент у листи (може да буде NULL ако таква променљива не постоји)
* _var_next_: име променљиве у структури која је показивач на наредни елемент у листи (може да буде NULL ако таква променљива не постоји)
* _create_allowed_: 1 ако је дозвољено креирање структуре, у супротном 0 _(WeeChat ≥ 0.4.0)_
* _delete_allowed_: 1 ако је дозвољено брисање структуре, у супротном 0 _(WeeChat ≥ 0.3.9)_
* _callback_update_: функција повратног позива за ажурирање података у hdata, може да буде NULL ако није дозвољено ажурирање (WeeChat ≥ 0.3.9)_, аргументи и повратна вредност су:
** _void *data_: показивач
** _struct t_hdata *hdata_: показивач на hdata
** _struct t_hashtable *hashtable_: хеш табела са променљивама које треба да се ажурирају (погледајте <<_hdata_update,hdata_update>>)
** повратна вредност: број ажурираних променљивих
* _callback_update_data_: показивач прослеђен функцији повратног позива када је позове програм WeeChat _(WeeChat ≥ 0.3.9)_

Повратна вредност:

* показивач на нови hdata

C пример:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_new ("myplugin_list", "prev", "next", 0, 0, &callback_update, NULL);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== hdata_new_var

_WeeChat ≥ 0.3.6, ажурирано у верзијама 0.3.7, 0.3.9, 0.4.3, 3.4 и 4.3.0._

Креира нову променљиву у hdata.

Прототип:

[source,c]
----
void weechat_hdata_new_var (struct t_hdata *hdata, const char *name, int offset, int type,
                            int update_allowed, const char *array_size, const char *hdata_name);
----

Аргументи:

* _hdata_: показивач на hdata
* _name_: име променљиве
* _offset_: померај променљиве од почетка структуре
* _type_: тип променљиве, једно од:
** _WEECHAT_HDATA_CHAR_
** _WEECHAT_HDATA_INTEGER_
** _WEECHAT_HDATA_LONG_
** _WEECHAT_HDATA_LONGLONG_ (_WeeChat ≥ 4.3.0_)
** _WEECHAT_HDATA_STRING_
** _WEECHAT_HDATA_SHARED_STRING_ (_WeeChat ≥ 0.4.3_)
** _WEECHAT_HDATA_POINTER_
** _WEECHAT_HDATA_TIME_
** _WEECHAT_HDATA_HASHTABLE_ (_WeeChat ≥ 0.3.7_)
** _WEECHAT_HDATA_OTHER_
* _update_allowed_: 1 ако се дозвољава ажурирање променљиве, у супротном 0 _(WeeChat ≥ 0.3.9)_
* _array_size_: није NULL само ако је променљива низ, и може бити: _(WeeChat ≥ 0.3.9)_
** име променљиве у hdata: ова променљива ће се користити као величина низа (динамичка величина низа)
** вео број (као стринг): фиксна величина низа
** _*_: аутоматска величина: величина низа се израчунава гледањем у вредности, када се наиђе на прво NULL (само за тип стринг, показивач или хеш табелу)
* _hdata_name_: име hdata (ако је то показивач на структуру са hdata)

Од WeeChat ≥ 3.4, испред _array_size_ параметра може да се постави `*,` што
представља показивач на динамички алоциран низ (без овог префикса, низ се
сматра статички).

Примери променљивих и одговарајуће величине низа (_WeeChat ≥ 3.4_):

[width="100%",cols="3,3m,2,7",options="header"]
|===
| Декларација променљиве у C | Hdata тип | Величина низа | Опис

| `+int *numbers;+` | WEECHAT_HDATA_INTEGER | `+*,2+`
| Алоцирани низ од 2 цела броја.

| `+int *numbers;+` | WEECHAT_HDATA_INTEGER | `+*,array_size+`
| Алоцирани низ целих бројева, величина се чува у другој променљивој под називом
  "array_size".

| `+int numbers[3];+` | WEECHAT_HDATA_INTEGER | `+3+`
| Статички низ од 3 цела броја.

| `+char **words;+` | WEECHAT_HDATA_STRING | `+*,*+`
| Алоцирани низ стрингова, динамичке величине (иза последње речи мора да дође
  NULL показивач).

| `+char **words;+` | WEECHAT_HDATA_STRING | `+*,count_words+`
| Алоцирани низ стрингова, величина се чува у другој променљивој под називом
  "count_words".
|===

C пример:

[source,c]
----
struct t_myplugin_list
{
    char *name;
    struct t_gui_buffer *buffer;
    int numbers[3];
    int tags_count;
    char **tags_array;
    char **string_split;
    struct t_myplugin_list *prev;
    struct t_myplugin_list *next;
};

/* ... */

struct t_hdata *hdata = weechat_hdata_new ("myplugin_list", "prev", "next");
weechat_hdata_new_var (hdata, "name", offsetof (struct t_myplugin_list, name), WEECHAT_HDATA_STRING, 0, NULL, NULL);
weechat_hdata_new_var (hdata, "buffer", offsetof (struct t_myplugin_list, buffer), WEECHAT_HDATA_POINTER, 0, NULL, NULL);
weechat_hdata_new_var (hdata, "numbers", offsetof (struct t_myplugin_list, numbers), WEECHAT_HDATA_INTEGER, 0, "3", NULL);
weechat_hdata_new_var (hdata, "tags_count", offsetof (struct t_myplugin_list, tags_count), WEECHAT_HDATA_INTEGER, 0, NULL, NULL);
weechat_hdata_new_var (hdata, "tags_array", offsetof (struct t_myplugin_list, tags_array), WEECHAT_HDATA_STRING, 0, "*,tags_count", NULL);
weechat_hdata_new_var (hdata, "string_split", offsetof (struct t_myplugin_list, string_split), WEECHAT_HDATA_STRING, 0, "*,*", NULL);
weechat_hdata_new_var (hdata, "prev", offsetof (struct t_myplugin_list, prev), WEECHAT_HDATA_POINTER, 0, NULL, "myplugin_list");
weechat_hdata_new_var (hdata, "next", offsetof (struct t_myplugin_list, next), WEECHAT_HDATA_POINTER, 0, NULL, "myplugin_list");
----

За скраћење кода, може да се употреби макро „WEECHAT_HDATA_VAR”:

[source,c]
----
WEECHAT_HDATA_VAR(struct t_myplugin_list, name, STRING, 0, NULL, NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, buffer, POINTER, 0, NULL, NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, numbers, INTEGER, 0, "3", NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, tags_count, INTEGER, 0, NULL, NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, tags_array, STRING, 0, "*,tags_count", NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, string_split, STRING, 0, "*,*", NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, prev, POINTER, 0, NULL, "myplugin_list");
WEECHAT_HDATA_VAR(struct t_myplugin_list, next, POINTER, 0, NULL, "myplugin_list");
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== hdata_new_list

_WeeChat ≥ 0.3.6, ажурирано у верзији 1.0._

Креира нови показивач на листу у hdata.

Прототип:

[source,c]
----
void weechat_hdata_new_list (struct t_hdata *hdata, const char *name, void *pointer, int flags);
----

Аргументи:

* _hdata_: показивач на hdata
* _name_: име променљиве
* _pointer_: показивач на листу
* _flags_: комбинација следећих вредности: _(WeeChat ≥ 1.0)_
** _WEECHAT_HDATA_LIST_CHECK_POINTERS_: листа која се користи за проверу показивача

C пример:

[source,c]
----
struct t_myplugin_list
{
    char *name;
    struct t_gui_buffer *buffer;
    int tags_count;
    char **tags_array;
    char **string_split;
    struct t_myplugin_list *prev;
    struct t_myplugin_list *next;
};

/* ... */

struct t_hdata *hdata = weechat_hdata_new ("myplugin_list", "prev", "next");
weechat_hdata_new_var (hdata, "name", offsetof (struct t_myplugin_list, name), WEECHAT_HDATA_STRING, NULL, NULL);
weechat_hdata_new_var (hdata, "buffer", offsetof (struct t_myplugin_list, buffer), WEECHAT_HDATA_POINTER, NULL, NULL);
weechat_hdata_new_var (hdata, "tags_count", offsetof (struct t_myplugin_list, tags_count), WEECHAT_HDATA_INTEGER, NULL, NULL);
weechat_hdata_new_var (hdata, "tags_array", offsetof (struct t_myplugin_list, tags_array), WEECHAT_HDATA_STRING, "tags_count", NULL);
weechat_hdata_new_var (hdata, "string_split", offsetof (struct t_myplugin_list, string_split), WEECHAT_HDATA_STRING, "*", NULL);
weechat_hdata_new_var (hdata, "prev", offsetof (struct t_myplugin_list, prev), WEECHAT_HDATA_POINTER, NULL, "myplugin_list");
weechat_hdata_new_var (hdata, "next", offsetof (struct t_myplugin_list, next), WEECHAT_HDATA_POINTER, NULL, "myplugin_list");

weechat_hdata_new_list (hdata, "buffers", &buffers, WEECHAT_HDATA_LIST_CHECK_POINTERS);
weechat_hdata_new_list (hdata, "last_buffer", &last_buffer, 0);
----

За скраћивање кода, може да се користи макро „WEECHAT_HDATA_LIST”:

[source,c]
----
WEECHAT_HDATA_LIST(buffers, WEECHAT_HDATA_LIST_CHECK_POINTERS);
WEECHAT_HDATA_LIST(last_buffer, 0);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== hdata_get

_WeeChat ≥ 0.3.6._

Враћа hdata за структуру програма WeeChat или додатка.

[NOTE]
Hdata не садржи податке, то је само хеш табела са позицијама променљивих у структури. То значи да вам је за читање неких података потребан само овај hdata и показивач на објекат програма WeeChat/додатка.

Прототип:

[source,c]
----
struct t_hdata *weechat_hdata_get (const char *hdata_name);
----

Аргументи:

* _hdata_name_: име hdata (погледајте листу испод)

Повратна вредност:

* показивач на hdata, NULL у случају да је дошло до грешке

Листа hdata:

include::{autogendir}/autogen_api_hdata.sr.adoc[tag=hdata]

C пример:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("irc_server");
----

Скрипта (Python):

[source,python]
----
# прототип
def hdata_get(hdata_name: str) -> str: ...

# пример
hdata = weechat.hdata_get("irc_server")
----

==== hdata_get_var_offset

_WeeChat ≥ 0.3.6._

Враћа померај променљиве у hdata.

Прототип:

[source,c]
----
int weechat_hdata_get_var_offset (struct t_hdata *hdata, const char *name);
----

Аргументи:

* _hdata_: показивач на hdata
* _name_: име променљиве

Повратна вредност:

* померај променљиве, -1 у случају да је дошло до грешке

C пример:

[source,c]
----
int offset = weechat_hdata_get_var_offset (hdata, "name");
----

Скрипта (Python):

[source,python]
----
# прототип
def hdata_get_var_offset(hdata: str, name: str) -> int: ...

# пример
offset = weechat.hdata_get_var_offset(hdata, "name")
----

==== hdata_get_var_type

_WeeChat ≥ 0.3.6._

Повратни тип променљиве у hdata (као цео број).

Прототип:

[source,c]
----
int weechat_hdata_get_var_type (struct t_hdata *hdata, const char *name);
----

Аргументи:

* _hdata_: показивач на hdata
* _name_: име променљиве

Повратна вредност:

* тип променљиве, -1 у случају да је дошло до грешке

C пример:

[source,c]
----
int type = weechat_hdata_get_var_type (hdata, "name");
switch (type)
{
    case WEECHAT_HDATA_CHAR:
        /* ... */
        break;
    case WEECHAT_HDATA_INTEGER:
        /* ... */
        break;
    case WEECHAT_HDATA_LONG:
        /* ... */
        break;
    case WEECHAT_HDATA_LONGLONG:
        /* ... */
        break;
    case WEECHAT_HDATA_STRING:
        /* ... */
        break;
    case WEECHAT_HDATA_SHARED_STRING:
        /* ... */
        break;
    case WEECHAT_HDATA_POINTER:
        /* ... */
        break;
    case WEECHAT_HDATA_TIME:
        /* ... */
        break;
    case WEECHAT_HDATA_HASHTABLE:
        /* ... */
        break;
    case WEECHAT_HDATA_OTHER:
        /* ... */
        break;
    default:
        /* променљива није пронађена */
        break;
}
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== hdata_get_var_type_string

_WeeChat ≥ 0.3.6._

Повратни тип променљиве у hdata (као стринг).

Прототип:

[source,c]
----
const char *weechat_hdata_get_var_type_string (struct t_hdata *hdata, const char *name);
----

Аргументи:

* _hdata_: показивач на hdata
* _name_: име променљиве

Повратна вредност:

* тип променљиве, NULL у случају да је дошло до грешке

C пример:

[source,c]
----
weechat_printf (NULL, "type = %s", weechat_hdata_get_var_type_string (hdata, "name"));
----

Скрипта (Python):

[source,python]
----
# прототип
def hdata_get_var_type_string(hdata: str, name: str) -> str: ...

# пример
weechat.prnt("", "type = %s" % weechat.hdata_get_var_type_string("name"))
----

==== hdata_get_var_array_size

_WeeChat ≥ 0.3.9._

Враћа величину низа за променљиву у hdata.

Прототип:

[source,c]
----
int weechat_hdata_get_var_array_size (struct t_hdata *hdata, void *pointer, const char *name);
----

Аргументи:

* _hdata_: показивач на hdata
* _pointer_: показивач на објекат програма WeeChat/додатка
* _name_: име променљиве

Повратна вредност:

* величина низа за променљиву, -1 ако променљива није низ или у случају да је дошло до грешке

C пример:

[source,c]
----
int array_size = weechat_hdata_get_var_array_size (hdata, pointer, "name");
----

Скрипта (Python):

[source,python]
----
# прототип
def hdata_get_var_array_size(hdata: str, pointer: str, name: str) -> int: ...

# пример
array_size = weechat.hdata_get_var_array_size(hdata, pointer, "name")
----

==== hdata_get_var_array_size_string

_WeeChat ≥ 0.3.9._

Враћа величину низа за променљиву у hdata (као стринг).

Прототип:

[source,c]
----
const char *weechat_hdata_get_var_array_size_string (struct t_hdata *hdata, void *pointer,
                                                     const char *name);
----

Аргументи:

* _hdata_: показивач на hdata
* _pointer_: показивач на објекат програма WeeChat/додатка
* _name_: име променљиве

Повратна вредност:

* величина низа за променљиву као стринг, NULL у случају да променљива није низ, или ако је дошло до грешке

C пример:

[source,c]
----
const char *array_size = weechat_hdata_get_var_array_size_string (hdata, pointer, "name");
----

Скрипта (Python):

[source,python]
----
# прототип
def hdata_get_var_array_size_string(hdata: str, pointer: str, name: str) -> str: ...

# пример
array_size = weechat.hdata_get_var_array_size_string(hdata, pointer, "name")
----

==== hdata_get_var_hdata

_WeeChat ≥ 0.3.6._

Враћа hdata за променљиву у hdata.

Прототип:

[source,c]
----
const char *weechat_hdata_get_var_hdata (struct t_hdata *hdata, const char *name);
----

Аргументи:

* _hdata_: показивач на hdata
* _name_: име променљиве

Повратна вредност:

* hdata за променљиву, NULL ако нема hdata или у случају да је дошло до грешке

C пример:

[source,c]
----
weechat_printf (NULL, "hdata = %s", weechat_hdata_get_var_hdata (hdata, "name"));
----

Скрипта (Python):

[source,python]
----
# прототип
def hdata_get_var_hdata(hdata: str, name: str) -> str: ...

# пример
weechat.prnt("", "hdata = %s" % weechat.hdata_get_var_hdata(hdata, "name"))
----

==== hdata_get_var

_WeeChat ≥ 0.3.6._

Враћа показивач на садржај променљиве у hdata.

Прототип:

[source,c]
----
void *weechat_hdata_get_var (struct t_hdata *hdata, void *pointer, const char *name);
----

Аргументи:

* _hdata_: показивач на hdata
* _pointer_: показивач на објекат програма WeeChat/додатка
* _name_: име променљиве

Повратна вредност:

* показивач на садржај променљиве, NULL у случају да је дошло до грешке

C пример:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
void *pointer = weechat_hdata_get_var (hdata, buffer, "name");
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== hdata_get_var_at_offset

_WeeChat ≥ 0.3.6._

Враћа показивач на садржај променљиве у hdata, користећи померај.

Прототип:

[source,c]
----
void *weechat_hdata_get_var_at_offset (struct t_hdata *hdata, void *pointer, int offset);
----

Аргументи:

* _hdata_: показивач на hdata
* _pointer_: показивач на објекат програма WeeChat/додатка
* _offset_: померај променљиве

Повратна вредност:

* показивач на садржај променљиве, NULL у случају да је дошло до грешке

C пример:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
int offset = weechat_hdata_get_var_offset (hdata, "name");
void *pointer = weechat_hdata_get_var_at_offset (hdata, buffer, offset);
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== hdata_get_list

_WeeChat ≥ 0.3.6._

Враћа показивач на листу из hdata.

Прототип:

[source,c]
----
void *weechat_hdata_get_list (struct t_hdata *hdata, const char *name);
----

Аргументи:

* _hdata_: показивач на hdata
* _name_: име листе

Повратна вредност:

* показивач на листу, NULL у случају да је дошло до грешке

C пример:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffers = weechat_hdata_get_list (hdata, "gui_buffers");
----

Скрипта (Python):

[source,python]
----
# прототип
def hdata_get_list(hdata: str, name: str) -> str: ...

# пример
hdata = weechat.hdata_get("buffer")
buffers = weechat.hdata_get_list(hdata, "gui_buffers")
----

==== hdata_check_pointer

_WeeChat ≥ 0.3.7, ажурирано у верзији 1.0._

Проверава да ли показивач важи за hdata и показивач листе.

Прототип:

[source,c]
----
int weechat_hdata_check_pointer (struct t_hdata *hdata, void *list, void *pointer);
----

Аргументи:

* _hdata_: показивач на hdata
* _list_: показивач на листу; ако је NULL _(WeeChat ≥ 1.0)_, показивач се проверава са листама у hdata које имају заставицу „check pointers” (погледајте <<_hdata_new_list,hdata_new_list>>), па ако таква листа не постоји, сматра се да је показивач важећи
* _pointer_: показивач који треба да се провери

Повратна вредност:

* 1 ако је показивач у листи, 0 ако се не пронађе

C пример:

[source,c]
----
/* check if a buffer pointer is valid */
struct t_hdata *hdata = weechat_hdata_get ("buffer");
if (weechat_hdata_check_pointer (hdata,
                                 weechat_hdata_get_list (hdata, "gui_buffers"),
                                 ptr_buffer))
{
    /* важећи показивач */
}
else
{
    /* неважећи показивач */
}
----

Скрипта (Python):

[source,python]
----
# прототип
def hdata_check_pointer(hdata: str, list: str, pointer: str) -> int: ...

# пример
hdata = weechat.hdata_get("buffer")
if weechat.hdata_check_pointer(hdata, weechat.hdata_get_list(hdata, "gui_buffers"), ptr_buffer):
    # важећи показивач
    # ...
else:
    # неважећи показивач
    # ...
----

==== hdata_move

_WeeChat ≥ 0.3.6._

Помера показивач на други елементу листи.

Прототип:

[source,c]
----
void *weechat_hdata_move (struct t_hdata *hdata, void *pointer, int count);
----

Аргументи:

* _hdata_: показивач на hdata
* _pointer_: показивач на објекат програма WeeChat/додатка
* _count_: број скок(а/ова) који треба да се изврше (негативни или позитивни цео број различит од нуле)

Повратна вредност:

* показивач на достигнут елемент, NULL ако се елемент не пронађе (на пример, крај листе), или је дошло до грешке

C пример:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();

/* помера се на наредни бафер, 2 пута */
buffer = weechat_hdata_move (hdata, buffer, 2);

/* помера се на претходни бафер */
if (buffer)
    buffer = weechat_hdata_move (hdata, buffer, -1);
----

Скрипта (Python):

[source,python]
----
# прототип
def hdata_move(hdata: str, pointer: str, count: int) -> str: ...

# пример
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()

# помера се на наредни бафер, 2 пута
buffer = weechat.hdata_move(hdata, buffer, 2)

# помера се на претходни бафер
if buffer:
    buffer = weechat.hdata_move(hdata, buffer, -1)
----

==== hdata_search

_WeeChat ≥ 0.4.1, ажурирано у верзији 3.4._

Тражи елемент у листи: израз _search_ се тражи за сваки елемент у листи, све док се елемент не пронађе (или наиђе на крај листе).

Прототип:

[source,c]
----
void *weechat_hdata_search (struct t_hdata *hdata, void *pointer, const char *search,
                            struct t_hashtable *pointers, struct t_hashtable *extra_vars,
                            struct t_hashtable *options, int move);
----

Аргументи:

* _hdata_: показивач на hdata
* _pointer_: показивач на објекат програма WeeChat/додатка
* _search_: израз који се израчунава, подразумевани показивач у изразу је име hdata (и овај показивач се мења за сваки елемент у листи); за помоћ у вези израза, погледајте link:weechat_user.sr.html#command_weechat_eval[WeeChat корисничко упутство / Команда /eval ^↗^^]
* _pointers_: хеш табела за позив функције <<_string_eval_expression,string_eval_expression>>
* _extra_vars_: хеш табела за позив функције <<_string_eval_expression,string_eval_expression>>
* _options_: хеш табела за позив функције <<_string_eval_expression,string_eval_expression>>
* _move_: број скок(а/ова) који треба да се изврши након неуспешне претраге (негативни или позитивни цео број, различит од 0)

[IMPORTANT]
Морате обезбедити да је _search_ израз сигуран и да не садржи корисничке
податке. Такви небезбедни подаци морају да се наведу у хеш табели _extra_vars_
и да се на њих у _search_ изразу укаже са `${xxx}` (погледајте пример испод).

Повратна вредност:

* показивач на пронађени елемент, NULL у случају да се не пронађе

C пример:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("irc_server");
void *servers = weechat_hdata_get_list (hdata, "irc_servers");
struct t_hashtable *extra_vars = weechat_hashtable_new (8,
                                                        WEECHAT_HASHTABLE_STRING,
                                                        WEECHAT_HASHTABLE_STRING,
                                                        NULL,
                                                        NULL);

/* тражи irc сервер под именом „libera” */
weechat_hashtable_set (extra_vars, "server_name", "libera");
void *server = weechat_hdata_search (hdata, servers, "${irc_server.name} == ${server_name}",
                                     NULL, extra_vars, NULL, 1);
if (server)
{
    /* ... */
}
weechat_hashtable_free (extra_vars);
----

Скрипта (Python):

[source,python]
----
# прототип
def hdata_search(hdata: str, pointer: str, search: str,
                 pointers: Dict[str, str], extra_vars: Dict[str, str], options: Dict[str, str],
                 count: int) -> str: ...

# пример
hdata = weechat.hdata_get("irc_server")
servers = weechat.hdata_get_list(hdata, "irc_servers")

# тражи irc сервер под именом „libera”
server = weechat.hdata_search(hdata, servers, "${irc_server.name} == ${server_name}",
                              {}, {"server_name": "libera"}, {}, 1)
if server:
    # ...
----

==== hdata_char

_WeeChat ≥ 0.3.7._

Враћа вредност карактер променљиве у структури користећи hdata.

Прототип:

[source,c]
----
char weechat_hdata_char (struct t_hdata *hdata, void *pointer, const char *name);
----

Аргументи:

* _hdata_: показивач на hdata
* _pointer_: показивач на објекат програма WeeChat/додатка
* _name_: име променљиве (мора бити типа „char”); у случају низова, име може да буде „N|име” где је N индекс низа (који почиње од 0), на пример: „2|име”

Повратна вредност:

* карактер вредност променљиве

C пример:

[source,c]
----
weechat_printf (NULL, "letter = %c", weechat_hdata_char (hdata, pointer, "letter"));
----

Скрипта (Python):

[source,python]
----
# прототип
def hdata_char(hdata: str, pointer: str, name: str) -> int: ...

# пример
weechat.prnt("", "letter = %c" % weechat.hdata_char(hdata, pointer, "letter"))
----

==== hdata_integer

_WeeChat ≥ 0.3.6._

Враћа вредност целобројне променљиве у структури користећи hdata.

Прототип:

[source,c]
----
int weechat_hdata_integer (struct t_hdata *hdata, void *pointer, const char *name);
----

Аргументи:

* _hdata_: показивач на hdata
* _pointer_: показивач на објекат програма WeeChat/додатка
* _name_: име променљиве (мора бити типа „integer”); у случају низова, име може да буде „N|име” где је N индекс низа (који почиње од 0), на пример: „2|име”

Повратна вредност:

* целобројна вредност променљиве

C пример:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
weechat_printf (NULL, "number = %d", weechat_hdata_integer (hdata, buffer, "number"));
----

Скрипта (Python):

[source,python]
----
# прототип
def hdata_integer(hdata: str, pointer: str, name: str) -> int: ...

# пример
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
weechat.prnt("", "number = %d" % weechat.hdata_integer(hdata, buffer, "number"))
----

==== hdata_long

_WeeChat ≥ 0.3.6._

Враћа вредност дугачке променљиве у структури користећи hdata.

Прототип:

[source,c]
----
long weechat_hdata_long (struct t_hdata *hdata, void *pointer, const char *name);
----

Аргументи:

* _hdata_: показивач на hdata
* _pointer_: показивач на објекат програма WeeChat/додатка
* _name_: име променљиве (мора бити типа „long”); у случају низова, име може да буде „N|име” где је N индекс низа (који почиње од 0), на пример: „2|име”

Повратна вредност:

* дугачка вредност променљиве

C пример:

[source,c]
----
weechat_printf (NULL, "longvar = %ld", weechat_hdata_long (hdata, pointer, "longvar"));
----

Скрипта (Python):

[source,python]
----
# прототип
def hdata_long(hdata: str, pointer: str, name: str) -> int: ...

# пример
weechat.prnt("", "longvar = %d" % weechat.hdata_long(hdata, pointer, "longvar"))
----

==== hdata_longlong

_WeeChat ≥ 4.3.0._

Повратна вредност „long long” променљиве у структури користећи hdata.

Прототип:

[source,c]
----
long long weechat_hdata_longlong (struct t_hdata *hdata, void *pointer, const char *name);
----

Аргументи:

* _hdata_: показивач на hdata
* _pointer_: показивач на објекат програма WeeChat/додатка
* _name_: име променљиве (мора бити типа „long long”); у случају низова, име може да буде „N|име” где је N индекс низа (који почиње од 0), на пример: „2|име”

Повратна вредност:

* „long long” вредност променљиве

C пример:

[source,c]
----
weechat_printf (NULL, "longlongvar = %lld", weechat_hdata_longlong (hdata, pointer, "longlongvar"));
----

Скрипта (Python):

[source,python]
----
# прототип
def hdata_longlong(hdata: str, pointer: str, name: str) -> int: ...

# пример
weechat.prnt("", "longlongvar = %d" % weechat.hdata_longlong(hdata, pointer, "longlongvar"))
----

==== hdata_string

_WeeChat ≥ 0.3.6._

Враћа вредност стринг променљиве у структури користећи hdata.

Прототип:

[source,c]
----
const char *weechat_hdata_string (struct t_hdata *hdata, void *pointer, const char *name);
----

Аргументи:

* _hdata_: показивач на hdata
* _pointer_: показивач на објекат програма WeeChat/додатка
* _name_: име променљиве (мора бити типа „string”); у случају низова, име може да буде „N|име” где је N индекс низа (који почиње од 0), на пример: „2|име”

Повратна вредност:

* стринг вредност променљиве

C пример:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
weechat_printf (NULL, "name = %s", weechat_hdata_string (hdata, buffer, "name"));
----

Скрипта (Python):

[source,python]
----
# прототип
def hdata_string(hdata: str, pointer: str, name: str) -> str: ...

# пример
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
weechat.prnt("", "name = %s" % weechat.hdata_string(hdata, buffer, "name"))
----

==== hdata_pointer

_WeeChat ≥ 0.3.6._

Враћа вредност показивач променљиве у структури користећи hdata.

Прототип:

[source,c]
----
void *weechat_hdata_pointer (struct t_hdata *hdata, void *pointer, const char *name);
----

Аргументи:

* _hdata_: показивач на hdata
* _pointer_: показивач на објекат програма WeeChat/додатка
* _name_: име променљиве (мора бити типа „pointer”); у случају низова, име може да буде „N|име” где је N индекс низа (који почиње од 0), на пример: „2|име”

Повратна вредност:

* показивач вредност променљиве

C пример:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
weechat_printf (NULL, "lines = %p", weechat_hdata_pointer (hdata, buffer, "lines"));
----

Скрипта (Python):

[source,python]
----
# прототип
def hdata_pointer(hdata: str, pointer: str, name: str) -> str: ...

# пример
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
weechat.prnt("", "lines = %x" % weechat.hdata_pointer(hdata, buffer, "lines"))
----

==== hdata_time

_WeeChat ≥ 0.3.6._

Враћа вредност временске променљиве у структури користећи hdata.

Прототип:

[source,c]
----
time_t weechat_hdata_time (struct t_hdata *hdata, void *pointer, const char *name);
----

Аргументи:

* _hdata_: показивач на hdata
* _pointer_: показивач на објекат програма WeeChat/додатка
* _name_: име променљиве (мора бити типа „time”); у случају низова, име може да буде „N|име” где је N индекс низа (који почиње од 0), на пример: „2|име”

Повратна вредност:

* временска вредност променљиве

C пример:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *ptr = weechat_buffer_search_main ();
ptr = weechat_hdata_pointer (hdata, ptr, "lines");
if (ptr)
{
    hdata = weechat_hdata_get ("lines");
    ptr = weechat_hdata_pointer (hdata, ptr, "first_line");
    if (ptr)
    {
        hdata = weechat_hdata_get ("line");
        ptr = weechat_hdata_pointer (hdata, ptr, "data");
        if (ptr)
        {
            hdata = weechat_hdata_get ("line_data");
            time_t date = weechat_hdata_time (hdata, hdata, "date");
            weechat_printf (NULL, "time of last line displayed = %s", ctime (&date));
        }
    }
}
----

Скрипта (Python):

[source,python]
----
# прототип
def hdata_time(hdata: str, pointer: str, name: str) -> int: ...

# пример
buf = weechat.buffer_search_main()
ptr = weechat.hdata_pointer(weechat.hdata_get("buffer"), buf, "lines")
if ptr:
    ptr = weechat.hdata_pointer(weechat.hdata_get("lines"), ptr, "first_line")
    if ptr:
        ptr = weechat.hdata_pointer(weechat.hdata_get("line"), ptr, "data")
        if ptr:
            date = weechat.hdata_time(weechat.hdata_get("line_data"), ptr, "date")
            weechat.prnt("", "time of first line displayed = %s" % time.strftime("%F %T", time.localtime(int(date))))
----

==== hdata_hashtable

_WeeChat ≥ 0.3.7._

Враћа вредност хеш табела променљиве у структури користећи hdata.

Прототип:

[source,c]
----
struct t_hashtable *weechat_hdata_hashtable (struct t_hdata *hdata, void *pointer, const char *name);
----

Аргументи:

* _hdata_: показивач на hdata
* _pointer_: показивач на објекат програма WeeChat/додатка
* _name_: име променљиве (мора бити типа „hashtable”); у случају низова, име може да буде „N|име” где је N индекс низа (који почиње од 0), на пример: „2|име”

Повратна вредност:

* хеш табела вредност променљиве (показивач на хеш табелу)

C пример:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
struct t_hashtable *hashtable = weechat_hdata_hashtable (hdata, buffer, "local_variables");
weechat_printf (NULL, "%d local variables in core buffer",
                weechat_hashtable_get_integer (hashtable, "items_count"));
----

Скрипта (Python):

[source,python]
----
# прототип
def hdata_hashtable(hdata: str, pointer: str, name: str) -> Dict[str, str]: ...

# пример
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
hash = weechat.hdata_hashtable(hdata, buffer, "local_variables")
weechat.prnt("", "локалне променљиве у core баферу:")
for key in hash:
    weechat.prnt("", "  %s == %s" % (key, hash[key]))
----

==== hdata_compare

_WeeChat ≥ 1.9, ажурирано у верзији 4.1.0._

Пореди hdata променљиву два објекта.

Прототип:

[source,c]
----
int weechat_hdata_compare (struct t_hdata *hdata, void *pointer1, void *pointer2, const char *name, int case_sensitive);
----

Аргументи:

* _hdata_: показивач на hdata
* _pointer1_: показивач на први објекат програма WeeChat/додатка
* _pointer2_: показивач на други објекат програма WeeChat/додатка
* _name_: назив променљиве или путања до назива променљиве; у случају низова, име може
  бити „N|име” где је N индекс низа (који почиње од 0), на пример: „2|име”
* _case_sensitive_: 1 за поређење стрингова које разликује величину слова, у супротном 0

Повратна вредност:

* -1 ако је variable1 < variable2
* 0 ако је variable1 == variable2
* 1 ако је variable1 > variable2

C пример:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer1 = weechat_buffer_search ("irc", "libera.#weechat");
struct t_gui_buffer *buffer2 = weechat_buffer_search ("irc", "libera.#weechat-fr");
weechat_printf (NULL, "comparison of buffer number = %d",
                weechat_hdata_compare (hdata, buffer1, buffer2, "number", 0));
weechat_printf (NULL, "comparison of number of lines = %d",
                weechat_hdata_compare (hdata, buffer1, buffer2, "own_lines.lines_count", 0));
weechat_printf (NULL, "comparison of local variable = %d",
                weechat_hdata_compare (hdata, buffer1, buffer2, "local_variables.myvar", 0));
----

Скрипта (Python):

[source,python]
----
# прототип
def hdata_compare(hdata: str, pointer1: str, pointer2: str, name: str, case_sensitive: int) -> int: ...

# пример
hdata = weechat.hdata_get("buffer")
buffer1 = weechat.buffer_search("irc", "libera.#weechat")
buffer2 = weechat.buffer_search("irc", "libera.#weechat-fr")
weechat.prnt("", "comparison of buffer number = %d" % weechat.hdata_compare(hdata, buffer1, buffer2, "number", 0))
weechat.prnt("", "comparison of number of lines = %d" % weechat.hdata_compare(hdata, buffer1, buffer2, "own_lines.lines_count", 0))
weechat.prnt("", "comparison of local variable = %d" % weechat.hdata_compare(hdata, buffer1, buffer2, "local_variables.myvar", 0))
----

==== hdata_set

_WeeChat ≥ 0.3.9._

Поставља нову вредност променљиве у hdata.

[NOTE]
Ова функција може да се позива само из функције повратног позива ажурирања (погледајте <<_hdata_new,hdata_new>> и <<_hdata_update,hdata_update>>), ако је дозвољено ажурирање променљиве.

Прототип:

[source,c]
----
int weechat_hdata_set (struct t_hdata *hdata, void *pointer, const char *name, const char *value);
----

Аргументи:

* _hdata_: показивач на hdata
* _pointer_: показивач на објекат програма WeeChat/додатка
* _name_: име променљиве (дозвољени типови: char, integer, long, string, pointer, time)
* _value_: нова вредност променљиве

Повратна вредност:

* 1 ако је све OK, 0 у случају грешке

C пример:

[source,c]
----
weechat_hdata_set (hdata, pointer, "message", "test");
----

[NOTE]
Ова функција није доступна у API скриптовања.

==== hdata_update

_WeeChat ≥ 0.3.9._

Ажурира податке у hdata.

Прототип:

[source,c]
----
int weechat_hdata_update (struct t_hdata *hdata, void *pointer, struct t_hashtable *hashtable);
----

Аргументи:

* _hdata_: показивач на hdata
* _pointer_: показивач на објекат програма WeeChat/додатка
* _hashtable_: променљиве које треба да се ажурирају: кључеви су имена променљивих, вредност су нове вредности за те променљиве (кључеви и вредности су стрингови), дозвољени су и неки специјални кључеви:
** кључ `+__create_allowed+` (са било којим вредности): враћа се 1 ако је за структуру дозвољено ажурирање, у супротном 0 _(WeeChat ≥ 0.4.0)_
** кључ `+__delete_allowed+` (са било којом вредности): враћа се 1 ако је за структуру дозвољено брисање, у супротном 0
** кључ `+__update_allowed+`, вредност је име променљиве: враћа се 1 ако је за ову променљиву дозвољено ажурирање, у супротном 0
** кључ `+__delete+` (са било којом вредности): структура се брише (ако је то дозвољено)

Повратна вредност:

* број ажурираних променљивих

C пример:

[source,c]
----
/* одузима један сад од последње приказане поруке у текућем баферу */

struct t_gui_lines *own_lines;
struct t_gui_line *line;
struct t_gui_line_data *line_data;
struct t_hdata *hdata;
struct t_hashtable *hashtable;
char str_date[64];

own_lines = weechat_hdata_pointer (weechat_hdata_get ("buffer"), weechat_current_buffer (), "own_lines");
if (own_lines)
{
    line = weechat_hdata_pointer (weechat_hdata_get ("lines"), own_lines, "last_line");
    if (line)
    {
        line_data = weechat_hdata_pointer (weechat_hdata_get ("line"), line, "data");
        hdata = weechat_hdata_get ("line_data");
        hashtable = weechat_hashtable_new (8,
                                           WEECHAT_HASHTABLE_STRING,
                                           WEECHAT_HASHTABLE_STRING,
                                           NULL,
                                           NULL);
        if (hashtable)
        {
            snprintf (str_date, sizeof (str_date), "%ld", ((long int)weechat_hdata_time (hdata, line_data, "date")) - 3600);
            weechat_hashtable_set (hashtable, "date", str_date);
            weechat_hdata_update (hdata, line_data, hashtable);
            weechat_hashtable_free (hashtable);
        }
    }
}
----

Скрипта (Python):

[source,python]
----
# прототип
def hdata_update(hdata: str, pointer: str, hashtable: Dict[str, str]) -> int: ...

# пример: одузима један сад од последње приказане поруке у текућем баферу
own_lines = weechat.hdata_pointer(weechat.hdata_get("buffer"), weechat.current_buffer(), "own_lines")
if own_lines:
    line = weechat.hdata_pointer(weechat.hdata_get("lines"), own_lines, "last_line")
    if line:
        line_data = weechat.hdata_pointer(weechat.hdata_get("line"), line, "data")
        hdata = weechat.hdata_get("line_data")
        weechat.hdata_update(hdata, line_data, {"date": str(weechat.hdata_time(hdata, line_data, "date") - 3600)})
----

==== hdata_get_string

_WeeChat ≥ 0.3.6._

Враћа стринг вредност hdata особине.

Прототип:

[source,c]
----
const char *weechat_hdata_get_string (struct t_hdata *hdata, const char *property);
----

Аргументи:

* _hdata_: показивач на hdata
* _property_: име особине:
** _var_keys_: стринг са листом кључева за променљиве у hdata (у формату: „кључ1,кључ2,кључ3")
** _var_values_: стринг са листом вредности за променљиве у hdata (у формату: „вредност1,вредност2,вредност3”)
** _var_keys_values_: стринг са листом кључева и вредности за променљиве у hdata (у формату: „кључ1:вредост1,кључ2:вредност2,кључ3:вредност3”)
** _var_prev_: име променљиве у структури која је показивач на претходни елемент листе
** _var_next_: име променљиве у структури која је показивач на наредни елемент листе
** _list_keys_: стринг са листом кључева за листе у hdata (у формату: „кључ1,кључ2,кључ3”)
** _list_values_: стринг са листом вредности за листе у hdata (у формату: „вредност1,вредност2,вредност3”)
** _list_keys_values_: стринг са листом кључева и вредности за листе у hdata (у формату: „кључ1:вредност1,кључ2:вредност2,кључ3:вредност3”)

Повратна вредност:

* стринг вредност особине

C пример:

[source,c]
----
weechat_printf (NULL, "променљиве у hdata: %s", weechat_hdata_get_string (hdata, "var_keys"));
weechat_printf (NULL, "листе у hdata: %s", weechat_hdata_get_string (hdata, "list_keys"));
----

Скрипта (Python):

[source,python]
----
# прототип
def hdata_get_string(hdata: str, property: str) -> str: ...

# пример
weechat.prnt("", "променљиве у hdata: %s" % weechat.hdata_get_string(hdata, "var_keys"))
weechat.prnt("", "листе у hdata: %s" % weechat.hdata_get_string(hdata, "list_keys"))
----

[[upgrade]]
=== Ажурирање

Функције за ажурирање програма WeeChat (командом "/upgrade").

==== upgrade_new

_Ажурирано у верзији 1.5._

Креира или чита фајл за ажурирање.

Прототип:

[source,c]
----
struct t_upgrade_file *upgrade_file_new (const char *filename,
                                         int (*callback_read)(const void *pointer,
                                                              void *data,
                                                              struct t_upgrade_file *upgrade_file,
                                                              int object_id,
                                                              struct t_infolist *infolist),
                                         const void *callback_read_pointer,
                                         void *callback_read_data);
----

Аргументи:

* _filename_: име фајла (програм WeeChat овом имену додаје екстензију „.upgrade”)
* _callback_read_: функција која се зове за сваки објекат који се прочита у фајлу ажурирања (ако је NULL, фајл ажурирања се отвара у режиму уписа), аргументи и повратна вредност су:
** _const void *pointer_: показивач
** _void *data_: показивач
** _struct t_upgrade_file *upgrade_file_: показивач на фајл ажурирања
** _int object_id_: id објекта
** _struct t_infolist *infolist_: инфолиста са садржајем објекта
** повратна вредност:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_read_pointer_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat
* _callback_read_data_: показивач који се прослеђује функцији повратног позива када је позове програм WeeChat; ако је NULL, алоцирала га је malloc (или нека слична функција) и аутоматски се ослобађа када се затвори фајл ажурирања

Повратна вредност:

* показивач на фајл ажурирања

C пример:

[source,c]
----
struct t_upgrade_file *upgrade_file = weechat_upgrade_new ("my_file",
                                                           NULL, NULL, NULL);
----

Скрипта (Python):

[source,python]
----
# прототип
def upgrade_new(filename: str, callback_read: str, callback_read_data: str) -> str: ...

# пример
upgrade_file = weechat.upgrade_new("my_file", "", "")
----

==== upgrade_write_object

Уписује објекат у фајл ажурирања.

Прототип:

[source,c]
----
int weechat_upgrade_write_object (struct t_upgrade_file *upgrade_file,
                                  int object_id,
                                  struct t_infolist *infolist);
----

Аргументи:

* _upgrade_file_: показивач на фајл ажурирања
* _object_id_: id за објекат
* _infolist_: инфолиста која треба да се упише у фајл

Повратна вредност:

* 1 ако је све OK, 0 у случају грешке

C пример:

[source,c]
----
if (weechat_upgrade_write_object (upgrade_file, 1, &infolist))
{
    /* OK */
}
else
{
    /* грешка */
}
----

Скрипта (Python):

[source,python]
----
# прототип
def upgrade_write_object(upgrade_file: str, object_id: int, infolist: str) -> int: ...

# пример
weechat.upgrade_write_object(upgrade_file, 1, infolist)
----

==== upgrade_read

_Ажурирано у верзији 1.5._

Чита фајл ажурирања.

Прототип:

[source,c]
----
int weechat_upgrade_read (struct t_upgrade_file *upgrade_file);
----

Аргументи:

* _upgrade_file_: показивач на фајл ажурирања

Повратна вредност:

* 1 ако је све OK, 0 у случају грешке

C пример:

[source,c]
----
weechat_upgrade_read (upgrade_file);
----

Скрипта (Python):

[source,python]
----
# прототип
def upgrade_read(upgrade_file: str) -> int: ...

# пример
weechat.upgrade_read(upgrade_file)
----

==== upgrade_close

Затвара фајл ажурирања.

Прототип:

[source,c]
----
void weechat_upgrade_close (struct t_upgrade_file *upgrade_file);
----

Аргументи:

* _upgrade_file_: показивач на фајл ажурирања

C пример:

[source,c]
----
weechat_upgrade_close (upgrade_file);
----

Скрипта (Python):

[source,python]
----
# прототип
def upgrade_close(upgrade_file: str) -> int: ...

# пример
weechat.upgrade_close(upgrade_file)
----
