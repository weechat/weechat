= WeeChat プラグイン API リファレンス
:author: Sébastien Helleu
:email: flashcode@flashtux.org
:lang: ja-jp
include::includes/attributes-ja.adoc[]

翻訳者:

* Ryuunosuke Ayanokouzi <i38w7i3@yahoo.co.jp>, 2014-2019

このマニュアルは WeeChat チャットクライアントについての文書で、WeeChat の一部です。

// TRANSLATION MISSING
Latest version of this document can be found on
https://weechat.org/doc/[this page ^↗^^].

[[introduction]]
== はじめに

WeeChat (Wee Enhanced Environment for Chat)
は無料のチャットクライアントで、高速、軽量、多くのオペレーティングシステムで動くように設計されています。

このマニュアルは WeeChat プラグイン API についての文書で、C
言語プラグインはこの API を使って WeeChat の中核部と通信しています。

[[plugins_in_weechat]]
== WeeChat プラグイン

プラグインは C 言語のプログラムであり、インターフェースが定義する
WeeChat 関数を呼び出すことができます。

この C 言語プログラムはコンパイルの際に WeeChat のソースを必要としません、WeeChat
は `/plugin` コマンドでこのプログラムを動的に読み込むことができます。

プラグインを動的にオペレーティングシステムに読み込ませるために、プラグインは必ずダイナミックライブラリにしてください。ファイルの拡張子は
GNU/Linux では ".so"、Windows
では ".dll" です。

プラグインでは必ず "weechat-plugin.h" ファイルをインクルードしてください
(WeeChat ソースコードに含まれています)。このファイルでは WeeChat
と通信する際に使う構造体や型が定義されています。

WeeChat 関数を <<plugin_api>>
に表示された書式で呼び出すには、以下のグローバルポインタを定義して
<<_weechat_plugin_init,weechat_plugin_init>> 関数の中でそれを初期化しなければいけません:

[source,c]
----
struct t_weechat_plugin *weechat_plugin;
----

[[macros]]
=== マクロ

プラグインでは必ず以下のマクロを使ってください (いくつかの変数を定義するために必要です):

WEECHAT_PLUGIN_NAME("name")::
    プラグイン名

WEECHAT_PLUGIN_DESCRIPTION("description")::
    プラグインの短い説明

// TRANSLATION MISSING
WEECHAT_PLUGIN_AUTHOR("author")::
    the author name

WEECHAT_PLUGIN_VERSION("1.0")::
    プラグインのバージョン番号

WEECHAT_PLUGIN_LICENSE("GPL3")::
    プラグインのライセンス

WEECHAT_PLUGIN_PRIORITY(1000)::
    プラグインの優先度 (任意、下記参照)

[[main_functions]]
=== 重要な関数

プラグインでは必ず以下の 2 つの関数を使ってください:

* weechat_plugin_init
* weechat_plugin_end

==== weechat_plugin_init

WeeChat はプラグインを読み込む際にこの関数を呼び出します。

プロトタイプ:

[source,c]
----
int weechat_plugin_init (struct t_weechat_plugin *plugin,
                         int argc, char *argv[]);
----

引数:

* _plugin_: WeeChat プラグイン構造体へのポインタ。これはグローバルポインタ
  `+weechat_plugin+` を初期化する際に使われます
* _argc_: プラグインに対する引数の数
// TRANSLATION MISSING
* _argv_: プラグインに対する引数 (see below)

戻り値:

* _WEECHAT_RC_OK_ 成功した場合 (プラグインをロードします)
* _WEECHAT_RC_ERROR_ エラーが起きた場合 (プラグインをロードしません)

// TRANSLATION MISSING
[[plugin_arguments]]
===== Plugin arguments

When the plugin is loaded by WeeChat, it receives the list of arguments
in parameter `argv` and the number of arguments in `argc`.

The arguments can be:

* command line arguments when running the WeeChat binary,
* arguments given to the command `/plugin load xxx`, when the plugin is manually
  loaded by the user.

When the arguments come from the command line, only these arguments are sent to
the plugin:

*-a*, *--no-connect*::
    WeeChat の起動時にサーバへの自動接続を行わない

*-s*, *--no-script*::
    スクリプトの自動ロードを止める

*plugin:option*::
    Option for a plugin: only the plugin-related options are sent, for example
    only the options starting with `irc:` are sent to the plugin called "irc".

[[plugin_priority]]
===== プラグインの優先度

複数のプラグインが自動ロードされた場合 (たとえば起動時)、WeeChat
はまず全てのプラグインをロードし、各プラグインで定義された優先度に従って _init_
関数を呼び出します。優先度を大きな値にすれば _init_ 関数を呼び出す順番が早くなります

デフォルトの優先度は 1000 です
(この値を設定した場合、全てのデフォルトプラグインの後にプラグインをロードします)。

WeeChat のデフォルトプラグインは以下の順番で初期化されます:

include::{autogendir}/autogen_api_plugins_priority.ja.adoc[tag=plugins_priority]

==== weechat_plugin_end

WeeChat プラグインをリロードする際にこの関数を呼び出します。

プロトタイプ:

[source,c]
----
int weechat_plugin_end (struct t_weechat_plugin *plugin);
----

引数:

* _plugin_: WeeChat プラグイン構造体へのポインタ

戻り値:

* _WEECHAT_RC_OK_ 成功した場合
* _WEECHAT_RC_ERROR_ エラーが起きた場合

[[compile_plugin]]
=== プラグインのコンパイル

コンパイルするために WeeChat のソースは不要で、_weechat-plugin.h_
ファイルだけが必要です。

1 つのファイル "toto.c" からなるプラグインは以下のようにコンパイルします (GNU/Linux の場合):

[source,shell]
----
gcc -fPIC -Wall -c toto.c
gcc -shared -fPIC -o toto.so toto.o
----

[[load_plugin]]
=== プラグインを読み込む

_toto.so_ ファイルをシステムのプラグインディレクトリ (例えば
_/usr/local/lib/weechat/plugins_) またはユーザのプラグインディレクトリ (例えば
_/home/user/.local/share/weechat/plugins_) にコピーしてください。

WeeChat の中で:

----
/plugin load toto
----

[[plugin_example]]
=== プラグインの例

コマンド `/double` を追加するプラグインの例: 引数を 2
倍して現在のバッファに表示するか、コマンドを 2 回実行する
(これは実用的なコマンドというよりも、ただの例です!):

[source,c]
----
#include <stdlib.h>

#include "weechat-plugin.h"

WEECHAT_PLUGIN_NAME("double");
WEECHAT_PLUGIN_DESCRIPTION("Test plugin for WeeChat");
WEECHAT_PLUGIN_AUTHOR("Sébastien Helleu <flashcode@flashtux.org>");
WEECHAT_PLUGIN_VERSION("0.1");
WEECHAT_PLUGIN_LICENSE("GPL3");

struct t_weechat_plugin *weechat_plugin = NULL;


/* "/double" コマンドのコールバック*/

int
command_double_cb (const void *pointer, void *data,
                   struct t_gui_buffer *buffer,
                   int argc, char **argv, char **argv_eol)
{
    /* C 言語コンパイラ向けに必要 */
    (void) pointer;
    (void) data;
    (void) buffer;
    (void) argv;

    if (argc > 1)
    {
        weechat_command (NULL, argv_eol[1]);
        weechat_command (NULL, argv_eol[1]);
    }

    return WEECHAT_RC_OK;
}

int
weechat_plugin_init (struct t_weechat_plugin *plugin,
                     int argc, char *argv[])
{
    weechat_plugin = plugin;

    weechat_hook_command ("double",
                          "Display two times a message "
                          "or execute two times a command",
                          "message | command",
                          "message: message to display two times\n"
                          "command: command to execute two times",
                          NULL,
                          &command_double_cb, NULL, NULL);

    return WEECHAT_RC_OK;
}

int
weechat_plugin_end (struct t_weechat_plugin *plugin)
{
    /* C 言語コンパイラ向けに必要 */
    (void) plugin;

    return WEECHAT_RC_OK;
}
----

[[plugin_api]]
== プラグイン API

以下の章では API 関数をカテゴリごとに説明しています。

それぞれの関数について、以下の内容が記載されています:

* 関数の説明、
* C 言語のプロトタイプ、
* 引数の詳細、
* 戻り値、
* C 言語での使用例、
* Python スクリプトでの使用例 (他のスクリプト言語を使う場合も文法は似ています)。

// TRANSLATION MISSING
[[registering]]
=== Registering

Functions to register a script: used only by scripting API, not the C API.

==== register

Register the script.

For more information, see the
link:weechat_scripting.ja.html#register_function[WeeChat scripting guide ^↗^^].

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def register(name: str, author: str, version: str, license: str, description: str, shutdown_function: str, charset: str) -> int: ...
----

[NOTE]
This function is not available in the C API.

[[plugins]]
=== プラグイン

プラグインに関する情報を取得する関数。

==== plugin_get_name

プラグインの名前を取得。

プロトタイプ:

[source,c]
----
const char *weechat_plugin_get_name (struct t_weechat_plugin *plugin);
----

引数:

* _plugin_: WeeChat プラグイン構造体へのポインタ (NULL でも可)

戻り値:

* プラグインの名前、WeeChat コアの場合は "core" (プラグインへのポインタが NULL の場合)

C 言語での使用例:

[source,c]
----
const char *name = weechat_plugin_get_name (plugin);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def plugin_get_name(plugin: str) -> str: ...

# 例
plugin = weechat.buffer_get_pointer(weechat.current_buffer(), "plugin")
name = weechat.plugin_get_name(plugin)
----

[[strings]]
=== 文字列

以下の多くの文字列関数は標準的な C 言語の関数でも定義されていますが、この
API 関数を使うことを推奨します。なぜなら、これらの関数は文字列を
UTF-8 とロケールに準じて取り扱うようになっているからです。

==== charset_set

新しいプラグインの文字セットを設定する (デフォルトの文字セットは _UTF-8_
です、このためプラグインで _UTF-8_ を使う場合は、この関数を呼び出す必要はありません。

プロトタイプ:

[source,c]
----
void weechat_charset_set (const char *charset);
----

引数:

* _charset_: 新たに利用する文字セット

C 言語での使用例:

[source,c]
----
weechat_charset_set ("iso-8859-1");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def charset_set(charset: str) -> int: ...

# 例
weechat.charset_set("iso-8859-1")
----

==== iconv_to_internal

文字列の文字セットを WeeChat の内部文字セット (UTF-8) に変換。

プロトタイプ:

[source,c]
----
char *weechat_iconv_to_internal (const char *charset, const char *string);
----

引数:

* _charset_: 変換元の文字列の文字セット
* _string_: 変換元の文字列

戻り値:

* 文字セットを変換した文字列 (使用後には必ず "free" を呼び出して領域を開放してください)

C 言語での使用例:

[source,c]
----
char *str = weechat_iconv_to_internal ("iso-8859-1", "iso string: é à");
/* ... */
free (str);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def iconv_to_internal(charset: str, string: str) -> str: ...

# 例
str = weechat.iconv_to_internal("iso-8859-1", "iso string: é à")
----

==== iconv_from_internal

文字列の文字セットを WeeChat の内部文字セット (UTF-8) から別の文字セットに変換。

プロトタイプ:

[source,c]
----
char *weechat_iconv_from_internal (const char *charset, const char *string);
----

引数:

* _charset_: 変換先の文字列の文字セット
* _string_: 変換元の文字列

戻り値:

* 文字セットを変換した文字列 (使用後には必ず "free" を呼び出して領域を開放してください)

C 言語での使用例:

[source,c]
----
char *str = weechat_iconv_from_internal ("iso-8859-1", "utf-8 string: é à");
/* ... */
free (str);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def iconv_from_internal(charset: str, string: str) -> str: ...

# 例
str = weechat.iconv_from_internal("iso-8859-1", "utf-8 string: é à")
----

==== gettext

翻訳済み文字列を返す (設定言語に依存)。

プロトタイプ:

[source,c]
----
const char *weechat_gettext (const char *string);
----

引数:

* _string_: 翻訳元の文字列

戻り値:

* 翻訳済み文字列または _string_ (未翻訳の場合)

C 言語での使用例:

[source,c]
----
char *str = weechat_gettext ("hello");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def gettext(string: str) -> str: ...

# 例
str = weechat.gettext("hello")
----

==== ngettext

_count_
引数を元に単数形または複数形で、翻訳済み文字列を返す。

プロトタイプ:

[source,c]
----
const char *weechat_ngettext (const char *string, const char *plural,
                              int count);
----

引数:

* _string_: 翻訳元の文字列、単数形
* _plural_: 翻訳元の文字列、複数形
* _count_: 単数形と複数形のどちらを返すかの判断に使います
  (選択は設定言語に依存)

戻り値:

* 翻訳済み文字列または _string_ / _plural_
  (未翻訳の場合)

C 言語での使用例:

[source,c]
----
char *str = weechat_ngettext ("file", "files", num_files);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def ngettext(string: str, plural: str, count: int) -> str: ...

# 例
num_files = 2
str = weechat.ngettext("file", "files", num_files)
----

==== asprintf

_WeeChat ≥ 4.3.0._

// TRANSLATION MISSING
Format a message in a string allocated by the function.

// TRANSLATION MISSING
[NOTE]
This function is defined for systems where the GNU function `asprintf()`
is not available. +
The behavior is almost the same except that `*result` is set to NULL on error.

プロトタイプ:

[source,c]
----
int weechat_asprintf (char **result, const char *fmt, ...);
----

引数:

// TRANSLATION MISSING
* _result_: pointer to a string pointer
// TRANSLATION MISSING
* _fmt_: format string

戻り値:

// TRANSLATION MISSING
* number of bytes written in `*result` (excluding the final null byte),
  a negative value in case of error.

C 言語での使用例:

[source,c]
----
char *str;

if (weechat_asprintf (&str, "%s, %d", "test", 42) >= 0)
{
    /* *str == "test, 42" */
    /* ... */
    free (str);
}
else
{
    /* error: *str == NULL */
}
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== strndup

// TRANSLATION MISSING
Return duplicated string, with a max number of bytes.

プロトタイプ:

[source,c]
----
char *weechat_strndup (const char *string, int bytes);
----

引数:

* _string_: 複製元の文字列
// TRANSLATION MISSING
* _bytes_: max bytes to duplicate

戻り値:

* 複製した文字列 (使用後には必ず "free" を呼び出して領域を開放してください)

C 言語での使用例:

[source,c]
----
char *str = weechat_strndup ("abcdef", 3);  /* result: "abc" */
/* ... */
free (str);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

// TRANSLATION MISSING
==== string_cut

_WeeChat バージョン 3.3 以上で利用可。_

Cut a string after a given number of chars, add an optional suffix after the
string if it is cut.

プロトタイプ:

[source,c]
----
char *weechat_string_cut (const char *string, int length, int count_suffix, int screen, const char *cut_suffix);
----

引数:

* _string_: string to cut
* _length_: max chars
* _count_suffix_: if 1, the length of suffix is counted in the max length
* _screen_: if 1, the cut is based on width of chars displayed
* _cut_suffix_: the suffix added after the string if it is cut

戻り値:

* cut string (must be freed by calling "free" after use)

C 言語での使用例:

[source,c]
----
char *str = weechat_string_cut ("this is a test", 5, 1, 1, "…");  /* result: "this…" */
/* ... */
free (str);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_tolower

_WeeChat バージョン 3.8 で更新。_

// TRANSLATION MISSING
Return a string with uppercase letters converted to lowercase.

[NOTE]
Behavior has changed in version 3.8: now all uppercase letters are properly
converted to lowercase (by calling function `towlower`), in addition to the
range `A` to `Z`. +
Moreover, a newly allocated string is returned and must be freed after use.

プロトタイプ:

[source,c]
----
char *weechat_string_tolower (const char *string);
----

引数:

* _string_: 変換元の文字列

戻り値:

// TRANSLATION MISSING
* string with lowercase letters (must be freed by calling "free" after use)

C 言語での使用例:

[source,c]
----
char *str = weechat_string_tolower ("ABCD_É");  /* result: "abcd_é" */
/* ... */
free (str);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_toupper

_WeeChat バージョン 3.8 で更新。_

// TRANSLATION MISSING
Return a string with lowercase letters converted to uppercase.

[NOTE]
Behavior has changed in version 3.8: now all lowercase letters are properly
converted to uppercase (by calling function `towupper`), in addition to the
range `a` to `z`. +
Moreover, a newly allocated string is returned and must be freed after use.

プロトタイプ:

[source,c]
----
char *weechat_string_toupper (const char *string);
----

引数:

* _string_: 変換元の文字列

戻り値:

// TRANSLATION MISSING
* string with uppercase letters (must be freed by calling "free" after use)

C 言語での使用例:

[source,c]
----
char *str = weechat_string_toupper ("abcd_é");  /* result: "ABCD_É" */
/* ... */
free (str);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_charcmp

_WeeChat バージョン 1.0, 3.8 で更新。_

2 つの 文字を比較。

プロトタイプ:

[source,c]
----
int weechat_string_charcmp (const char *string1, const char *string2);
----

引数:

* _string1_: 1 番目の比較文字列
* _string2_: 2 番目の比較文字列

// TRANSLATION MISSING
Return value:

* arithmetic result of subtracting the first UTF-8 char in _string2_
  from the first UTF-8 char in _string1_:
// TRANSLATION MISSING
** < 0 if char1 < char2
** 0 if char1 == char2
** > 0 if char1 > char2

C 言語での使用例:

[source,c]
----
int diff = weechat_string_charcmp ("aaa", "ccc");  /* == -2 */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_charcasecmp

_WeeChat バージョン 1.0, 3.8 で更新。_

大文字小文字の違いを無視して、2 つの 文字を比較。

// TRANSLATION MISSING
[NOTE]
Behavior has changed in version 3.8: now all uppercase letters are properly
converted to lowercase (by calling function `towlower`), in addition to the
range `A` to `Z`.

プロトタイプ:

[source,c]
----
int weechat_string_charcasecmp (const char *string1, const char *string2);
----

引数:

* _string1_: 1 番目の比較文字列
* _string2_: 2 番目の比較文字列

// TRANSLATION MISSING
Return value:

* arithmetic result of subtracting the first UTF-8 char in _string2_
  (converted to lowercase) from the first UTF-8 char in _string1_ (converted to
  lowercase):
// TRANSLATION MISSING
** < 0 if char1 < char2
** 0 if char1 == char2
** > 0 if char1 > char2

C 言語での使用例:

[source,c]
----
int diff = weechat_string_charcasecmp ("aaa", "CCC");  /* == -2 */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== strcmp

_WeeChat ≥ 3.8_

// TRANSLATION MISSING
Case-sensitive string comparison.

プロトタイプ:

[source,c]
----
int weechat_strcmp (const char *string1, const char *string2);
----

引数:

* _string1_: 1 番目の比較対象の文字列
* _string2_: 2 番目の比較対象の文字列

// TRANSLATION MISSING
Return value:

* arithmetic result of subtracting the last compared UTF-8 char in
  _string2_ from the last compared UTF-8 char in _string1_:
// TRANSLATION MISSING
** < 0 if string1 < string2
** 0 if string1 == string2
** > 0 if string1 > string2

C 言語での使用例:

[source,c]
----
int diff = weechat_strcmp ("aaa", "ccc");  /* == -2 */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== strncmp

_WeeChat ≥ 3.8_

// TRANSLATION MISSING
Case-sensitive string comparison, for _max_ chars.

プロトタイプ:

[source,c]
----
int weechat_strncmp (const char *string1, const char *string2, int max);
----

引数:

* _string1_: 1 番目の比較対象の文字列
* _string2_: 2 番目の比較対象の文字列
* _max_: 比較する文字数の最大値

// TRANSLATION MISSING
Return value:

* arithmetic result of subtracting the last compared UTF-8 char in
  _string2_ from the last compared UTF-8 char in _string1_:
// TRANSLATION MISSING
** < 0 if string1 < string2
** 0 if string1 == string2
** > 0 if string1 > string2

C 言語での使用例:

[source,c]
----
int diff = weechat_strncmp ("aabb", "aacc", 2);  /* == 0 */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== strcasecmp

_WeeChat バージョン 1.0, 3.8 で更新。_

// TRANSLATION MISSING
Case-insensitive string comparison.

// TRANSLATION MISSING
[NOTE]
Behavior has changed in version 3.8: now all uppercase letters are properly
converted to lowercase (by calling function `towlower`), in addition to the
range `A` to `Z`.

プロトタイプ:

[source,c]
----
int weechat_strcasecmp (const char *string1, const char *string2);
----

引数:

* _string1_: 1 番目の比較対象の文字列
* _string2_: 2 番目の比較対象の文字列

// TRANSLATION MISSING
Return value:

* arithmetic result of subtracting the last compared UTF-8 char in
  _string2_ (converted to lowercase) from the last compared UTF-8 char in _string1_
  (converted to lowercase):
// TRANSLATION MISSING
** < 0 if string1 < string2
** 0 if string1 == string2
** > 0 if string1 > string2

C 言語での使用例:

[source,c]
----
int diff;
diff = weechat_strcasecmp ("aaa", "CCC");    /* == -2 */
diff = weechat_strcasecmp ("noël", "NOËL");  /* == 0  */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== strcasecmp_range

_WeeChat バージョン 0.3.7 以上で利用可、バージョン 1.0, 3.8 で更新。_

大文字小文字を無視する文字範囲の幅を使い、ロケールと大文字小文字を無視して文字列を比較。

プロトタイプ:

[source,c]
----
int weechat_strcasecmp_range (const char *string1, const char *string2, int range);
----

引数:

* _string1_: 1 番目の比較対象の文字列
* _string2_: 2 番目の比較対象の文字列
* _range_: 大文字小文字を無視する文字範囲の幅、例:
** 26: `+A-Z+` を `+a-z+` のように変換して比較
** 29: `+A-Z [ \ ]+` を `+a-z { | }+` のように変換して比較
** 30: `+A-Z [ \ ] ^+` を `+a-z { | } ~+` のように変換して比較

[NOTE]
29 と 30 は IRC など一部のプロトコルで使います。

// TRANSLATION MISSING
Return value:

* arithmetic result of subtracting the last compared UTF-8 char in
  _string2_ (converted to lowercase) from the last compared UTF-8 char in _string1_
  (converted to lowercase):
// TRANSLATION MISSING
** < 0 if string1 < string2
** 0 if string1 == string2
** > 0 if string1 > string2

C 言語での使用例:

[source,c]
----
int diff = weechat_strcasecmp_range ("nick{away}", "NICK[away]", 29);  /* == 0 */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== strncasecmp

_WeeChat バージョン 1.0, 3.8 で更新。_

// TRANSLATION MISSING
Case-insensitive string comparison, for _max_ chars.

// TRANSLATION MISSING
[NOTE]
Behavior has changed in version 3.8: now all uppercase letters are properly
converted to lowercase (by calling function `towlower`), in addition to the
range `A` to `Z`.

プロトタイプ:

[source,c]
----
int weechat_strncasecmp (const char *string1, const char *string2, int max);
----

引数:

* _string1_: 1 番目の比較対象の文字列
* _string2_: 2 番目の比較対象の文字列
* _max_: 比較する文字数の最大値

// TRANSLATION MISSING
Return value:

* arithmetic result of subtracting the last compared UTF-8 char in
  _string2_ (converted to lowercase) from the last compared UTF-8 char in _string1_
  (converted to lowercase):
// TRANSLATION MISSING
** < 0 if string1 < string2
** 0 if string1 == string2
** > 0 if string1 > string2

C 言語での使用例:

[source,c]
----
int diff = weechat_strncasecmp ("aabb", "AACC", 2);  /* == 0 */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== strncasecmp_range

_WeeChat バージョン 0.3.7 以上で利用可、バージョン 1.0, 3.8 で更新。_

大文字小文字を無視する文字範囲の幅を使い、ロケールと大文字小文字を無視して
_max_ 文字だけ文字列を比較。

プロトタイプ:

[source,c]
----
int weechat_strncasecmp_range (const char *string1, const char *string2, int max, int range);
----

引数:

* _string1_: 1 番目の比較対象の文字列
* _string2_: 2 番目の比較対象の文字列
* _max_: 比較する文字数の最大値
* _range_: 大文字小文字を無視する文字範囲の幅、例:
** 26: `+A-Z+` を `+a-z+` のように変換して比較
** 29: `+A-Z [ \ ]+` を `+a-z { | }+` のように変換して比較
** 30: `+A-Z [ \ ] ^+` を `+a-z { | } ~+` のように変換して比較

[NOTE]
29 と 30 は IRC など一部のプロトコルで使います。

// TRANSLATION MISSING
Return value:

* arithmetic result of subtracting the last compared UTF-8 char in
  _string2_ (converted to lowercase) from the last compared UTF-8 char in _string1_
  (converted to lowercase):
// TRANSLATION MISSING
** < 0 if string1 < string2
** 0 if string1 == string2
** > 0 if string1 > string2

C 言語での使用例:

[source,c]
----
int diff = weechat_strncasecmp_range ("nick{away}", "NICK[away]", 6, 29);  /* == 0 */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== strcmp_ignore_chars

_WeeChat バージョン 1.0, 3.8 で更新。_

// TRANSLATION MISSING
String comparison ignoring some chars.

プロトタイプ:

[source,c]
----
int weechat_strcmp_ignore_chars (const char *string1, const char *string2,
                                 const char *chars_ignored,
                                 int case_sensitive);
----

引数:

* _string1_: 1 番目の比較対象の文字列
* _string2_: 2 番目の比較対象の文字列
* _chars_ignored_: 無視する文字
* _case_sensitive_: 大文字小文字を区別して比較する場合は 1、区別しない場合は 0

// TRANSLATION MISSING
[NOTE]
Behavior has changed in version 3.8 when _case_sensitive_ is set to 0: now all
uppercase letters are properly converted to lowercase (by calling function
`towlower`), in addition to the range `A` to `Z`.

// TRANSLATION MISSING
Return value:

* arithmetic result of subtracting the last compared UTF-8 char in
  _string2_ (converted to lowercase if _case_sensitive_ is set to 0) from the last
  compared UTF-8 char in _string1_ (converted to lowercase if _case_sensitive_ is
  set to 0):
// TRANSLATION MISSING
** < 0 if string1 < string2
** 0 if string1 == string2
** > 0 if string1 > string2

C 言語での使用例:

[source,c]
----
int diff = weechat_strcmp_ignore_chars ("a-b", "--a-e", "-", 1);  /* == -3 */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== strcasestr

_WeeChat バージョン 1.3, 3.8 で更新。_

// TRANSLATION MISSING
Case-insensitive string search.

// TRANSLATION MISSING
[NOTE]
Behavior has changed in version 3.8: now all uppercase letters are properly
converted to lowercase (by calling function `towlower`), in addition to the
range `A` to `Z`.

プロトタイプ:

[source,c]
----
const char *weechat_strcasestr (const char *string, const char *search);
----

引数:

* _string_: 文字列
* _search_: _string_ 内を検索する文字

戻り値:

* 見つかった文字列へのポインタ、見つからない場合は NULL
  (_WeeChat バージョン 1.3 以上の場合_: 返されるポインタは _const char *_ であり、_char *_ ではありません)

C 言語での使用例:

[source,c]
----
const char *pos = weechat_strcasestr ("aBcDeF", "de");  /* result: pointer to "DeF" */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== strlen_screen

// TRANSLATION MISSING
_WeeChat ≥ 0.4.2, updated in 3.8._

// TRANSLATION MISSING
Return number of chars needed on screen to display UTF-8 string.

// TRANSLATION MISSING
WeeChat color codes are skipped and don't count in the result (this is the only
difference with the function <<_utf8_strlen_screen,utf8_strlen_screen>>).

プロトタイプ:

[source,c]
----
int weechat_strlen_screen (const char *string);
----

引数:

* _string_: 文字列

戻り値:

* UTF-8 文字列を画面上に表示するために必要な画面幅

C 言語での使用例:

[source,c]
----
int length_on_screen = weechat_strlen_screen ("é");  /* == 1 */
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def strlen_screen(string: str) -> int: ...

# 例
length = weechat.strlen_screen("é")  # 1
----

==== string_match

_WeeChat バージョン 1.0, 3.8 で更新。_

文字列がマスクにマッチするか確認。

プロトタイプ:

[source,c]
----
int weechat_string_match (const char *string, const char *mask,
                          int case_sensitive);
----

引数:

* _string_: 文字列
* _mask_: ワイルドカード (`+*+`) を含むマスク、各ワイルドカードは文字列中の
  0 個またはそれ以上の文字にマッチします
* _case_sensitive_: 大文字小文字を区別する場合は 1、区別しない場合は 0

[NOTE]
WeeChat バージョン 1.0 以上の場合、ワイルドカードをマスクの内部で使うことが可能です
(マスクの最初および最後だけではありません)。

// TRANSLATION MISSING
[NOTE]
Behavior has changed in version 3.8 when _case_sensitive_ is set to 0: now all
uppercase letters are properly converted to lowercase (by calling function
`towlower`), in addition to the range `A` to `Z`.

戻り値:

* マスクにマッチした場合は 1、それ以外は 0

C 言語での使用例:

[source,c]
----
int match1 = weechat_string_match ("abcdef", "abc*", 0);   /* == 1 */
int match2 = weechat_string_match ("abcdef", "*dd*", 0);   /* == 0 */
int match3 = weechat_string_match ("abcdef", "*def", 0);   /* == 1 */
int match4 = weechat_string_match ("abcdef", "*de*", 0);   /* == 1 */
int match5 = weechat_string_match ("abcdef", "*b*d*", 0);  /* == 1 */
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def string_match(string: str, mask: str, case_sensitive: int) -> int: ...

# 例
match1 = weechat.string_match("abcdef", "abc*", 0)   # == 1
match2 = weechat.string_match("abcdef", "*dd*", 0)   # == 0
match3 = weechat.string_match("abcdef", "*def", 0)   # == 1
match4 = weechat.string_match("abcdef", "*de*", 0)   # == 1
match5 = weechat.string_match("abcdef", "*b*d*", 0)  # == 1
----

==== string_match_list

// TRANSLATION MISSING
_WeeChat ≥ 2.5, updated in 3.8._

文字列が否定マスク
(書式: "!word")
を含むマスクリストにマッチするか確認します。否定マスクは通常のマスクよりも優先度が高いです。

プロトタイプ:

[source,c]
----
int weechat_string_match_list (const char *string, const char **masks,
                               int case_sensitive);
----

引数:

* _string_: 文字列
* _masks_: マスクリスト、リストの最後には NULL をつけてください;
  各マスクは関数 <<_string_match,string_match>> で文字列と比較されます
* _case_sensitive_: 大文字と小文字を区別する場合は 1、区別しない場合は 0

// TRANSLATION MISSING
[NOTE]
Behavior has changed in version 3.8 when _case_sensitive_ is set to 0: now all
uppercase letters are properly converted to lowercase (by calling function
`towlower`), in addition to the range `A` to `Z`.

戻り値:

* 1 if string matches list of masks (at least one mask matches and no negative
  mask matches), otherwise 0
* 文字列がマスクリストとマッチした場合 (1 つ以上のマスクにマッチするか、否定マスクに
  1 つもマッチしない場合) は 1、それ以外の場合は 0

C 言語での使用例:

[source,c]
----
const char *masks[3] = { "*", "!abc*", NULL };
int match1 = weechat_string_match_list ("abc", masks, 0);     /* == 0 */
int match2 = weechat_string_match_list ("abcdef", masks, 0);  /* == 0 */
int match3 = weechat_string_match_list ("def", masks, 0);     /* == 1 */
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def string_match_list(string: str, masks: str, case_sensitive: int) -> int: ...

# 例
match1 = weechat.string_match("abc", "*,!abc*", 0)     # == 0
match2 = weechat.string_match("abcdef", "*,!abc*", 0)  # == 0
match3 = weechat.string_match("def", "*,!abc*", 0)     # == 1
----

==== string_expand_home

_WeeChat バージョン 0.3.3 以上で利用可。_

文字列が `+~+` から始まる場合はこれをホームディレクトリで置換。文字列が
`+~+` から始まっていない場合は同じ文字列を返す。

プロトタイプ:

[source,c]
----
char *weechat_string_expand_home (const char *path);
----

引数:

* _path_: パス

戻り値:

* `+~+` から始まるパスをホームディレクトリで置換したパス
  (使用後には必ず "free" を呼び出して領域を開放してください)

C 言語での使用例:

[source,c]
----
char *str = weechat_string_expand_home ("~/file.txt");
/* result: "/home/user/file.txt" */
/* ... */
free (str);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_eval_path_home

// TRANSLATION MISSING
_WeeChat ≥ 1.3, updated in 3.2._

3 段階でパスを評価します:

// TRANSLATION MISSING
. replace leading `%h` by a WeeChat directory (data by default),
. 先頭の `+~+` をユーザのホームディレクトリで置換し
  (<<_string_expand_home,string_expand_home>> を実行し)、
. 変数を評価します
  (<<_string_eval_expression,string_eval_expression>> を参照してください)。

プロトタイプ:

[source,c]
----
char *weechat_string_eval_path_home (const char *path,
                                     struct t_hashtable *pointers,
                                     struct t_hashtable *extra_vars,
                                     struct t_hashtable *options);
----

引数:

// TRANSLATION MISSING
* _path_: パス
* _pointers_: 関数に渡されるハッシュテーブル
  <<_string_eval_expression,string_eval_expression>>
* _extra_vars_: 関数に渡されるハッシュテーブル
  <<_string_eval_expression,string_eval_expression>>
* _options_: hashtable for call to function
  <<_string_eval_expression,string_eval_expression>>, with one extra key
  supported:
** _directory_: WeeChat directory to use when replacing `%h`, one of:
*** _config_
*** _data_ (default)
*** _cache_
*** _runtime_

戻り値:

* 評価済みのパス (使用後には必ず "free" を呼び出して領域を開放してください)

C 言語での使用例:

[source,c]
----
char *str = weechat_string_eval_path_home ("${weechat_config_dir}/test.conf", NULL, NULL, NULL);
/* result: "/home/user/.config/weechat/test.conf" */
/* ... */
free (str);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def string_eval_path_home(path: str, pointers: Dict[str, str], extra_vars: Dict[str, str], options: Dict[str, str]) -> str: ...

# 例
path = weechat.string_eval_path_home("${weechat_config_dir}/test.conf", {}, {}, {})
# path == "/home/user/.config/weechat/test.conf"
----

==== string_remove_quotes

文字列の最初と最後から引用符を削除
(最初の引用符の前と最後の引用符の後にある空白文字は無視)。

プロトタイプ:

[source,c]
----
char *weechat_string_remove_quotes (const char *string, const char *quotes);
----

引数:

* _string_: 文字列
* _quotes_: 引用符のリストを含む文字列

戻り値:

* 最初と最後から引用符を削除した文字列
  (使用後には必ず "free" を呼び出して領域を開放してください)

C 言語での使用例:

[source,c]
----
char *str = weechat_string_remove_quotes (string, " 'I can't' ", "'");
/* result: "I can't" */
/* ... */
free (str);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_strip

文字列の最初と最後から文字を削除する。

プロトタイプ:

[source,c]
----
char *weechat_string_strip (const char *string, int left, int right,
                            const char *chars);
----

引数:

* _string_: 文字列
* _left_: 0 以外の場合は左側の文字を削除
* _right_: 0 以外の場合は右側の文字を削除
* _chars_: 削除する文字を含む文字列

戻り値:

* 文字を削除した文字列 (使用後には必ず "free" を呼び出して領域を開放してください)

C 言語での使用例:

[source,c]
----
char *str = weechat_string_strip (".abc -", 0, 1, "- .");  /* result: ".abc" */
/* ... */
free (str);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_convert_escaped_chars

_WeeChat バージョン 1.0 以上で利用可。_

エスケープ文字を値に変換:

* `+\"+`: 二重引用符
* `+\\+`: バックスラッシュ
* `+\a+`: アラート (BEL)
* `+\b+`: バックスペース
* `+\e+`: エスケープ
* `+\f+`: 改ページ
* `+\n+`: 改行
* `+\r+`: キャリッジリターン
* `+\t+`: 水平タブ
* `+\v+`: 垂直タブ
* `+\0ooo+`: 文字の 8 進数表現 (`ooo` は 0 桁から 3 桁)
* `+\xhh+`: 文字の 16 進数表現 (`hh` は 1 桁から 2 桁)
* `+\uhhhh+`: ユニコード文字の 16 進数表現 (`hhhh` は 1 桁から 4 桁)
* `+\Uhhhhhhhh+`: ユニコード文字の 16 進数表現 (`hhhhhhhh` は 1 桁から 8 桁)

プロトタイプ:

[source,c]
----
char *weechat_string_convert_escaped_chars (const char *string);
----

引数:

* _string_: 文字列

戻り値:

* エスケープ文字を値に変換した文字列
  (使用後には必ず "free" を呼び出して領域を開放してください)

C 言語での使用例:

[source,c]
----
char *str = weechat_string_convert_escaped_chars ("snowman: \\u2603");
/* str == "snowman: ☃" */
/* ... */
free (str);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_mask_to_regex

マスクから正規表現を作りこれを返す、マスク用の特殊文字は
`+*+` のみ。これ以外の文字はすべてエスケープされます。

プロトタイプ:

[source,c]
----
char *weechat_string_mask_to_regex (const char *mask);
----

引数:

* _mask_: マスク

戻り値:

* 正規表現の文字列 (使用後には必ず "free" を呼び出して領域を開放してください)

C 言語での使用例:

[source,c]
----
char *str_regex = weechat_string_mask_to_regex ("test*mask");
/* result: "test.*mask" */
/* ... */
free (str_regex);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def string_mask_to_regex(mask: str) -> str: ...

# 例
regex = weechat.string_mask_to_regex("test*mask")  # "test.*mask"
----

==== string_regex_flags

_WeeChat バージョン 0.3.7 以上で利用可。_

フラグ以降の文字列へのポインタと正規表現をコンパイルするためのフラグ付きマスクを返す

プロトタイプ:

[source,c]
----
const char *weechat_string_regex_flags (const char *regex, int default_flags, int *flags)
----

引数:

* _regex_: POSIX 拡張正規表現
* _default_flags_: 以下の値を組み合わせたもの (`man regcomp` を参照):
** REG_EXTENDED
** REG_ICASE
** REG_NEWLINE
** REG_NOSUB
* _flags_: ポインタ値は正規表現中で指定されたフラグと一緒にセットされます
  (デフォルトのフラグ + 正規表現中で指定されたフラグ)

フラグは必ず正規表現の最初につけてください。書式:
"(?eins-eins)string"。

利用可能なフラグ:

* _e_: POSIX 拡張正規表現 (_REG_EXTENDED_)
* _i_: 大文字小文字を区別しない (_REG_ICASE_)
* _n_: 任意の文字にマッチする演算子を改行文字にマッチさせない (_REG_NEWLINE_)
* _s_: マッチした部分文字列の位置を使わない (_REG_NOSUB_)

戻り値:

* _regex_ からフラグを除いた位置へのポインタ

C 言語での使用例:

[source,c]
----
const char *regex = "(?i)test";
int flags;
const char *ptr_regex = weechat_string_regex_flags (regex, REG_EXTENDED, &flags);
/* ptr_regex == "test", flags == REG_EXTENDED | REG_ICASE */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_regcomp

_WeeChat バージョン 0.3.7 以上で利用可。_

文字列の最初に含まれるオプションフラグを使って POSIX
拡張正規表現をコンパイル (フラグの書式については
<<_string_regex_flags,string_regex_flags>> を参照)。

プロトタイプ:

[source,c]
----
int weechat_string_regcomp (void *preg, const char *regex, int default_flags)
----

引数:

* _preg_: _regex_t_ 構造体へのポインタ
* _regex_: POSIX 拡張正規表現
* _default_flags_: 以下の値の組み合わせ (`man regcomp` を参照):
** REG_EXTENDED
** REG_ICASE
** REG_NEWLINE
** REG_NOSUB

戻り値:

* `regcomp` 関数と同じ戻り値
  (成功の場合は 0、エラーが起きた場合は 0 以外、`man regcomp` を参照)

[NOTE]
// TRANSLATION MISSING
Regular expression _preg_ must be cleaned by calling "regfree" after use,
if the function returned 0 (OK).

C 言語での使用例:

[source,c]
----
regex_t my_regex;
if (weechat_string_regcomp (&my_regex, "(?i)test", REG_EXTENDED) == 0)
{
    /* OK */
    /* ... */
    regfree (&my_regex);
}
else
{
    /* error */
    /* ... */
}
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_has_highlight

ハイライトしたい単語のリストを元に、1 箇所以上マッチする部分があるか調べる。

プロトタイプ:

[source,c]
----
int weechat_string_has_highlight (const char *string,
                                  const char highlight_words);
----

引数:

* _string_: 文字列
* _highlight_words_: ハイライトしたい単語のリスト、コンマ区切り

戻り値:

* ハイライトしたい単語にマッチする部分が 1 箇所以上ある場合は 1、それ以外は 0

C 言語での使用例:

[source,c]
----
int hl = weechat_string_has_highlight ("my test string", "test,word2");  /* == 1 */
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def string_has_highlight(string: str, highlight_words: str) -> int: ...

# 例
highlight = weechat.string_has_highlight("my test string", "test,word2")  # 1
----

==== string_has_highlight_regex

_WeeChat バージョン 0.3.4 以上で利用可。_

POSIX 拡張正規表現を使って、文字列中から正規表現にマッチする部分が 1
つ以上あるか確認。 +
文字列を正規表現にマッチさせるには、マッチする部分の前後に区切り文字
(アルファベット、`+-+`、`+_+`、`+|+` 以外) がなければいけません。

プロトタイプ:

[source,c]
----
int weechat_string_has_highlight_regex (const char *string, const char *regex);
----

引数:

* _string_: 文字列
* _regex_: POSIX 拡張正規表現

戻り値:

* ハイライトしたい正規表現にマッチする部分が 1 箇所以上ある場合は 1、それ以外は 0

C 言語での使用例:

[source,c]
----
int hl = weechat_string_has_highlight_regex ("my test string", "test|word2");  /* == 1 */
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def string_has_highlight_regex(string: str, regex: str) -> int: ...

# 例
highlight = weechat.string_has_highlight_regex("my test string", "test|word2")  # 1
----

==== string_replace

マッチした全ての文字列を別の文字列で置換。

プロトタイプ:

[source,c]
----
char *weechat_string_replace (const char *string, const char *search,
                              const char *replace);
----

引数:

* _string_: 文字列
* _search_: マッチさせる文字列
* _replace_: _search_ を置き換える文字列

戻り値:

* _search_ を _replace_ で置き換えた文字列
  (使用後には必ず "free" を呼び出して領域を開放してください)

C 言語での使用例:

[source,c]
----
char *str = weechat_string_replace ("test", "s", "x");  /* result: "text" */
/* ... */
free (str);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_replace_regex

_WeeChat バージョン 1.0 以上で利用可。_

文字列中のテキストを正規表現、置換先テキスト、任意指定のコールバックを使って置換。

プロトタイプ:

[source,c]
----
char *weechat_string_replace_regex (const char *string, void *regex,
                                    const char *replace, const char reference_char,
                                    char *(*callback)(void *data, const char *text),
                                    void *callback_data);
----

引数:

* _string_: 文字列
* _regex_: WeeChat 関数 <<_string_regcomp,string_regcomp>>
  または regcomp (`man regcomp` を参照)
  でコンパイルした正規表現へのポインタ (_regex_t_ 構造体)
* _replace_: 置換先テキスト、以下のリファレンスを使うことができます:
** `+$0+` から `+$99+`: 正規表現中の 0 から 99 番目のマッチ部分 (0
   はマッチする部分全体、1 から 99 は括弧で括られたグループ)
** `+$++`: 最後にマッチした部分 (最大の番号を持つマッチ部分)
** `+$.*N+`: `+*+` で全ての文字を置換した `+N+` 番目 (`+++` または `+0+` から `+99+` を使うことができます)
   のマッチ部分 (`+*+` 文字は空白 (32) から `+~+` (126) までの任意の文字を使うことができます)
* _reference_char_: マッチ部分を参照するための文字 (通常は `+$+`)
* _callback_: _replace_ に含まれる各リファレンスに対して呼び出される任意指定可能なコールバック関数
  (マッチ部分を文字で置換する場合を除く); このコールバックは必ず以下の値を返してください:
** 新しく割り当てられた文字列: 文字列を置換先テキストとして使います
   (文字列は使用後に開放されます)
** NULL: コールバックに渡されたテキストを置換先テキストとして使います
   (文字列に変更を加えません)
* _callback_data_: _callback_ コールバックを呼び出す際にコールバックに渡すポインタ

戻り値:

* 置換されたテキストを含む文字、問題が起きた場合は NULL
  (使用後には必ず "free" を呼び出して領域を開放してください)

C 言語での使用例:

[source,c]
----
regex_t my_regex;
char *string;
if (weechat_string_regcomp (&my_regex, "([0-9]{4})-([0-9]{2})-([0-9]{2})",
                            REG_EXTENDED) == 0)
{
    string = weechat_string_replace_regex ("date: 2014-02-14", &my_regex,
                                           "$3/$2/$1", '$', NULL, NULL);
    /* string == "date: 14/02/2014" */
    if (string)
        free (string);
    regfree (&my_regex);
}
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_translate_chars

_WeeChat バージョン 3.8 以上で利用可。_

// TRANSLATION MISSING
Translate chars in a string.

プロトタイプ:

[source,c]
----
char *string_translate_chars (const char *string, const char *chars1, const char *chars2);
----

引数:

// TRANSLATION MISSING
* _string_: string
* _chars1_: string with chars to translate
* _chars2_: string with replacement chars; it must contain the same number of
  UTF-8 chars than _chars1_

戻り値:

* string with translated chars, NULL if problem (must be freed by calling "free"
  after use)

C 言語での使用例:

[source,c]
----
/* "test" => "tEst" */
char *str = weechat_string_translate_chars ("test", "abcdef", "ABCDEF");

/* "clean the boat" => "CleAn the BoAt" */
char *str = weechat_string_translate_chars ("clean the boat", "abc", "ABC");
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_split

_WeeChat バージョン 2.5、2.6 で更新。_

1 つ以上の区切り文字に従って文字列を分割。

プロトタイプ:

[source,c]
----
char **weechat_string_split (const char *string, const char *separators,
                             const char *strip_items, int flags,
                             int num_items_max, int *num_items);
----

引数:

* _string_: 分割する文字列
* _separators_: 分割に使う区切り文字
// TRANSLATION MISSING
* _strip_items_: chars to strip from returned items (left/right);
  optional, can be NULL
* _flags_:
  デフォルト動作を変更するビットフラグの組合せ値; 値が 0 の場合、デフォルト動作
  (文字列の先頭と末尾にある区切り文字を削除しない、連続する区切り文字を 1 つにまとめない)
  になります。以下のフラグを組み合わせて値を指定してください:
** WEECHAT_STRING_SPLIT_STRIP_LEFT:
   文字列左端 (先頭) の区切り文字を削除する
** WEECHAT_STRING_SPLIT_STRIP_RIGHT:
   文字列右端 (末尾) の区切り文字を削除する
** WEECHAT_STRING_SPLIT_COLLAPSE_SEPS:
   連続する区切り文字を 1 つにまとめる
** WEECHAT_STRING_SPLIT_KEEP_EOL: 分割後の各値は分割位置先頭から文字列の最後までとする
* _num_items_max_: 分割回数の上限 (0 = 制限なし)
* _num_items_: 分割回数を返す整数型変数へのポインタ

[NOTE]
WeeChat バージョン 2.4 以下で _keep_eol_ とされていた引数は現在 _flags_
引数に変わられました。両引数の値の対応関係は以下の通りです:
[width="100%",cols="1,10",options="header"]
|===
| keep_eol | flags
| 0        | WEECHAT_STRING_SPLIT_STRIP_LEFT \| WEECHAT_STRING_SPLIT_STRIP_RIGHT \| WEECHAT_STRING_SPLIT_COLLAPSE_SEPS
| 1        | WEECHAT_STRING_SPLIT_STRIP_LEFT \| WEECHAT_STRING_SPLIT_STRIP_RIGHT \| WEECHAT_STRING_SPLIT_COLLAPSE_SEPS \| WEECHAT_STRING_SPLIT_KEEP_EOL
| 2        | WEECHAT_STRING_SPLIT_STRIP_LEFT \| WEECHAT_STRING_SPLIT_COLLAPSE_SEPS \| WEECHAT_STRING_SPLIT_KEEP_EOL
|===

戻り値:

* 文字列の配列、分割に失敗した場合は NULL (使用後には必ず
  <<_string_free_split,string_free_split>> を呼び出して領域を開放してください)

C 言語での使用例:

[source,c]
----
char **argv;
int argc;

argv = weechat_string_split ("abc de  fghi ", " ", NULL, 0, 0, &argc);
/* result: argv[0] == "abc"
           argv[1] == "de"
           argv[2] == ""
           argv[3] == "fghi"
           argv[4] == ""
           argv[5] == NULL
           argc == 5
*/
weechat_string_free_split (argv);

argv = weechat_string_split ("abc de  fghi ", " ", NULL,
                             WEECHAT_STRING_SPLIT_STRIP_LEFT
                             | WEECHAT_STRING_SPLIT_STRIP_RIGHT
                             | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS,
                             0, &argc);
/* result: argv[0] == "abc"
           argv[1] == "de"
           argv[2] == "fghi"
           argv[3] == NULL
           argc == 3
*/
weechat_string_free_split (argv);

argv = weechat_string_split ("abc de  fghi ", " ", NULL,
                             WEECHAT_STRING_SPLIT_STRIP_LEFT
                             | WEECHAT_STRING_SPLIT_STRIP_RIGHT
                             | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS
                             | WEECHAT_STRING_SPLIT_KEEP_EOL,
                             0, &argc);
/* result: argv[0] == "abc de  fghi"
           argv[1] == "de  fghi"
           argv[2] == "fghi"
           argv[3] == NULL
           argc == 3
*/
weechat_string_free_split (argv);

argv = weechat_string_split ("abc de  fghi ", " ", NULL,
                             WEECHAT_STRING_SPLIT_STRIP_LEFT
                             | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS
                             | WEECHAT_STRING_SPLIT_KEEP_EOL,
                             0, &argc);
/* result: argv[0] == "abc de  fghi "
           argv[1] == "de  fghi "
           argv[2] == "fghi "
           argv[3] == NULL
           argc == 3
*/
weechat_string_free_split (argv);

argv = weechat_string_split (" abc, de,, fghi ", ",", " ",
                             WEECHAT_STRING_SPLIT_STRIP_LEFT
                             | WEECHAT_STRING_SPLIT_STRIP_RIGHT
                             | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS,
                             0, &argc);
/* result: argv[0] == "abc"
           argv[1] == "de"
           argv[2] == "fghi"
           argv[3] == NULL
           argc == 3
*/
weechat_string_free_split (argv);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_split_shell

_WeeChat バージョン 1.0 以上で利用可。_

コマンドを引数を分割する際にシェルがやるように文字列を分割。

// TRANSLATION MISSING
This function is a C conversion of Python class "shlex" (file: Lib/shlex.py in
Python repository), see
https://docs.python.org/3/library/shlex.html[this page ^↗^^].

プロトタイプ:

[source,c]
----
char **weechat_string_split_shell (const char *string, int *num_items);
----

引数:

* _string_: 分割する文字列
* _num_items_: 分割回数を返す整数型変数へのポインタ

戻り値:

* 文字列の配列、分割に失敗した場合は NULL (使用後には必ず
  <<_string_free_split,string_free_split>> を呼び出して領域を開放してください)

C 言語での使用例:

[source,c]
----
char **argv;
int argc;
argv = weechat_string_split_shell ("test 'first arg'  \"second arg\"", &argc);
/* result: argv[0] == "test"
           argv[1] == "first arg"
           argv[2] == "second arg"
           argv[3] == NULL
           argc == 3
*/
weechat_string_free_split (argv);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_free_split

文字列分割に使用したメモリを開放。

プロトタイプ:

[source,c]
----
void weechat_string_free_split (char **split_string);
----

引数:

* _split_string_: 関数 <<_string_split,string_split>>
  が返した分割文字列の配列

C 言語での使用例:

[source,c]
----
char *argv;
int argc;
argv = weechat_string_split (string, " ", 0, 0, &argc);
/* ... */
weechat_string_free_split (argv);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_rebuild_split_string

_WeeChat バージョン 3.7 で更新。_

// TRANSLATION MISSING
Rebuild a string with a split string, using optional separator and index of
first/last string to use.

プロトタイプ:

[source,c]
----
char *weechat_string_rebuild_split_string (char **split_string,
                                           const char *separator,
                                           int index_start, int index_end);
----

引数:

* _split_string_: 関数 <<_string_split,string_split>>
  が返した分割文字列の配列
// TRANSLATION MISSING
* _separator_: string used to separate strings (can be NULL or empty string)
// TRANSLATION MISSING
* _index_start_: index of first string to use (≥ 0)
// TRANSLATION MISSING
* _index_end_: index of last string to use
  (must be ≥ _index_start_; special value -1 can be used to use all arguments
  until NULL is found)

戻り値:

* 分割文字列から作った文字列 (使用後には必ず "free" を呼び出して領域を開放してください)

C 言語での使用例:

[source,c]
----
char **argv;
int argc;
argv = weechat_string_split ("abc def ghi", " ", 0, 0, &argc);
char *str = weechat_string_rebuild_split_string (argv, ";", 0, -1);
/* str == "abc;def;ghi" */
/* ... */
free (str);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_split_command

_separator_ でコマンドのリストを分割
(コマンドに区切り文字を使う場合は `+\+` でエスケープ)。

プロトタイプ:

[source,c]
----
char **weechat_string_split_command (const char *command, char separator);
----

引数:

* _command_: 分割するコマンド
* _separator_: 区切り文字

戻り値:

* 文字列の配列、分割に失敗した場合は NULL (使用後には必ず
  <<_free_split_command,free_split_command>> を呼び出して領域を開放してください)

C 言語での使用例:

[source,c]
----
char **argv = weechat_string_split_command ("/command1 arg;/command2", ';');
/* result: argv[0] == "/command1 arg"
           argv[1] == "/command2"
           argv[2] == NULL
*/
weechat_free_split_command (argv);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_free_split_command

コマンド分割で使用したメモリを開放。

プロトタイプ:

[source,c]
----
void weechat_string_free_split_command (char **split_command);
----

引数:

* _split_command_: 関数 <<_string_split_command,string_split_command>>
  が返す分割コマンドの配列

C 言語での使用例:

[source,c]
----
char **argv = weechat_string_split_command ("/command1 arg;/command2", ';');
/* ... */
weechat_free_split_command (argv);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_format_size

ファイルサイズと設定言語に翻訳された単位を書式に当てはめて文字列を作る

プロトタイプ:

[source,c]
----
char *weechat_string_format_size (unsigned long long size);
----

引数:

* _size_: サイズ (バイト単位)

戻り値:

* 書式に従う文字列 (使用後には必ず "free" を呼び出して領域を開放してください)

C 言語での使用例:

[source,c]
----
/* examples with English locale */

char *str = weechat_string_format_size (0);  /* str == "0 bytes" */
/* ... */
free (str);

char *str = weechat_string_format_size (1);  /* str == "1 byte" */
/* ... */
free (str);

char *str = weechat_string_format_size (200);  /* str == "200 bytes" */
/* ... */
free (str);

char *str = weechat_string_format_size (15200);  /* str == "15.2 KB" */
/* ... */
free (str);

char *str = weechat_string_format_size (2097152);  /* str == "2.10 MB" */
/* ... */
free (str);
----

スクリプト (Python) での使用例、_WeeChat バージョン 2.2 以上で利用可_:

[source,python]
----
# プロトタイプ
def string_format_size(size: int) -> str: ...

# 例
str = weechat.string_format_size(15200)  # == "15.2 KB"
----

// TRANSLATION MISSING
==== string_parse_size

_WeeChat ≥ 3.7._

Parse a string with a size and optional unit and return the size in bytes.

プロトタイプ:

[source,c]
----
unsigned long long weechat_string_parse_size (const char *size);
----

引数:

* _size_: the size as string: positive integer number followed by optional
  spaces and optional unit (lower or upper case), which is one of:
** _b_: bytes
** _k_: kilobytes (1k = 1000 bytes)
** _m_: megabytes (1m = 1000k = 1,000,000 bytes)
** _g_: gigabytes (1g = 1000m = 1,000,000,000 bytes)
** _t_: terabytes (1t = 1000g = 1,000,000,000,000 bytes)

戻り値:

* size in bytes, 0 if error

C 言語での使用例:

[source,c]
----
unsigned long long size = weechat_parse_size ("1.34m");  /* size == 1340000 */
----

Script (Python):

[source,python]
----
# プロトタイプ
def string_parse_size(size: str) -> int: ...

# 例
size = weechat.string_parse_size("1.34m")  # 1340000
----

==== string_color_code_size

_WeeChat ≥ 3.0._

// TRANSLATION MISSING
Return the size (in bytes) of the WeeChat color code at the beginning of
the string.

プロトタイプ:

[source,c]
----
int weechat_string_color_code_size (const char *string);
----

引数:

* _string_: 文字列

戻り値:

// TRANSLATION MISSING
* size (in bytes) of the WeeChat color code at the beginning of the string;
  if the string is NULL, empty or does not start with a color code, 0 is returned;
  if the string begins with multiple color codes, only the size of the first one
  is returned

C 言語での使用例:

[source,c]
----
int size;

size = weechat_string_color_code_size ("test");  /* size == 0 */
size = weechat_string_color_code_size (weechat_color ("bold"));  /* size == 2 */
size = weechat_string_color_code_size (weechat_color ("yellow,red"));  /* size == 7 */
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def string_color_code_size(string: str) -> int: ...

# 例
size = weechat.string_color_code_size("test")  # size == 0
size = weechat.string_color_code_size(weechat.color("bold"))  # size == 2
size = weechat.string_color_code_size(weechat.color("yellow,red"))  # size == 7
----

==== string_remove_color

_WeeChat バージョン 4.3.0 で更新。_

文字列から WeeChat 色コードを削除。

プロトタイプ:

[source,c]
----
char *weechat_string_remove_color (const char *string, const char *replacement);
----

引数:

* _string_: 文字列
// TRANSLATION MISSING
* _replacement_: if not NULL and not empty, WeeChat color codes are replaced by
  this string, otherwise WeeChat color codes and following chars (if related
  to color) are removed from string

戻り値:

* 色コードを削除した文字列 (使用後には必ず "free" を呼び出して領域を開放してください)

C 言語での使用例:

[source,c]
----
/* remove color codes */
char *str = weechat_string_remove_color (my_string1, NULL);
/* ... */
free (str);

/* replace color codes by "?" */
char *str = weechat_string_remove_color (my_string2, "[color]");
/* ... */
free (str);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def string_remove_color(string: str, replacement: str) -> str: ...

# 例
str = weechat.string_remove_color(my_string, "[color]")
----

==== string_base_encode

// TRANSLATION MISSING
_WeeChat ≥ 2.4, updated in 4.3.0._

base 16、32、64 で文字列をエンコード。

プロトタイプ:

[source,c]
----
int weechat_string_base_encode (const char *base, const char *from, int length, char *to);
----

引数:

// TRANSLATION MISSING
* _base_: "16"、"32"、"64"、"64url"
* _from_: エンコード元文字列
* _length_: エンコードする文字列の長さ (例えば `strlen(from)`)
* _to_: エンコード結果を保存する文字列へのポインタ
  (十分な領域を確保してください、結果はエンコード元文字列よりも長くなります)

戻り値:

* _*to_ に保存された文字列の長さ (最後の `\0` は数えません)、エラー発生時は -1

C 言語での使用例:

[source,c]
----
char *string = "abcdefgh", result[128];
int length;
length = weechat_string_base_encode ("16", string, strlen (string), result);
/* length == 16, result == "6162636465666768" */
length = weechat_string_base_encode ("32", string, strlen (string), result);
/* length == 16, result == "MFRGGZDFMZTWQ===" */
length = weechat_string_base_encode ("64", string, strlen (string), result);
/* length == 12, result == "YWJjZGVmZ2g=" */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_base_decode

// TRANSLATION MISSING
_WeeChat ≥ 2.4, updated in 4.3.0._

base 16、32、64 でエンコードされた文字列をデコード。

プロトタイプ:

[source,c]
----
int weechat_string_base_decode (const char *base, const char *from, char *to);
----

引数:

// TRANSLATION MISSING
* _base_: "16"、"32"、"64"、"64url"
* _from_: デコード元文字列
* _to_: デコード結果を保存する文字列へのポインタ
  (十分な領域を確保してください、結果はデコード元文字列よりも短くなります)

戻り値:

* _*to_ に保存された文字列の長さ (最後の `\0` は数えません)、エラー発生時は -1

C 言語での使用例:

[source,c]
----
char result[128];
int length;
length = weechat_string_base_decode ("16", "6162636465666768", result);
/* length == 8, result == "abcdefgh" */
length = weechat_string_base_decode ("32", "MFRGGZDFMZTWQ===", result);
/* length == 8, result == "abcdefgh" */
length = weechat_string_base_decode ("64", "YWJjZGVmZ2g=", result);
/* length == 8, result == "abcdefgh" */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_hex_dump

_WeeChat バージョン 1.4 以上で利用可。_

16 進数とアスキーバイトを使ってデータのダンプを表示。

プロトタイプ:

[source,c]
----
char *string_hex_dump (const char *data, int data_size, int bytes_per_line,
                       const char *prefix, const char *suffix);
----

引数:

* _data_: ダンプ対象のデータ
* _data_size_: _data_ からダンプ対象にするバイト数
* _bytes_per_line_: 各行に表示するバイト数
* _prefix_: 各行の先頭に表示するプレフィックス
  (任意、NULL も可)
* _suffix_: 各行の末尾に表示するサフィックス
  (任意、NULL も可)

戻り値:

* データのダンプ表示を含む文字列 (使用後には必ず "free" を呼び出して領域を開放してください)

C 言語での使用例:

[source,c]
----
char *string = "abc def-ghi";
char *dump = weechat_string_hex_dump (string, strlen (string), 8, " >> ", NULL);
/* dump == " >> 61 62 63 20 64 65 66 2D   a b c   d e f - \n"
           " >> 67 68 69                  g h i           "  */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_is_command_char

_WeeChat バージョン 0.3.2 以上で利用可。_

文字列の 1 文字目がコマンド文字か確認 (デフォルトのコマンド文字は `+/+`)。

プロトタイプ:

[source,c]
----
int weechat_string_is_command_char (const char *string);
----

引数:

* _string_: 文字列

戻り値:

* 文字列の 1 文字目がコマンド文字の場合は 1、コマンド文字でない場合は 0

C 言語での使用例:

[source,c]
----
int command_char1 = weechat_string_is_command_char ("/test");  /* == 1 */
int command_char2 = weechat_string_is_command_char ("test");   /* == 0 */
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def string_is_command_char(string: str) -> int: ...

# 例
command_char1 = weechat.string_is_command_char("/test")  # == 1
command_char2 = weechat.string_is_command_char("test")   # == 0
----

==== string_input_for_buffer

_WeeChat バージョン 0.3.2 以上で利用可。_

文字列からバッファに入力される部分に対するポインタを返す
("string" 引数の内部へのポインタ)、コマンドの場合は NULL。

プロトタイプ:

[source,c]
----
const char *weechat_string_input_for_buffer (const char *string);
----

引数:

* _string_: 文字列

戻り値:

* "string" の内部へのポインタまたは NULL

C 言語での使用例:

[source,c]
----
const char *str1 = weechat_string_input_for_buffer ("test");    /* "test"  */
const char *str2 = weechat_string_input_for_buffer ("/test");   /* NULL    */
const char *str3 = weechat_string_input_for_buffer ("//test");  /* "/test" */
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def string_input_for_buffer(string: str) -> str: ...

# 例
str1 = weechat.string_input_for_buffer("test")    # "test"
str2 = weechat.string_input_for_buffer("/test")   # ""
str3 = weechat.string_input_for_buffer("//test")  # "/test"
----

==== string_eval_expression

// TRANSLATION MISSING
_WeeChat ≥ 0.4.0, updated in 0.4.2, 0.4.3, 1.0, 1.1, 1.2, 1.3, 1.6, 1.8, 2.0, 2.2, 2.3, 2.7, 2.9, 3.1, 3.2, 3.3, 3.4, 3.6, 3.8, 4.0.0, 4.2.0, 4.3.0, 4.4.0._

式を評価して文字列として返す。`+${variable}+`
という書式で書かれた特殊変数は展開されます (以下の表を参照)。

[NOTE]
WeeChat バージョン 1.0 以上の場合、入れ子変数を使えるようになりました、例:
`+${color:${variable}}+`。

プロトタイプ:

[source,c]
----
char *weechat_string_eval_expression (const char *expr,
                                      struct t_hashtable *pointers,
                                      struct t_hashtable *extra_vars,
                                      struct t_hashtable *options);
----

引数:

* _expr_: 評価する式
  (<<eval_conditions,条件>>および<<eval_variables,変数>>を参照してください)
* _pointers_: ポインタを含むハッシュテーブル (キーは文字列、値はポインタ);
  (現在のウィンドウやバッファへのポインタを持つ) ハッシュテーブルが "window" と
  "buffer" ポインタを持たない場合はこれらは自動的に追加される (NULL でも可):
** _regex_: WeeChat 関数 <<_string_regcomp,string_regcomp>>
   または regcomp (`man regcomp` を参照) でコンパイル済みの正規表現へのポインタ
   (_regex_t_ 構造体); このオプションは (以下の) ハッシュテーブル構造体 _options_
   メンバの _regex_ とよく似ていますが、より高速に動作します
* _extra_vars_: 展開される追加変数 (NULL でも可)
* _options_: いくつかのオプションを含むハッシュテーブル (キーと値は必ず文字列)
  (NULL でも可):
** _type_:
   デフォルトの挙動では式中の変数をその値で置換するだけですが、この挙動を変更します。設定可能なタイプは以下です:
*** _condition_: 条件式として式を評価します:
    演算子と括弧が使われます、結果はブール値 ("0" または "1") です
** _prefix_: 置換する変数のプレフィックス (デフォルト: `+${+`)
** _suffix_: 置換する変数のサフィックス (デフォルト: `+}+`)
** _extra_: デフォルトの挙動では追加変数 (_extra_vars_)
   を単純に置換するだけですが、この挙動を変更します。設定可能な値は以下です:
*** _eval_: 置換前に追加変数 (_extra_vars_)
    を評価します _(WeeChat バージョン 1.6 以上で利用可)_
** _regex_: _expr_ のテキストを置換する正規表現
   (この場合 _expr_ は評価されません)
** _regex_replace_: _regex_ と一緒に使われる置換テキスト、_expr_
   に含まれるテキストを置換する (_regex_replace_ は、_expr_ 内で
   _regex_ 引数にマッチする部分が見つからなくなるまで、毎回評価されます)
// TRANSLATION MISSING
** _debug_: debug level (string with integer number ≥ 1), if enabled, a key
   "debug_output" is added in hashtable _options_:
*** _1_: enable debug
*** _2_: enable more verbose debug

戻り値:

* 評価された式 (使用後には必ず "free" を呼び出して領域を開放してください)、失敗した場合は
  NULL (式が不正な場合やメモリが不足している場合)

C 言語での使用例:

[source,c]
----
/* 条件式の評価 */
struct t_hashtable *options1 = weechat_hashtable_new (8,
                                                      WEECHAT_HASHTABLE_STRING,
                                                      WEECHAT_HASHTABLE_STRING,
                                                      NULL,
                                                      NULL);
weechat_hashtable_set (options1, "type", "condition");
char *str1 = weechat_string_eval_expression ("${window.win_width} > 100", NULL, NULL, options1);  /* "1" */
char *str2 = weechat_string_eval_expression ("abc =~ def", NULL, NULL, options1);                 /* "0" */

/* 単純な展開 */
char *str3 = weechat_string_eval_expression ("${buffer.full_name}", NULL, NULL, NULL);  /* "core.weechat" */

/* 正規表現を用いた置換 */
struct t_hashtable *options2 = weechat_hashtable_new (8,
                                                      WEECHAT_HASHTABLE_STRING,
                                                      WEECHAT_HASHTABLE_STRING,
                                                      NULL,
                                                      NULL);
/* URL に関するブラックリストを追加 */
weechat_hashtable_set (options2, "regex", "[a-zA-Z0-9_]+://[^ ]+");
weechat_hashtable_set (options2, "regex_replace", "[ ${re:0} ]");
char *str4 = weechat_string_eval_expression ("test: https://weechat.org", NULL, NULL, NULL);  /* "test: [ https://weechat.org ]" */

/* パスワードを隠す */
weechat_hashtable_set (options2, "regex", "(password=)([^ ]+)");
weechat_hashtable_set (options2, "regex_replace", "${re:1}${hide:*,${re:2}}");
char *str5 = weechat_string_eval_expression ("password=abc password=def", NULL, NULL, NULL);  /* "password=*** password=***" */
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def string_eval_expression(expr: str, pointers: Dict[str, str], extra_vars: Dict[str, str], options: Dict[str, str]) -> str: ...

# 例

# 条件式の評価
str1 = weechat.string_eval_expression("${window.win_width} > 100", {}, {}, {"type": "condition"})  # "1"
str2 = weechat.string_eval_expression("abc =~ def", {}, {}, {"type": "condition"})                 # "0"

# 単純な展開
str3 = weechat.string_eval_expression("${buffer.full_name}", {}, {}, {}) # "core.weechat"

# 正規表現を用いた置換: URL に関するブラックリストを追加
options = {
    "regex": "[a-zA-Z0-9_]+://[^ ]+",
    "regex_replace": "[ ${re:0} ]",
}
str4 = weechat.string_eval_expression("test: https://weechat.org", {}, {}, options)  # "test: [ https://weechat.org ]"

# 正規表現を用いた置換: パスワードを隠す
options = {
    "regex": "(password=)([^ ]+)",
    "regex_replace": "${re:1}${hide:*,${re:2}}",
}
str5 = weechat.string_eval_expression("password=abc password=def", {}, {}, options)  # "password=*** password=***"
----

[[eval_conditions]]
===== 条件

条件に使える論理演算子のリスト
(上から優先順位の高い順):

[width="100%",cols="2,1,5,5",options="header"]
|===
// TRANSLATION MISSING
| 演算子 | Min WeeChat | 説明 | 例

| `+&&+` |
| 論理積
| >> `+25 && 77+` +
  == `+1+` +
  +
  >> `+25 && 0+` +
  == `+0+`

| `+\|\|+` |
| 論理和
| >> `+25 \|\| 0+` +
  == `+1+` +
  +
  >> `+0 \|\| 0+` +
  == `+0+`
|===

条件に使える比較演算子のリスト
(上から優先順位の高い順):

[width="100%",cols="2,1,5,5",options="header"]
|===
// TRANSLATION MISSING
| 演算子 | Min WeeChat | 説明 | 例

| `+=~+` |
| POSIX 拡張正規表現にマッチ (任意でフラグを指定することも可能です、関数 <<_string_regcomp,string_regcomp>> を確認してください)
| >> `+abc def =~ ab.*ef+` +
  == `+1+` +
  +
  >> `+abc def =~ y.*z+` +
  == `+0+`

| `+!~+` |
| POSIX 拡張正規表現にマッチしない (任意でフラグを指定することも可能です、関数 <<_string_regcomp,string_regcomp>> を確認してください)
| >> `+abc def !~ ab.*ef+` +
  == `+0+` +
  +
  >> `+abc def !~ y.*z+` +
  == `+1+`

// TRANSLATION MISSING
| `+==*+` | 2.9
| Is matching mask where "*" is allowed, case-sensitive (see function <<_string_match,string_match>>)
| >> `+abc def ==* a*f+` +
  == `+1+` +
  +
  >> `+abc def ==* y*z+` +
  == `+0+`

// TRANSLATION MISSING
| `+!!*+` | 2.9
| Is NOT wildcard mask where "*" is allowed, case-sensitive (see function <<_string_match,string_match>>)
| >> `+abc def !!* a*f+` +
  == `+0+` +
  +
  >> `+abc def !!* y*z+` +
  == `+1+`

// TRANSLATION MISSING
| `+=*+` | 1.8
| Is matching mask where "*" is allowed, case-insensitive (see function <<_string_match,string_match>>)
| >> `+abc def =* A*F+` +
  == `+1+` +
  +
  >> `+abc def =* Y*Z+` +
  == `+0+`

// TRANSLATION MISSING
| `+!*+` | 1.8
| Is NOT wildcard mask where "*" is allowed, case-insensitive (see function <<_string_match,string_match>>)
| >> `+abc def !* A*F+` +
  == `+0+` +
  +
  >> `+abc def !* Y*Z+` +
  == `+1+`

// TRANSLATION MISSING
| `+==-+` | 2.9
| Is included, case-sensitive
| >> `+abc def ==- bc+` +
  == `+1+` +
  +
  >> `+abc def ==- xyz+` +
  == `+0+`

// TRANSLATION MISSING
| `+!!-+` | 2.9
| Is NOT included, case-sensitive
| >> `+abc def !!- bc+` +
  == `+0+` +
  +
  >> `+abc def !!- xyz+` +
  == `+1+`

// TRANSLATION MISSING
| `+=-+` | 2.9
| Is included, case-insensitive
| >> `+abc def =- BC+` +
  == `+1+` +
  +
  >> `+abc def =- XYZ+` +
  == `+0+`

// TRANSLATION MISSING
| `+!-+` | 2.9
| Is NOT included, case-insensitive
| >> `+abc def !- BC+` +
  ==   `+0+` +
  +
  >> `+abc def !- XYZ+` +
  == `+1+`

| `+==+` |
| 等しい
| >> `+test == test+` +
  == `+1+` +
  +
  >> `+test == string+` +
  == `+0+`

| `+!=+` |
| 等しくない
| >> `+test != test+` +
  == `+0+` +
  +
  >> `+test != string+` +
  == `+1+`

| `+<=+` |
| 以下
| >> `+abc <= defghi+` +
  == `+1+` +
  +
  >> `+abc <= abc+` +
  == `+1+` +
  +
  >> `+defghi <= abc+` +
  == `+0+` +
  +
  >> `+15 <= 2+` +
  == `+0+`

| `+<+` |
| より小さい
| >> `+abc < defghi+` +
  == `+1+` +
  +
  >> `+abc < abc+` +
  == `+0+` +
  +
  >> `+defghi < abc+` +
  == `+0+` +
  +
  >> `+15 < 2+` +
  == `+0+`

| `+>=+` |
| 以上
| >> `+defghi >= abc+` +
  == `+1+` +
  +
  >> `+abc >= abc+` +
  == `+1+` +
  +
  >> `+abc >= defghi+` +
  == `+0+` +
  +
  >> `+15 >= 2+` +
  == `+1+`

| `+>+` |
| より大きい
| >> `+defghi > abc+` +
  == `+1+` +
  +
  >> `+abc > abc+` +
  == `+0+` +
  +
  >> `+abc > defghi+` +
  == `+0+` +
  +
  >> `+15 > 2+` +
  == `+1+`
|===

浮動小数点数として比較される数値表現の書式は以下です:

* 整数 (例: 5、-7)
* 浮動小数点数 (例: 5.2、-7.5、2.83e-2) _(WeeChat バージョン 2.0 以上で利用可)_
* 16 進数 (例: 0xA3、-0xA3) _(WeeChat バージョン 2.0 以上で利用可)_

数値表現を二重引用符で括ることで、文字列として比較されます。例:

* `50 > 100` は 0 を返します (数値として比較)
* `"50" > "100"` は 1 を返します (文字列として比較)

[[eval_variables]]
===== 変数

式中で展開される変数のリスト
(優先度の高い順、展開順の早いものを上に遅いものを下に):

[width="100%",cols="2,1,5,5",options="header"]
|===
// TRANSLATION MISSING
| 書式 | Min WeeChat | 説明 | 例

// TRANLSATION MISSING
| `+${raw_hl:xxx}+` | 4.2.0
| Raw string (not evaluated), with syntax highlighting (using colors).
| >> `+${raw_hl:${cut:1,,${rev:hello}}}+` +
  == `+${cut:1,,${rev:hello}}+` (with colors)

// TRANSLATION MISSING
| `+${raw:xxx}+` | 3.1
| Raw string (not evaluated).
| >> `+${raw:${info:version}}+` +
  == `+${info:version}+`

// TRANSLATION MISSING
| `+${hl:xxx}+` | 4.2.0
| String with syntax highlighting (using colors).
| >> `+${hl:${file.section.option}}+` +
  == `+test ${variable}+` (with colors)

// TRANSLATION MISSING
| `+${name}+` | 3.4
| User variable (defined with `+${define:name,value}+`).
| >> `+${name}+` +
  == `+value+`

| `+${name}+` |
| _extra_vars_ の変数 `name` の値に展開
| >> `+${name}+` +
  == `+value+`

// TRANSLATION MISSING
| `+${weechat_xxx_dir}+` | 3.2
| A WeeChat directory: `+${weechat_config_dir}+`, `+${weechat_data_dir}+`,
  `+${weechat_state_dir}+`, `+${weechat_cache_dir}+` or `+${weechat_runtime_dir}+`.
| >> `+${weechat_config_dir}+` +
  == `+/home/user/.config/weechat+` +
  +
  >> `+${weechat_data_dir}+` +
  == `+/home/user/.local/share/weechat+` +
  +
  >> `+${weechat_state_dir}+` +
  == `+/home/user/.local/state/weechat+` +
  +
  >> `+${weechat_cache_dir}+` +
  == `+/home/user/.cache/weechat+` +
  +
  >> `+${weechat_runtime_dir}+` +
  == `+/run/user/1000/weechat+`

| `+${eval:xxx}+` | 1.3
| 評価する文字列
| >> `+${eval:${date:${weechat.look.buffer_time_format}}}+` +
  ==  `+19:02:45+` ^(1)^ +
  +
  ^(1)^ オプション weechat.look.buffer_time_format 内に色コードが存在する場合色付き

// TRANSLATION MISSING
| `+${eval_cond:xxx}+` | 3.1
| String to evaluate as condition.
| >> `+${eval_cond:${window.win_width} > 100}+` +
  == `+1+`

| `+${esc:xxx}+` +
  `+${\xxx}+` | 1.0
| エスケープ文字を含む文字列
| >> `+${esc:prefix\tmessage}+` +
  == `+prefix<TAB>message+` +
  +
  >> `+${\ua9}+` +
  == `+©+`

// TRANSLATION MISSING
| `+${chars:range}+` | 3.8
| String with a range of chars, where `range` is one of: +
  - `digit` (`0123456789`) +
  - `xdigit` (`0123456789abcdefABCDEF`) +
  - `lower` (all lower case letters) +
  - `upper` (all upper case letters) +
  - `alpha` (all letters) +
  - `alnum` (all letters and digits) +
  - a range of chars with format `c1-c2` (`c1` code point must be lower or equal to `c2`)
| >> `+${chars:digit}+` +
  == `+0123456789+` +
  +
  >> `+${chars:xdigit}+` +
  == `+0123456789abcdefABCDEF+` +
  +
  >> `+${chars:lower}+` +
  == `+abcdefghijklmnopqrstuvwxyz+` +
  +
  >> `+${chars:J-V}+` +
  == `+JKLMNOPQRSTUV+` +
  +
  >> `+${chars:←-↓}+` +
  == `+←↑→↓+`

// TRANSLATION MISSING
| `+${lower:string}+` | 3.6
| String converted to lower case.
| >> `+${lower:TEST}+` +
  == `+test+`

// TRANSLATION MISSING
| `+${upper:string}+` | 3.6
| String converted to upper case.
| >> `+${upper:test}+` +
  == `+TEST+`

| `+${hide:x,string}+` | 1.1
| 隠す文字を含むテキスト (`string` に含まれる文字をすべて `x` で置換)
| >> `+${hide:*,password}+` +
  == `+********+`

| `+${cut:max,suffix,string}+` +
  `+${cut:+max,suffix,string}+` | 1.8
| `string` の先頭 `max` 文字とオプションの `suffix` 文字 (`string` の文字数が `max` 文字を超える場合) +
  `+max` を使った場合、`max` 文字にはサフィックスの文字数も含まれます。|
  >> `+${cut:4,…,this is a test}+` +
  == `+this…+` +
  +
  >> `+${cut:+4,…,this is a test}+` +
  == `+t…+` +
  +
  >> `+${cut:2,>>,こんにちは世界}+` +
  == `+こん>>+`

| `+${cutscr:max,suffix,string}+` +
  `+${cutscr:+max,suffix,string}+` | 1.8
| `string` の先頭 `max` 文字 (半角文字幅換算) とオプションの `suffix` 文字 (`string` の文字数が `max` 文字を超える場合) +
  `+max` を使った場合、`max` 文字にはサフィックスの文字数も含まれます。|
  >> `+${cutscr:4,…,this is a test}+` +
  == `+this…+` +
  +
  >> `+${cutscr:+4,…,this is a test}+` +
  == `+thi…+` +
  +
  >> `+${cutscr:2,>>,こんにちは世界}+` +
  == `+こ>>+`

// TRANSLATION MISSING
| `+${rev:xxx}+` | 2.2
| Reversed string (color codes are reversed, so the string should not contain
  color codes).
| >> `+${rev:Hello, world!}+` +
  == `+!dlrow ,olleH+` +
  +
  >> `+${rev:Hello, ${color:red}world!}+` +
  == `+!dlrow30F ,olleH+` ^(1)^ +
  +
  ^(1)^ No color, the color code is reversed

// TRANSLATION MISSING
| `+${revscr:xxx}+` | 2.7
| Reversed string for screen, color codes are not reversed.
| >> `+${revscr:Hello, world!}+` +
  == `+!dlrow ,olleH+` +
  +
  >> `+${revscr:Hello, ${color:red}world!}+` +
  == `+!dlrow ,olleH+` ^(1)^ +
  +
  ^(1)^ `pass:[ ,olleH]` in red

| `+${repeat:count,string}+` | 2.3
| 繰り返し文字列。|
  >> `+${repeat:5,-}+` +
  == `+-----+`

// TRANSLATION MISSING
| `+${length:xxx}+` | 2.7
| Length of string (number of UTF-8 chars), color codes are ignored.
| >> `+${length:test}+` +
  == `+4+` +
  +
  >> `+${length:こんにちは世界}+` +
  == `+7+`

// TRANSLATION MISSING
| `+${lengthscr:xxx}+` | 2.7
| Length of string displayed on screen, color codes are ignored.
| >> `+${lengthscr:test}+` +
  == `+4+` +
  +
  >> `+${lengthscr:こんにちは世界}+` +
  == `+14+`

// TRANSLATION MISSING
| `+${split:number,seps,flags,xxx}+` | 3.3
| Split string, and return, according to `number`: +
  - `count`: the number of items after split +
  - `random`: a random item +
  - integer ≥ 1: the item by index (1 = first item) +
  - integer ≤ -1: the item by index from the end (-1 = last item, -2 = penultimate item, etc.), +
  `seps` is a list of chars that are used as separators (if empty, a comma is used), +
  `flags` is a list of flags separated by `+`: +
  - `strip_left`: strip separators on the left (beginning of string) +
  - `strip_right`: strip separators on the right (end of string) +
  - `collapse_seps`: collapse multiple consecutive separators into a single one +
  - `keep_eol`: keep end of line for each value +
  - `strip_items=xyz`: strip chars `x`, `y` and `z` from beginning/end of items +
  - `max_items=N`: return max N items
| >> `+${split:1,,,abc,def,ghi}+` +
  == `+abc+` +
  +
  >> `+${split:-1,,,abc,def,ghi}+` +
  == `+ghi+` +
  +
  >> `+${split:count,,,abc,def,ghi}+` +
  == `+3+` +
  +
  >> `+${split:random,,,abc,def,ghi}+` +
  == `+def+` +
  +
  >> `+${split:3,,collapse_seps,abc,,,def,,,ghi}+` +
  == `+ghi+` +
  +
  >> `+${split:3,,strip_items=-_,_-abc-_,_-def-_,_-ghi-_}+` +
  == `+ghi+` +
  +
  >> `+${split:2, ,,this is a test}+` +
  == `+is+` +
  +
  >> `+${split:2, ,strip_left+strip_right, this is a test }+` +
  == `+is+` +
  +
  >> `+${split:2, ,keep_eol,this is a test}+` +
  == `+is a test+`

// TRANSLATION MISSING
| `+${split_shell:number,xxx}+` | 3.3
| Split shell arguments, and return, according to `number`: +
  - `count`: the number of arguments after split +
  - `random`: a random argument +
  - integer ≥ 1: the argument by index (1 = first argument) +
  - integer ≤ -1: the argument by index from the end (-1 = last argument, -2 = penultimate argument, etc.)
| >> `+${split_shell:1,"first arg" arg2}+` +
  == `+first arg+` +
  +
  >> `+${split_shell:-1,"first arg" arg2}+` +
  == `+arg2+` +
  +
  >> `+${split_shell:count,"first arg" arg2}+` +
  == `+2+` +
  +
  >> `+${split_shell:random,"first arg" arg2}+` +
  == `+arg2+`

// TRANSLATION MISSING
| `+${re:xxx}+` | 1.1
| Regex data: +
  `0` = whole string matching, +
  `1` to `99` = group captured, +
  `+++` = last group captured, +
  `#` = index of last group captured _(WeeChat ≥ 1.8)_, +
  `repl_index` = index of replacement being done (starts to 1) _(WeeChat ≥ 3.3)_.
| >> `+${re:0}+` +
  == `+test1 test2+` +
  +
  >> `+${re:1}+` +
  == `+test1+` +
  +
  >> `+${re:2}+` +
  == `+test2+` +
  +
  >> `pass:[${re:+}]` +
  == `+test2+` +
  +
  >> `+${re:#}+` +
  == `+2+` +
  +
  >> `+${re:repl_index}+` +
  == `+1+`

| `+${color:name}+` | 0.4.2
| WeeChat 色コード (色名部分はオプション属性をとることも可能です),
  書式を確認するには関数 <<_color,color>> をご確認ください
| >> `+${color:red}red text+` +
  == `+red text+` ^(1)^ +
  +
  >> `+${color:*214}bold orange text+` +
  == `+bold orange text+` ^(2)^ +
  +
  ^(1)^ 赤色で +
  ^(2)^ 太字オレンジ色で

// TRANSLATION MISSING
| `+${modifier:name,data,string}+` | 2.7
| Result of a modifier, see function
  <<_hook_modifier_exec,hook_modifier_exec>>.
| >> `+${modifier:eval_path_home,,~}+` +
  == `+/home/user+` +
  +
  >> `+${modifier:eval_path_home,directory=config,%h/irc.conf}+` +
  == `+/home/user/.config/weechat/irc.conf+`

| `+${info:name}+` +
  `+${info:name,arguments}+` | 0.4.3
| WeeChat またはプラグインのインフォ、<<_info_get,info_get>>
  を参照
| >> `+${info:version}+` +
  == `+1.0+` +
  +
  >> `+${info:nick_color_name,foo}+` +
  == `+lightblue+`

// TRANSLATION MISSING
| `+${base_encode:base,xxx}+` | 2.9
| String encoded in base 16, 32 or 64.
| >> `+${base_encode:16,test string}+` +
  == `+7465737420737472696E67+` +
  +
  >> `+${base_encode:32,test string}+` +
  == `+ORSXG5BAON2HE2LOM4======+` +
  +
  >> `+${base_encode:64,test string}+` +
  == `+dGVzdCBzdHJpbmc=+`

// TRANSLATION MISSING
| `+${base_decode:base,xxx}+` | 2.9
| String decoded from base 16, 32 or 64.
| >> `+${base_decode:16,7465737420737472696E67}+` +
  == `+test string+` +
  +
  >> `+${base_decode:32,ORSXG5BAON2HE2LOM4======}+` +
  == `+test string+` +
  +
  >> `+${base_decode:64,dGVzdCBzdHJpbmc=}+` +
  == `+test string+`

// TRANSLATION MISSING
| `+${date}+` +
  `+${date:xxx}+` | 1.3
| 現在の日付/時刻、カスタム書式を使うことも可能です (see function <<_util_strftimeval,util_strftimeval>>)、
  デフォルト書式は `%F %T`
| >> `+${date}+` +
  == `+2015-06-30 19:02:45+` +
  +
  >> `+${date:%H:%M:%S}+` +
  == `+19:02:45+` +
  +
  >> `+${date:%!.%.3}+` +
  == `+1435683765.482+`

| `+${env:NAME}+` | 1.2
| 環境変数 `NAME` の値
| >> `+${env:HOME}+` +
  == `+/home/user+`

| `+${if:condition}+` +
  `+${if:condition?true}+`
  `+${if:condition?true:false}+` | 1.8
| 条件、条件が真の場合の値 (任意)、条件が偽の場合の値 (任意)
  からなる三項演算子。値を指定しなかった場合、条件の評価結果に応じて
  "1" または "0" が返されます
| >> `+${if:${info:term_width}>80?big:small}+` +
  == `+big+`

// TRANSLATION MISSING
| `+${calc:xxx}+` | 2.7
| Result of expression, where parentheses and the following operators are
  supported: +
  `+++`: addition +
  `+-+`: subtraction +
  `+*+`: multiplication +
  `+/+`: division +
  `+//+`: result of division without fractional part +
  `+%+`: remainder of division +
  `+**+`: power.
| >> `+${calc:5+2*3}+` +
  == `+11+` +
  +
  >> `+${calc:(5+2)*3}+` +
  == `+21+` +
  +
  >> `+${calc:10/4}+` +
  == `+2.5+` +
  +
  >> `+${calc:10//4}+` +
  == `+2+` +
  +
  >> `+${calc:9.2%3}+` +
  == `+0.2+` +
  +
  >> `+${calc:2**16}+` +
  == `+65536+`

// TRANSLATION MISSING
| `+${random:min,max}+` | 3.3
| Random integer number in the range from `min` to `max` (inclusive).
| >> `+${random:0,10}+` +
  == `+3+`

// TRANSLATION MISSING
| `+${translate:xxx}+` | 3.2
| Translated string (depends on the language used by WeeChat to display messages).
| >> `+${translate:Plugin}+` +
  == `+Extension+` ^(1)^ +
  +
  ^(1)^ Example in French

// TRANSLATION MISSING
| `+${define:name,value}+` | 3.4
| Define a variable `name` set to `value`, which can then be used in the same
  evaluated expression with `+${name}+`.
| >> `+${define:len,${calc:5+3}}${len}x${len}+` +
  == `+8x8+`

// TRANSLATION MISSING
| `+${hdata_count:name[list]}+` +
  `+${hdata_count:name[pointer]}+` | 4.4.0
| Number of items in a hdata list or starting at `pointer`.
| >> `+${hdata_count:buffer[gui_buffers]}+` +
  == `+15+`

| `+${sec.data.name}+` |
| セキュアデータ `name` の値
| >> `+${sec.data.libera_pass}+` +
  == `+my_password+`

| `+${file.section.option}+` |
| オプションの値
| >> `+${weechat.look.buffer_time_format}+` +
  == `+%H:%M:%S+`

| `+${name}+` |
| バッファに対するローカル変数 `name` の値
| >> `+${nick}+` +
  == `+FlashCode+`

| `+${pointer}+` |
| _pointers_ の変数 `pointer` の値に展開
| >> `+${buffer}+` +
  == `+0x1234abcd+`

// TRANSLATION MISSING
| `+${hdata.var1.var2...}+` +
  `+${hdata[list].var1.var2...}+` |
| hdata の値 (`window` と `buffer`
  ポインタはデフォルトで現在のウィンドウ/バッファに設定されます),
  `list` can be a list name (example: "gui_buffers"), a pointer
  (example: "0x1234abcd") or a pointer name (example: "my_pointer"). +
  When `var1` is a hashtable, methods `keys()`, `values()`, `keys_sorted()`,
  `keys_values()` and `keys_values_sorted()` can be called.
| >> `+${buffer[gui_buffers].full_name}+` +
  == `+core.weechat+` +
  +
  >> `+${buffer[my_buffer_pointer].full_name}+` +
  == `+core.weechat+` +
  +
  >> `+${window.buffer.number}+` +
  == `+1+` +
  +
  >> `+${buffer.local_variables.keys_values()}+` +
  == `+plugin:core,name:weechat+` +
  +
  >> `+${buffer.local_variables.plugin}+` +
  == `+core+`
|===

==== string_dyn_alloc

_WeeChat バージョン 1.8 以上で利用可_

可変長の動的文字列を確保します。 +
内部では、文字列ポインタ、確保されたサイズ、現在の文字列長の情報からなる構造体が確保されます。

すべての _pass:[string_dyn_*]_ 関数は文字列ポインタへのポインタ
(_**string_) のみを使います。

プロトタイプ:

[source,c]
----
char **weechat_string_dyn_alloc (int size_alloc);
----

引数:

* _size_alloc_: 初期確保サイズ (必ずゼロより大きい値を指定してください)

戻り値:

* 動的文字列へのポインタ

C 言語での使用例:

[source,c]
----
char **string = weechat_string_dyn_alloc (256);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_dyn_copy

_WeeChat バージョン 1.8 以上で利用可_

動的文字列内に文字列をコピーします。

文字列が再確保された場合 (文字列をコピーするのに十分なサイズが確保されていなかった場合)
にはポインタ _*string_ が変わる可能性があります。

プロトタイプ:

[source,c]
----
int weechat_string_dyn_copy (char **string, const char *new_string);
----

引数:

* _string_: 動的文字列へのポインタ
* _new_string_: コピーする文字列

戻り値:

* 成功した場合は 1、失敗した場合は 0

C 言語での使用例:

[source,c]
----
char **string = weechat_string_dyn_alloc (256);
if (weechat_string_dyn_copy (string, "test"))
{
    /* 成功 */
}
else
{
    /* 失敗 */
}
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_dyn_concat

// TRANSLATION MISSING
_WeeChat バージョン 1.8 以上で利用可, updated in 3.0_

動的文字列に文字列を連結します。

文字列が再確保された場合 (文字列を連結するのに十分なサイズが確保されていなかった場合)
にはポインタ _*string_ が変わる可能性があります。

プロトタイプ:

[source,c]
----
int weechat_string_dyn_concat (char **string, const char *add, int bytes);
----

引数:

* _string_: 動的文字列へのポインタ
* _add_: 連結する文字列
// TRANSLATION MISSING
* _bytes_: max number of bytes in _add_ to concatenate, must be lower or equal
  to length of _add_ (-1 = automatic: concatenate whole string _add_)
  _(WeeChat ≥ 3.0)_

戻り値:

* 成功した場合は 1、失敗した場合は 0

C 言語での使用例:

[source,c]
----
char **string = weechat_string_dyn_alloc (256);
if (weechat_string_dyn_copy (string, "test"))
{
    if (weechat_string_dyn_concat (string, "abc", -1))
    {
        /* ... */
    }
}
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_dyn_free

_WeeChat バージョン 1.8 以上で利用可_

動的文字列を解放します。

プロトタイプ:

[source,c]
----
char *weechat_string_dyn_free (char **string, int free_string);
----

引数:

* _string_: 動的文字列へのポインタ
* _free_string_: 文字列の解放; 0 を指定することで、この関数を呼び出した後でも
  _*string_ が指すアドレスのメモリを確保したままにできます。

戻り値:

* _free_string_ が 0 の場合には文字列ポインタ、それ以外の場合は NULL

C 言語での使用例:

[source,c]
----
char **string = weechat_string_dyn_alloc (256);
if (weechat_string_dyn_concat (string, "test"))
{
    /* 成功 */
}
else
{
    /* 失敗 */
}
/* ... */
weechat_string_dyn_free (string, 1);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== string_concat

_WeeChat ≥ 4.2.0._

// TRANSLATION MISSING
Concatenate multiple strings using a separator.

プロトタイプ:

[source,c]
----
const char *weechat_string_concat (const char *separator, ...);
----

引数:

// TRANSLATION MISSING
* _separator_: the separator string which is inserted between concatenated
  strings (can be NULL or empty string)

// TRANSLATION MISSING
[NOTE]
Last argument *MUST* always be NULL. +
A macro called `WEECHAT_STR_CONCAT` can be used, where the final NULL value is
not needed (usage of this macro is recommended).

戻り値:

// TRANSLATION MISSING
* concatenated string

C 言語での使用例:

// TRANSLATION MISSING
[source,c]
----
const char *result = weechat_string_concat (" / ", "abc", "def", "ghi", NULL);  /* result == "abc / def / ghi" */

/* with macro */
const char *result = WEECHAT_STR_CONCAT(" / ", "abc", "def", "ghi");  /* result == "abc / def / ghi" */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

[[utf-8]]
=== UTF-8

UTF-8 文字列関数。

==== utf8_has_8bits

文字列に 8 ビット文字が含まれているか確認。

プロトタイプ:

[source,c]
----
int weechat_utf8_has_8bits (const char *string);
----

引数:

* _string_: 文字列

戻り値:

* 文字列に 8 ビット文字が含まれる場合は 1、7 ビット文字だけの場合は 0

C 言語での使用例:

[source,c]
----
if (weechat_utf8_has_8bits (string))
{
    /* ... */
}
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== utf8_is_valid

_WeeChat バージョン 1.4 で更新。_

文字列が妥当な UTF-8 表現か確認。

プロトタイプ:

[source,c]
----
int weechat_utf8_is_valid (const char *string, int length, char **error);
----

引数:

* _string_: 文字列
* _length_: 確認する UTF-8 文字の最大文字数; これを 0 以下に設定した場合、文字列中のすべての文字を確認します
  _(WeeChat バージョン 1.4 以上で利用可)_
* _error_: NULL でない場合は _*error_
  は文字列に含まれる最初の妥当でない UTF-8 文字へのポインタ

戻り値:

* 妥当な UTF-8 文字列の場合は 1、妥当でない場合は 0

C 言語での使用例:

[source,c]
----
char *error;
if (weechat_utf8_is_valid (string, -1, &error))
{
    /* ... */
}
else
{
    /* "error" points to first invalid char */
}
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== utf8_normalize

UTF-8 文字列を正規化: 非 UTF-8 文字を削除し、これらを文字で置換。

プロトタイプ:

[source,c]
----
void weechat_utf8_normalize (char *string, char replacement);
----

引数:

* _string_: 文字列
* _replacement_: 非 UTF-8 文字を置き換える文字

C 言語での使用例:

[source,c]
----
weechat_utf8_normalize (string, '?');
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== utf8_prev_char

_WeeChat バージョン 1.3 で更新。_

文字列中の 1 つ前の UTF-8 文字へのポインタを返す。

プロトタイプ:

[source,c]
----
const char *weechat_utf8_prev_char (const char *string_start,
                                    const char *string);
----

引数:

* _string_start_: 文字列の開始位置へのポインタ
  (関数はこのポインタよりも前の文字を返しません)
* _string_: 文字列へのポインタ (必ず _string_start_ 以上の値)

戻り値:

* 1 つ前の UTF-8 文字へのポインタ、見つからなければ (文字列の開始位置に到達した場合は) NULL
  (_WeeChat バージョン 1.3 以上の場合_: 返されるポインタは _const char *_ であり、_char *_ ではありません)

C 言語での使用例:

[source,c]
----
const char *prev_char = weechat_utf8_prev_char (string, ptr_in_string);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== utf8_next_char

_WeeChat バージョン 1.3 で更新。_

文字列中の 1 つ後の UTF-8 文字へのポインタを返す。

プロトタイプ:

[source,c]
----
const char *weechat_utf8_next_char (const char *string);
----

引数:

* _string_: 文字列

戻り値:

* 1 つ後の UTF-8 文字へのポインタ、見つからなければ (文字列の最後に到達した場合は) NULL
  (_WeeChat バージョン 1.3 以上の場合_: 返されるポインタは _const char *_ であり、_char *_ ではありません)

C 言語での使用例:

[source,c]
----
const char *next_char = weechat_utf8_next_char (string);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== utf8_char_int

UTF-8 文字を整数で返す。

プロトタイプ:

[source,c]
----
int weechat_utf8_char_int (const char *string);
----

引数:

* _string_: 文字列

戻り値:

* UTF-8 文字の整数表現

C 言語での使用例:

[source,c]
----
int char_int = weechat_utf8_char_int ("être");  /* "ê" as integer */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== utf8_char_size

UTF-8 文字のサイズを返す (バイト単位)。

プロトタイプ:

[source,c]
----
int weechat_utf8_char_size (const char *string);
----

引数:

* _string_: 文字列

戻り値:

* UTF-8 文字のサイズ (バイト単位)

C 言語での使用例:

[source,c]
----
int char_size = weechat_utf8_char_size ("être");  /* == 2 */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== utf8_strlen

UTF-8 文字の長さを返す (UTF-8 文字の個数)。

プロトタイプ:

[source,c]
----
int weechat_utf8_strlen (const char *string);
----

引数:

* _string_: 文字列

戻り値:

* UTF-8 文字列の長さ (UTF-8 文字の個数)

C 言語での使用例:

[source,c]
----
int length = weechat_utf8_strlen ("chêne");  /* == 5 */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== utf8_strnlen

文字列の _bytes_ バイト目までに含まれる UTF-8 文字列の長さを返す (UTF-8 文字の個数)。

プロトタイプ:

[source,c]
----
int weechat_utf8_strnlen (const char *string, int bytes);
----

引数:

* _string_: 文字列
* _bytes_: バイト数の上限

戻り値:

* UTF-8 文字列の長さ (UTF-8 文字の個数)

C 言語での使用例:

[source,c]
----
int length = weechat_utf8_strnlen ("chêne", 4);  /* == 3 */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== utf8_strlen_screen

UTF-8 文字列を画面上に表示するために必要な画面幅を返す。

プロトタイプ:

[source,c]
----
int weechat_utf8_strlen_screen (const char *string);
----

引数:

* _string_: 文字列

戻り値:

* UTF-8 文字列を画面上に表示するために必要な画面幅。

C 言語での使用例:

[source,c]
----
int length_on_screen = weechat_utf8_strlen_screen ("é");  /* == 1 */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== utf8_char_size_screen

_WeeChat バージョン 3.8 で更新。_

UTF-8 文字を画面上に表示するために必要な画面幅を返す。

プロトタイプ:

[source,c]
----
int weechat_utf8_char_size_screen (const char *string);
----

引数:

* _string_: 文字列

戻り値:

* UTF-8 文字を画面上に表示するために必要な画面幅:
// TRANSLATION MISSING
** -1: non printable char
// TRANSLATION MISSING
** ≥ 0: printable char

// TRANSLATION MISSING
The result is the return value of function `wcwidth` (see `man wcwidth`), with
exception for the following chars, that have a specific behavior in WeeChat:

// TRANSLATION MISSING
* U+0009 (Tabulation): value of option
  link:weechat_user.ja.html#option_weechat.look.tab_width[weechat.look.tab_width ^↗^^]
* U+0001 (1) to U+001F (31), except U+0009 (Tabulation): 1
* U+00AD (173, soft hyphen): -1
* U+200B (8203, zero width space): -1

C 言語での使用例:

[source,c]
----
int length_on_screen = weechat_utf8_char_size_screen ("é");  /* == 1 */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== utf8_add_offset

_WeeChat バージョン 1.3 で更新。_

UTF-8 文字列で N 文字前に進む。

プロトタイプ:

[source,c]
----
const char *weechat_utf8_add_offset (const char *string, int offset);
----

引数:

* _string_: 文字列
* _offset_: 文字数

戻り値:

* 文字列の N 文字後に進んだ位置へのポインタ (元文字列の最後より後の位置を指す場合は NULL)
  (_WeeChat バージョン 1.3 以上の場合_: 返されるポインタは _const char *_ であり、_char *_ ではありません)

C 言語での使用例:

[source,c]
----
const char *str = "chêne";
const char *str2 = weechat_utf8_add_offset (str, 3);  /* points to "ne" */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== utf8_real_pos

UTF-8 文字列中の真の位置を返す。

プロトタイプ:

[source,c]
----
int weechat_utf8_real_pos (const char *string, int pos);
----

引数:

* _string_: 文字列
* _pos_: 位置 (文字目)

戻り値:

* 真の位置 (バイト目)

C 言語での使用例:

[source,c]
----
int pos = weechat_utf8_real_pos ("chêne", 3);  /* == 4 */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== utf8_pos

UTF-8 文字列中の位置を返す。

プロトタイプ:

[source,c]
----
int weechat_utf8_pos (const char *string, int real_pos);
----

引数:

* _string_: 文字列
* _real_pos_: 真の位置 (バイト単位)

戻り値:

* 位置 (文字目)

C 言語での使用例:

[source,c]
----
int pos = weechat_utf8_pos ("chêne", 4);  /* == 3 */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== utf8_strndup

最長 _length_ 文字の複製された文字列を返す。

プロトタイプ:

[source,c]
----
char *weechat_utf8_strndup (const char *string, int length);
----

引数:

* _string_: 文字列
* _length_: 複製する文字数の最大値

戻り値:

* 複製された文字列 (使用後には必ず "free" を呼び出して領域を開放してください)

C 言語での使用例:

[source,c]
----
char *string = weechat_utf8_strndup ("chêne", 3);  /* returns "chê" */
/* ... */
free (string);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== utf8_strncpy

_WeeChat ≥ 3.8._

// TRANSLATION MISSING
Copy _length_ chars max in another string and add null byte at the end.

プロトタイプ:

[source,c]
----
void weechat_utf8_strncpy (char *dest, const char *string, int length);
----

引数:

// TRANSLATION MISSING
* _dest_: destination string (must be long enough)
* _string_: 文字列
// TRANSLATION MISSING
* _length_: max chars to copy

C 言語での使用例:

[source,c]
----
char dest[256];

weechat_utf8_strncpy (dest, "chêne", 3);  /* copies "chê" to dest */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

// TRANSLATION MISSING
[[crypto]]
=== Cryptography

Some cryptographic functions.

// TRANSLATION MISSING
==== crypto_hash

_WeeChat バージョン 2.8 以上で利用可。_

Compute hash of data.

プロトタイプ:

[source,c]
----
int weechat_crypto_hash (const void *data, int data_size, const char *hash_algo,
                         void *hash, int *hash_size);
----

引数:

* _data_: the data to hash
* _data_size_: number of bytes to hash in _data_
* _hash_algo_: the hash algorithm, see table below
* _hash_: pointer to the hash variable, which is used to store the resulting hash
  (the buffer must be large enough, according to the algorithm, see table below)
* _hash_size_: pointer to a variable used to store the length of the hash computed
  (in bytes) (can be NULL)

[[crypto_hash_algorithms]]
Supported hash algorithms:

[width="100%",cols="2,2,3,6",options="header"]
|===
| Value           | Algorithm   | Hash size           | Notes
| `+crc32+`       | CRC32       | 4 bytes (32 bits)   | Not a hash algorithm in the cryptographic sense.
| `+md5+`         | MD5         | 16 bytes (128 bits) | *Weak*, not recommended for cryptography usage.
| `+sha1+`        | SHA-1       | 20 bytes (160 bits) | *Weak*, not recommended for cryptography usage.
| `+sha224+`      | SHA-224     | 28 bytes (224 bits) |
| `+sha256+`      | SHA-256     | 32 bytes (256 bits) |
| `+sha384+`      | SHA-384     | 48 bytes (384 bits) |
| `+sha512+`      | SHA-512     | 64 bytes (512 bits) |
| `+sha512-224+`  | SHA-512/224 | 28 bytes (224 bits) | Algorithm available with libgcrypt ≥ 1.9.4.
| `+sha512-256+`  | SHA-512/256 | 32 bytes (256 bits) | Algorithm available with libgcrypt ≥ 1.9.4.
| `+sha3-224+`    | SHA3-224    | 28 bytes (224 bits) | Algorithm available with libgcrypt ≥ 1.7.0.
| `+sha3-256+`    | SHA3-256    | 32 bytes (256 bits) | Algorithm available with libgcrypt ≥ 1.7.0.
| `+sha3-384+`    | SHA3-384    | 48 bytes (384 bits) | Algorithm available with libgcrypt ≥ 1.7.0.
| `+sha3-512+`    | SHA3-512    | 64 bytes (512 bits) | Algorithm available with libgcrypt ≥ 1.7.0.
| `+blake2b-160+` | BLAKE2B-160 | 20 bytes (160 bits) | Algorithm available with libgcrypt ≥ 1.8.0.
| `+blake2b-256+` | BLAKE2B-256 | 32 bytes (256 bits) | Algorithm available with libgcrypt ≥ 1.8.0.
| `+blake2b-384+` | BLAKE2B-384 | 48 bytes (384 bits) | Algorithm available with libgcrypt ≥ 1.8.0.
| `+blake2b-512+` | BLAKE2B-512 | 64 bytes (512 bits) | Algorithm available with libgcrypt ≥ 1.8.0.
| `+blake2s-128+` | BLAKE2S-128 | 16 bytes (128 bits) | Algorithm available with libgcrypt ≥ 1.8.0.
| `+blake2s-160+` | BLAKE2S-160 | 20 bytes (160 bits) | Algorithm available with libgcrypt ≥ 1.8.0.
| `+blake2s-224+` | BLAKE2S-224 | 28 bytes (224 bits) | Algorithm available with libgcrypt ≥ 1.8.0.
| `+blake2s-256+` | BLAKE2S-256 | 32 bytes (256 bits) | Algorithm available with libgcrypt ≥ 1.8.0.
|===

戻り値:

* 成功した場合は 1、失敗した場合は 0

C 言語での使用例:

[source,c]
----
const char *data = "abcdefghijklmnopqrstuvwxyz";
char hash[256 / 8];
int rc, hash_size;
rc = weechat_crypto_hash (data, strlen (data), "sha256", hash, &hash_size);
/* rc == 1, hash_size == 32 and hash is a buffer with:
   71 c4 80 df 93 d6 ae 2f 1e fa d1 44 7c 66 c9 52 5e 31 62 18 cf 51 fc 8d 9e d8 32 f2 da f1 8b 73 */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

// TRANSLATION MISSING
==== crypto_hash_flie

_WeeChat バージョン 3.7 以上で利用可。_

Compute hash of a file.

プロトタイプ:

[source,c]
----
int weechat_crypto_hash_file (const char *filename, const char *hash_algo,
                              void *hash, int *hash_size);
----

引数:

* _filename_: パスやファイル名
* _hash_algo_: the hash algorithm, see table in function
  <<crypto_hash_algorithms,crypto_hash>>
* _hash_: pointer to the hash variable, which is used to store the resulting hash
  (the buffer must be large enough, according to the algorithm, see table in
  function <<crypto_hash_algorithms,crypto_hash>>)
* _hash_size_: pointer to a variable used to store the size of the hash computed
  (in bytes) (can be NULL)

戻り値:

* 成功した場合は 1、失敗した場合は 0

C 言語での使用例:

[source,c]
----
char hash[256 / 8];
int rc, hash_size;
rc = weechat_crypto_hash_file ("/path/to/file", "sha256", hash, &hash_size);
/* rc == 1, hash_size == 32 and hash is a buffer with:
   71 c4 80 df 93 d6 ae 2f 1e fa d1 44 7c 66 c9 52 5e 31 62 18 cf 51 fc 8d 9e d8 32 f2 da f1 8b 73 */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== crypto_hash_pbkdf2

_WeeChat バージョン 2.8 以上で利用可。_

Compute PKCS#5 Passphrase Based Key Derivation Function number 2 (PBKDF2) hash
of data.

プロトタイプ:

[source,c]
----
int weechat_crypto_hash_pbkdf2 (const void *data, int data_size,
                                const char *hash_algo,
                                const void *salt, int salt_size,
                                int iterations,
                                void *hash, int *hash_size);
----

引数:

* _data_: the data to hash
* _data_size_: number of bytes to hash in _data_
* _hash_algo_: hash algorithm used by the key derivation function, see table
  in function <<crypto_hash_algorithms,crypto_hash>>
* _salt_: the salt
* _salt_size_: number of bytes in _salt_
* _iterations_: number of iterations
* _hash_: pointer to the hash variable, which is used to store the resulting hash
  (the buffer must be large enough, according to the algorithm, see table in
  function <<crypto_hash_algorithms,crypto_hash>>)
* _hash_size_: pointer to a variable used to store the size of the hash computed
  (in bytes) (can be NULL)

戻り値:

* 成功した場合は 1、失敗した場合は 0

C 言語での使用例:

[source,c]
----
const char *data = "abcdefghijklmnopqrstuvwxyz";
const char *salt = "12345678901234567890123456789012";  /* 32 bytes */
char hash[256 / 8];
int rc, hash_size;
rc = weechat_crypto_hash_pbkdf2 (data, strlen (data), "sha256", salt, strlen (salt), 100000,
                                 hash, &hash_size);
/* rc == 1, hash_size == 32 and hash is a buffer with:
   99 b3 5e 42 53 d1 a7 a8 49 c1 dc 2c e2 53 c2 b6 6d a1 8b dc 6e 78 a7 06 e0 ef 34 db 0a 7a a2 bb */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

// TRANSLATION MISSING
==== crypto_hmac

_WeeChat バージョン 3.2 以上で利用可。_

Compute keyed-hash message authentication code (HMAC).

プロトタイプ:

[source,c]
----
int weechat_crypto_hmac (const void *key, int key_size, const void *message, int message_size,
                         int hash_algo, void *hash, int *hash_size);
----

引数:

* _key_: the key
* _key_size_: number of bytes in _key_
* _message_: the message
* _message_size_: number of bytes in _message_
* _hash_algo_: the hash algorithm, see table in function
  <<crypto_hash_algorithms,crypto_hash>>
* _hash_: pointer to the hash variable, which is used to store the resulting hash
  (the buffer must be large enough, according to the algorithm, see table
  in function <<crypto_hash_algorithms,crypto_hash>>)
* _hash_size_: pointer to a variable used to store the size of the hash computed
  (in bytes) (can be NULL)

戻り値:

* 成功した場合は 1、失敗した場合は 0

C 言語での使用例:

[source,c]
----
const char *key = "the key";
const char *message = "the message";
char hash[256 / 8];
int rc, hash_size;
rc = weechat_crypto_hmac (key, strlen (key), message, strlen (message), "sha256", hash, &hash_size);
/* rc == 1, hash_size == 32 and hash is a buffer with:
   47 36 67 02 fc bc b1 97 a4 25 e6 7a b9 52 92 bd 15 9a 66 91 9c fb 94 b0 b4 9a 39 cb c0 24 2d 7b */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

[[directories]]
=== ディレクトリ

ディレクトリに関する関数。

==== mkdir_home

_WeeChat バージョン 3.2 で更新。_

WeeChat ホームディレクトリの下にディレクトリを作成。

プロトタイプ:

[source,c]
----
int weechat_mkdir_home (char *directory, int mode);
----

引数:

// TRANSLATION MISSING
* _directory_: name of directory to create; it can start with one of these
  strings to force a specific WeeChat directory (WeeChat ≥ 3.2):
** `${weechat_config_dir}`
** `${weechat_data_dir}` (default)
** `${weechat_state_dir}`
** `${weechat_cache_dir}`
** `${weechat_runtime_dir}`
* _mode_: ディレクトリのモード

戻り値:

* ディレクトリの作成に成功した場合は 1、エラーが起きた場合は 0

C 言語での使用例:

[source,c]
----
if (!weechat_mkdir_home ("${weechat_cache_dir}/temp", 0755))
{
    /* error */
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def mkdir_home(directory: str, mode: int) -> int: ...

# 例
weechat.mkdir_home("${weechat_cache_dir}/temp", 0755)
----

==== mkdir

ディレクトリを作成。

プロトタイプ:

[source,c]
----
int weechat_mkdir (char *directory, int mode);
----

引数:

* _directory_: 作成するディレクトリの名前
* _mode_: ディレクトリのモード

戻り値:

* ディレクトリの作成に成功した場合は 1、エラーが起きた場合は 0

C 言語での使用例:

[source,c]
----
if (!weechat_mkdir ("/tmp/mydir", 0755))
{
    /* error */
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def mkdir(directory: str, mode: int) -> int: ...

# 例
weechat.mkdir("/tmp/mydir", 0755)
----

==== mkdir_parents

ディレクトリの作成と必要に応じて親ディレクトリの作成を行う。

プロトタイプ:

[source,c]
----
int weechat_mkdir_parents (char *directory, int mode);
----

引数:

* _directory_: 作成するディレクトリの名前
* _mode_: ディレクトリのモード

戻り値:

* ディレクトリの作成に成功した場合は 1、エラーが起きた場合は 0

C 言語での使用例:

[source,c]
----
if (!weechat_mkdir_parents ("/tmp/my/dir", 0755))
{
    /* error */
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def mkdir_parents(directory: str, mode: int) -> int: ...

# 例
weechat.mkdir_parents("/tmp/my/dir", 0755)
----

==== exec_on_files

_WeeChat バージョン 1.5 と 2.0 で更新。_

ディレクトリ中のファイルを探し、各ファイルに対してコールバックを実行。

プロトタイプ:

[source,c]
----
void weechat_exec_on_files (const char *directory,
                            int recurse_subdirs,
                            int hidden_files,
                            void (*callback)(void *data,
                                             const char *filename),
                            void *callback_data);
----

引数:

* _directory_: ファイルを検索するディレクトリ
* _recurse_subdirs_: サブディレクトリ内を再帰的に探す場合は 1 _(WeeChat バージョン 2.0 以上で利用可)_
* _hidden_files_: 検索対象に隠しファイルを含める場合は 1、含めない場合は 0
* _callback_: 各ファイルに対して呼び出すコールバック関数、引数:
** _void *data_: ポインタ
** _const char *filename_: 見つかったファイルの名前
* _callback_data_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ

C 言語での使用例:

[source,c]
----
void callback (void *data, const char *filename)
{
    /* ... */
}
...
weechat_exec_on_files ("/tmp", 0, 0, &callback, NULL);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== file_get_content

_WeeChat バージョン 0.3.1 以上で利用可。_

テキストファイルの内容を文字列に代入。

プロトタイプ:

[source,c]
----
char *weechat_file_get_content (const char *filename);
----

引数:

* _filename_: パスやファイル名

戻り値:

* ファイルの内容を含む文字列 (使用後には必ず "free" を呼び出して領域を開放してください)

C 言語での使用例:

[source,c]
----
char *content;

content = weechat_file_get_content ("/tmp/test.txt");
/* ... */
free (content);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

// TRANSLATION MISSING
==== file_copy

_WeeChat ≥ 3.3._

Copy a file to another location.

プロトタイプ:

[source,c]
----
int weechat_file_copy (const char *from, const char *to);
----

引数:

* _from_: source file
* _to_: destination file

戻り値:

* 1 if OK, 0 if error

C 言語での使用例:

[source,c]
----
if (weechat_file_copy ("/tmp/test.txt", "/path/to/test2.txt"))
{
    /* OK */
}
----

[NOTE]
スクリプト API ではこの関数を利用できません。

// TRANSLATION MISSING
==== file_compress

_WeeChat ≥ 3.7._

Compress a file with gzip or zstd.

プロトタイプ:

[source,c]
----
int weechat_file_compress (const char *from, const char *to,
                           const char *compressor, int compression_level);
----

引数:

* _from_: source file
* _to_: destination file
* _compressor_: the compressor to use, one of:
** _gzip_: gzip compression
** _zstd_: zstandard compression (available only if zstd was enabled when
   WeeChat was compiled)
* _compression_level_: compression level, between 1 (fast, low compression) to
  100 (slow, best compression)

戻り値:

* 1 if OK, 0 if error

C 言語での使用例:

[source,c]
----
if (weechat_file_compress ("/tmp/test.txt", "/tmp/test.txt.zst", "zstd", 50))
{
    /* OK */
}
----

[NOTE]
スクリプト API ではこの関数を利用できません。

[[util]]
=== ユーティリティ

便利な関数。

==== util_timeval_cmp

2 つの "timeval" 構造体を比較。

プロトタイプ:

[source,c]
----
int weechat_util_timeval_cmp (struct timeval *tv1, struct timeval *tv2);
----

引数:

* _tv1_: 1 番目の "timeval" 構造体
* _tv2_: 2 番目の "timeval" 構造体

戻り値:

* tv1 < tv2 の場合は -1
* tv1 == tv2 の場合は 0
* tv1 > tv2 の場合は +1

C 言語での使用例:

[source,c]
----
if (weechat_util_timeval_cmp (&tv1, &tv2) > 0)
{
    /* tv1 > tv2 */
}
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== util_timeval_diff

_WeeChat バージョン 1.1 で更新。_

2 つの "timeval" 構造体の差を返す (マイクロ秒単位)。

プロトタイプ:

[source,c]
----
long long weechat_util_timeval_diff (struct timeval *tv1, struct timeval *tv2);
----

引数:

* _tv1_: 1 番目の "timeval" 構造体
* _tv2_: 2 番目の "timeval" 構造体

戻り値:

* マイクロ秒単位の差

[NOTE]
WeeChat バージョン 1.0 以前の場合、戻り値の単位はミリ秒でした。

C 言語での使用例:

[source,c]
----
long long diff = weechat_util_timeval_diff (&tv1, &tv2);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== util_timeval_add

_WeeChat バージョン 1.1 で更新。_

timeval 構造体に時間間隔を追加 (マイクロ秒単位)。

プロトタイプ:

[source,c]
----
void weechat_util_timeval_add (struct timeval *tv, long long interval);
----

引数:

* _tv_: timeval 構造体
* _interval_: 時間間隔 (マイクロ秒単位)

[NOTE]
WeeChat バージョン 1.0 以前の場合、時間間隔の単位はミリ秒でした。

C 言語での使用例:

[source,c]
----
weechat_util_timeval_add (&tv, 2000000);  /* add 2 seconds */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== util_get_time_string

_WeeChat バージョン 0.3.2 以上で利用可、バージョン 1.3 で更新。_

日付/時刻を "strftime" で作った文字列として取得します。書式は
_weechat.look.time_format_ で定義されています。

プロトタイプ:

[source,c]
----
const char *weechat_util_get_time_string (const time_t *date);
----

引数:

* _date_: 日付へのポインタ

戻り値:

* 日付/時刻文字列へのポインタ

C 言語での使用例:

[source,c]
----
time_t date = time (NULL);
weechat_printf (NULL, "date: %s",
                weechat_util_get_time_string (&date));
----

[NOTE]
スクリプト API ではこの関数を利用できません。

// TRANSLATION MISSING
==== util_strftimeval

_WeeChat ≥ 4.2.0, updated in 4.3.0._

Format date and time like function `strftime` in C library, using `struct timeval`
as input, and supporting extra specifiers.

Prototype:

[source,c]
----
int weechat_util_strftimeval (char *string, int max, const char *format, struct timeval *tv);
----

Arguments:

* _string_: buffer where the formatted string is stored
* _max_: string size
* _format_: format, the same as _strftime_ function, with these extra specifiers:
** `%.N` where `N` is between 1 and 6: zero-padded microseconds on N digits
   (for example `%.3` for milliseconds)
** `%f`: alias of `%.6`
** `%!`: timestamp as integer, in seconds (value of tv->tv_sec)

Return value:

* number of bytes put in _string_ (value returned from _strftime_ function)

C example:

[source,c]
----
char time[256];
struct timeval tv;
gettimeofday (&tv, NULL);
weechat_util_strftimeval (time, sizeof (time), "%FT%T.%f", &tv);
/* result: 2023-12-26T18:10:04.460509 */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

// TRANSLATION MISSING
==== util_parse_time

_WeeChat ≥ 4.2.0._

Parse date/time with support of microseconds.

Prototype:

[source,c]
----
int util_parse_time (const char *datetime, struct timeval *tv);
----

Arguments:

* _date_: date/time
* _tv_: parsed date/time ("timeval" structure)

Return value:

* 1 if OK, 0 if error

C example:

[source,c]
----
struct timeval tv;
weechat_util_parse_time ("2023-12-25T10:29:09.456789Z", &tv);  /* == 1 */
/* result: tv.tv_sec == 1703500149, tv.tv_usec = 456789 */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== util_version_number

_WeeChat バージョン 0.3.9 以上で利用可。_

WeeChat バージョンの文字列を番号に変換。

プロトタイプ:

[source,c]
----
int weechat_util_version_number (const char *version);
----

引数:

* _version_: WeeChat バージョン文字列 (例: "0.3.9" や "0.3.9-dev")

C 言語での使用例:

[source,c]
----
version_number = weechat_util_version_number ("0.3.8");      /* == 0x00030800 */
version_number = weechat_util_version_number ("0.3.9-dev");  /* == 0x00030900 */
version_number = weechat_util_version_number ("0.3.9-rc1");  /* == 0x00030900 */
version_number = weechat_util_version_number ("0.3.9");      /* == 0x00030900 */
version_number = weechat_util_version_number ("1.0");        /* == 0x01000000 */
version_number = weechat_util_version_number ("4.0.0");      /* == 0x04000000 */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

[[sorted_lists]]
=== ソート済みリスト

ソート済みリスト関数。

==== list_new

新しいリストを作成。

プロトタイプ:

[source,c]
----
struct t_weelist *weechat_list_new ();
----

戻り値:

* 新しいリストへのポインタ

C 言語での使用例:

[source,c]
----
struct t_weelist *list = weechat_list_new ();
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def list_new() -> str: ...

# 例
list = weechat.list_new()
----

==== list_add

リストに要素を追加。

プロトタイプ:

[source,c]
----
struct t_weelist_item *weechat_list_add (struct t_weelist *weelist,
                                         const char *data,
                                         const char *where,
                                         void *user_data);
----

引数:

* _weelist_: リストへのポインタ
* _data_: リストに追加するデータ
* _where_: データを追加する場所:
** _WEECHAT_LIST_POS_SORT_: リストに追加、リストをソートされた状態を保持
** _WEECHAT_LIST_POS_BEGINNING_: リストの最初に追加
** _WEECHAT_LIST_POS_END_: リストの最後に追加
* _user_data_: 任意のポインタ

戻り値:

* 新しい要素へのポインタ

C 言語での使用例:

[source,c]
----
struct t_weelist_item *my_item =
    weechat_list_add (list, "my data", WEECHAT_LIST_POS_SORT, NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def list_add(list: str, data: str, where: str, user_data: str) -> str: ...

# 例
item = weechat.list_add(list, "my data", weechat.WEECHAT_LIST_POS_SORT, "")
----

==== list_search

リストから要素を検索。

プロトタイプ:

[source,c]
----
struct t_weelist_item *weechat_list_search (struct t_weelist *weelist,
                                            const char *data);
----

引数:

* _weelist_: リストへのポインタ
* _data_: リストから検索するデータ

戻り値:

* 見つかった要素へのポインタ、見つからなかった場合は NULL

C 言語での使用例:

[source,c]
----
struct t_weelist_item *item = weechat_list_search (list, "my data");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def list_search(list: str, data: str) -> str: ...

# 例
item = weechat.list_search(list, "my data")
----

==== list_search_pos

_WeeChat バージョン 0.3.4 以上で利用可。_

リストから要素の位置を検索。

プロトタイプ:

[source,c]
----
int weechat_list_search_pos (struct t_weelist *weelist,
                             const char *data);
----

引数:

* _weelist_: リストへのポインタ
* _data_: リストから検索するデータ

戻り値:

* 見つかった要素の位置、見つからなかった場合は -1

C 言語での使用例:

[source,c]
----
int pos_item = weechat_list_search_pos (list, "my data");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def list_search_pos(list: str, data: str) -> int: ...

# 例
pos_item = weechat.list_search_pos(list, "my data")
----

==== list_casesearch

大文字小文字を無視してリストから要素を検索。

プロトタイプ:

[source,c]
----
struct t_weelist_item *weechat_list_casesearch (struct t_weelist *weelist,
                                                const char *data);
----

引数:

* _weelist_: リストへのポインタ
* _data_: リストから検索するデータ

戻り値:

* 見つかった要素へのポインタ、見つからなかった場合は NULL

C 言語での使用例:

[source,c]
----
struct t_weelist_item *item = weechat_list_casesearch (list, "my data");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def list_casesearch(list: str, data: str) -> str: ...

# 例
item = weechat.list_casesearch(list, "my data")
----

==== list_casesearch_pos

_WeeChat バージョン 0.3.4 以上で利用可。_

大文字小文字を無視してリストから要素の位置を検索。

プロトタイプ:

[source,c]
----
int weechat_list_casesearch_pos (struct t_weelist *weelist,
                                 const char *data);
----

引数:

* _weelist_: リストへのポインタ
* _data_: リストから検索するデータ

戻り値:

* 見つかった要素の位置、見つからなかった場合は -1

C 言語での使用例:

[source,c]
----
int pos_item = weechat_list_casesearch_pos (list, "my data");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def list_casesearch_pos(list: str, data: str) -> int: ...

# 例
pos_item = weechat.list_casesearch_pos(list, "my data")
----

==== list_get

リスト中の位置を指定して要素を返す。

プロトタイプ:

[source,c]
----
struct t_weelist_item *weechat_list_get (struct t_weelist *weelist,
                                         int position);
----

引数:

* _weelist_: リストへのポインタ
* _position_: リスト中の位置 (1 番目の要素は 0)

戻り値:

* 見つかった要素へのポインタ、見つからなかった場合は NULL

C 言語での使用例:

[source,c]
----
struct t_weelist_item *item = weechat_list_get (list, 0);  /* first item */
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def list_get(list: str, position: int) -> str: ...

# 例
item = weechat.list_get(list, 0)
----

==== list_set

ある要素に新しい値をセット。

プロトタイプ:

[source,c]
----
void weechat_list_set (struct t_weelist_item *item, const char *value);
----

引数:

* _item_: 要素へのポインタ
* _value_: 要素にセットする新しい値

C 言語での使用例:

[source,c]
----
weechat_list_set (item, "new data");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def list_set(item: str, value: str) -> int: ...

# 例
weechat.list_set(item, "new data")
----

==== list_next

リストから 1 つ後の要素を返す。

プロトタイプ:

[source,c]
----
struct t_weelist_item *weechat_list_next (struct t_weelist_item *item);
----

引数:

* _item_: 要素へのポインタ

戻り値:

* 1 つ後の要素へのポインタ、ポインタがリストの最後を指す場合は NULL

C 言語での使用例:

[source,c]
----
struct t_weelist_item *next_item = weechat_list_next (item);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def list_next(item: str) -> str: ...

# 例
item = weechat.list_next(item)
----

==== list_prev

リストから 1 つ前の要素を返す。

プロトタイプ:

[source,c]
----
struct t_weelist_item *weechat_list_prev (struct t_weelist_item *item);
----

引数:

* _item_: 要素へのポインタ

戻り値:

* 1 つ前の要素へのポインタ、ポインタがリストの最初を指す場合は NULL

C 言語での使用例:

[source,c]
----
struct t_weelist_item *prev_item = weechat_list_prev (item);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def list_prev(item: str) -> str: ...

# 例
item = weechat.list_prev(item)
----

==== list_string

ある要素の文字列値を返す。

プロトタイプ:

[source,c]
----
const char *weechat_list_string (struct t_weelist_item *item);
----

引数:

* _item_: 要素へのポインタ

戻り値:

* 要素の文字列値

C 言語での使用例:

[source,c]
----
weechat_printf (NULL, "value of item: %s", weechat_list_string (item));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def list_string(item: str) -> str: ...

# 例
weechat.prnt("", "value of item: %s" % weechat.list_string(item))
----

==== list_user_data

_WeeChat バージョン 2.6 以上で利用可_

// TRANSLATION MISSING
Return pointer to the user data of an item.

プロトタイプ:

[source,c]
----
void *weechat_list_user_data (struct t_weelist_item *item);
----

引数:

* _item_: 要素へのポインタ

戻り値:

// TRANSLATION MISSING
* pointer to the user data of item

C 言語での使用例:

// TRANSLATION MISSING
[source,c]
----
weechat_printf (NULL, "user data of item: %p", weechat_list_user_data (item));
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== list_size

リストのサイズ (要素の個数) を返す。

プロトタイプ:

[source,c]
----
char *weechat_list_size (struct t_weelist *weelist);
----

引数:

* _weelist_: 要素へのポインタ

戻り値:

* リストのサイズ (要素の個数)、リストが空の場合は 0

C 言語での使用例:

[source,c]
----
weechat_printf (NULL, "size of list: %d", weechat_list_size (list));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def list_size(list: str) -> int: ...

# 例
weechat.prnt("", "size of list: %d" % weechat.list_size(list))
----

==== list_remove

ある要素をリストから削除。

プロトタイプ:

[source,c]
----
void weechat_list_remove (struct t_weelist *weelist,
                          struct t_weelist_item *item);
----

引数:

* _weelist_: リストへのポインタ
* _item_: 要素へのポインタ

C 言語での使用例:

[source,c]
----
weechat_list_remove (list, item);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def list_remove(list: str, item: str) -> int: ...

# 例
weechat.list_remove(list, item)
----

==== list_remove_all

あるリストの要素をすべて削除。

プロトタイプ:

[source,c]
----
void weechat_list_remove_all (struct t_weelist *weelist);
----

引数:

* _weelist_: リストへのポインタ

C 言語での使用例:

[source,c]
----
weechat_list_remove_all (list);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def list_remove_all(list: str) -> int: ...

# 例
weechat.list_remove_all(list)
----

==== list_free

リストを開放。

プロトタイプ:

[source,c]
----
void weechat_list_free (struct t_weelist *weelist);
----

引数:

* _weelist_: リストへのポインタ

C 言語での使用例:

[source,c]
----
weechat_list_free (list);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def list_free(list: str) -> int: ...

# 例
weechat.list_free(list)
----

[[array_lists]]
=== 配列リスト

配列リスト関数。

配列リストとはサイズ可変でソート可能なポインタのリストです。

==== arraylist_new

_WeeChat バージョン 1.8 以上で利用可_

新しい配列リストを作成します。

プロトタイプ:

[source,c]
----
struct t_arraylist *weechat_arraylist_new (int initial_size,
                                           int sorted,
                                           int allow_duplicates,
                                           int (*callback_cmp)(void *data,
                                                               struct t_arraylist *arraylist,
                                                               void *pointer1,
                                                               void *pointer2),
                                           void *callback_cmp_data,
                                           void (*callback_free)(void *data,
                                                                 struct t_arraylist *arraylist,
                                                                 void *pointer),
                                           void *callback_free_data);
----

引数:

* _initial_size_: 配列リストの初期サイズ (要素数ではありません)
* _sorted_: 1 の場合には配列リストをソートし、0 の場合にはソートしません
* _allow_duplicates_: 1 の場合にはエントリの重複を許可し、0
  の場合にはエントリが重複して追加されることを防ぎます
* _callback_cmp_: 2 つの要素を比較する際に使われるコールバック
  (任意)、引数と戻り値は以下:
** _void *data_: ポインタ
** _struct t_arraylist *arraylist_: 配列リストポインタ
** _void *pointer1_: 1 番目の要素へのポインタ
** _void *pointer2_: 2 番目の要素へのポインタ
** 戻り値:
*** 1 番目の要素が 2 番目の要素よりも小さければ負数
*** 1 番目の要素が 2 番目の要素と同じならばゼロ
*** 1 番目の要素が 2 番目の要素よりも大きければ正数
* _callback_cmp_data_: WeeChat がコールバックを呼び出す際に、コールバックに渡すポインタ
* _callback_free_: 要素を解放する際に使われるコールバック (任意)、引数は以下:
** _void *data_: ポインタ
** _struct t_arraylist *arraylist_: 配列リストポインタ
** _void *pointer_: 要素へのポインタ
* _callback_free_data_: WeeChat がコールバックを呼び出す際に、コールバックに渡すポインタ

戻り値:

* 新しい配列リストへのポインタ

C 言語での使用例:

[source,c]
----
int
cmp_cb (void *data, struct t_arraylist *arraylist,
        void *pointer1, void *pointer2)
{
    if (...)
        return -1;
    else if (...)
        return 1;
    else
        return 0;
}

struct t_arraylist *list = weechat_arraylist_new (32, 1, 1,
                                                  &cmp_cb, NULL, NULL, NULL);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== arraylist_size

_WeeChat バージョン 1.8 以上で利用可_

配列リストのサイズ (要素ポインタの数) を返します。

プロトタイプ:

[source,c]
----
int weechat_list_size (struct t_arraylist *arraylist);
----

引数:

* _arraylist_: 配列リストポインタ

戻り値:

* 配列リストのサイズ (要素の数)、0 は配列リストが空であることを意味します

C 言語での使用例:

[source,c]
----
weechat_printf (NULL, "size of array list: %d", weechat_arraylist_size (arraylist));
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== arraylist_get

_WeeChat バージョン 1.8 以上で利用可_

指定された位置の要素ポインタを返します。

プロトタイプ:

[source,c]
----
void *weechat_arraylist_get (struct t_arraylist *arraylist, int index);
----

引数:

* _arraylist_: 配列リストポインタ
* _index_: リストのインデックス番号 (インデックス番号は 0 から始まります)

戻り値:

* ポインタが見つかった場合はそのポインタ、見つからなかった場合は NULL

C 言語での使用例:

[source,c]
----
void *pointer = weechat_arraylist_get (arraylist, 0);  /* first item */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== arraylist_search

_WeeChat バージョン 1.8 以上で利用可_

配列リストから要素を検索します。

プロトタイプ:

[source,c]
----
void *weechat_arraylist_search (struct t_arraylist *arraylist, void *pointer,
                                int *index, int *index_insert);
----

引数:

* _arraylist_: 配列リストポインタ
* _pointer_: 配列リストから検索する要素へのポインタ
* _index_: 要素が見つかった場合はそのインデックス番号を示す整数へのポインタ、見つからなかった場合は
  -1 (任意)
* _index_insert_: _arraylist_ に要素を挿入するために使われるインデックス番号を示す整数へのポインタ
  (これは _arraylist_ のソート状態を保存する目的で使います) (任意)

戻り値:

* 要素が見つかったにはその要素へのポインタ、見つからなかった場合は NULL

C 言語での使用例:

[source,c]
----
int index, index_insert;
void *item = weechat_arraylist_search (arraylist, pointer, &index, &index_insert);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== arraylist_insert

_WeeChat バージョン 1.8 以上で利用可_

配列リストに要素を挿入します。

プロトタイプ:

[source,c]
----
int weechat_arraylist_insert (struct t_arraylist *arraylist, int index, void *pointer);
----

引数:

* _arraylist_: 配列リストポインタ
* _index_:
  配列リストにおける要素の挿入位置または末尾に挿入することを意味する -1
  (この引数は配列リストがソート済みでない場合にのみ使われ、配列リストがソートされている場合には無視されます)
* _pointer_: 挿入する要素へのポインタ

戻り値:

* 成功した場合には挿入された要素のインデックス番号 (0 以上)、失敗した場合には -1。

C 言語での使用例:

[source,c]
----
int index = weechat_arraylist_insert (arraylist, -1, pointer);  /* 未ソートの配列リストに対しては要素を末尾に挿入します */
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== arraylist_add

_WeeChat バージョン 1.8 以上で利用可_

配列リストに要素を追加します。

プロトタイプ:

[source,c]
----
int weechat_arraylist_add (struct t_arraylist *arraylist, void *pointer);
----

引数:

* _arraylist_: 配列リストポインタ
* _pointer_: 追加する要素へのポインタ

戻り値:

* 成功した場合には追加された要素のインデックス番号 (0 以上)、失敗した場合には -1。

C 言語での使用例:

[source,c]
----
int index = weechat_arraylist_add (arraylist, pointer);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== arraylist_remove

_WeeChat バージョン 1.8 以上で利用可_

配列リストから要素を削除します。

プロトタイプ:

[source,c]
----
int weechat_arraylist_remove (struct t_arraylist *arraylist, int index);
----

引数:

* _arraylist_: 配列リストポインタ
* _index_: 削除する要素のインデックス番号

戻り値:

* 成功した場合には削除された要素のインデックス番号、失敗した場合には -1。

C 言語での使用例:

[source,c]
----
int index_removed = weechat_arraylist_remove (arraylist, index);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== arraylist_clear

_WeeChat バージョン 1.8 以上で利用可_

配列リストからすべての要素を削除します。

プロトタイプ:

[source,c]
----
int weechat_arraylist_clear (struct t_arraylist *arraylist);
----

引数:

* _arraylist_: 配列リストポインタ

戻り値:

* 成功した場合には 1、失敗した場合には 0

C 言語での使用例:

[source,c]
----
if (weechat_arraylist_clear (arraylist))
{
    /* 成功 */
}
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== arraylist_free

_WeeChat バージョン 1.8 以上で利用可_

配列リストを解放します。

プロトタイプ:

[source,c]
----
void weechat_arraylist_free (struct t_arraylist *arraylist);
----

引数:

* _arraylist_: 配列リストポインタ

C 言語での使用例:

[source,c]
----
weechat_arraylist_free (arraylist);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

[[hashtables]]
=== ハッシュテーブル

ハッシュテーブル関数。

==== hashtable_new

_WeeChat バージョン 0.3.3 以上で利用可、バージョン 4.4.0 で更新。_

新しいハッシュテーブルを作成。

プロトタイプ:

[source,c]
----
struct t_hashtable *weechat_hashtable_new (int size,
                                           const char *type_keys,
                                           const char *type_values,
                                           unsigned long long (*callback_hash_key)(struct t_hashtable *hashtable,
                                                                                   const void *key),
                                           int (*callback_keycmp)(struct t_hashtable *hashtable,
                                                                  const void *key1,
                                                                  const void *key2));
----

引数:

* _size_:
  ハッシュキーを保存している内部配列のサイズ、値が大きければ多くのメモリを使う反面パフォーマンスがよくなります
  (これはハッシュテーブルの要素数の上限を決めるもの *ではありません*)
* _type_keys_: ハッシュテーブルのキーの種類:
** _WEECHAT_HASHTABLE_INTEGER_
** _WEECHAT_HASHTABLE_STRING_
** _WEECHAT_HASHTABLE_POINTER_
** _WEECHAT_HASHTABLE_BUFFER_
** _WEECHAT_HASHTABLE_TIME_
** _WEECHAT_HASHTABLE_LONGLONG_ _(WeeChat ≥ 4.4.0)_
* _type_values_: ハッシュテーブルの値の種類:
** _WEECHAT_HASHTABLE_INTEGER_
** _WEECHAT_HASHTABLE_STRING_
** _WEECHAT_HASHTABLE_POINTER_
** _WEECHAT_HASHTABLE_BUFFER_
** _WEECHAT_HASHTABLE_TIME_
** _WEECHAT_HASHTABLE_LONGLONG_ _(WeeChat ≥ 4.4.0)_
* _callback_hash_key_: キーを「ハッシュ化」する (キーを整数値にする)
  際のコールバック関数、キーの種類が "buffer" 以外の場合、コールバックは
  NULL でも可 (デフォルトのハッシュ関数を使います)、引数と戻り値:
** _struct t_hashtable *hashtable_: ハッシュテーブルへのポインタ
** _const void *key_: キー
** 戻り値: キーのハッシュ値
* _callback_keycmp_: 2 つのキーを比較する際のコールバック関数、キーの種類が
  "buffer" 以外の場合、コールバックは NULL でも可
  (デフォルトの比較関数を使います)、引数と戻り値:
** _struct t_hashtable *hashtable_: ハッシュテーブルへのポインタ
** _const void *key1_: 1 番目のキー
** _const void *key2_: 2 番目のキー
** 戻り値:
*** _key1_ が _key2_ より小さい場合は負
*** _key1_ が _key2_ と同じ場合はゼロ
*** _key1_ が _key2_ より大きい場合は正

戻り値:

* 新しいハッシュテーブルへのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== hashtable_set_with_size

_WeeChat バージョン 0.3.3 以上で利用可、バージョン 0.4.2 で更新。_

キーと値のサイズを使ってハッシュテーブルの要素を追加または更新。

プロトタイプ:

[source,c]
----
struct t_hashtable_item *weechat_hashtable_set_with_size (struct t_hashtable *hashtable,
                                                          const void *key, int key_size,
                                                          const void *value, int value_size);
----

引数:

* _hashtable_: ハッシュテーブルへのポインタ
* _key_: キーへのポインタ
* _key_size_: キーのサイズ (バイト単位)、ハッシュテーブルのキーの種類が
  "buffer" の場合のみ使用
* _value_: 値へのポインタ
* _value_size_: 値のサイズ (バイト単位)、ハッシュテーブルの値の種類が
  "buffer" の場合のみ使用

戻り値:

* 作成または更新された要素へのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
weechat_hashtable_set_with_size (hashtable, "my_key", 0,
                                 my_buffer, sizeof (my_buffer_struct));
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== hashtable_set

_WeeChat バージョン 0.3.3 以上で利用可、バージョン 0.4.2 で更新。_

ハッシュテーブルの要素を追加または更新。

プロトタイプ:

[source,c]
----
struct t_hashtable_item *weechat_hashtable_set (struct t_hashtable *hashtable,
                                                const void *key, const void *value);
----

引数:

* _hashtable_: ハッシュテーブルへのポインタ
* _key_: キーへのポインタ
* _value_: 値へのポインタ

戻り値:

* 作成または更新された要素へのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
weechat_hashtable_set (hashtable, "my_key", "my_value");
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== hashtable_get

_WeeChat バージョン 0.3.3 以上で利用可。_

ハッシュテーブルからキーに紐付けられた値を取得。

プロトタイプ:

[source,c]
----
void *weechat_hashtable_get (struct t_hashtable *hashtable, void *key);
----

引数:

* _hashtable_: ハッシュテーブルへのポインタ
* _key_: キーへのポインタ

戻り値:

* キーに対応する値、キーが見つからない場合は NULL

C 言語での使用例:

[source,c]
----
void *value = weechat_hashtable_get (hashtable, "my_key");
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== hashtable_has_key

_WeeChat バージョン 0.3.4 以上で利用可。_

ハッシュテーブル内にキーが有るか確認する。

プロトタイプ:

[source,c]
----
int weechat_hashtable_has_key (struct t_hashtable *hashtable, void *key);
----

引数:

* _hashtable_: ハッシュテーブルへのポインタ
* _key_: キーへのポインタ

戻り値:

* ハッシュテーブル内にキーが有る場合は 1、無い場合は 0

C 言語での使用例:

[source,c]
----
if (weechat_hashtable_has_key (hashtable, "my_key"))
{
    /* key is in hashtable */
    /* ... */
}
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== hashtable_map

_WeeChat バージョン 0.3.3 以上で利用可。_

// TRANSLATION MISSING
ハッシュテーブルのすべてのエントリに対して関数を呼び出す,
by insertion order in the hashtable (from oldest to newest one).

プロトタイプ:

[source,c]
----
void weechat_hashtable_map (struct t_hashtable *hashtable,
                            void (*callback_map)(void *data,
                                                 struct t_hashtable *hashtable,
                                                 const void *key,
                                                 const void *value),
                            void *callback_map_data);
----

引数:

* _hashtable_: ハッシュテーブルへのポインタ
* _callback_map_: ハッシュテーブルの各のエントリに対して呼び出すコールバック関数
* _callback_map_data_: _callback_map_ コールバックを呼び出す際のコールバックの結果保存先へのポインタ

C 言語での使用例:

[source,c]
----
void
map_cb (void *data, struct t_hashtable *hashtable,
        const void *key, const void *value)
{
    /* display key and value (they are both strings here) */
    weechat_printf (NULL, "key: '%s', value: '%s'",
                    (const char *)key,
                    (const char *)value);
}
/* ... */
weechat_hashtable_map (hashtable, &map_cb, NULL);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== hashtable_map_string

_WeeChat バージョン 0.3.7 以上で利用可。_

// TRANSLATION MISSING
Call a function on all hashtable entries, by insertion order in the hashtable
(from oldest to newest one), sending keys and values as strings.

プロトタイプ:

[source,c]
----
void weechat_hashtable_map_string (struct t_hashtable *hashtable,
                                   void (*callback_map)(void *data,
                                                        struct t_hashtable *hashtable,
                                                        const char *key,
                                                        const char *value),
                                   void *callback_map_data);
----

引数:

* _hashtable_: ハッシュテーブルへのポインタ
* _callback_map_: ハッシュテーブルの各のエントリに対して呼び出すコールバック関数
* _callback_map_data_: _callback_map_ コールバックを呼び出した際のコールバックの結果保存先へのポインタ

[NOTE]
コールバックに渡される文字列 _key_ と _value_
は一時的な文字列で、コールバックの呼び出しが終了したら削除されます。

C 言語での使用例:

[source,c]
----
void
map_cb (void *data, struct t_hashtable *hashtable,
        const char *key, const char *value)
{
    /* display key and value */
    weechat_printf (NULL, "key: '%s', value: '%s'",
                    key, value);
}
/* ... */
weechat_hashtable_map_string (hashtable, &map_cb, NULL);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== hashtable_dup

_WeeChat バージョン 1.0 以上で利用可。_

ハッシュテーブルを複製。

プロトタイプ:

[source,c]
----
struct t_hashtable *weechat_hashtable_dup (struct t_hashtable *hashtable);
----

引数:

* _hashtable_: ハッシュテーブルへのポインタ

戻り値:

* 複製されたハッシュテーブ

C 言語での使用例:

[source,c]
----
struct t_hashtable *new_hashtable = weechat_hashtable_dup (hashtable);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== hashtable_get_integer

_WeeChat バージョン 0.3.3 以上で利用可。_

ハッシュテーブルプロパティの整数値を返す。

プロトタイプ:

[source,c]
----
int weechat_hashtable_get_integer (struct t_hashtable *hashtable,
                                   void *property);
----

引数:

* _hashtable_: ハッシュテーブルへのポインタ
* _property_: プロパティ名:
** _size_: ハッシュテーブルの内部配列 "htable" のサイズ
** _items_count_: ハッシュテーブルに含まれる要素の数

戻り値:

* プロパティの整数値

C 言語での使用例:

[source,c]
----
int items_count = weechat_hashtable_get_integer (hashtable, "items_count");
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== hashtable_get_string

_WeeChat バージョン 0.3.4 以上で利用可。_

ハッシュテーブルプロパティを文字列値で返す。

プロトタイプ:

[source,c]
----
const char *weechat_hashtable_get_string (struct t_hashtable *hashtable,
                                          const char *property);
----

引数:

* _hashtable_: ハッシュテーブルへのポインタ
* _property_: プロパティ名:
** _type_keys_: キーの型:
*** _integer_: 整数
*** _string_: 文字列
*** _pointer_: ポインタ
*** _buffer_: バッファ
*** _time_: 時間
// TRANSLATION MISSING
*** _longlong_: long long integer
** _type_values_: 値の型:
*** _integer_: 整数
*** _string_: 文字列
*** _pointer_: ポインタ
*** _buffer_: バッファ
*** _time_: 時間
// TRANSLATION MISSING
*** _longlong_: long long integer
** _keys_: キーのリストを含む文字列 (書式: "key1,key2,key3")
** _keys_sorted_: ソートされたキーのリストを含む文字列 (書式: "key1,key2,key3")
** _values_: 値のリストを含む文字列 (書式: "value1,value2,value3")
** _keys_values_: リストのキーと値を含む文字列
   (書式: "key1:value1,key2:value2,key3:value3")
** _keys_values_sorted_: リストのキーと値を含む文字列 (キーでソート)
   (書式: "key1:value1,key2:value2,key3:value3")

戻り値:

* プロパティに対する結果の文字列

C 言語での使用例:

[source,c]
----
weechat_printf (NULL, "keys are type: %s",
                weechat_hashtable_get_string (hashtable, "type_keys"));
weechat_printf (NULL, "list of keys: %s",
                weechat_hashtable_get_string (hashtable, "keys"));
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== hashtable_set_pointer

_WeeChat バージョン 0.3.4 以上で利用可。_

ハッシュテーブルのポインタ値を設定。

プロトタイプ:

[source,c]
----
void weechat_hashtable_set_pointer (struct t_hashtable *hashtable,
                                    const char *property, void *pointer);
----

引数:

* _hashtable_: ハッシュテーブルへのポインタ
* _property_: プロパティ名:
** _callback_free_key_: ハッシュテーブルからキーを開放する際のコールバック関数
   _(WeeChat バージョン 0.4.2 以上で利用可)_
** _callback_free_value_: ハッシュテーブルから値を開放する際のコールバック関数
* _pointer_: プロパティの新しいポインタ値

C 言語での使用例:

[source,c]
----
void
my_free_value_cb (struct t_hashtable *hashtable, const void *key, void *value)
{
    /* ... */
}

void
my_free_key_cb (struct t_hashtable *hashtable, void *key)
{
    /* ... */
}

weechat_hashtable_set_pointer (hashtable, "callback_free_value", &my_free_value_cb);
weechat_hashtable_set_pointer (hashtable, "callback_free_key", &my_free_key_cb);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== hashtable_add_to_infolist

_WeeChat バージョン 0.3.3 以上で利用可。_

// TRANSLATION MISSING
ハッシュテーブルの要素をインフォリスト要素に追加, by insertion order in the hashtable
(from oldest to newest one).

プロトタイプ:

[source,c]
----
int weechat_hashtable_add_to_infolist (struct t_hashtable *hashtable,
                                       struct t_infolist_item *infolist_item,
                                       const char *prefix);
----

引数:

* _hashtable_: ハッシュテーブルへのポインタ
* _infolist_item_: インフォリスト要素へのポインタ
* _prefix_: インフォリストで名前のプレフィックスとして使う文字列

戻り値:

* 成功した場合は 1、エラーが起きた場合は 0

C 言語での使用例:

[source,c]
----
weechat_hashtable_add_to_infolist (hashtable, infolist_item, "testhash");

/* ハッシュテーブルが以下の内容を保つ場合:
     "key1" => "value 1"
     "key2" => "value 2"
   以下の変数がインフォリスト要素に追加されます:
     "testhash_name_00000"  = "key1"
     "testhash_value_00000" = "value 1"
     "testhash_name_00001"  = "key2"
     "testhash_value_00001" = "value 2"
*/
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== hashtable_remove

_WeeChat バージョン 0.3.3 以上で利用可。_

ハッシュテーブルから要素を削除。

プロトタイプ:

[source,c]
----
void weechat_hashtable_remove (struct t_hashtable *hashtable, const void *key);
----

引数:

* _hashtable_: ハッシュテーブルへのポインタ
* _key_: キーへのポインタ

C 言語での使用例:

[source,c]
----
weechat_hashtable_remove (hashtable, "my_key");
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== hashtable_remove_all

_WeeChat バージョン 0.3.3 以上で利用可。_

ハッシュテーブルからすべての要素を削除。

プロトタイプ:

[source,c]
----
void weechat_hashtable_remove_all (struct t_hashtable *hashtable);
----

引数:

* _hashtable_: ハッシュテーブルへのポインタ

C 言語での使用例:

[source,c]
----
weechat_hashtable_remove_all (hashtable);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== hashtable_free

_WeeChat バージョン 0.3.3 以上で利用可。_

ハッシュテーブルを開放。

プロトタイプ:

[source,c]
----
void weechat_hashtable_free (struct t_hashtable *hashtable);
----

引数:

* _hashtable_: ハッシュテーブルへのポインタ

C 言語での使用例:

[source,c]
----
weechat_hashtable_free (hashtable);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

[[configuration_files]]
=== 設定ファイル

設定ファイルに関する関数。

==== config_new

_WeeChat バージョン 1.5, 4.0.0 で更新。_

新しい設定ファイルを作成。

プロトタイプ:

[source,c]
----
struct t_config_file *weechat_config_new (const char *name,
                                          int (*callback_reload)(const void *pointer,
                                                                 void *data,
                                                                 struct t_config_file *config_file),
                                          const void *callback_reload_pointer,
                                          void *callback_reload_data);
----

引数:

// TRANSLATION MISSING
* _name_: 設定ファイルの名前 (パスと拡張子は不要); a priority
  is allowed before the name, with format `nnn|name` where `nnn` is non-negative
  integer with priority; default priority is 1000; files are sorted by priority
  from higher to lower when running command `/reload`
  (see priority of configuration files below)
* _callback_reload_: `/reload` で設定ファイルをリロードする際に呼び出すコールバック関数
  (任意、NULL でも可、下の説明を参照)、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _struct t_config_file *config_file_: 設定ファイルへのポインタ
** 戻り値:
*** _WEECHAT_CONFIG_READ_OK_
*** _WEECHAT_CONFIG_READ_MEMORY_ERROR_
*** _WEECHAT_CONFIG_READ_FILE_NOT_FOUND_
* _callback_reload_pointer_: WeeChat が _callback_reload_
  コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_reload_data_: WeeChat が _callback_reload_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成した設定ファイルが開放された時点で自動的に開放されます

リロードコールバック:

* リロードコールバックは必ず <<_config_reload,config_reload>>
  を呼び出してください。<<_config_reload,config_reload>> 関数は設定ファイルを削除してはいけません。
* <<_config_reload,config_reload>>
  関数の前処理や後処理が必要な場合に限り、これらを行うリロードコールバックを指定します。 +
  リロードコールバックを指定しなかった場合、WeeChat
  は内部リロード関数を呼び出し、常に設定ファイルがリロードされます。

戻り値:

* 新しい設定ファイルへのポインタ、エラーが起きた場合は NULL

[NOTE]
この関数はディスク上にファイルを作りません。ファイルを作るには
<<_config_write,config_write>>
関数を使ってください。この関数を呼び出す必要があるのは
(<<_config_new_section,config_new_section>> を使って) セクションもしくは
(<<_config_new_option,config_new_option>> を使って) オプションを追加した後だけです。

// TRANSLATION MISSING
Priority of default configuration files:

include::{autogendir}/autogen_api_config_priority.ja.adoc[tag=config_priority]

C 言語での使用例:

[source,c]
----
int
my_config_reload_cb (const void *pointer, void *data,
                     struct t_config_file *config_file)
{
    /* ... */

    return WEECHAT_RC_OK;
}

struct t_config_file *config_file = weechat_config_new ("test",
                                                        &my_config_reload_cb,
                                                        NULL, NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_new(name: str, callback_reload: str, callback_reload_data: str) -> str: ...

# 例
def my_config_reload_cb(data: str, config_file: str) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

config_file = weechat.config_new("test", "my_config_reload_cb", "")
----

// TRANSLATION MISSING
==== config_set_version

_WeeChat ≥ 4.0.0._

Set configuration file version and a callback to update config sections/options
on-the-fly when the config is read.

プロトタイプ:

[source,c]
----
int config_file_set_version (struct t_config_file *config_file,
                             int version,
                             struct t_hashtable *(*callback_update)(const void *pointer,
                                                                    void *data,
                                                                    struct t_config_file *config_file,
                                                                    int version_read,
                                                                    struct t_hashtable *data_read),
                             const void *callback_update_pointer,
                             void *callback_update_data);
----

引数:

* _config_file_: configuration file pointer
* _version_: version, must be ≥ 2
* _callback_update_: function called when configuration file is read, for each
  section and each option, if the version read is less than the expected version,
  (optional, can be NULL, see below), arguments and return value:
** _const void *pointer_: pointer
** _void *data_: pointer
** _struct t_config_file *config_file_: configuration file pointer
** _int version_read_: version read in configuration file (1 by default)
** _struct t_hashtable *data_read_: hashtable with data read from configuration file
   (see below)
** return value:
*** either "data_read" pointer (hashtable completed), or pointer to a new
    hashtable (created by callback, with keys and values of type "string")
* _callback_update_pointer_: pointer given to callback when it is called by
  WeeChat
* _callback_update_data_: pointer given to callback when it is called by
  WeeChat; if not NULL, it must have been allocated with malloc (or similar
  function) and it is automatically freed when the configuration file is freed

Update callback:

* The callback receives a hashtable with data read from configuration file:

[width="100%",cols="1m,2,8",options="header"]
|===
| Key        | Availability    | Value
| config     | Always set      | Name of configuration file, without extension (eg: `weechat`)
| section    | Always set      | Name of section being read
| option     | For option only | Name of the option
| value      | For option only | Value of the option (if not NULL)
| value_null | For option only | Option as NULL value (value is always `1`)
|===

* The callback can update "section" for a line with a section and "option", "value"
  and "value_null" for a line with an option.
* If "option" is set to empty string by the callback, the line read in
  configuration file is ignored.
* Field "value_null" is set to force a NULL value for the option.

戻り値:

* 1 if OK, 0 if error

C 言語での使用例:

[source,c]
----
struct t_hashtable *
my_config_update_cb (const void *pointer, void *data,
                     struct t_config_file *config_file,
                     int version_read,
                     struct t_hashtable *data_read)
{
    const char *ptr_section, *ptr_option;

    /* return now if version is already up-to-date */
    if (version_read >= 2)
        return NULL;

    ptr_section = hashtable_get (data_read, "section");
    ptr_option = hashtable_get (data_read, "option");

    /* rename section "abc" to "def" */
    if (ptr_section && !ptr_option && (strcmp (ptr_section, "abc") == 0))
    {
        hashtable_set (data_read, "section", "def");
        return data_read;
    }

    /* limit other changes to section "test" */
    if (!ptr_section || !ptr_option || (strcmp (ptr_section, "test") != 0))
        return NULL;

    /* rename option "test1" to "test2" */
    if (strcmp (ptr_option, "test1") == 0)
    {
        hashtable_set (data_read, "option", "test2");
        return data_read;
    }

    /* set value to "xxx" for option "test" */
    if (strcmp (ptr_option, "test") == 0)
    {
        hashtable_set (data_read, "value", "xxx");
        return data_read;
    }

    /* set value to NULL for option "test_null" */
    if (strcmp (ptr_option, "test_null") == 0)
    {
        hashtable_set (data_read, "value_null", "1");
        return data_read;
    }

    /* no changes */
    return NULL;
}

struct t_config_file *config_file = weechat_config_new ("test", NULL, NULL, NULL);
weechat_config_set_version (config_file, 2, &my_config_update_cb, NULL, NULL);
weechat_config_read (config_file);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_set_version(config_file: str, version: int, callback_update: str, callback_update_data: str) -> int: ...

# 例
def my_config_update_cb(data: str, config_file: str, version_read: int, data_read: Dict[str, str]) -> Dict[str, str]:
    # return now if version is already up-to-date
    if version_read >= 2:
        return {}

    section = data_read.get("section")
    option = data_read.get("option")

    # rename section "abc" to "def"
    if section and not option and section == "abc":
        data_read["section"] = "def"
        return data_read

    # limit other changes to section "test"
    if not section or not option or section != "test":
        return {}

    # rename option "test1" to "test2"
    if option == "test1":
        data_read["option"] = "test2"
        return data_read

    # set value to "xxx" for option "test"
    if option == "test":
        data_read["value"] = "xxx"
        return data_read

    # set value to NULL for option "test_null"
    if option == "test_null":
        data_read["value_null"] = "1"
        return data_read

    # no changes
    return {}

config_file = weechat.config_new("test", "", "")
weechat.config_set_version(config_file, 2, "my_config_update_cb", "")
weechat.config_read(config_file)
----

==== config_new_section

_WeeChat バージョン 1.5 で更新。_

設定ファイルに新しいセクションを作成する。

プロトタイプ:

[source,c]
----
struct t_config_section *weechat_config_new_section (
    struct t_config_file *config_file,
    const char *name,
    int user_can_add_options,
    int user_can_delete_options,
    int (*callback_read)(const void *pointer,
                         void *data,
                         struct t_config_file *config_file,
                         struct t_config_section *section,
                         const char *option_name,
                         const char *value),
    const void *callback_read_pointer,
    void *callback_read_data,
    int (*callback_write)(const void *pointer,
                          void *data,
                          struct t_config_file *config_file,
                          const char *section_name),
    const void *callback_write_pointer,
    void *callback_write_data,
    int (*callback_write_default)(const void *pointer,
                                  void *data,
                                  struct t_config_file *config_file,
                                  const char *section_name),
    const void *callback_write_default_pointer,
    void *callback_write_default_data,
    int (*callback_create_option)(const void *pointer,
                                  void *data,
                                  struct t_config_file *config_file,
                                  struct t_config_section *section,
                                  const char *option_name,
                                  const char *value),
    const void *callback_create_option_pointer,
    void *callback_create_option_data,
    int (*callback_delete_option)(const void *pointer,
                                  void *data,
                                  struct t_config_file *config_file,
                                  struct t_config_section *section,
                                  struct t_config_option *option),
    const void *callback_delete_option_pointer,
    void *callback_delete_option_data);
----

引数:

* _config_file_: 設定ファイルへのポインタ
* _name_: セクションの名前
* _user_can_add_options_:
  ユーザがこのセクションに新しいオプションを作成することを許可する場合は 1、禁止する場合は 0
* _user_can_delete_options_:
  ユーザがこのセクションからオプションを削除することを許可する場合は 1、禁止する場合は 0
* _callback_read_: このセクションに含まれるオプションがディスクから読まれた際に呼び出すコールバック関数
  (特別な関数を使ってセクションを読み出す必要がある場合を除いて、殆どの場合は
  NULL を指定する)、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _struct t_config_file *config_file_: 設定ファイルへのポインタ
** _struct t_config_section *section_: セクションへのポインタ
** _const char *option_name_: オプションの名前
** _const char *value_: 値
** 戻り値:
*** _WEECHAT_CONFIG_OPTION_SET_OK_CHANGED_
*** _WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE_
*** _WEECHAT_CONFIG_OPTION_SET_ERROR_
*** _WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND_
* _callback_read_pointer_: WeeChat が _callback_read_
  コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_read_data_: WeeChat が _callback_read_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したセクションが開放された時点で自動的に開放されます
* _callback_write_: セクションをファイルに書き込む際に呼び出すコールバック関数
  (特別な関数を使ってセクションを書き込む必要がある場合を除いて、殆どの場合は
  NULL を指定する)、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _struct t_config_file *config_file_: 設定ファイルへのポインタ
** _const char *section_name_: セクションの名前
** 戻り値:
*** _WEECHAT_CONFIG_WRITE_OK_
*** _WEECHAT_CONFIG_WRITE_ERROR_
*** _WEECHAT_CONFIG_WRITE_MEMORY_ERROR_
* _callback_write_pointer_: WeeChat が _callback_write_
  コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_write_data_: WeeChat が _callback_write_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したセクションが開放された時点で自動的に開放されます
* _callback_write_default_:
  セクションのデフォルト値が必ずファイルに書き込まれる際に呼び出すコールバック関数、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _struct t_config_file *config_file_: 設定ファイルへのポインタ
** _const char *section_name_: セクションの名前
** 戻り値:
*** _WEECHAT_CONFIG_WRITE_OK_
*** _WEECHAT_CONFIG_WRITE_ERROR_
*** _WEECHAT_CONFIG_WRITE_MEMORY_ERROR_
* _callback_write_default_pointer_: WeeChat が _callback_write_default_
  コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_write_default_data_: WeeChat が _callback_write_default_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したセクションが開放された時点で自動的に開放されます
* _callback_create_option_: セクションに新しいオプションを作成する際に呼び出すコールバック関数
  (セクションに新しいオプションを作成することを禁止する場合は
  NULL)、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _struct t_config_file *config_file_: 設定ファイルへのポインタ
** _struct t_config_section *section_: セクションへのポインタ
** _const char *option_name_: オプションの名前
** _const char *value_: 値
** 戻り値:
*** _WEECHAT_CONFIG_OPTION_SET_OK_CHANGED_
*** _WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE_
*** _WEECHAT_CONFIG_OPTION_SET_ERROR_
*** _WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND_
* _callback_create_option_pointer_: WeeChat が _callback_create_option_
  コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_create_option_data_: WeeChat が _callback_create_option_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したセクションが開放された時点で自動的に開放されます
* _callback_delete_option_: セクションからオプションを削除する際に呼び出すコールバック関数
  (セクションからオプションを削除することを禁止する場合は
  NULL)、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _struct t_config_file *config_file_: 設定ファイルへのポインタ
** _struct t_config_section *section_: セクションへのポインタ
** _struct t_config_option *option_: オプションへのポインタ
** 戻り値:
*** _WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET_
*** _WEECHAT_CONFIG_OPTION_UNSET_OK_RESET_
*** _WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED_
*** _WEECHAT_CONFIG_OPTION_UNSET_ERROR_
* _callback_delete_option_pointer_: WeeChat が _callback_delete_option_
  コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_delete_option_data_: WeeChat が _callback_delete_option_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、ポインタはここで作成したセクションが開放された時点で自動的に開放されます

戻り値:

* 設定ファイルの新しいセクションへのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
int
my_section_read_cb (const void *pointer, void *data,
                    struct t_config_file *config_file,
                    struct t_config_section *section,
                    const char *option_name,
                    const char *value)
{
    /* ... */

    return WEECHAT_CONFIG_OPTION_SET_OK_CHANGED;
    /* return WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE; */
    /* return WEECHAT_CONFIG_OPTION_SET_ERROR; */
    /* return WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND; */
}

int
my_section_write_cb (const void *pointer, void *data,
                     struct t_config_file *config_file,
                     const char *section_name)
{
    /* ... */

    return WEECHAT_CONFIG_WRITE_OK;
    /* return WEECHAT_CONFIG_WRITE_ERROR; */
    /* return WEECHAT_CONFIG_WRITE_MEMORY_ERROR; */
}

int
my_section_write_default_cb (const void *pointer, void *data,
                             struct t_config_file *config_file,
                             const char *section_name)
{
    /* ... */

    return WEECHAT_CONFIG_WRITE_OK;
    /* return WEECHAT_CONFIG_WRITE_ERROR; */
    /* return WEECHAT_CONFIG_WRITE_MEMORY_ERROR; */
}

int
my_section_create_option_cb (const void *pointer, void *data,
                             struct t_config_file *config_file,
                             struct t_config_section *section,
                             const char *option_name,
                             const char *value)
{
    /* ... */

    return WEECHAT_CONFIG_OPTION_SET_OK_CHANGED;
    /* return WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE; */
    /* return WEECHAT_CONFIG_OPTION_SET_ERROR; */
    /* return WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND; */
}

int
my_section_delete_option_cb (const void *pointer, void *data,
                             struct t_config_file *config_file,
                             struct t_config_section *section,
                             struct t_config_option *option)
{
    /* ... */

    return WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED;
    /* return WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET; */
    /* return WEECHAT_CONFIG_OPTION_UNSET_OK_RESET; */
    /* return WEECHAT_CONFIG_OPTION_UNSET_ERROR; */
}

/* standard section, user cannot add/delete options */
struct t_config_section *new_section1 =
    weechat_config_new_section (config_file, "section1", 0, 0,
                                NULL, NULL, NULL,
                                NULL, NULL, NULL,
                                NULL, NULL, NULL,
                                NULL, NULL, NULL,
                                NULL, NULL, NULL);

/* special section, user can add/delete options, and options need
   callback to be read/written */
struct t_config_section *new_section2 =
    weechat_config_new_section (config_file, "section2", 1, 1,
                                &my_section_read_cb, NULL, NULL,
                                &my_section_write_cb, NULL, NULL,
                                &my_section_write_default_cb, NULL, NULL,
                                &my_section_create_option_cb, NULL, NULL,
                                &my_section_delete_option_cb, NULL, NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_new_section(config_file: str, name: str,
                       user_can_add_options: int, user_can_delete_options: int,
                       callback_read: str, callback_read_data: str,
                       callback_write: str, callback_write_data: str,
                       callback_write_default: str, callback_write_default_data: str,
                       callback_create_option: str, callback_create_option_data: str,
                       callback_delete_option: str, callback_delete_option_data: str) -> str: ...

# 例
def my_section_read_cb(data: str, config_file: str, section: str, option_name: str, value: Union[str, None]) -> int:
    # ...
    return weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED
    # return weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE
    # return weechat.WEECHAT_CONFIG_OPTION_SET_ERROR
    # return weechat.WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND

def my_section_write_cb(data: str, config_file: str, section_name: str) -> int:
    # ...
    return weechat.WEECHAT_CONFIG_WRITE_OK
    # return weechat.WEECHAT_CONFIG_WRITE_ERROR
    # return weechat.WEECHAT_CONFIG_WRITE_MEMORY_ERROR

def my_section_write_default_cb(data: str, config_file: str, section_name: str) -> int:
    # ...
    return weechat.WEECHAT_CONFIG_WRITE_OK
    # return weechat.WEECHAT_CONFIG_WRITE_ERROR
    # return weechat.WEECHAT_CONFIG_WRITE_MEMORY_ERROR

def my_section_create_option_cb(data: str, config_file: str, section: str, option_name: str, value: Union[str, None]) -> int:
    # ...
    return weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED
    # return weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE
    # return weechat.WEECHAT_CONFIG_OPTION_SET_ERROR
    # return weechat.WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND

def my_section_delete_option_cb(data: str, config_file: str, section: str, option: str) -> int:
    # ...
    return weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED
    # return weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET
    # return weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_RESET
    # return weechat.WEECHAT_CONFIG_OPTION_UNSET_ERROR

section = weechat.config_new_section(config_file, "section1", 1, 1,
    "my_section_read_cb", "",
    "my_section_write_cb", "",
    "my_section_write_default_cb", "",
    "my_section_create_option_cb", "",
    "my_section_delete_option_cb", "")
----

==== config_search_section

設定ファイルからセクションを検索。

プロトタイプ:

[source,c]
----
struct t_config_section *weechat_config_search_section (
    struct t_config_file *config_file,
    const char *section_name);
----

引数:

* _config_file_: 設定ファイルへのポインタ
* _section_name_: 検索するセクションの名前

戻り値:

* セクションが見つかった場合はセクションへのポインタ、見つからなかった場合は NULL

C 言語での使用例:

[source,c]
----
struct t_config_section *section = weechat_config_search_section (config_file,
                                                                  "section");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_search_section(config_file: str, section_name: str) -> str: ...

# 例
section = weechat.config_search_section(config_file, "section")
----

==== config_new_option

// TRANSLATION MISSING
_Updated in 1.5, 4.1.0._

設定ファイルのあるセクションに新しいオプションを作成。

プロトタイプ:

[source,c]
----
struct t_config_option *weechat_config_new_option (
    struct t_config_file *config_file,
    struct t_config_section *section,
    const char *name,
    const char *type,
    const char *description,
    const char *string_values,
    int min,
    int max,
    const char *default_value,
    const char *value,
    int null_value_allowed,
    int (*callback_check_value)(const void *pointer,
                                void *data,
                                struct t_config_option *option,
                                const char *value),
    const void *callback_check_value_pointer,
    void *callback_check_value_data,
    void (*callback_change)(const void *pointer,
                            void *data,
                            struct t_config_option *option),
    const void *callback_change_pointer,
    void *callback_change_data,
    void (*callback_delete)(const void *pointer,
                            void *data,
                            struct t_config_option *option),
    const void *callback_delete_pointer,
    void *callback_delete_data);
----

引数:

* _config_file_: 設定ファイルへのポインタ
* _section_: セクションへのポインタ
* _name_: オプションの名前; WeeChat バージョン 1.4 以上の場合、名前には親オプションの名前を含めることも可能です
  (このオプションが "null" の場合、親オプションの値が `/set`
  コマンドの出力に表示されます)。以下の構文を使ってください:
  "name << file.section.option"
* _type_: オプションの型:
** _boolean_: ブール値 (on/off)
** _integer_: 整数値
** _string_: 文字列
** _color_: 色
// TRANSLATION MISSING
** _enum_: list of string values (stored as integer internally)
* _description_: オプションの説明
// TRANSLATION MISSING
* _string_values_: 文字列で値を受ける
  (`+|+` で区切る) (optional, required for type _enum_)
* _min_: 最小値 (_integer_ 型で有効)
* _max_: 最大値 (_integer_ 型で有効)
* _default_value_: オプションのデフォルト値 (オプションをリセットした際に使われる)
* _value_: オプションの値
* _null_value_allowed_: オプションに _null_ (未定義値)
  を設定することを許可する場合に 1、禁止する場合は 0
* _callback_check_value_: オプションの新しい値をチェックする際に呼び出すコールバック関数
  (任意)、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _struct t_config_option *option_: オプションへのポインタ
** _const char *value_: オプションの新しい値
** 戻り値:
*** 値が有効の場合は 1
*** 値が無効の場合は 0
* _callback_check_value_pointer_: WeeChat が _callback_check_value_
  コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_check_value_data_: WeeChat が _callback_check_value_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したオプションが開放された時点で自動的に開放されます
* _callback_change_: オプションの値を変更した際に呼び出すコールバック関数
  (任意)、引数:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _struct t_config_option *option_: オプションへのポインタ
* _callback_change_pointer_: WeeChat が _callback_change_
  コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_change_data_: WeeChat が _callback_change_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したオプションが開放された時点で自動的に開放されます
* _callback_delete_: オプションを削除する前に際に呼び出すコールバック関数
  (任意)、引数:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _struct t_config_option *option_: オプションへのポインタ
* _callback_delete_pointer_: WeeChat が _callback_delete_
  コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_delete_data_: WeeChat が _callback_delete_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したオプションが開放された時点で自動的に開放されます

戻り値:

* セクションの新しいオプションへのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
/* boolean */
struct t_config_option *option_bool =
    weechat_config_new_option (config_file, section, "option_bool", "boolean",
                               "My option, type boolean",
                               NULL,
                               0, 0,
                               "on",
                               "on",
                               0,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL);

/* integer */
struct t_config_option *option_int =
    weechat_config_new_option (config_file, section, "option_int", "integer",
                               "My option, type integer",
                               NULL,
                               0, 100,
                               "15",
                               "15",
                               0,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL);

/* string */
struct t_config_option *option_str =
    weechat_config_new_option (config_file, section, "option_str", "string",
                               "My option, type string",
                               NULL,
                               0, 0,
                               "test",
                               "test",
                               1,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL);

/* color */
struct t_config_option *option_col =
    weechat_config_new_option (config_file, section, "option_col", "color",
                               "My option, type color",
                               NULL,
                               0, 0,
                               "lightblue",
                               "lightblue",
                               0,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL);

/* enum */
struct t_config_option *option_enum =
    weechat_config_new_option (config_file, section, "option_enum", "enum",
                               "My option, type enum",
                               "top|bottom|left|right",
                               0, 0,
                               "bottom",
                               "bottom",
                               0,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL,
                               NULL, NULL, NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_new_option(config_file: str, section: str, name: str, type: str, description: str,
                      string_values: str, min: int, max: int,
                      default_value: Union[str, None], value: Union[str, None], null_value_allowed: int,
                      callback_check_value: str, callback_check_value_data: str,
                      callback_change: str, callback_change_data: str,
                      callback_delete: str, callback_delete_data: str) -> str: ...

# 例
def option_str_check_value_cb(data: str, option: str, value: str) -> int:
    # ...
    return 1
    # return 0

def option_str_change_cb(data: str, option: str) -> None:
    # ...

def option_str_delete_cb(data: str, option: str) -> None:
    # ...

option_bool = weechat.config_new_option(config_file, section, "option_bool", "boolean",
    "My option, type boolean",
    "", 0, 0, "on", "on", 0,
    "", "",
    "", "",
    "", "")

option_int = weechat.config_new_option(config_file, section, "option_int", "integer",
    "My option, type integer",
    "", 0, 100, "15", "15", 0,
    "", "",
    "", "",
    "", "")

option_str = weechat.config_new_option(config_file, section, "option_str", "string",
    "My option, type string",
    "", 0, 0, "test", "test", 1,
    "option_str_check_value_cb", "",
    "option_str_change_cb", "",
    "option_str_delete_cb", "")

option_col = weechat.config_new_option(config_file, section, "option_col", "color",
    "My option, type color",
    "", 0, 0, "lightblue", "lightblue", 0,
    "", "",
    "", "",
    "", "")

option_enum = weechat.config_new_option(config_file, section, "option_enum", "enum",
    "My option, type enum",
    "top|bottom|left|right",
    0, 0, "bottom", "bottom", 0,
    "", "",
    "", "",
    "", "")
----

[NOTE]
Ruby では、3 組のコールバックとデータ (6 つの文字列変数) を渡す際に必ず 6 つの文字列変数の配列を
1 つ渡してください (これは Ruby が関数に 15 個以上の引数を渡せないことが原因です)、より詳しい内容は
link:++weechat_scripting.ja.html#_ruby++[WeeChat スクリプト作成ガイド ^↗^^]を参照してください
_(WeeChat バージョン 0.4.1 で修正済み)_。

==== config_search_option

設定ファイルのセクションからオプションを検索。

プロトタイプ:

[source,c]
----
struct t_config_option *weechat_config_search_option (
    struct t_config_file *config_file,
    struct t_config_section *section,
    const char *option_name);
----

引数:

* _config_file_: 設定ファイルへのポインタ
* _section_: セクションへのポインタ
* _name_: 検索するオプションの名前

戻り値:

* オプションが見つかった場合はオプションへのポインタ、見つからなかった場合は NULL

C 言語での使用例:

[source,c]
----
struct t_config_option *option =
    weechat_config_search_option (config_file, section, "option");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_search_option(config_file: str, section: str, option_name: str) -> str: ...

# 例
option = weechat.config_search_option(config_file, section, "option")
----

==== config_search_section_option

設定ファイルまたはセクションからセクションやオプションを検索。

プロトタイプ:

[source,c]
----
void weechat_config_search_section_option (struct t_config_file *config_file,
                                           struct t_config_section *section,
                                           const char *option_name,
                                           struct t_config_section **section_found,
                                           struct t_config_option **option_found);
----

引数:

* _config_file_: 設定ファイルへのポインタ
* _section_: セクションへのポインタ
* _option_name_: オプション名
* _section_found_:
  セクションへのポインタへのポインタ、これは見つかったオプションのセクションになります
* _option_found_:
  オプションへのポインタへのポインタ、これは見つかったオプションのへのポインタになります

C 言語での使用例:

[source,c]
----
struct t_config_section *ptr_section;
struct t_config_option *ptr_option;

weechat_config_search_section_option(config_file,
                                     section,
                                     "option",
                                     &ptr_section,
                                     &ptr_option);
if (ptr_option)
{
    /* option found */
}
else
{
    /* option not found */
}
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== config_search_with_string

ファイル/セクション/オプションの情報をオプションを完全な名前で検索。

プロトタイプ:

[source,c]
----
void weechat_config_search_with_string (const char *option_name,
                                        struct t_config_file **config_file,
                                        struct t_config_section **section,
                                        struct t_config_option **option,
                                        char **pos_option_name);
----

引数:

* _option_name_: オプションの完全な名前 (書式: "file.section.option")
* _config_file_:
  設定ファイルへのポインタへのポインタ、これは見つかったオプションの設定ファイルへのポインタになります
* _section_:
  セクションへのポインタのポインタ、これは見つかったオプションのセクションになります
* _option_:
  オプションへのポインタのポインタ、これは見つかったオプションへのポインタになります
* _pos_option_name_:
  文字列へのポインタへのポインタ、これはオプション名へのポインタになります

C 言語での使用例:

[source,c]
----
struct t_config_file *ptr_config_file;
struct t_config_section *ptr_section;
struct t_config_option *ptr_option;
char *option_name;

weechat_config_search_with_string ("file.section.option",
                                   &ptr_config_file,
                                   &ptr_section,
                                   &ptr_option,
                                   &option_name);
if (ptr_option)
{
    /* option found */
}
else
{
    /* option not found */
}
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== config_string_to_boolean

テキストがブール値としての "true" または "false" かをチェック。

プロトタイプ:

[source,c]
----
int weechat_config_string_to_boolean (const char *text);
----

引数:

* _text_: チェックするテキスト

戻り値:

* テキストが "true" ("on"、"yes"、"y"、"true"、"t"、"1") の場合は 1
* テキストが "false" ("off"、"no"、"n"、"false"、"f"、"0") の場合は 0

C 言語での使用例:

[source,c]
----
if (weechat_config_string_to_boolean (option_value))
{
    /* value is "true" */
}
else
{
    /* value is "false" */
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_string_to_boolean(text: str) -> int: ...

# 例
if weechat.config_string_to_boolean(text):
    # ...
----

==== config_option_reset

オプションをデフォルト値にリセット。

プロトタイプ:

[source,c]
----
int weechat_config_option_reset (struct t_config_option *option,
                                 int run_callback);
----

引数:

* _option_: オプションへのポインタ
* _run_callback_: オプションを変更する際に、コールバックを呼び出す場合は
  1、呼び出さない場合は 0

戻り値:

* オプションの値がリセットされた場合は _WEECHAT_CONFIG_OPTION_SET_OK_CHANGED_
* 値が変更されなかった場合は _WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE_
* エラーが起きた場合は _WEECHAT_CONFIG_OPTION_SET_ERROR_

C 言語での使用例:

[source,c]
----
switch (weechat_config_option_reset (option, 1))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* .... */
        break;
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_option_reset(option: str, run_callback: int) -> int: ...

# 例
rc = weechat.config_option_reset(option, 1)
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----

==== config_option_set

オプションに新しい値を設定。

プロトタイプ:

[source,c]
----
int weechat_config_option_set (struct t_config_option *option,
                               const char *value, int run_callback);
----

引数:

* _option_: オプションへのポインタ
* _value_:
  オプションの新しい値、オプションのタイプによって以下の特殊値を取ることも可能です:
** _ブール型_:
*** `toggle`: 現在の値を切り替える
// TRANSLATION MISSING
** _integer_, _color_ or _enum_:
*** `++N`: 現在の値に `N` (任意の整数) を加える
*** `--N`: 現在の値から `N` (任意の整数) を引く
* _run_callback_: オプションが変更された際に、_callback_change_ コールバックを呼び出す場合は
  1、呼び出さない場合は 0

戻り値:

* オプションの値が変更された場合は _WEECHAT_CONFIG_OPTION_SET_OK_CHANGED_
* 値が変更されなかった場合は _WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE_
* エラーが起きた場合は _WEECHAT_CONFIG_OPTION_SET_ERROR_

C 言語での使用例:

[source,c]
----
switch (weechat_config_option_set (option, "new_value", 1))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* .... */
        break;
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_option_set(option: str, value: str, run_callback: int) -> int: ...

# 例
rc = weechat.config_option_set(option, "new_value", 1)
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----

==== config_option_set_null

あるオプションに null (未定義値) を設定する。

プロトタイプ:

[source,c]
----
int weechat_config_option_set_null (struct t_config_option *option,
                                    int run_callback);
----

引数:

* _option_: オプションへのポインタ
* _run_callback_: オプションが (null 以外の値に) 変更された際に、_callback_change_
  コールバックを呼び出す場合は 1、呼び出さない場合は 0

[NOTE]
オプションに null を設定することが許可されている場合にのみ null を設定できます
(<<_config_new_option,config_new_option>> を参照)。

戻り値:

* オプション値が変更された場合は _WEECHAT_CONFIG_OPTION_SET_OK_CHANGED_
* 値が変更されなかった場合は _WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE_
* エラーが起きた場合は _WEECHAT_CONFIG_OPTION_SET_ERROR_

C 言語での使用例:

[source,c]
----
switch (weechat_config_option_set_null (option, 1))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* .... */
        break;
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_option_set_null(option: str, run_callback: int) -> int: ...

# 例
rc = weechat.config_option_set_null(option, 1)
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----

==== config_option_unset

オプションをアンセット/リセットする。

プロトタイプ:

[source,c]
----
int weechat_config_option_unset (struct t_config_option *option);
----

引数:

* _option_: オプションへのポインタ

戻り値:

* オプションの値がリセットされなかった場合は _WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET_
* オプションの値がリセットされた場合は _WEECHAT_CONFIG_OPTION_UNSET_OK_RESET_
* オプションが削除された場合は _WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED_
* エラーが起きた場合は _WEECHAT_CONFIG_OPTION_UNSET_ERROR_

C 言語での使用例:

[source,c]
----
switch (weechat_config_option_unset (option))
{
    case WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_ERROR:
        /* .... */
        break;
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_option_unset(option: str) -> int: ...

# 例
rc = weechat.config_option_unset(option)
if rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_ERROR:
    # ...
----

==== config_option_rename

オプションをリネーム。

プロトタイプ:

[source,c]
----
void weechat_config_option_rename (struct t_config_option *option,
                                   const char *new_name);
----

引数:

* _option_: オプションへのポインタ
* _new_name_: オプションの新しい名前

C 言語での使用例:

[source,c]
----
weechat_config_option_rename (option, "new_name");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_option_rename(option: str, new_name: str) -> int: ...

# 例
weechat.config_option_rename(option, "new_name")
----

==== config_option_get_string

_WeeChat バージョン 1.9 以上で利用可。_

オプションプロパティの文字列値を返す。

プロトタイプ:

[source,c]
----
const char *weechat_config_option_get_string (struct t_config_option *option,
                                              const char *property);
----

引数:

* _option_: オプションへのポインタ
* _property_: プロパティ名:
** _config_name_: ファイル名
** _section_name_: セクション名
** _name_: オプション名
** _parent_name_: 親オプション名
** _type_: オプション型、以下のリストのどれか 1 つ:
*** _boolean_
*** _integer_
*** _string_
*** _color_
*** _enum_
** _description_: オプションの説明

戻り値:

* プロパティの文字列値

C 言語での使用例:

[source,c]
----
const char *type = weechat_config_option_get_string (option, "type");
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== config_option_get_pointer

あるオプションのプロパティへのポインタを返す。

プロトタイプ:

[source,c]
----
void *weechat_config_option_get_pointer (struct t_config_option *option,
                                         const char *property);
----

引数:

* _option_: オプションへのポインタ
* _property_: プロパティ名:
** _config_file_: 設定ファイルへのポインタ (_struct t_config_file *_)
** _section_: セクションへのポインタ (_struct t_config_section *_)
** _name_: オプション名 (_char *_)
** _parent_name_: 親オプションの名前 (_char *_) _(WeeChat バージョン 1.4 以上で利用可)_
** _type_: オプションの型 (_int *_)
** _description_: オプションの説明 (_char *_)
** _string_values_: 文字列値 (_char *_)
** _min_: 最大値 (_int *_)
** _max_: 最小値 (_int *_)
** _default_value_: デフォルト値 (オプションの型に依存)
** _value_: 現在の値 (オプションの型に依存)
** _prev_option_: 1 つ前のオプションへのポインタ (_struct t_config_option *_)
** _next_option_: 1 つ後のオプションへのポインタ (_struct t_config_option *_)

戻り値:

* 要求されたプロパティへのポインタ

C 言語での使用例:

[source,c]
----
char *description = weechat_config_option_get_pointer (option, "description");
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== config_option_is_null

オプションの値が "null" (未定義値) か否かを確認。

プロトタイプ:

[source,c]
----
int weechat_config_option_is_null (struct t_config_option *option);
----

引数:

* _option_: オプションへのポインタ

戻り値:

* オプションの値が "null" の場合は 1
* オプションの値が "null" でない場合は 0

C 言語での使用例:

[source,c]
----
if (weechat_config_option_is_null (option))
{
    /* value is "null" */
}
else
{
    /* value is not "null" */
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_option_is_null(option: str) -> int: ...

# 例
if weechat.config_option_is_null(option):
    # ...
----

==== config_option_default_is_null

あるオプションのデフォルト値が "null" (未定義値) か否かを確認。

プロトタイプ:

[source,c]
----
int weechat_config_option_default_is_null (struct t_config_option *option);
----

引数:

* _option_: オプションへのポインタ

戻り値:

* オプションの値が "null" の場合は 1
* オプションの値が "null" でない場合は 0

C 言語での使用例:

[source,c]
----
if (weechat_config_option_default_is_null (option))
{
    /* default value is "null" */
}
else
{
    /* default value is not "null" */
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_option_default_is_null(option: str) -> int: ...

# 例
if weechat.config_option_default_is_null(option):
    # ...
----

==== config_boolean

オプションのブール値を返す。

プロトタイプ:

[source,c]
----
int weechat_config_boolean (struct t_config_option *option);
----

引数:

* _option_: オプションへのポインタ

戻り値、オプションの型に依存:

* _boolean_: オプションのブール値 (0 または 1)
* _integer_: 0
* _string_: 0
* _color_: 0
* _enum_: 0

C 言語での使用例:

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
if (weechat_config_boolean (option))
{
    /* value is "true" */
}
else
{
    /* value is "false" */
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_boolean(option: str) -> int: ...

# 例
option = weechat.config_get("plugin.section.option")
if weechat.config_boolean(option):
    # ...
----

==== config_boolean_default

オプションのデフォルトブール値を返す。

プロトタイプ:

[source,c]
----
int weechat_config_boolean_default (struct t_config_option *option);
----

引数:

* _option_: オプションへのポインタ

戻り値、オプションの型に依存:

* _boolean_: オプションのデフォルトブール値 (0 または 1)
* _integer_: 0
* _string_: 0
* _color_: 0
* _enum_: 0

C 言語での使用例:

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
if (weechat_config_boolean_default (option))
{
    /* value is "true" */
}
else
{
    /* value is "false" */
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_boolean_default(option: str) -> int: ...

# 例
option = weechat.config_get("plugin.section.option")
if weechat.config_boolean_default(option):
    # ...
----

// TRANSLATION MISSING
==== config_boolean_inherited

_WeeChat ≥ 4.3.0._

Return inherited boolean value of option: value of option if not NULL,
or value of the parent option (if option inherits from another option). +
If the parent option is not found, return the default value of the option. +
If the parent value is NULL, return the default value of the parent option.

プロトタイプ:

[source,c]
----
int weechat_config_boolean_inherited (struct t_config_option *option);
----

引数:

* _option_: オプションへのポインタ

Return value: see functions <<_config_boolean,config_boolean>> and
<<_config_boolean_default,config_boolean_default>>.

C 言語での使用例:

[source,c]
----
struct t_config_option *option = weechat_config_get ("irc.server.libera.autoconnect");
int autoconnect = weechat_config_boolean_inherited (option);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_boolean_inherited(option: str) -> int: ...

# 例
option = weechat.config_get("irc.server.libera.autoconnect")
autoconnect = weechat.config_boolean_inherited(option)
----

==== config_integer

オプションの整数値を返す。

プロトタイプ:

[source,c]
----
int weechat_config_integer (struct t_config_option *option);
----

引数:

* _option_: オプションへのポインタ

戻り値、オプションの型に依存:

* _boolean_: オプションのブール値 (0 または 1)
* _integer_: オプションの整数値
* _string_: 0
* _color_: 色インデックス
// TRANSLATION MISSING
* _enum_: integer value of option (index of enum value)

C 言語での使用例:

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
int value = weechat_config_integer (option);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_integer(option: str) -> int: ...

# 例
option = weechat.config_get("plugin.section.option")
value = weechat.config_integer(option)
----

==== config_integer_default

オプションのデフォルト整数値を返す。

プロトタイプ:

[source,c]
----
int weechat_config_integer_default (struct t_config_option *option);
----

引数:

* _option_: オプションへのポインタ

戻り値、オプションの型に依存:

* _boolean_: オプションのデフォルトブール値 (0 または 1)
* _integer_: オプションのデフォルト整数値
* _string_: 0
* _color_: デフォルト色インデックス
// TRANSLATION MISSING
* _enum_: default integer value of option (index of enum value)

C 言語での使用例:

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
int value = weechat_config_integer_default (option);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_integer_default(option: str) -> int: ...

# 例
option = weechat.config_get("plugin.section.option")
value = weechat.config_integer_default(option)
----

// TRANSLATION MISSING
==== config_integer_inherited

_WeeChat ≥ 4.3.0._

Return inherited integer value of option: value of option if not NULL,
or value of the parent option (if option inherits from another option). +
If the parent option is not found, return the default value of the option. +
If the parent value is NULL, return the default value of the parent option.

プロトタイプ:

[source,c]
----
int weechat_config_integer_inherited (struct t_config_option *option);
----

引数:

* _option_: オプションへのポインタ

Return value: see functions <<_config_integer,config_integer>> and
<<_config_integer_default,config_integer_default>>.

C 言語での使用例:

[source,c]
----
struct t_config_option *option = weechat_config_get ("irc.server.libera.autojoin_delay");
int delay = weechat_config_integer_inherited (option);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_integer_inherited(option: str) -> int: ...

# 例
option = weechat.config_get("irc.server.libera.autojoin_delay")
delay = weechat.config_integer_inherited(option)
----

==== config_string

オプションの文字列値を返す。

プロトタイプ:

[source,c]
----
const char *weechat_config_string (struct t_config_option *option);
----

引数:

* _option_: オプションへのポインタ

戻り値、オプションの型に依存:

* _boolean_: 値が真の場合は "on"、それ以外の場合は "off"
* _integer_: NULL
* _string_: オプションの文字列値
* _color_: 色名
// TRANSLATION MISSING
* _enum_: string value of option

C 言語での使用例:

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
const char *value = weechat_config_string (option);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_string(option: str) -> str: ...

# 例
option = weechat.config_get("plugin.section.option")
value = weechat.config_string(option)
----

==== config_string_default

オプションのデフォルト文字列値を返す。

プロトタイプ:

[source,c]
----
const char *weechat_config_string_default (struct t_config_option *option);
----

引数:

* _option_: オプションへのポインタ

戻り値、オプションの型に依存:

* _boolean_: デフォルト値が真の場合は "on"、それ以外の場合は "off"
* _integer_: NULL
* _string_: オプションのデフォルト文字列値
* _color_: デフォルト色名
// TRANSLATION MISSING
* _enum_: default string value of option

C 言語での使用例:

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
const char *value = weechat_config_string_default (option);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_string_default(option: str) -> str: ...

# 例
option = weechat.config_get("plugin.section.option")
value = weechat.config_string_default(option)
----

// TRANSLATION MISSING
==== config_string_inherited

_WeeChat ≥ 4.3.0._

Return inherited string value of option: value of option if not NULL,
or value of the parent option (if option inherits from another option). +
If the parent option is not found, return the default value of the option. +
If the parent value is NULL, return the default value of the parent option.

プロトタイプ:

[source,c]
----
const char *weechat_config_string_inherited (struct t_config_option *option);
----

引数:

* _option_: オプションへのポインタ

Return value: see functions <<_config_string,config_string>> and
<<_config_string_default,config_string_default>>.

C 言語での使用例:

[source,c]
----
struct t_config_option *option = weechat_config_get ("irc.server.libera.msg_quit");
const char *msg_quit = weechat_config_string_inherited (option);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_string_inherited(option: str) -> str: ...

# 例
option = weechat.config_get("irc.server.libera.msg_quit")
msg_quit = weechat.config_string_inherited(option)
----

==== config_color

オプションの色値を返す。

プロトタイプ:

[source,c]
----
const char *weechat_config_color (struct t_config_option *option);
----

引数:

* _option_: オプションへのポインタ

戻り値、オプションの型に依存:

* _boolean_: NULL
* _integer_: NULL
* _string_: NULL
* _color_: 色名
* _enum_: NULL

C 言語での使用例:

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
const char *color = weechat_config_color (option);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_color(option: str) -> str: ...

# 例
option = weechat.config_get("plugin.section.option")
color = weechat.config_color(option)
----

==== config_color_default

オプションのデフォルト色値を返す。

プロトタイプ:

[source,c]
----
const char *weechat_config_color_default (struct t_config_option *option);
----

引数:

* _option_: オプションへのポインタ

戻り値、オプションの型に依存:

* _boolean_: NULL
* _integer_: NULL
* _string_: NULL
* _color_: デフォルト色名
* _enum_: NULL

C 言語での使用例:

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
const char *color = weechat_config_color_default (option);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_color_default(option: str) -> str: ...

# 例
option = weechat.config_get("plugin.section.option")
color = weechat.config_color_default(option)
----

// TRANSLATION MISSING
==== config_color_inherited

_WeeChat ≥ 4.3.0._

Return inherited color value of option: value of option if not NULL,
or value of the parent option (if option inherits from another option). +
If the parent option is not found, return the default value of the option. +
If the parent value is NULL, return the default value of the parent option.

プロトタイプ:

[source,c]
----
const char *weechat_config_color_inherited (struct t_config_option *option);
----

引数:

* _option_: オプションへのポインタ

Return value: see functions <<_config_color,config_color>> and
<<_config_color_default,config_color_default>>.

C 言語での使用例:

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
const char *color = weechat_config_color_inherited (option);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_color_inherited(option: str) -> str: ...

# 例
option = weechat.config_get("plugin.section.option")
color = weechat.config_color_inherited(option)
----

// TRANSLATION MISSING
==== config_enum

_WeeChat ≥ 4.1.0._

Return enum value of option, as integer.

Prototype:

[source,c]
----
int weechat_config_enum (struct t_config_option *option);
----

Arguments:

* _option_: option pointer

Return value, depending on the option type:

* _boolean_: boolean value of option (0 or 1)
* _integer_: integer value of option
* _string_: 0
* _color_: color index
* _enum_: integer value of option (index of enum value)

C example:

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
int value = weechat_config_enum (option);
----

Script (Python):

[source,python]
----
# prototype
def config_enum(option: str) -> int: ...

# example
option = weechat.config_get("plugin.section.option")
value = weechat.config_enum(option)
----

// TRANSLATION MISSING
==== config_enum_default

_WeeChat ≥ 4.1.0._

Return default enum value of option, as integer.

Prototype:

[source,c]
----
int weechat_config_enum_default (struct t_config_option *option);
----

Arguments:

* _option_: option pointer

Return value, depending on the option type:

* _boolean_: default boolean value of option (0 or 1)
* _integer_: default integer value of option
* _string_: 0
* _color_: default color index
* _enum_: integer value of option (index of enum value)

C example:

[source,c]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
int value = weechat_config_enum_default (option);
----

Script (Python):

[source,python]
----
# prototype
def config_enum_default(option: str) -> int: ...

# example
option = weechat.config_get("plugin.section.option")
value = weechat.config_enum_default(option)
----

// TRANSLATION MISSING
==== config_enum_inherited

_WeeChat ≥ 4.3.0._

Return inherited enum value of option: value of option if not NULL,
or value of the parent option (if option inherits from another option). +
If the parent option is not found, return the default value of the option. +
If the parent value is NULL, return the default value of the parent option.

プロトタイプ:

[source,c]
----
int weechat_config_enum_inherited (struct t_config_option *option);
----

引数:

* _option_: オプションへのポインタ

Return value: see functions <<_config_enum,config_enum>> and
<<_config_enum_default,config_enum_default>>.

C 言語での使用例:

[source,c]
----
struct t_config_option *option = weechat_config_get ("irc.server.libera.sasl_fail");
int sasl_fail = weechat_config_enum_inherited (option);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_enum_inherited(option: str) -> int: ...

# 例
option = weechat.config_get("irc.server.libera.sasl_fail")
sasl_fail = weechat.config_enum_inherited(option)
----

==== config_write_option

設定ファイルにオプションとその値を収めた行を書き込む (この関数をセクションの
"write" および "write_default" コールバック以外で使わないでください)。

プロトタイプ:

[source,c]
----
void weechat_config_write_option (struct t_config_file *config_file,
                                  struct t_config_option *option);
----

引数:

* _config_file_: 設定ファイルへのポインタ
* _option_: オプションへのポインタ

C 言語での使用例:

[source,c]
----
int
my_section_write_cb (const void *pointer, void *data,
                     struct t_config_file *config_file,
                     const char *section_name)
{
    weechat_config_write_line (config_file, "my_section", NULL);

    weechat_config_write_option (config_file, option);

    return WEECHAT_RC_OK;
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_write_option(config_file: str, option: str) -> int: ...

# 例
def my_section_write_cb(data: str, config_file: str, section_name: str) -> int:
    weechat.config_write_line(config_file, "my_section", "")
    weechat.config_write_option(config_file, option)
    return weechat.WEECHAT_RC_OK
----

==== config_write_line

設定ファイルに行を書き込む (この関数をセクションの
"write" および "write_default" コールバック以外で使わないでください)

プロトタイプ:

[source,c]
----
void weechat_config_write_line (struct t_config_file *config_file,
                                const char *option_name,
                                const char *value, ...);
----

引数:

* _config_file_: 設定ファイルへのポインタ
* _option_name_: オプション名
* _value_: 値 (NULL の場合、セクション名の行を書き込みます。例:
  "[section]")

C 言語での使用例:

[source,c]
----
int
my_section_write_cb (const void *pointer, void *data,
                     struct t_config_file *config_file,
                     const char *section_name)
{
    weechat_config_write_line (config_file, "my_section", NULL);

    weechat_config_write_line (config_file, "option", "%s;%d",
                               "value", 123);

    return WEECHAT_RC_OK;
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_write_line(config_file: str, option_name: str, value: str) -> int: ...

# 例
def my_section_write_cb(data: str, config_file: str, section_name: str) -> int:
    weechat.config_write_line(config_file, "my_section", "")
    weechat.config_write_line(config_file, "option", "value")
    return weechat.WEECHAT_RC_OK
----

==== config_write

設定ファイルをディスクに書き込む。

プロトタイプ:

[source,c]
----
int weechat_config_write (struct t_config_file *config_file);
----

引数:

* _config_file_: 設定ファイルへのポインタ

戻り値:

* 設定を書き込んだ場合は _WEECHAT_CONFIG_WRITE_OK_
* メモリ不足の場合は _WEECHAT_CONFIG_WRITE_MEMORY_ERROR_
* その他のエラーが起きた場合は _WEECHAT_CONFIG_WRITE_ERROR_

C 言語での使用例:

[source,c]
----
switch (weechat_config_write (config_file))
{
    case WEECHAT_CONFIG_WRITE_OK:
        /* ... */
        break;
    case WEECHAT_CONFIG_WRITE_MEMORY_ERROR:
        /* ... */
        break;
    case WEECHAT_CONFIG_WRITE_ERROR:
        /* ... */
        break;
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_write(config_file: str) -> int: ...

# 例
rc = weechat.config_write(config_file)
if rc == weechat.WEECHAT_CONFIG_WRITE_OK:
    # ...
elif rc == weechat.WEECHAT_CONFIG_WRITE_MEMORY_ERROR:
    # ...
elif rc == weechat.WEECHAT_CONFIG_WRITE_ERROR:
    # ...
----

==== config_read

設定ファイルをディスクから読み込む。

プロトタイプ:

[source,c]
----
int weechat_config_read (struct t_config_file *config_file);
----

引数:

* _config_file_: 設定ファイルへのポインタ

戻り値:

* 設定ファイルを読み込んだ場合は _WEECHAT_CONFIG_READ_OK_
* メモリ不足の場合は _WEECHAT_CONFIG_READ_MEMORY_ERROR_
* ファイルが見つからない場合は _WEECHAT_CONFIG_READ_FILE_NOT_FOUND_

C 言語での使用例:

[source,c]
----
switch (weechat_config_read (config_file))
{
    case WEECHAT_CONFIG_READ_OK:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_MEMORY_ERROR:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
        /* ... */
        break;
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_read(config_file: str) -> int: ...

# 例
rc = weechat.config_read(config_file)
if rc == weechat.WEECHAT_CONFIG_READ_OK:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_MEMORY_ERROR:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
    # ...
----

==== config_reload

設定ファイルをディスクからリロードする。

プロトタイプ:

[source,c]
----
int weechat_config_reload (struct t_config_file *config_file);
----

引数:

* _config_file_: 設定ファイルへのポインタ

戻り値:

* 設定をリロードした場合は _WEECHAT_CONFIG_READ_OK_
* メモリ不足の合は _WEECHAT_CONFIG_READ_MEMORY_ERROR_
* ファイルが見つからない場合は _WEECHAT_CONFIG_READ_FILE_NOT_FOUND_

C 言語での使用例:

[source,c]
----
switch (weechat_config_reload (config_file))
{
    case WEECHAT_CONFIG_READ_OK:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_MEMORY_ERROR:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
        /* ... */
        break;
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_reload(config_file: str) -> int: ...

# 例
rc = weechat.config_reload(config_file)
if rc == weechat.WEECHAT_CONFIG_READ_OK:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_MEMORY_ERROR:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
    # ...
----

==== config_option_free

オプションを開放。

プロトタイプ:

[source,c]
----
void weechat_config_option_free (struct t_config_option *option);
----

引数:

* _option_: オプションへのポインタ

C 言語での使用例:

[source,c]
----
weechat_config_option_free (option);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_option_free(option: str) -> int: ...

# 例
weechat.config_option_free(option)
----

==== config_section_free_options

セクションの全てのオプションを開放。

プロトタイプ:

[source,c]
----
void weechat_config_section_free_options (struct t_config_section *section);
----

引数:

* _section_: セクションへのポインタ

C 言語での使用例:

[source,c]
----
weechat_config_section_free_options (section);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_section_free_options(section: str) -> int: ...

# 例
weechat.config_section_free_options(section)
----

==== config_section_free

セクションを開放。

プロトタイプ:

[source,c]
----
void weechat_config_section_free (struct t_config_section *section);
----

引数:

* _section_: セクションへのポインタ

C 言語での使用例:

[source,c]
----
weechat_config_section_free (section);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_section_free(section: str) -> int: ...

# 例
weechat.config_section_free(section)
----

==== config_free

設定ファイルを開放。

プロトタイプ:

[source,c]
----
void weechat_config_free (struct t_config_file *config_file);
----

引数:

* _config_file_: 設定ファイルへのポインタ

C 言語での使用例:

[source,c]
----
weechat_config_free (config_file);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_free(config_file: str) -> int: ...

# 例
weechat.config_free(config_file)
----

==== config_get

完全な名前でオプションを検索。

プロトタイプ:

[source,c]
----
struct t_config_option *weechat_config_get (const char *option_name);
----

引数:

* _option_name_: オプションの完全な名前 (書式: "file.section.option")

戻り値:

* 見つかったオプションへのポインタ、見つからなかった場合は NULL

C 言語での使用例:

[source,c]
----
struct t_config_option *option = weechat_config_get ("weechat.look.item_time_format");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_get(option_name: str) -> str: ...

# 例
option = weechat.config_get("weechat.look.item_time_format")
----

==== config_get_plugin

プラグインの設定ファイル (plugins.conf) からオプションを検索。

プロトタイプ:

[source,c]
----
const char *weechat_config_get_plugin (const char *option_name);
----

引数:

* _option_name_: オプション名、プレフィックス "plugins.var.xxx."
  が自動的に付けられる (ここで "xxx" は現在のプラグイン名)。

戻り値:

* 見つかったオプションの値、オプションが見つからなければ NULL

C 言語での使用例:

[source,c]
----
/* if current plugin is "test", then look for value of option
   "plugins.var.test.option" in file plugins.conf */
char *value = weechat_config_get_plugin ("option");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_get_plugin(option_name: str) -> str: ...

# 例
value = weechat.config_get_plugin("option")
----

==== config_is_set_plugin

オプションがプラグインの設定ファイル (plugins.conf) で設定されているか否かを確認。

プロトタイプ:

[source,c]
----
int weechat_config_is_set_plugin (const char *option_name);
----

引数:

* _option_name_: オプション名、プレフィックス "plugins.var.xxx."
  が自動的に付けられる (ここで "xxx" は現在のプラグイン名)。

戻り値:

* オプションが設定されている場合は 1、オプションが存在しない場合は 0

C 言語での使用例:

[source,c]
----
if (weechat_config_is_set_plugin ("option"))
{
    /* option is set */
}
else
{
    /* option does not exist */
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_is_set_plugin(option_name: str) -> int: ...

# 例
if weechat.config_is_set_plugin("option"):
    # option is set
    # ...
else:
    # option does not exist
    # ...
----

==== config_set_plugin

プラグイン設定ファイル (plugins.conf) のオプションの新しい値を設定。

プロトタイプ:

[source,c]
----
int weechat_config_set_plugin (const char *option_name, const char *value);
----

引数:

* _option_name_: オプション名、プレフィックス "plugins.var.xxx."
  が自動的に付けられる (ここで "xxx" は現在のプラグイン名)。
* _value_: オプションの新しい値

戻り値:

* オプションの値を変更した場合は _WEECHAT_CONFIG_OPTION_SET_OK_CHANGED_
* 値を変更しなかった場合は _WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE_
* オプションが見つからない場合は _WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND_
* その他のエラーが起きた場合は _WEECHAT_CONFIG_OPTION_SET_ERROR_

C 言語での使用例:

[source,c]
----
switch (weechat_config_set_plugin ("option", "test_value"))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* ... */
        break;
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_set_plugin(option_name: str, value: str) -> int: ...

# 例
rc = weechat.config_set_plugin("option", "test_value")
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----

==== config_set_desc_plugin

_WeeChat バージョン 0.3.5 以上で利用可。_

プラグイン設定ファイル (plugins.conf) のオプションに関する説明を設定。

プロトタイプ:

[source,c]
----
void weechat_config_set_desc_plugin (const char *option_name,
                                     const char *description);
----

引数:

* _option_name_: オプション名、プレフィックス "plugins.var.xxx."
  が自動的に付けられる (ここで "xxx" は現在のプラグイン名)。
* _description_: オプションの説明

[NOTE]
オプション (plugins.var.xxx.option_name)
が存在しなくても問題ありません。この説明を持つような名前のオプションが作成されます。

C 言語での使用例:

[source,c]
----
weechat_config_set_desc_plugin ("option", "description of option");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_set_desc_plugin(option_name: str, description: str) -> int: ...

# 例
version = weechat.info_get("version_number", "") or 0
if int(version) >= 0x00030500:
    weechat.config_set_desc_plugin("option", "description of option")
----

==== config_unset_plugin

プラグイン設定ファイル (plugins.conf) のオプションをアンセットする。

プロトタイプ:

[source,c]
----
int weechat_config_unset_plugin (const char *option_name);
----

引数:

* _option_name_: オプション名、プレフィックス "plugins.var.xxx."
  が自動的に付けられる (ここで "xxx" は現在のプラグイン名)。

戻り値:

* オプションの値をリセットしなかった場合は _WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET_
* オプションの値をリセットした場合は _WEECHAT_CONFIG_OPTION_UNSET_OK_RESET_
* オプションを削除した場合は _WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED_
* エラーが起きた場合は _WEECHAT_CONFIG_OPTION_UNSET_ERROR_

C 言語での使用例:

[source,c]
----
switch (weechat_config_unset_plugin ("option"))
{
    case WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_ERROR:
        /* ... */
        break;
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def config_unset_plugin(option_name: str) -> int: ...

# 例
rc = weechat.config_unset_plugin("option")
if rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_ERROR:
    # ...
----

[[key_bindings]]
=== キー割り当て

キー割り当てに関する関数。

==== key_bind

_WeeChat バージョン 0.3.6 以上で利用可、バージョン 1.8 で更新。_

新しいキー割り当てを追加。

[NOTE]
コマンド `/key bind`
とは異なり、この関数がすでに存在しているキー割り当てを変更することはありません。新しいキー割り当てを作成するだけです。キー割り当てを削除するには
<<_key_unbind,key_unbind>> を使ってください。

プロトタイプ:

[source,c]
----
int weechat_key_bind (const char *context, struct t_hashtable *keys);
----

:key_bind_quiet: __quiet

引数:

* _context_: キーのコンテキスト:
** _default_: デフォルトコンテキスト (一般的な動作)
** _search_: 検索コンテキスト (バッファ中のテキストを検索中)
** _cursor_: 画面上のカーソルを自由に移動
** _mouse_: マウスイベント用のキー
* _keys_: キー割り当てを収めたハッシュテーブル; 以下の特殊キーを収めることが可能です:
** _{key_bind_quiet}_: コアバッファに追加されたキーを表示しない
   _(WeeChat バージョン 1.8 以上で利用可)_

戻り値:

* 追加されたキー割り当て

C 言語での使用例:

[source,c]
----
struct t_hashtable *keys = weechat_hashtable_new (8,
                                                  WEECHAT_HASHTABLE_STRING,
                                                  WEECHAT_HASHTABLE_STRING,
                                                  NULL,
                                                  NULL);
if (keys)
{
    weechat_hashtable_set (keys, "@chat(plugin.buffer):button1", "hsignal:test_mouse");
    weechat_hashtable_set (keys, "@chat(plugin.buffer):wheelup", "/mycommand up");
    weechat_hashtable_set (keys, "@chat(plugin.buffer):wheeldown", "/mycommand down");
    weechat_key_bind ("mouse", keys);
    weechat_hashtable_free (keys);
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def key_bind(context: str, keys: Dict[str, str]) -> int: ...

# 例
keys = {"@chat(python.test):button1": "hsignal:test_mouse",
        "@chat(python.test):wheelup": "/mycommand up",
        "@chat(python.test):wheeldown": "/mycommand down"}
weechat.key_bind("mouse", keys)
----

==== key_unbind

_WeeChat バージョン 0.3.6 以上で利用可、バージョン 2.0 で更新。_

キー割り当てを削除。

[CAUTION]
この関数を呼び出す際には、ユーザのキー割り当てを削除しないように注意してください。

プロトタイプ:

[source,c]
----
int weechat_key_unbind (const char *context, const char *key);
----

引数:

* _context_: キーのコンテキスト (<<_key_bind,key_bind>> を参照)
* _key_: 削除するキーまたは特殊値 "area:XXX" で1 番目または 2
  番目の領域から _XXX_ をもつすべてのキーを削除しますが、
  キーの先頭に "quiet:" を付けた場合には、削除されたキーを _core_
  バッファに表示しません _(WeeChat バージョン 2.0 以上で利用可)_。

戻り値:

* 削除されたキー割り当ての個数

C 言語での使用例:

[source,c]
----
/* remove a single key */
weechat_key_unbind ("mouse", "@chat(plugin.buffer):button1");

/* remove all keys with area "chat(plugin.buffer)" */
weechat_key_unbind ("mouse", "area:chat(plugin.buffer)");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def key_unbind(context: str, key: str) -> int: ...

# 例

# remove a single key
weechat.key_unbind("mouse", "@chat(plugin.buffer):button1")

# remove all keys with area "chat(python.test)"
weechat.key_unbind("mouse", "area:chat(python.test)")
----

[[display]]
=== 表示

バッファにテキストを表示する関数。

==== prefix

プレフィックスを返す。

プロトタイプ:

[source,c]
----
const char *weechat_prefix (const char *prefix);
----

引数:

* _prefix_: プレフィックスの名前 (以下の表を参照)

戻り値:

* プレフィックスの値
  (プレフィックスと色コードを含む文字列)、プレフィックスが見つからない場合は空文字列

List of prefixes:

[width="100%",cols="^2m,^1,^3,5",options="header"]
|===
| プレフィックス    | 値 | 色    | 説明
| error   | `+=!=+` | yellow     | エラーメッセージ
| network | `+--+`  | magenta    | ネットワークからのメッセージ
| action  | `+*+`   | white      | 本人の動作
| join    | `+-->+` | lightgreen | 誰かが現在のチャットに参加
| quit    | `+<--+` | lightred   | 誰かが現在のチャットから退出
|===

[NOTE]
値と色はコマンド `/set` でカスタマイズできます。

C 言語での使用例:

[source,c]
----
weechat_printf (NULL, "%sThis is an error...", weechat_prefix ("error"));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def prefix(prefix: str) -> str: ...

# 例
weechat.prnt("", "%sThis is an error..." % weechat.prefix("error"))
----

==== color

表示する色コードを文字列で返す。

プロトタイプ:

[source,c]
----
const char *weechat_color (const char *color_name);
----

引数:

* _color_name_: 色の名前、以下の中から 1 つ:
** WeeChat 色オプション名 (weechat.color.xxx の xxx)、例えば
   _chat_delimiters_
** オプション名 (書式: file.section.option)、例えば
   _irc.color.message_quit_ _(WeeChat バージョン 1.2 以上で利用可)_
** 任意で属性や背景色を指定した色 (以下を参照)
** 属性:
// TRANSLATION MISSING
*** _blink_: set blink
// TRANSLATION MISSING
*** _-blink_: remove blink
// TRANSLATION MISSING
*** _dim_: set "dim" (half bright)
// TRANSLATION MISSING
*** _-dim_: remove "dim" (half bright)
*** _bold_: 太字を有効
*** _-bold_: 太字を無効
*** _reverse_: 色反転を有効
*** _-reverse_: 色反転を削除
*** _italic_: イタリックを有効
*** _-italic_: イタリックを無効
*** _underline_: 下線を有効
*** _-underline_: 下線を無効
*** _emphasis_: テキストの強調を切り替え (注意: WeeChat
    はテキスト強調をバッファテキストを検索する際に使用するため、バー以外でこれを使わないでください。)
    _(WeeChat バージョン 0.4.2 以上で利用可)_
** バーの色名:
*** _bar_fg_: バーのテキストの色
*** _bar_delim_: バーの区切り文字の色
*** _bar_bg_: バーの背景色
** リセット:
*** _reset_: 色と属性をリセット
*** _resetcolor_: 色をリセット (属性はリセットしない) _(WeeChat バージョン 0.3.6 以上で利用可)_

色の書式: 属性 (任意) + 色名 + ",background"
(任意)。以下の属性を使えます:

// TRANSLATION MISSING
* `+%+`: blink
// TRANSLATION MISSING
* `+.+`: "dim" (half bright)
* `+*+` : 太字
* `+!+` : 色反転
* `+/+` : イタリック
* `+_+` : 下線
* `+|+` : 属性を保存: 色を変更する際に太字/色反転/イタリック/下線の状態をリセットしない
  _(WeeChat バージョン 0.3.6 以上で利用可)_

例:

* `+yellow+` : テキストを黄色に
* `+_green+` : テキストに下線を引き、テキストを緑色に
* `+*214+` : テキストを太字でオレンジ色に
* `+yellow,red+` : テキストを黄色に、背景色を赤に
* `+|cyan+` : テキストをシアンに (これよりも前に設定した属性は変えない)

戻り値:

* 色コードを収めた文字列、色が見つからない場合は空文字列

C 言語での使用例:

[source,c]
----
weechat_printf (NULL, "Color: %sblue %sdefault color %syellow on red",
                weechat_color ("blue"),
                weechat_color ("chat"),
                weechat_color ("yellow,red"));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def color(color_name: str) -> str: ...

# 例
weechat.prnt("", "Color: %sblue %sdefault color %syellow on red"
    % (weechat.color("blue"), weechat.color("chat"), weechat.color("yellow,red")))
----

==== printf

バッファにメッセージを表示。

プロトタイプ:

[source,c]
----
void weechat_printf (struct t_gui_buffer *buffer, const char *message, ...);
----

この関数は printf_datetime_tags
関数の別名です。以下に示す通り、どちらの関数も同じ結果を返します:

[source,c]
----
weechat_printf (buffer, "message");
weechat_printf_datetime_tags (buffer, 0, 0, NULL, "message");
----

引数:

* _buffer_: バッファへのポインタ、NULL の場合は WeeChat バッファにメッセージを表示
* _message_: 表示するメッセージ

[NOTE]
メッセージに含まれる最初のタブ文字 ("\t") はメッセージのプレフィックスを分割するために使われます。 +
メッセージに複数のタブ文字が含まれ、プレフィックスを使いたくない場合は、空白、タブ文字、メッセージのように使ってください
(以下の例を参照): これでプレフィックスが無くなります
(タブ文字の前の空白は表示されません)。

[NOTE]
2 つ連続したタブ文字 ("\t")
がメッセージの最初にある場合、時刻は表示されず、メッセージの位置調整は行われません。さらにメッセージの時刻が
0 に設定されます。

C 言語での使用例:

[source,c]
----
weechat_printf (NULL, "Hello on WeeChat buffer");
weechat_printf (buffer, "Hello on this buffer");
weechat_printf (buffer, "%sThis is an error!", weechat_prefix ("error"));
weechat_printf (buffer, " \tMessage without prefix but with \t some \t tabs");
weechat_printf (buffer, "\t\tMessage without time/alignment");
weechat_printf (buffer, "\t\t");  /* empty line (without time) */
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def prnt(buffer: str, message: str) -> int: ...

# 例
weechat.prnt("", "Hello on WeeChat buffer")
weechat.prnt(buffer, "Hello on this buffer")
weechat.prnt(buffer, "%sThis is an error!" % weechat.prefix("error"))
weechat.prnt(buffer, " \tMessage without prefix but with \t some \t tabs")
weechat.prnt(buffer, "\t\tMessage without time/alignment")
weechat.prnt(buffer, "\t\t")  # empty line (without time)
----

[NOTE]
この関数をスクリプトの中で実行するには "print" (Python の場合は "prnt") と書きます。

==== printf_date_tags

日付とタグを指定してバッファにメッセージを表示。

プロトタイプ:

[source,c]
----
void weechat_printf_date_tags (struct t_gui_buffer *buffer, time_t date,
                               const char *tags, const char *message, ...);
----

この関数は printf_datetime_tags
関数の別名です。以下に示す通り、どちらの関数も同じ結果を返します:

[source,c]
----
weechat_printf_date_tags (buffer, 0, NULL, "message");
weechat_printf_datetime_tags (buffer, 0, 0, NULL, "message");
----

引数:

* _buffer_: バッファへのポインタ、NULL の場合、メッセージは WeeChat バッファに表示
* _date_: メッセージの日付 (0 は現在の日付/時間を意味する)
* _tags_: タグのコンマ区切りリスト (タグを指定しない場合は NULL)
* _message_: 表示するメッセージ

WeeChat で共通に使われるタグのリストは
link:weechat_user.ja.html#lines_tags[WeeChat ユーザーズガイド / 行のタグ ^↗^^]を参照してください

C 言語での使用例:

[source,c]
----
weechat_printf_date_tags (NULL, time (NULL) - 120, "notify_message",
                          "Message 2 minutes ago, with a tag 'notify_message'");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def prnt_date_tags(buffer: str, date: int, tags: str, message: str) -> int: ...

# 例
time = int(time.time())
weechat.prnt_date_tags("", time - 120, "notify_message",
    "Message 2 minutes ago, with a tag 'notify_message'")
----

[NOTE]
この関数をスクリプトの中で実行するには "print_date_tags" (Python の場合は "prnt_date_tags") と書きます。

==== printf_datetime_tags

_WeeChat ≥ 4.2.0._

// TRANSLATION MISSING
Display a message on a buffer, using a custom date/time (with microseconds)
and tags.

プロトタイプ:

[source,c]
----
void weechat_printf_datetime_tags (struct t_gui_buffer *buffer, time_t date,
                                   int date_usec, const char *tags, const char *message, ...);
----

引数:

* _buffer_: バッファへのポインタ、NULL の場合、メッセージは WeeChat バッファに表示
* _date_: メッセージの日付 (0 は現在の日付/時間を意味する)
// TRANSLATION MISSING
* _date_usec_: microseconds of date (between 0 and 999999)
* _tags_: タグのコンマ区切りリスト (タグを指定しない場合は NULL)
* _message_: 表示するメッセージ

WeeChat で共通に使われるタグのリストは
link:weechat_user.ja.html#lines_tags[WeeChat ユーザーズガイド / 行のタグ ^↗^^]を参照してください

C 言語での使用例:

[source,c]
----
struct timeval tv_now;

gettimeofday (&tv_now, NULL);
weechat_printf_datetime_tags (NULL, tv_now.tv_sec - 120, tv_now.tv_usec,
                              "notify_message",
                              "Message 2 minutes ago, with a tag 'notify_message'");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def prnt_datetime_tags(buffer: str, date: int, date_usec: int, tags: str, message: str) -> int: ...

# 例
now = time.time()
time_sec = int(now)
time_usec = int((now * 1000000) % 1000000)
weechat.prnt_datetime_tags("", time_sec - 120, time_usec, "notify_message",
                           "Message 2 minutes ago, with a tag 'notify_message'")
----

[NOTE]
この関数をスクリプトの中で実行するには "print_datetime_tags" (Python の場合は "prnt_datetime_tags") と書きます。

==== printf_y

自由内容のバッファのある行にメッセージを表示

プロトタイプ:

[source,c]
----
void weechat_printf_y (struct t_gui_buffer *buffer, int y, const char *message, ...);
----

// TRANSLATION MISSING
This function is a shortcut for function printf_y_datetime_tags. +
These two calls give exactly same result:

[source,c]
----
weechat_printf_y (buffer, 0, "message");
weechat_printf_y_datetime_tags (buffer, 0, 0, 0, NULL, "message");
----

引数:

* _buffer_: バッファへのポインタ
* _y_: 行番号 (1 行目は 0); 負数の場合は表示された最後の行の後に行を追加する:
  _y_ の絶対値で最後の行の後に追加する行数を指定 (例えば
  -1 は最後の行のすぐ後、-2 は 最後の行の 2 行後)
  _(WeeChat バージョン 1.0 以上で利用可)_
* _message_: 表示するメッセージ

C 言語での使用例:

[source,c]
----
weechat_printf_y (buffer, 2, "My message on third line");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def prnt_y(buffer: str, y: int, message: str) -> int: ...

# 例
weechat.prnt_y("", 2, "My message on third line")
----

[NOTE]
この関数をスクリプトの中で実行するには "print_y" (Python の場合は "prnt_y") と書きます。

==== printf_y_date_tags

_WeeChat ≥ 3.5._

// TRANSLATION MISSING
Display a message on a line of a buffer with free content, using a custom
date and tags.

プロトタイプ:

[source,c]
----
void weechat_printf_y_date_tags (struct t_gui_buffer *buffer, int y, time_t date,
                                 const char *tags, const char *message, ...);
----

// TRANSLATION MISSING
This function is a shortcut for function printf_y_datetime_tags. +
These two calls give exactly same result:

[source,c]
----
weechat_printf_y_date_tags (buffer, 0, 0, NULL, "message");
weechat_printf_y_datetime_tags (buffer, 0, 0, 0, NULL, "message");
----

引数:

* _buffer_: バッファへのポインタ
* _y_: 行番号 (1 行目は 0); 負数の場合は表示された最後の行の後に行を追加する:
  _y_ の絶対値で最後の行の後に追加する行数を指定 (例えば
  -1 は最後の行のすぐ後、-2 は 最後の行の 2 行後)
* _date_: メッセージの日付 (0 は現在の日付/時間を意味する)
* _tags_: タグのコンマ区切りリスト (タグを指定しない場合は NULL)
* _message_: 表示するメッセージ

C 言語での使用例:

[source,c]
----
weechat_printf_y_date_tags (buffer, 2, 0, "my_tag", "My message on third line with a tag");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def prnt_y_date_tags(buffer: str, y: int, date: int, tags: str, message: str) -> int: ...

# 例
weechat.prnt_y_date_tags("", 2, 0, "my_tag", "My message on third line with a tag")
----

[NOTE]
この関数をスクリプトの中で実行するには "print_y_date_tags" (Python の場合は "prnt_y_date_tags") と書きます。

==== printf_y_datetime_tags

_WeeChat ≥ 4.2.0._

// TRANSLATION MISSING
Display a message on a line of a buffer with free content, using a custom
date/time (with microseconds) and tags.

プロトタイプ:

[source,c]
----
void weechat_printf_y_datetime_tags (struct t_gui_buffer *buffer, int y, time_t date,
                                     int date_usec, const char *tags, const char *message, ...);
----

引数:

* _buffer_: バッファへのポインタ
* _y_: 行番号 (1 行目は 0); 負数の場合は表示された最後の行の後に行を追加する:
  _y_ の絶対値で最後の行の後に追加する行数を指定 (例えば
  -1 は最後の行のすぐ後、-2 は 最後の行の 2 行後)
* _date_: メッセージの日付 (0 は現在の日付/時間を意味する)
// TRANSLATION MISSING
* _date_usec_: microseconds of date (between 0 and 999999)
* _tags_: タグのコンマ区切りリスト (タグを指定しない場合は NULL)
* _message_: 表示するメッセージ

C 言語での使用例:

[source,c]
----
weechat_printf_y_datetime_tags (buffer, 2, 0, 0, "my_tag", "My message on third line with a tag");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def prnt_y_datetime_tags(buffer: str, y: int, date: int, date_usec: int, tags: str, message: str) -> int: ...

# 例
weechat.prnt_y_datetime_tags("", 2, 0, 0, "my_tag", "My message on third line with a tag")
----

[NOTE]
この関数をスクリプトの中で実行するには "print_y_datetime_tags" (Python の場合は "prnt_y_datetime_tags") と書きます。

==== log_printf

WeeChat ログファイル (weechat.log) にメッセージを書き込む。

プロトタイプ:

[source,c]
----
void weechat_log_printf (const char *message, ...);
----

引数:

* _message_: 書き込むメッセージ

C 言語での使用例:

[source,c]
----
weechat_log_printf ("My message in log file");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def log_print(message: str) -> int: ...

# 例
weechat.log_print("My message in log file")
----

[NOTE]
この関数をスクリプトの中で実行するには "log_print" と書きます。

[[hooks]]
=== フック

[[hook_priority]]
[float]
==== フックの優先度

_WeeChat バージョン 0.3.4 以上で利用可。_

一部のフックに対して優先度を設定することができます。フックリストは優先度の高い順にフックが並べられ、高い優先度を持つフックはそれよりも低い優先度を持つフックが実行される前に実行されます。これは実行順序が重要となる修飾子で便利です。

優先度が指定できる引数に優先度を設定するには、必ず以下の構文を使ってください:
`nnn|name` ここで `nnn` は優先度を示すゼロおよび正の整数で
`name` は引数の名前です
(優先度は自動的に文字列から削除され、フックの名前になります)。 +
// TRANSLATION MISSING
Only a single priority per hook is allowed.

デフォルトの優先度は 1000 です。

// TRANSLATION MISSING
C examples:

// TRANSLATION MISSING
[source,c]
----
/* hook modifier with priority = 2000 */
/* high priority: called before other modifier callbacks */
weechat_hook_modifier ("2000|input_text_display", &modifier_cb, NULL, NULL);

/* hook two signals with priority = 3000 */
/* high priority: called before other signal callbacks */
weechat_hook_signal ("3000|quit;upgrade", &signal_cb, NULL, NULL);

/* hook lines printed in formatted buffers with priority = 500 */
/* low priority: called after other line callbacks */
weechat_hook_line ("500|formatted", "*", NULL, &line_cb, NULL, NULL);
----

以下のフック型に対して優先度を設定できます:

* <<_hook_command,command>>
* <<_hook_completion,completion>>
* <<_hook_command_run,command_run>>
* <<_hook_line,line>>
* <<_hook_signal,signal>>
* <<_hook_hsignal,hsignal>>
* <<_hook_config,config>>
* <<_hook_modifier,modifier>>
* <<_hook_info,info>>
* <<_hook_info_hashtable,info_hashtable>>
* <<_hook_infolist,infolist>>
* <<_hook_hdata,hdata>>
* <<_hook_focus,focus>>

==== hook_command

_WeeChat バージョン 1.5 と 1.7 で更新。_

コマンドをフックする。

プロトタイプ:

[source,c]
----
struct t_hook *weechat_hook_command (const char *command,
                                     const char *description,
                                     const char *args,
                                     const char *args_description,
                                     const char *completion,
                                     int (*callback)(const void *pointer,
                                                     void *data,
                                                     struct t_gui_buffer *buffer,
                                                     int argc,
                                                     char **argv,
                                                     char **argv_eol),
                                     const void *callback_pointer,
                                     void *callback_data);
----

引数:

// TRANSLATION MISSING
* _command_: コマンド名
  (a priority is allowed before the command, see note about <<hook_priority,priority>>)
* _description_: コマンドの説明 (`/help command` で表示されます)
* _args_: コマンドの引数 (`/help command` で表示されます)
* _args_description_: 引数の説明 (`/help command` で表示されます)
* _completion_: コマンドに対する補完候補テンプレート (書式は以下を参照してください)
* _callback_: コマンドが使用された際に呼び出すコールバック関数、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _struct t_gui_buffer *buffer_: コマンドを実行するバッファ
** _int argc_: コマンドに渡す引数の個数
** _char **argv_: コマンドに渡す引数
** _char **argv_eol_: コマンドに渡す引数
   (最初の引数から各引数までを収めた文字列)
** 戻り値:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_data_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したフックが削除された時点で自動的に開放されます

上の _completion_ テンプレートは各引数に関する補完候補の空白区切りリストです。1
つの引数に対して複数の補完候補を設定するには補完候補同士を `+|+` で区切ってください。1
つのコマンドに対して複数のテンプレートを設定するにはテンプレート同士を `+||+` で区切ってください。

補完候補テンプレートには以下の書式を使えます:

* _%(name)_: _name_ という補完候補テンプレート
* _%(name:arguments)_: _arguments_ という引数をつけた _name_
  という補完候補テンプレートがコールバックに送信されます _(WeeChat バージョン 1.7 以上)_
* 任意の文字列: 補完候補としてそのまま使われる文字列

例えば `list || add %(filters_names) || del %(filters_names)|-all`
という補完候補テンプレートはコマンド引数として以下の値を補完します:

* 第 1 引数: `list`、`add`、`del`
* 第 2 引数、第 1 引数に依存:
** `list`: 第 2 引数なし
** `add`: フィルタ名
** `del`: フィルタ名および `-all`

デフォルトの補完候補コードは:

include::{autogendir}/autogen_api_completions.ja.adoc[tag=completions]

特殊コード:

* `+%%command+`: コマンド _command_ と同じ補完候補テンプレートを使用
* `+%-+`: 補完の中止
* `+%*+`: 最後の補完候補を繰り返す

戻り値:

* 新しいフックへのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
int
my_command_cb (const void *pointer, void *data, struct t_gui_buffer *buffer,
               int argc, char **argv, char **argv_eol)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* this example is inspired by command /filter */
struct t_hook *my_command_hook =
    weechat_hook_command ("myfilter",
                          "description of myfilter",
                          "[list] | [enable|disable|toggle [name]] | "
                          "[add name plugin.buffer tags regex] | "
                          "[del name|-all]",
                          "description of arguments...",
                          "list"
                          " || enable %(filters_names)"
                          " || disable %(filters_names)"
                          " || toggle %(filters_names)"
                          " || add %(filters_names) %(buffers_plugins_names)|*"
                          " || del %(filters_names)|-all",
                          &my_command_cb, NULL, NULL);
----

例えば、コマンドが `/command abc def ghi`
のように実行された場合、_argv_ と _argv_eol_ は以下のようになります:

* _argv_:
** _argv[0]_ == "/command"
** _argv[1]_ == "abc"
** _argv[2]_ == "def"
** _argv[3]_ == "ghi"
* _argv_eol_:
** _argv_eol[0]_ == "/command abc def ghi"
** _argv_eol[1]_ == "abc def ghi"
** _argv_eol[2]_ == "def ghi"
** _argv_eol[3]_ == "ghi"

スクリプトでは、_args_ は "abc def ghi" のようになります。

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hook_command(command: str, description: str, args: str, args_description: str,
                 completion: str, callback: str, callback_data: str) -> str: ...

# 例
def my_command_cb(data: str, buffer: str, args: str) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_command("myfilter", "description of myfilter",
    "[list] | [enable|disable|toggle [name]] | [add name plugin.buffer tags regex] | [del name|-all]",
    "description of arguments...",
    "list"
    " || enable %(filters_names)"
    " || disable %(filters_names)"
    " || toggle %(filters_names)"
    " || add %(filters_names) %(buffers_plugins_names)|*"
    " || del %(filters_names)|-all",
    "my_command_cb", "")
----

==== hook_completion

_WeeChat バージョン 1.5 と 1.7 で更新。_

補完をフック。

プロトタイプ:

[source,c]
----
struct t_hook *weechat_hook_completion (const char *completion_item,
                                        const char *description,
                                        int (*callback)(const void *pointer,
                                                        void *data,
                                                        const char *completion_item,
                                                        struct t_gui_buffer *buffer,
                                                        struct t_gui_completion *completion),
                                        const void *callback_pointer,
                                        void *callback_data);
----

引数:

// TRANSLATION MISSING
* _completion_item_: 補完候補テンプレートの名前、これ以降コマンドフックの
  _completion_ 引数で _%(name)_ という補完候補テンプレートを使えます
  (WeeChat バージョン 1.7 以上の場合 _%(name:arguments)_ も使えます)
  (a priority is allowed before the completion item, see note about <<hook_priority,priority>>)
* _description_: 補完候補テンプレートの説明
* _callback_: 補完候補テンプレート (ユーザはこの関数を使って何かを補完します)
  が使われた場合に呼び出すコールバック関数、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _const char *completion_item_: 補完候補テンプレートの名前 (WeeChat バージョン 1.7
   以上の場合、次の書式で引数を含めることも可能です: _name:arguments_)
** _struct t_gui_buffer *buffer_: 補完が行われたバッファ
** _struct t_gui_completion *completion_:
   補完に際して単語を追加するために使われる構造体
   (<<_completion_list_add,completion_list_add>> を参照)
** 戻り値:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_data_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したフックが削除された時点で自動的に開放されます

[NOTE]
補完名はグローバルです (WeeChat
とプラグインで共有されます)。このため、"plugin_xxx" (ここで "xxx" は要素の名前)
などの一意的なプレフィックスをつけた名前を使うことをおすすめします。

// TRANSLATION MISSING
[IMPORTANT]
The callback must only call completion functions like
<<_completion_list_add,completion_list_add>> and must *NOT* update the command line. +
kbd:[Tab] が押された時にコマンドラインを更新するためには、関数
<<_hook_command_run,hook_command_run>> を使ってコマンド
`+/input complete_next+` をフックしてください (コールバックがコマンドラインを更新する場合は必ず
_WEECHAT_RC_OK_EAT_ を返してください。そうすれば WeeChat は補完を行いません)。

戻り値:

* 新しいフックへのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
int
my_completion_cb (const void *pointer, void *data, const char *completion_item,
                  struct t_gui_buffer *buffer,
                  struct t_gui_completion *completion)
{
    weechat_completion_list_add (completion, "word1", 0, WEECHAT_LIST_POS_SORT);
    weechat_completion_list_add (completion, "test_word2", 0, WEECHAT_LIST_POS_SORT);
    return WEECHAT_RC_OK;
}

struct t_hook *my_completion_hook = weechat_hook_completion ("plugin_item",
                                                             "my custom completion!",
                                                             &my_completion_cb, NULL, NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hook_completion(completion_item: str, description: str, callback: str, callback_data: str) -> str: ...

# 例
def my_completion_cb(data: str, completion_item: str, buffer: str, completion: str) -> int:
    weechat.completion_list_add(completion, "word1", 0, weechat.WEECHAT_LIST_POS_SORT)
    weechat.completion_list_add(completion, "test_word2", 0, weechat.WEECHAT_LIST_POS_SORT)
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_completion("plugin_item", "my custom completion!",
                               "my_completion_cb", "")
----

// TRANSLATION MISSING
==== hook_completion_get_string

_WeeChat バージョン 0.3.4 以上で利用可。_

*Deprecated since WeeChat 2.9* (still there for compatibility). +
This function has been replaced by <<_completion_get_string,completion_get_string>>.

// TRANSLATION MISSING
==== hook_completion_list_add

*Deprecated since WeeChat 2.9* (still there for compatibility). +
This function has been replaced by <<_completion_list_add,completion_list_add>>.

==== hook_command_run

_WeeChat バージョン 1.5 で更新。_

WeeChat がコマンドを実行する際にこれをフック。

プロトタイプ:

[source,c]
----
struct t_hook *weechat_hook_command_run (const char *command,
                                         int (*callback)(const void *pointer,
                                                         void *data,
                                                         struct t_gui_buffer *buffer,
                                                         const char *command),
                                         const void *callback_pointer,
                                         void *callback_data);
----

引数:

// TRANSLATION MISSING
* _command_: フックするコマンド (ワイルドカード `+*+` を使うことができます)
  (a priority is allowed before the command, see note about <<hook_priority,priority>>)
* _callback_: コマンドが実行される際に呼び出すコールバック関数、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _struct t_gui_buffer *buffer_: コマンドを実行するバッファ
** _const char *command_: 実行するコマンド、引数付き
** 戻り値:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_OK_EAT_: コールバックの後にコマンドを実行しない
*** _WEECHAT_RC_ERROR_
* _callback_pointer_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_data_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したフックが削除された時点で自動的に開放されます

戻り値:

* 新しいフックへのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
int
my_command_run_cb (const void *pointer, void *data,
                   struct t_gui_buffer *buffer, const char *command)
{
    weechat_printf (NULL, "I'm eating the completion!");
    return WEECHAT_RC_OK_EAT;
}

struct t_hook *my_command_run_hook =
    weechat_hook_command_run ("/input complete*",
                              &my_command_run_cb, NULL, NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hook_command_run(command: str, callback: str, callback_data: str) -> str: ...

# 例
def my_command_run_cb(data: str, buffer: str, command: str) -> int:
    weechat.prnt("", "I'm eating the completion!")
    return weechat.WEECHAT_RC_OK_EAT

hook = weechat.hook_command_run("/input complete*", "my_command_run_cb", "")
----

==== hook_timer

_WeeChat バージョン 1.5 で更新。_

タイマをフックする。

プロトタイプ:

[source,c]
----
struct t_hook *weechat_hook_timer (long interval,
                                   int align_second,
                                   int max_calls,
                                   int (*callback)(const void *pointer,
                                                   void *data,
                                                   int remaining_calls),
                                   const void *callback_pointer,
                                   void *callback_data);
----

引数:

* _interval_: 2 つの呼び出し間隔 (ミリ秒、1000 = 1 秒)
* _align_second_: 秒の調整。例えば、現在時刻が 09:00、
  interval = 60000 (60 秒)、align_second = 60
  の場合、毎分 0 秒時にタイマを呼び出す
* _max_calls_: タイマを呼び出す回数 (0 の場合、タイマを無限に呼び出す)
* _callback_: 時間が来たら呼び出すコールバック関数、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _int remaining_calls_: 呼び出し残り回数 (タイマを無限に呼び出す場合は -1)
** 戻り値:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_data_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したフックが削除された時点で自動的に開放されます

戻り値:

* 新しいフックへのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
int
my_timer_cb (const void *pointer, void *data, int remaining_calls)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* timer called each 20 seconds */
struct t_hook *my_timer_hook =
    weechat_hook_timer (20 * 1000, 0, 0, &my_timer_cb, NULL, NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hook_timer(interval: int, align_second: int, max_calls: int, callback: str, callback_data: str) -> str: ...

# 例
def my_timer_cb(data: str, remaining_calls: int) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

# timer called each 20 seconds
hook = weechat.hook_timer(20 * 1000, 0, 0, "my_timer_cb", "")
----

==== hook_fd

_WeeChat バージョン 1.3、1.5、2.0 で更新。_

ファイルディスクリプタ (ファイルやソケット) をフック。

プロトタイプ:

[source,c]
----
struct t_hook *weechat_hook_fd (int fd,
                                int flag_read,
                                int flag_write,
                                int flag_exception,
                                int (*callback)(const void *pointer,
                                                void *data,
                                                int fd),
                                const void *callback_pointer,
                                void *callback_data);
----

引数:

* _fd_: ファイルディスクリプタ
* _flag_read_: 1 = ロードイベントをキャッチ、0 = 無視
* _flag_write_: 1 = 書き込みイベントをキャッチ、0 = 無視
* _flag_exception_: 1 = 例外イベントをキャッチ、0 = 無視
  (_WeeChat バージョン 1.3 以上の場合_: この引数は無視され、使われません)
* _callback_: ファイル (またはソケット)
  に対してキャッチしたいイベントが発生した場合に実行するコールバック関数、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _int fd_: ファイルディスクリプタ
** 戻り値:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_data_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したフックが削除された時点で自動的に開放されます

戻り値:

* 新しいフックへのポインタ、エラーが起きた場合は NULL

[IMPORTANT]
スクリプトにおけるコールバック引数 _fd_  は
WeeChat バージョン 2.0 以上では整数、バージョン 1.9 以下では文字列です。 +
すべてのバージョンで互換性を保つには、使用前にコールバック引数 _fd_
を整数へ変換することを推奨します (Python の場合 `int(fd)` のように変換してください)。

C 言語での使用例:

[source,c]
----
int
my_fd_cb (const void *pointer, void *data, int fd)
{
    /* ... */
    return WEECHAT_RC_OK;
}

int sock = socket (AF_INET, SOCK_STREAM, 0);
/* set socket options */
/* ... */
struct t_hook *my_fd_hook = weechat_hook_fd (sock, 1, 0, 0, &my_fd_cb, NULL, NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hook_fd(fd: int, flag_read: int, flag_write: int, flag_exception: int, callback: str, callback_data: str) -> str: ...

# 例
def my_fd_cb(data: str, fd: int) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

sock = ...
hook = weechat.hook_fd(sock, 1, 0, 0, "my_fd_cb", "")
----

==== hook_process

_WeeChat バージョン 1.5 で更新。_

プロセスをフックして (フォークして実行)、出力を受け取る。

[NOTE]
WeeChat バージョン 0.3.9.2
以上の場合、コマンドを実行するためにシェルを使わないようになりました。WeeChat
が自動的にコマンドと引数を分割します (シェルがやっているように)。 +
分割 (引用符に基づくコマンド分割)
に失敗する場合、またはシェルを使いたい場合は、ハッシュテーブル _options_
に引数を入れて <<_hook_process_hashtable,hook_process_hashtable>>
関数を使ってください _(WeeChat バージョン 0.4.0 以上で利用可)_。

プロトタイプ:

[source,c]
----
struct t_hook *weechat_hook_process (const char *command,
                                     int timeout,
                                     int (*callback)(const void *pointer,
                                                     void *data,
                                                     const char *command,
                                                     int return_code,
                                                     const char *out,
                                                     const char *err),
                                     const void *callback_pointer,
                                     void *callback_data);
----

引数:

* _command_: 子プロセスで実行するコマンド、URL _(WeeChat バージョン 0.3.7 以上で利用可)_
  または関数 _(WeeChat バージョン 1.5 以上で利用可)_ (下記参照)
* _timeout_: コマンドのタイムアウト (ミリ秒):
  このタイムアウトを過ぎたら、子プロセスを kill します (タイムアウトさせない場合は 0)
* _callback_:
  子プロセスからのデータが利用可能になるか、子プロセスが終了したら呼び出すコールバック関数、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _const char *command_: 子プロセスが実行するコマンド
** _int return_code_: リターンコード:
*** _≥ 0_: コマンドを実行した子プロセスのまたは URL に対するリターンコード。URL の場合に取り得る値は:
**** _0_: 転送に成功
**** _1_: 無効な URL
**** _2_: 転送エラー
**** _3_: メモリ不足
**** _4_: ファイルに関するエラー
*** _< 0_:
**** _WEECHAT_HOOK_PROCESS_RUNNING_ (-1): データは利用可能だが子プロセスは終了していない
**** _WEECHAT_HOOK_PROCESS_ERROR_ (-2): コマンドの起動中にエラー
// TRANSLATION MISSING
**** _WEECHAT_HOOK_PROCESS_CHILD_ (-3): 子プロセスからコールバックが呼び出された
     (used only in C API, not scripting API)
** _out_: コマンドの標準出力 (stdout)
** _err_: コマンドの標準エラー出力 (stderr)
** 戻り値:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
*** 子プロセスのリターンコード (_command_ に "func:" を指定して関数を実行した場合)
* _callback_pointer_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_data_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したフックが削除された時点で自動的に開放されます

戻り値:

* 新しいフックへのポインタ、エラーが起きた場合は NULL

コマンドが終了するか、タイムアウトを過ぎた場合、WeeChat は自動的にフックを解除します
(プロセスが実行中であればプロセスを kill します)。

コマンドを "url:https://www.example.com" の書式に従う URL にすることで、URL
の内容がダウンロードされます _(WeeChat バージョン 0.3.7 以上で利用可)_。<<_hook_process_hashtable,hook_process_hashtable>>
関数を使えば URL に対してオプションを与えることもできます。

_command_ には関数名を指定することも可能です。"name" という関数を実行するには "func:name"
のように指定します _(WeeChat バージョン 1.5 以上で利用可)_。ここで指定した関数 "name" は単独の引数 (_data_)
を受け取り、文字列を返すものでなければいけません。関数から返された文字列が _callback_ コールバックに送られます。 +
C API の場合、_callback_ コールバックが _return_code_ リターンコードに
_WEECHAT_HOOK_PROCESS_CHILD_ が設定された状態で呼び出されます。すなわち (フォークの後に)
子プロセスが呼び出すのは関数 "name" ではなく _callback_ コールバックです。 +
スクリプト API の場合、子プロセスが呼び出すのは関数 "name" であり、関数 "name" の戻り値 (文字列) が
_callback_ コールバックに送られます (関数の戻り値は外部コマンドを実行した場合の出力と同様に取り扱われます)。

[TIP]
// TRANSLATION MISSING
If you want to retrieve infos about WeeChat (like current stable version,
latest git commit, etc.), you can use URLs on
https://weechat.org/dev/info/[this page ^↗^^].

[NOTE]
コールバックにデータを送信するバッファのサイズは 64KB (バッファは 2
つあります: 標準出力用と、標準エラー出力用)
です。子プロセスからの出力 (標準出力または標準エラー出力) が 64KB
よりも大きくなった場合は、コールバックを 1 回以上呼び出します。

[IMPORTANT]
コールバックを 1
回より多く呼び出すことが皆無だとしても、コールバックを複数回呼び出しても安全なようにコードを書いてください:
必ず複数回送られたデータを連結し、データを使うのは戻り値が正またはゼロの時だけにしてください。

C 言語での使用例:

[source,c]
----
/* 外部コマンドを実行する例 */
int
my_process_cb (const void *pointer, void *data, const char *command,
               int return_code, const char *out, const char *err)
{
    if (return_code == WEECHAT_HOOK_PROCESS_ERROR)
    {
        weechat_printf (NULL, "Error with command '%s'", command);
        return WEECHAT_RC_OK;
    }

    if (return_code >= 0)
    {
        weechat_printf (NULL, "return_code = %d", return_code);
    }

    if (out)
    {
        weechat_printf (NULL, "stdout: %s", out);
    }

    if (err)
    {
        weechat_printf (NULL, "stderr: %s", err);
    }

    return WEECHAT_RC_OK;
}

struct t_hook *my_process_hook = weechat_hook_process ("ls", 5000,
                                                       &my_process_cb, NULL, NULL);

/* 子プロセスからコールバックを呼び出す例 */
int
my_process_func_cb (const void *pointer, void *data, const char *command,
                    int return_code, const char *out, const char *err)
{
    if (return_code == WEECHAT_HOOK_PROCESS_CHILD)
    {
        /* 何かブロックを生じさせるようなことを実行... */
        /* ... */

        /* 親プロセスはこの標準出力の内容を "out" に設定して、コールバックを呼び出します */
        printf ("this is the result");

        /* このプロセスの戻り値 */
        return 0;
    }
    else
    {
        if (return_code == WEECHAT_HOOK_PROCESS_ERROR)
        {
            weechat_printf (NULL, "Error with command '%s'", command);
            return WEECHAT_RC_OK;
        }

        if (return_code >= 0)
        {
            weechat_printf (NULL, "return_code = %d", return_code);
        }

        if (out)
        {
            weechat_printf (NULL, "stdout: %s", out);
        }

        if (err)
        {
            weechat_printf (NULL, "stderr: %s", err);
        }

        return WEECHAT_RC_OK;
    }
}

struct t_hook *my_process_hook = weechat_hook_process ("func:get_status", 5000,
                                                       &my_process_func_cb, NULL, NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hook_process(command: str, timeout: int, callback: str, callback_data: str) -> str: ...

# 外部コマンドを実行する例
def my_process_cb(data: str, command: str, return_code: int, out: str, err: str) -> int:
    if return_code == weechat.WEECHAT_HOOK_PROCESS_ERROR:
        weechat.prnt("", "Error with command '%s'" % command)
        return weechat.WEECHAT_RC_OK
    if return_code >= 0:
        weechat.prnt("", "return_code = %d" % return_code)
    if out:
        weechat.prnt("", "stdout: %s" % out)
    if err:
        weechat.prnt("", "stderr: %s" % err)
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_process("ls", 5000, "my_process_cb", "")

# スクリプト関数を実行する例
def get_status(data: str) -> str:
    # 何かブロックを生じさせるようなことを実行...
    # ...
    return "this is the result"

def my_process_cb(data: str, command: str, return_code: int, out: str, err: str) -> int:
    if return_code == weechat.WEECHAT_HOOK_PROCESS_ERROR:
        weechat.prnt("", "Error with command '%s'" % command)
        return weechat.WEECHAT_RC_OK
    if return_code >= 0:
        weechat.prnt("", "return_code = %d" % return_code)
    if out:
        weechat.prnt("", "stdout: %s" % out)
    if err:
        weechat.prnt("", "stderr: %s" % err)
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_process("func:get_status", 5000, "my_process_cb", "")
----

==== hook_process_hashtable

_WeeChat バージョン 0.3.7 以上で利用可、バージョン 1.5 で更新。_

ハッシュテーブルに収めたオプションを使いプロセスをフックする
(フォークして実行)、出力を受け取る。

プロトタイプ:

[source,c]
----
struct t_hook *weechat_hook_process_hashtable (const char *command,
                                               struct t_hashtable *options,
                                               int timeout,
                                               int (*callback)(const void *pointer,
                                                               void *data,
                                                               const char *command,
                                                               int return_code,
                                                               const char *out,
                                                               const char *err),
                                               const void *callback_pointer,
                                               void *callback_data);
----

引数は以下の追加引数を除いて
<<_hook_process,hook_process>> 関数と同じです:

* _options_: 実行するコマンドのオプション;
  ハッシュテーブルは関数の中で複製されるため、この関数を呼び出した後にハッシュテーブルを安全に開放できます。

一般的なコマンド (最初に "url:" が付かないコマンド)
では、以下のオプションを使うことができます:

[width="100%",cols="^1,^1,1,1,5",options="header"]
|===
// TRANSLATION MISSING
| オプション | Min WeeChat | 値 | デフォルト | 説明

| argN (N は 1 以上) | 0.4.0 | 任意の文字列 | 引数なし
| コマンドの引数;
  このオプションを使って引数を渡さない場合、シェルと同じように引数を自動的に分割します
  (_command_ 引数からコマンド引数をロードします)

| stdin | 0.4.3 | (非使用) | 標準出力を使用しない
| データを書き込むためのパイプを子プロセスの標準入力 (stdin)
  に作成します (関数 <<_hook_set,hook_set>> を参照)

| buffer_flush | 1.0 | バイト数 | 65536
| 標準出力および標準エラー出力をフラッシュ (出力をコールバックヘ送信)
  するバイト数の最小値。取りうる値の範囲は 1 から 65536 までです。1
  の場合、出力をすぐにコールバックへ送信します。

| detached | 1.0 | (非使用) | detached モードで実行しない
| detached モードでプロセスを実行: 標準出力と標準エラー出力を
  _/dev/null_ にリダイレクトする
|===

// TRANSLATION MISSING
For command "url:...", see available options in function <<_hook_url,hook_url>>.

戻り値:

* 新しいフックへのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
int
my_process_cb (const void *pointer, void *data, const char *command,
               int return_code, const char *out, const char *err)
{
    if (return_code == WEECHAT_HOOK_PROCESS_ERROR)
    {
        weechat_printf (NULL, "Error with command '%s'", command);
        return WEECHAT_RC_OK;
    }

    if (return_code >= 0)
    {
        weechat_printf (NULL, "return_code = %d", return_code);
    }

    if (out)
    {
        weechat_printf (NULL, "stdout: %s", out);
    }

    if (err)
    {
        weechat_printf (NULL, "stderr: %s", err);
    }

    return WEECHAT_RC_OK;
}

/* 例 1: URL をダウンロード */
struct t_hashtable *options_url1 = weechat_hashtable_new (8,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          NULL,
                                                          NULL);
if (options_url1)
{
    weechat_hashtable_set (options_url1, "file_out", "/tmp/weechat.org.html");
    struct t_hook *my_process_hook = weechat_hook_process_hashtable ("url:https://weechat.org/",
                                                                     options_url1,
                                                                     20000,
                                                                     &my_process_cb, NULL, NULL);
    weechat_hashtable_free (options_url1);
}

/* 例 2: 任意の HTTP ヘッダを付けて URL を開く */
struct t_hashtable *options_url2 = weechat_hashtable_new (8,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          NULL,
                                                          NULL);
if (options_url2)
{
    weechat_hashtable_set (options_url2, "httpheader",
                           "Header1: value1\n"
                           "Header2: value2");
    struct t_hook *my_process_hook = weechat_hook_process_hashtable ("url:http://localhost:8080/",
                                                                     options_url2,
                                                                     20000,
                                                                     &my_process_cb, NULL, NULL);
    weechat_hashtable_free (options_url2);
}

/* 例 3: メッセージを渡して通知プログラムを実行 */
struct t_hashtable *options_cmd1 = weechat_hashtable_new (8,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          NULL,
                                                          NULL);
if (options_cmd1)
{
    weechat_hashtable_set (options_cmd1, "arg1", "-from");
    weechat_hashtable_set (options_cmd1, "arg2", nick);
    weechat_hashtable_set (options_cmd1, "arg3", "-msg");
    weechat_hashtable_set (options_cmd1, "arg4", message);  /* untrusted argument */
    struct t_hook *my_process_hook = weechat_hook_process_hashtable ("my-notify-command",
                                                                     options_cmd1,
                                                                     20000,
                                                                     &my_process_cb, NULL, NULL);
    weechat_hashtable_free (options_cmd1);
}

/* 例 4: コマンドを実行するためにシェルを呼び出す (必ず安全なコマンドを実行してください) */
struct t_hashtable *options_cmd2 = weechat_hashtable_new (8,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          NULL,
                                                          NULL);
if (options_cmd2)
{
    weechat_hashtable_set (options_cmd2, "arg1", "-c");
    weechat_hashtable_set (options_cmd2, "arg2", "ls -l /tmp | grep something");
    struct t_hook *my_process_hook = weechat_hook_process_hashtable ("sh",
                                                                     options_cmd2,
                                                                     20000,
                                                                     &my_process_cb, NULL, NULL);
    weechat_hashtable_free (options_cmd2);
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hook_process_hashtable(command: str, options: Dict[str, str], timeout: int, callback: str, callback_data: str) -> str: ...

# 例
def my_process_cb(data: str, command: str, return_code: int, out: str, err: str) -> int:
    if return_code == weechat.WEECHAT_HOOK_PROCESS_ERROR:
        weechat.prnt("", "Error with command '%s'" % command)
        return weechat.WEECHAT_RC_OK
    if return_code >= 0:
        weechat.prnt("", "return_code = %d" % return_code)
    if out:
        weechat.prnt("", "stdout: %s" % out)
    if err:
        weechat.prnt("", "stderr: %s" % err)
    return weechat.WEECHAT_RC_OK

# 例 1: URL をダウンロード
hook1 = weechat.hook_process_hashtable("url:https://weechat.org/",
                                       {"file_out": "/tmp/weechat.org.html"},
                                       20000, "my_process_cb", "")

# 例 2: 任意の HTTP ヘッダを付けて URL を開く
options = {
    "httpheader": "\n".join([
        "Header1: value1",
        "Header2: value2",
    ]),
}
hook2 = weechat.hook_process_hashtable("url:http://localhost:8080/",
                                       options,
                                       20000, "my_process_cb", "")

# 例 3: メッセージを渡して通知プログラムを実行
hook3 = weechat.hook_process_hashtable("my-notify-command",
                                       {"arg1": "-from",
                                        "arg2": nick,
                                        "arg3": "-msg",
                                        "arg4": message},  # untrusted argument
                                       20000, "my_process_cb", "")

# 例 4: コマンドを実行するためにシェルを呼び出す (必ず安全なコマンドを実行してください)
hook4 = weechat.hook_process_hashtable("sh",
                                       {"arg1": "-c",
                                        "arg2": "ls -l /tmp | grep something"},
                                       20000, "my_process_cb", "")
----

// TRANSLATION MISSING
==== hook_url

_WeeChat ≥ 4.1.0._

URL transfer.

This function is similar to <<_hook_process,hook_process>> and
<<_hook_process_hashtable,hook_process_hashtable>> with command "url:..."
but it uses a thread instead of new process, making it more lightweight
and thus recommended for this usage.

プロトタイプ:

[source,c]
----
struct t_hook *weechat_hook_url (const char *url,
                                 struct t_hashtable *options,
                                 int timeout,
                                 int (*callback)(const void *pointer,
                                                 void *data,
                                                 const char *url,
                                                 struct t_hashtable *options,
                                                 struct t_hashtable *output),
                                 const void *callback_pointer,
                                 void *callback_data);
----

引数:

* _url_: URL
* _options_: options for URL transfer (see below);
  ハッシュテーブルは関数の中で複製されるため、この関数を呼び出した後にハッシュテーブルを安全に開放できます。
* _timeout_: timeout for URL transfer (in milliseconds): after this timeout,
  the transfer is stopped (0 means no timeout)
* _callback_: function called when the transfer has ended, arguments and return
  value:
** _const void *pointer_: pointer
** _void *data_: pointer
** _const char *url_: URL
** _struct t_hashtable *options_: options
** _struct t_hashtable *output_: result (keys and values are strings), which may
   contain the following keys:
*** _response_code_: HTTP response code
*** _headers_: HTTP headers in response
*** _output_: standard output (set only if _file_out_ was not set in options)
*** _error_: error message (set only in case of error)
** return value:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_data_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したフックが削除された時点で自動的に開放されます

The following Curl options are available (see `+man curl_easy_setopt+` for
a description of each option):

include::{autogendir}/autogen_api_url_options.ja.adoc[tag=url_options]

[NOTE]
^(1)^ "mask" タイプのオプションでは、フォーマットは "value1+value2+value3" です。
"list" タイプのオプションでは、リスト要素を改行で区切ってください。
(`\n`). +
^(2)^ 定数が利用可能な場合、定数は必ずオプションの値に含めてください。

These two extra options (strings) are allowed for input/output file:

[width="100%",cols="2,^1,7",options="header"]
|===
| Option   | Type   | Description
| file_in  | string | 読み込んで URL に送信するファイル (ファイルを送信)
| file_out | string | ダウンロードした URL/ファイルをこのファイルに書き込む (標準出力を使わない)
|===

戻り値:

* 新しいフックへのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
int
my_url_cb (const void *pointer, void *data, const char *url,
           struct t_hashtable *options, struct t_hashtable *output)
{
    weechat_printf (NULL, "response_code: %s", weechat_hashtable_get (output, "response_code"));
    weechat_printf (NULL, "headers: %s", weechat_hashtable_get (output, "headers"));
    weechat_printf (NULL, "output: %s", weechat_hashtable_get (output, "output"));
    weechat_printf (NULL, "error: %s", weechat_hashtable_get (output, "error"));
    return WEECHAT_RC_OK;
}

/* example 1: output to a file */
struct t_hashtable *options_url1 = weechat_hashtable_new (8,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          NULL,
                                                          NULL);
if (options_url1)
{
    weechat_hashtable_set (options_url1, "file_out", "/tmp/weechat.org.html");
    struct t_hook *my_url_hook = weechat_hook_url ("https://weechat.org/",
                                                   options_url1,
                                                   20000,
                                                   &my_url_cb, NULL, NULL);
    weechat_hashtable_free (options_url1);
}

/* example 2: custom HTTP headers, output sent to callback */
struct t_hashtable *options_url2 = weechat_hashtable_new (8,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          NULL,
                                                          NULL);
if (options_url2)
{
    weechat_hashtable_set (options_url2, "httpheader",
                           "Header1: value1\n"
                           "Header2: value2");
    struct t_hook *my_url_hook = weechat_hook_url ("http://localhost:8080/",
                                                   options_url2,
                                                   20000,
                                                   &my_url_cb, NULL, NULL);
    weechat_hashtable_free (options_url2);
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hook_url(url: str, options: Dict[str, str], timeout: int, callback: str, callback_data: str) -> str: ...

# 例
def my_url_cb(data: str, url: str, options: Dict[str, str], output: Dict[str, str]) -> int:
    weechat.prnt("", "output: %s" % output)
    return weechat.WEECHAT_RC_OK

# example 1: output to a file
hook1 = weechat.hook_url("https://weechat.org/",
                         {"file_out": "/tmp/weechat.org.html"},
                         20000, "my_url_cb", "")

# example 2: custom HTTP headers, output sent to callback
options = {
    "httpheader": "\n".join([
        "Header1: value1",
        "Header2: value2",
    ]),
}
hook2 = weechat.hook_url("http://localhost:8080/", options, 20000, "my_url_cb", "")
----

==== hook_connect

// TRANSLATION MISSING
_Updated in 1.5, 2.0, 4.4.0._

接続をフックする (リモートホストへのバックグラウンド接続)。

プロトタイプ:

[source,c]
----
struct t_hook *weechat_hook_connect (const char *proxy,
                                     const char *address,
                                     int port,
                                     int ipv6,
                                     int retry,
                                     void *gnutls_sess,
                                     void *gnutls_cb,
                                     int gnutls_dhkey_size,
                                     const char *gnutls_priorities,
                                     const char *local_hostname,
                                     int (*callback)(const void *pointer,
                                                     void *data,
                                                     int status,
                                                     int gnutls_rc,
                                                     int sock,
                                                     const char *error,
                                                     const char *ip_address),
                                     const void *callback_pointer,
                                     void *callback_data);
----

引数:

* _proxy_: 接続に使用するプロキシの名前
  (任意、プロキシを使わない場合は NULL)
* _address_: 接続先のドメイン名または IP アドレス
* _port_: ポート番号
* _ipv6_:
// TRANSLATION MISSING
** `WEECHAT_HOOK_CONNECT_IPV6_DISABLE` ^(1)^: disable IPv6 (use only IPv4)
// TRANSLATION MISSING
** `WEECHAT_HOOK_CONNECT_IPV6_AUTO` ^(1)^: use IPv6 with fallback to IPv4
// TRANSLATION MISSING
** `WEECHAT_HOOK_CONNECT_IPV6_FORCE` ^(1)^: force IPv6 (do not use IPv4) _(WeeChat ≥ 4.4.0)_
* _retry_: 再試行回数、IPv6 ホストに接続したもののクライアントの受け入れに失敗した際に
  IPv4 ホストへフォールバックする際に使う
* _gnutls_sess_: GnuTLS セッション (任意)
* _gnutls_cb_: GnuTLS コールバック (任意)
* _gnutls_dhkey_size_: Diffie-Hellman
  鍵交換の際に使う鍵のサイズ (GnuTLS)
* _gnutls_priorities_: gnutls のプロパティ (構文は gnutls マニュアルの
  _gnutls_priority_init_ 関数を参照)、基本的な値を以下に示す:
** _PERFORMANCE_
** _NORMAL_ (デフォルト)
** _SECURE128_
** _SECURE256_
** _EXPORT_
** _NONE_
* _local_hostname_: 接続に使うローカルのホスト名前 (任意)
* _callback_:
  接続に成功および失敗した際に呼び出すコールバック関数、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _int status_: 接続状態 ^(2)^:
*** _WEECHAT_HOOK_CONNECT_OK_: 接続成功
*** _WEECHAT_HOOK_CONNECT_ADDRESS_NOT_FOUND_: アドレスが見つかりません
*** _WEECHAT_HOOK_CONNECT_IP_ADDRESS_NOT_FOUND_: IP アドレスが見つかりません
*** _WEECHAT_HOOK_CONNECT_CONNECTION_REFUSED_: 接続が拒否されました
*** _WEECHAT_HOOK_CONNECT_PROXY_ERROR_: プロキシに関するエラー
*** _WEECHAT_HOOK_CONNECT_LOCAL_HOSTNAME_ERROR_: ローカルのホスト名に関するエラー
*** _WEECHAT_HOOK_CONNECT_GNUTLS_INIT_ERROR_: GnuTLS 初期化エラー
*** _WEECHAT_HOOK_CONNECT_GNUTLS_HANDSHAKE_ERROR_: GnuTLS ハンドシェイクエラー
*** _WEECHAT_HOOK_CONNECT_MEMORY_ERROR_: メモリ不足
*** _WEECHAT_HOOK_CONNECT_TIMEOUT_: タイムアウト
*** _WEECHAT_HOOK_CONNECT_SOCKET_ERROR_: ソケットの作成に失敗
** _gnutls_rc_: _gnutls_handshake()_ の戻り値 ^(2)^
** _sock_: 接続に使うソケット ^(2)^
** _const char *error_: _gnutls_strerror(gnutls_rc)_ の戻り値
** _const char *ip_address_: 見つかった IP アドレス
** 戻り値:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_data_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したフックが削除された時点で自動的に開放されます

// TRANSLATION MISSING
[NOTE]
^(1)^ Constants for parameter _ipv6_ are available since WeeChat 4.4.0. +
For older releases, allowed values are `1` (use IPv6 with fallback to IPv4) and
`0` (disable IPv6, use only IPv4). +
^(2)^ スクリプトにおけるコールバック引数 _status_、_gnutls_rc_、_sock_  は
WeeChat バージョン 2.0 以上では整数、バージョン 1.9 以下では文字列です。 +
すべてのバージョンで互換性を保つには、使用前にコールバック引数 _status_、_gnutls_rc_、_sock_
を整数へ変換することを推奨します (Python の場合 `int(sock)` のように変換してください)。

戻り値:

* 新しいフックへのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
int
my_connect_cb (const void *pointer, void *data, int status, int gnutls_rc,
               int sock, const char *error, const char *ip_address)
{
    switch (status)
    {
        case WEECHAT_HOOK_CONNECT_OK:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_ADDRESS_NOT_FOUND:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_IP_ADDRESS_NOT_FOUND:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_CONNECTION_REFUSED:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_PROXY_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_LOCAL_HOSTNAME_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_GNUTLS_INIT_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_GNUTLS_HANDSHAKE_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_MEMORY_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_TIMEOUT:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_SOCKET_ERROR:
            /* ... */
            break;
    }
    return WEECHAT_RC_OK;
}

struct t_hook *my_connect_hook = weechat_hook_connect (NULL,
                                                       "my.server.org", 1234,
                                                       WEECHAT_HOOK_CONNECT_IPV6_AUTO,
                                                       0,
                                                       NULL, NULL, 0,  /* GnuTLS */
                                                       NULL,
                                                       &my_connect_cb, NULL, NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hook_connect(proxy: str, address: str, port: int, ipv6: int, retry: int, local_hostname: str,
                 callback: str, callback_data: str) -> str: ...

# 例
def my_connect_cb(data: str, status: int, gnutls_rc: int, sock: int, error: str, ip_address: str) -> int:
    if status == weechat.WEECHAT_HOOK_CONNECT_OK:
        # ...
    elif status == weechat.WEECHAT_HOOK_CONNECT_ADDRESS_NOT_FOUND:
        # ...
    elif status == weechat.WEECHAT_HOOK_CONNECT_IP_ADDRESS_NOT_FOUND:
        # ...
    elif status == weechat.WEECHAT_HOOK_CONNECT_CONNECTION_REFUSED:
        # ...
    elif status == weechat.WEECHAT_HOOK_CONNECT_PROXY_ERROR:
        # ...
    elif status == weechat.WEECHAT_HOOK_CONNECT_LOCAL_HOSTNAME_ERROR:
        # ...
    elif status == weechat.WEECHAT_HOOK_CONNECT_GNUTLS_INIT_ERROR:
        # ...
    elif status == weechat.WEECHAT_HOOK_CONNECT_GNUTLS_HANDSHAKE_ERROR:
        # ...
    elif status == weechat.WEECHAT_HOOK_CONNECT_MEMORY_ERROR:
        # ...
    elif status == weechat.WEECHAT_HOOK_CONNECT_TIMEOUT:
        # ...
    elif status == weechat.WEECHAT_HOOK_CONNECT_SOCKET_ERROR:
        # ...
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_connect("", "my.server.org", 1234,
                            weechat.WEECHAT_HOOK_CONNECT_IPV6_AUTO, 0, "",
                            "my_connect_cb", "")
----

==== hook_line

// TRANSLATION MISSING
_WeeChat ≥ 2.3, updated in 4.2.0._

バッファに対する行表示をフックする。

バッファに行が表示される際に、以下の順番でフックが呼び出されます:

* <<_hook_line,hook line>> (このフック):
  バッファ、プレフィックス、メッセージ、タグ、通知レベル、… を変更可能 (以下を参照)
* <<_hook_modifier,hook modifier>> "<<hook_modifier_weechat_print,weechat_print>>":
  フォーマット済み内容バッファ上のプレフィックスとメッセージを変更可能
* <<_hook_print,hook print>>: 行がフォーマット済み内容バッファに追加された時点で呼び出されます
  (このフックでは何かを変更することはできません)。

[NOTE]
上記 3 つのフックの中で、フォーマット済み内容バッファの内容を操作できるのは
"line" フックだけです。

プロトタイプ:

[source,c]
----
struct t_hook *weechat_hook_line (const char *buffer_type,
                                  const char *buffer_name,
                                  const char *tags,
                                  struct t_hashtable *(*callback)(const void *pointer,
                                                                  void *data,
                                                                  struct t_hashtable *line),
                                  const void *callback_pointer,
                                  void *callback_data);
----

引数:

* _buffer_type_: ここで指定したバッファ型の行をフックします (NULL または空文字列の場合、
  _formatted_ を指定したことになります)
  (_WeeChat ≥ 3.7_: a priority is allowed before the buffer type,
  see note about <<hook_priority,priority>>):
** _formatted_: フォーマット済み内容バッファの行のみをフックします (デフォルト)
** _free_: 自由内容バッファの行のみをフックします
** _*_: すべてのバッファの行をフックします
* _buffer_name_: バッファマスクのコンマ区切りリスト
  (<<_buffer_match_list,buffer_match_list>> を参照してください);
  NULL、空文字列、"*" は任意のバッファにマッチします。
* _tags_: 指定したタグを付けられたメッセージのみをフックします (任意):
   メッセージに含まれるタグのコンマ区切りリスト (論理 "or");
   複数のタグを論理 "and" で組み合わせるには `+++` を使ってください;
   タグ中の `+*+` はワイルドカードを意味します
* _callback_:
  バッファに行が追加されると呼び出される関数、引数と戻り値は以下:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _struct t_hashtable *line_: 行のインフォを含むハッシュテーブル、キーと値は文字列
   (以下のテーブルを参照してください)
** 戻り値: 新しい値のハッシュテーブル (以下のテーブルを参照してください)
* _callback_pointer_: WeeChat がコールバックを呼び出した際にコールバックに渡したポインタ
* _callback_data_: WeeChat がコールバックを呼び出した際にコールバックに渡したポインタ;
  NULL 以外の場合、このポインタの指す領域は malloc (もしくは類似の関数)
  で割り当てられたものでなければいけません。加えて、このポインタの指す領域はフックが削除された時点で自動的に解放されます。

戻り値:

* 新しいフックへのポインタ、エラーが起きた場合は NULL

コールバックへ送られる行のデータは以下の値を持つハッシュテーブルです
(キーと値は文字列):

[width="100%",cols="^1,3,3,2",options="header"]
|===
| キー | 値 (フォーマット済みバッファ) | 値 (自由内容バッファ) | 例

| buffer
| バッファポインタ
| バッファポインタ
| `+0x1234abcd+`

| buffer_name
| バッファ名
| バッファ名
| `+core.weechat+` +
  `+irc.server.libera+` +
  `+irc.libera.#weechat+`

| buffer_type
| "formatted"
| "free"
| `+formatted+` +
  `+free+`

| y
| 利用不可 ("-1")
| 行番号 (≥ "0")
| `+-1+` +
  `+8+`

| date
| 行日付 (タイムスタンプ)
| 利用不可 ("0")
| `+1533792000+`

// TRANSLATION MISSING
| date_usec
| Microseconds of line date (between 0 and 999999).
| N/A ("0").
| `+123456+`

| date_printed
| 行が表示された日付 (タイムスタンプ)
| 利用不可 ("0")
| `+1533792012+`

// TRANSLATION MISSING
| date_usec_printed
| Microseconds of date when line was displayed (between 0 and 999999).
| N/A ("0").
| `+654321+`

| str_time
| 行に追加される日付 (色コードを入れてもよい)
| 利用不可 (空文字列)
| `+09:07:20+`

| tags_count
| タグの個数 (≥ "0")
| 利用不可 ("0")
| `+2+`

| tags
| タグのコンマ区切りリスト
| 利用不可 (空文字列)
| `+irc_join,nick_test+`

| displayed
| "0" = 行はフィルタされました (非表示) +
  "1" = 行はフィルタされませんでした (表示)
| "0" = 行はフィルタされました (非表示) +
  "1" = 行はフィルタされませんでした (表示)
| `+0+` +
  `+1+`

// TRANSLATION MISSING
| notify_level
| "-1" = no notify +
  "0" = 低レベル +
  "1" = メッセージ +
  "2" = プライベートメッセージ +
  "3" = ハイライト
| 利用不可 ("0")
| `+2+`

| highlight
| "0" = ハイライトなし +
  "1" = ハイライトあり
| 利用不可 ("0").
| `+0+` +
  `+1+`

| prefix
| 行のプレフィックス
| 利用不可 (空文字列)
| `+-->+`

| message
| 行のメッセージ
| 行のメッセージ
| `+test (~test@example.com) has joined #channel+`
|===

戻り値としては、値すべてのフィールドを含む完全なハッシュテーブルを返す必要もありませんし、無効なフィールドがあっても
WeeChat はそれらを無視します。

ハッシュテーブルに設定できるキーを以下に挙げます
(ハッシュテーブル中のキーと値は文字列です)。

[width="100%",cols="^1,2,2,5",options="header"]
|===
| キー | 設定可能な値 (フォーマット済みバッファ) | 設定可能な値 (自由内容バッファ) | 結果

| buffer
| フォーマット済みバッファへのポインタ
| 自由内容バッファへのポインタ
| 行を表示するバッファ。 +
  この値が空の場合、行は削除されます (ハッシュテーブルに含まれるその他の情報も無視されます);
  "line" 型の次のフックも呼び出されません。

| buffer_name
| フォーマット済み内容バッファの名前.
| 自由内容バッファの名前
| 行を表示するバッファ。 +
  `buffer` と `+buffer_name+` の両方が設定された場合、`+buffer_name+` の値が優先されます +
  この値が空の場合、行は削除されます (ハッシュテーブルに含まれるその他の情報も無視されます);
  "line" 型の次のフックも呼び出されません。

| y
| 利用不可
| 整数 (≥ "0")
| 行番号はこの値に設定されます

| date
| タイムスタンプ
| 利用不可
| 日付はこの値に設定されます +
  これに対応して `+str_time+` も更新されます

// TRANSLATION MISSING
| date_usec
| Integer ("0" to "999999").
| 利用不可
| The microseconds of line date is set to this value. +
  これに対応して `+str_time+` も更新されます

| date_printed
| タイムスタンプ
| 利用不可
| 表示される日付はこのタイムスタンプを使います。The printed date is set to this timestamp (not displayed).

// TRANSLATION MISSING
| date_usec_printed
| Integer ("0" to "999999").
| 利用不可
| The microseconds of printed date is set to this value.

| str_time
| 文字列
| 利用不可
| この文字列は日付を表示する際に使われます。 +
  `date` と `+str_time+` の両方が設定された場合、`+str_time+` の値が優先されます。

| tags
| 文字列
| 利用不可
| 行タグはここで指定したコンマ区切りリストに置き換えられます。 +
  これに対応して `+notify_level+` と `highlight` も更新されます。

| notify_level
| 整数 ("-1" から "3")
| 利用不可
| 通知レベルがこの値に設定されます。バッファに行が追加されるとホットリストも更新されます。 +
  この値に対応して `highlight` の値も更新されます。 +
  `tags` と `+notify_level+` の両方が設定された場合、`+notify_level+`
  の値が優先されます。

| highlight
| 整数 ("0" または "1")
| 利用不可
| "0" は行のハイライトを無効化し、"1" は行のハイライトを強制します。 +
  この値と `tags` または `+notify_level+` の両方が設定された場合、`highlight`
  の値が優先されます。

| prefix
| 文字列
| 利用不可
| 行のプレフィックスがこの値に設定されます

| message
| 文字列
| 文字列
| 行メッセージがこの値に設定されます
|===

C 言語での使用例:

[source,c]
----
int
my_line_cb (const void *pointer, void *data, struct t_hashtable *line)
{
    struct t_hashtable *hashtable;

    hashtable = weechat_hashtable_new (8,
                                       WEECHAT_HASHTABLE_STRING,
                                       WEECHAT_HASHTABLE_STRING,
                                       NULL,
                                       NULL);
    /* この行のハイライトを強制 */
    weechat_hashtable_set (hashtable, "highlight", "1");
    return hashtable;
}

/* タグ "irc_join" をつけられた行をフック */
struct t_hook *my_line_hook =
    weechat_hook_line ("", "", "irc_join", &my_line_cb, NULL, NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hook_line(buffer_type: str, buffer_name: str, tags: str, callback: str, callback_data: str) -> str: ...

# 例
def my_line_cb(data: str, line: Dict[str, str]) -> Dict[str, str]:
    # この行のハイライトを強制
    return {"highlight": "1"}

# タグ "irc_join" をつけられた行をフック
hook = weechat.hook_line("", "", "irc_join", "my_line_cb", "")
----

==== hook_print

_WeeChat バージョン 0.4.3、1.0、1.5、4.2.0 で更新。_

メッセージの表示をフックする。これは行がフォーマット済みバッファに追加された時点で呼び出されます。

行が表示された際に呼び出されるフックの情報は
<<_hook_line,hook_line>> を参照してください。

プロトタイプ:

[source,c]
----
struct t_hook *weechat_hook_print (struct t_gui_buffer *buffer,
                                   const char *tags,
                                   const char *message,
                                   int strip_colors,
                                   int (*callback)(const void *pointer,
                                                   void *data,
                                                   struct t_gui_buffer *buffer,
                                                   time_t date,
                                                   int date_usec,
                                                   int tags_count,
                                                   const char **tags,
                                                   int displayed,
                                                   int highlight,
                                                   const char *prefix,
                                                   const char *message),
                                   const void *callback_pointer,
                                   void *callback_data);
----

引数:

* _buffer_: バッファへのポインタ、NULL の場合、任意のバッファからのメッセージをキャッチする
* _tags_: このタグが付けられたメッセージだけをキャッチする (任意):
** WeeChat バージョン 0.4.3 以上の場合: メッセージに付けられたタグのコンマ区切りリスト (論理 "or");
   複数の条件を論理 "and" で組み合わせる場合は区切りに `+++` を使ってください;
   ワイルドカード `+*+` を使うことができます
** WeeChat バージョン 0.4.2 以下の場合: 論理 "and"
   で組み合わせたタグのコンマ区切りリスト
* _message_: この文字列を含むメッセージだけをキャッチする
  (任意、大文字小文字を区別しない)
* _strip_colors_: 1
  の場合、コールバックを呼ぶ前に、表示されるメッセージから色を削除する
* _callback_:
  メッセージが表示される際に呼び出すコールバック関数、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _struct t_gui_buffer *buffer_: バッファへのポインタ
** _time_t date_: 日付
// TRANSLATION MISSING
** _int date_usec_: microseconds of date
** _int tags_count_: 行に付けられたタグの個数
** _const char **tags_: 行に付けられたタグの配列
** _int displayed_: 行が表示される場合は 1、フィルタされる (隠される) 場合は 0
** _int highlight_: 行がハイライトされる場合は 1、ハイライトされない場合は 0
** _const char *prefix_: プレフィックス
** _const char *message_: メッセージ
** 戻り値:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_data_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したフックが削除された時点で自動的に開放されます

戻り値:

* 新しいフックへのポインタ、エラーが起きた場合は NULL

[IMPORTANT]
スクリプトにおけるコールバック引数 _displayed_、_highlight_ は
WeeChat バージョン 1.0 以上では整数、バージョン 0.4.3 以下では文字列です。 +
すべてのバージョンで互換性を保つには、使用前にコールバック引数 _displayed_、_highlight_
を整数へ変換することを推奨します (Python の場合 `if int(highlight):` のように変換してください)。

C 言語での使用例:

[source,c]
----
int
my_print_cb (const void *pointer, void *data, struct t_gui_buffer *buffer,
             time_t date, int date_usec, int tags_count, const char **tags,
             int displayed, int highlight,
             const char *prefix, const char *message)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* catch all messages, on all buffers, without color */
struct t_hook *my_print_hook =
    weechat_hook_print (NULL, NULL, NULL, 1, &my_print_cb, NULL, NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hook_print(buffer: str, tags: str, message: str, strip_colors: int, callback: str, callback_data: str) -> str: ...

# 例
def my_print_cb(data: str, buffer: str, date: str, tags: str, displayed: int, highlight: int, prefix: str, message: str) -> int:
    if highlight:
        # ...
    return weechat.WEECHAT_RC_OK

# catch all messages, on all buffers, without color
hook = weechat.hook_print("", "", "", 1, "my_print_cb", "")
----

==== hook_signal

_WeeChat バージョン 1.5, 3.6 で更新。_

シグナルをフックする。

プロトタイプ:

[source,c]
----
struct t_hook *weechat_hook_signal (const char *signal,
                                    int (*callback)(const void *pointer,
                                                    void *data,
                                                    const char *signal,
                                                    const char *type_data,
                                                    void *signal_data),
                                    const void *callback_pointer,
                                    void *callback_data);
----

引数:

// TRANSLATION MISSING
* _signal_: キャッチするシグナル、ワイルドカード `+*+` を使うことができます,
  multiple signals can be separated by semi-colons
  (a priority is allowed before one or more signals, see note about <<hook_priority,priority>>)
  (以下の表を参照)
* _callback_:
  シグナルを受信した際に呼び出すコールバック関数、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _const char *signal_: 受信したシグナル
** _const char *type_data_: シグナルが送信したデータの型
*** _WEECHAT_HOOK_SIGNAL_STRING_: 文字列
*** _WEECHAT_HOOK_SIGNAL_INT_: 整数
*** _WEECHAT_HOOK_SIGNAL_POINTER_:  ポインタ
** _void *signal_data_: シグナルが送信したデータ
** 戻り値:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_OK_EAT_ (直ちにシグナルの送信を止める)
    _(WeeChat バージョン 0.4.0 以上で利用可)_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_data_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したフックが削除された時点で自動的に開放されます

戻り値:

* 新しいフックへのポインタ、エラーが起きた場合は NULL

WeeChat とプラグインが送信するシグナルのリスト:

[width="100%",cols="^2,^4,^1,6,9",options="header"]
|===
// TRANSLATION MISSING
| プラグイン | シグナル | Min WeeChat | 引数 | 説明

| guile | [[hook_signal_guile_script_loaded]] guile_script_loaded | 0.3.9
| String: スクリプトへのパス
| Scheme スクリプトをロード

| guile | [[hook_signal_guile_script_unloaded]] guile_script_unloaded | 0.3.9
| String: スクリプトへのパス
| Scheme スクリプトをリロード

| guile | [[hook_signal_guile_script_installed]] guile_script_installed | 0.3.9
| String: インストールされたスクリプトへのパスのコンマ区切りリスト
| Scheme スクリプトをインストール

| guile | [[hook_signal_guile_script_removed]] guile_script_removed | 0.3.9
| String: 削除されたスクリプトへのパスのコンマ区切りリスト
| Scheme スクリプトを削除

// TRANSLATION MISSING
| irc | [[hook_signal_xxx_irc_in_yyy]] xxx,irc_in_yyy ^(1)^ |
| String: メッセージ
| サーバから IRC メッセージを受信 (メッセージを *無視しない* 場合のみ irc
  プラグインがメッセージを処理する前に、シグナルが送信される) +
  バージョン 2.2 以上ではタグを含めたすべての IRC メッセージが送信されます。 +
  If the return code of a callback is _WEECHAT_RC_OK_EAT_, then the IRC message
  is immediately destroyed and not processed _(WeeChat ≥ 3.3)_.

| irc | [[hook_signal_xxx_irc_in2_yyy]] xxx,irc_in2_yyy ^(1)^ |
| String: メッセージ
| サーバから IRC メッセージを受信 (メッセージを *無視しない* 場合のみ irc
  プラグインがメッセージを処理した後に、シグナルが送信される) +
  バージョン 2.2 以上ではタグを含めたすべての IRC メッセージが送信されます。

// TRANSLATION MISSING
| irc | [[hook_signal_xxx_irc_raw_in_yyy]] xxx,irc_raw_in_yyy ^(1)^ | 0.3.2
| String: メッセージ
| サーバから IRC メッセージを受信 (メッセージを無視する場合でも irc
  プラグインがメッセージを処理する前に、シグナルが送信される) +
  バージョン 2.2 以上ではタグを含めたすべての IRC メッセージが送信されます。 +
  If the return code of a callback is _WEECHAT_RC_OK_EAT_, then the IRC message
  is immediately destroyed and not processed _(WeeChat ≥ 3.3)_.

| irc | [[hook_signal_xxx_irc_raw_in2_yyy]] xxx,irc_raw_in2_yyy ^(1)^ | 0.3.2
| String: メッセージ
| サーバから IRC メッセージを受信 (メッセージを無視する場合でも irc
  プラグインがメッセージを処理した後に、シグナルが送信される) +
  バージョン 2.2 以上ではタグを含めたすべての IRC メッセージが送信されます。

| irc | [[hook_signal_xxx_irc_out1_yyy]] xxx,irc_out1_yyy ^(1)^ | 0.3.7
| String: メッセージ
| サーバに送信する IRC メッセージ
  (自動分割前、自動分割はデフォルトでメッセージを 512 バイト内に収まるように分割します)。

// TRANSLATION MISSING
| irc | [[hook_signal_xxx_irc_out_yyy]] xxx,irc_out_yyy ^(1)^ |
| String: メッセージ
| サーバに送信する IRC メッセージ
  (自動分割後、自動分割はデフォルトでメッセージを 512 バイト内に収まるように分割します)。 +
  *Warning:* the string may contain invalid UTF-8 data.
  Signal "xxx,irc_out1_yyy" is recommended instead.

// TRANSLATION MISSING
| irc | [[hook_signal_xxx_irc_outtags_yyy]] xxx,irc_outtags_yyy ^(1)^ | 0.3.4
| String: タグ  + ";" + メッセージ
| タグ + サーバに送信する IRC メッセージ +
  *Warning:* the string may contain invalid UTF-8 data.
  Signal "xxx,irc_out1_yyy" is recommended instead.

| irc | [[hook_signal_irc_ctcp]] irc_ctcp |
| String: メッセージ
| CTCP を受信

| irc | [[hook_signal_irc_dcc]] irc_dcc |
| String: メッセージ
| 新しい DCC

| irc | [[hook_signal_irc_pv]] irc_pv |
| String: メッセージ
| プライベートメッセージを受信

| irc | [[hook_signal_irc_channel_opened]] irc_channel_opened |
| Pointer: バッファ
| チャンネルを開いた

| irc | [[hook_signal_irc_pv_opened]] irc_pv_opened |
| Pointer: バッファ
| プライベートメッセージを開いた

| irc | [[hook_signal_irc_server_opened]] irc_server_opened | 0.3.7
| Pointer: バッファ
| サーババッファを開いた

| irc | [[hook_signal_irc_server_connecting]] irc_server_connecting |
| String: サーバ名
| サーバに接続中

| irc | [[hook_signal_irc_server_connected]] irc_server_connected |
| String: サーバ名
| サーバとの接続を確立

| irc | [[hook_signal_irc_server_disconnected]] irc_server_disconnected |
| String: サーバ名
| サーバから切断された

| irc | [[hook_signal_irc_server_lag_changed]] irc_server_lag_changed | 1.8
| String: サーバ名
| 指定したサーバの遅延時間が変化

| irc | [[hook_signal_irc_ignore_removing]] irc_ignore_removing |
| Pointer: 無視
| 無視条件を削除中

| irc | [[hook_signal_irc_ignore_removed]] irc_ignore_removed |
| -
| 無視条件を削除した

| irc | [[hook_signal_irc_notify_join]] irc_notify_join | 0.3.8
| String: サーバ名 + "," + ニックネーム
| 通知リストに入っているニックネームがサーバに参加

| irc | [[hook_signal_irc_notify_quit]] irc_notify_quit | 0.3.8
| String: サーバ名 + "," + ニックネーム
| 通知リストに入っているニックネームがサーバから切断

| irc | [[hook_signal_irc_notify_away]] irc_notify_away | 0.3.8
| String: サーバ名 + "," + ニックネーム + "," + 離席メッセージ
| 通知リストに入っているニックネームが離席状態に

| irc | [[hook_signal_irc_notify_still_away]] irc_notify_still_away | 0.3.8
| String: サーバ名 + "," + ニックネーム + "," + 離席メッセージ
| 通知リストに入っているニックネームはまだ離席状態 (離席メッセージを変更)

| irc | [[hook_signal_irc_notify_back]] irc_notify_back | 0.3.8
| String: サーバ名 + "," + ニックネーム
| 通知リストに入っているニックネームが着席状態に (離席状態を解除)

| javascript | [[hook_signal_javascript_script_loaded]] javascript_script_loaded | 1.2
| String: スクリプトへのパス
| JavaScript スクリプトをロード

| javascript | [[hook_signal_javascript_script_unloaded]] javascript_script_unloaded | 1.2
| String: スクリプトへのパス
| JavaScript スクリプトをリロード

| javascript | [[hook_signal_javascript_script_installed]] javascript_script_installed | 1.2
| String: インストールされたスクリプトへのパスのコンマ区切りリスト
| JavaScript スクリプトをインストール

| javascript | [[hook_signal_javascript_script_removed]] javascript_script_removed | 1.2
| String: 削除されたスクリプトへのパスのコンマ区切りリスト
| JavaScript スクリプトを削除

| logger | [[hook_signal_logger_start]] logger_start |
| Pointer: バッファ
| バッファのログ保存を開始

| logger | [[hook_signal_logger_stop]] logger_stop |
| Pointer: バッファ
| バッファのログ保存を中止

| logger | [[hook_signal_logger_backlog]] logger_backlog |
| Pointer: バッファ
| バッファのバックログを表示

| lua | [[hook_signal_lua_script_loaded]] lua_script_loaded | 0.3.9
| String: スクリプトへのパス
| Lua スクリプトをロード

| lua | [[hook_signal_lua_script_unloaded]] lua_script_unloaded | 0.3.9
| String: スクリプトへのパス
| Lua スクリプトをリロード

| lua | [[hook_signal_lua_script_installed]] lua_script_installed | 0.3.9
| String: インストールされたスクリプトへのパスのコンマ区切りリスト
| Lua スクリプトをインストール

| lua | [[hook_signal_lua_script_removed]] lua_script_removed | 0.3.9
| String: 削除されたスクリプトへのパスのコンマ区切りリスト
| Lua スクリプトを削除

| perl | [[hook_signal_perl_script_loaded]] perl_script_loaded | 0.3.9
| String: スクリプトへのパス
| Perl スクリプトをロード

| perl | [[hook_signal_perl_script_unloaded]] perl_script_unloaded | 0.3.9
| String: スクリプトへのパス
| Perl スクリプトをリロード

| perl | [[hook_signal_perl_script_installed]] perl_script_installed | 0.3.9
| String: インストールされたスクリプトへのパスのコンマ区切りリスト
| Perl スクリプトをインストール

| perl | [[hook_signal_perl_script_removed]] perl_script_removed | 0.3.9
| String: 削除されたスクリプトへのパスのコンマ区切りリスト
| Perl スクリプトを削除

| php | [[hook_signal_php_script_loaded]] php_script_loaded | 2.0
| String: スクリプトへのパス
| PHP スクリプトをロード

| php | [[hook_signal_php_script_unloaded]] php_script_unloaded | 2.0
| String: スクリプトへのパス
| PHP スクリプトをリロード

| php | [[hook_signal_php_script_installed]] php_script_installed | 2.0
| String: インストールされたスクリプトへのパスのコンマ区切りリスト
| PHP スクリプトをインストール

| php | [[hook_signal_php_script_removed]] php_script_removed | 2.0
| String: 削除されたスクリプトへのパスのコンマ区切りリスト
| PHP スクリプトを削除

| python | [[hook_signal_python_script_loaded]] python_script_loaded | 0.3.9
| String: スクリプトへのパス
| Python スクリプトをロード

| python | [[hook_signal_python_script_unloaded]] python_script_unloaded | 0.3.9
| String: スクリプトへのパス
| Python スクリプトをリロード

| python | [[hook_signal_python_script_installed]] python_script_installed | 0.3.9
| String: インストールされたスクリプトへのパスのコンマ区切りリスト
| Python スクリプトをインストール

| python | [[hook_signal_python_script_removed]] python_script_removed | 0.3.9
| String: 削除されたスクリプトへのパスのコンマ区切りリスト
| Python スクリプトを削除

| relay | [[hook_signal_relay_client_connecting]] relay_client_connecting | 1.0
| Pointer: リレークライアント
| リレークライアントが接続中

| relay | [[hook_signal_relay_client_waiting_auth]] relay_client_waiting_auth | 1.0
| Pointer: リレークライアント
| リレークライアントからの認証待ち

| relay | [[hook_signal_relay_client_auth_ok]] relay_client_auth_ok | 1.0
| Pointer: リレークライアント
| リレークライアントからの認証に成功

| relay | [[hook_signal_relay_client_connected]] relay_client_connected | 1.0
| Pointer: リレークライアント
| リレークライアントが接続

| relay | [[hook_signal_relay_client_auth_failed]] relay_client_auth_failed | 1.0
| Pointer: リレークライアント
| リレークライアントの認証に失敗

| relay | [[hook_signal_relay_client_disconnected]] relay_client_disconnected | 1.0
| Pointer: リレークライアント
| リレークライアントが切断

| ruby | [[hook_signal_ruby_script_loaded]] ruby_script_loaded | 0.3.9
| String: スクリプトへのパス
| Ruby スクリプトをロード

| ruby | [[hook_signal_ruby_script_unloaded]] ruby_script_unloaded | 0.3.9
| String: スクリプトへのパス
| Ruby スクリプトをリロード

| ruby | [[hook_signal_ruby_script_installed]] ruby_script_installed | 0.3.9
| String: インストールされたスクリプトへのパスのコンマ区切りリスト
| Ruby スクリプトをインストール

| ruby | [[hook_signal_ruby_script_removed]] ruby_script_removed | 0.3.9
| String: 削除されたスクリプトへのパスのコンマ区切りリスト
| Ruby スクリプトを削除

| spell | [[hook_signal_spell_suggest]] spell_suggest | 2.4
| Pointer: バッファ
| スペルの間違っている単語に対する新しい修正候補

| tcl | [[hook_signal_tcl_script_loaded]] tcl_script_loaded | 0.3.9
| String: スクリプトへのパス
| Tcl スクリプトをロード

| tcl | [[hook_signal_tcl_script_unloaded]] tcl_script_unloaded | 0.3.9
| String: スクリプトへのパス
| Tcl スクリプトをリロード

| tcl | [[hook_signal_tcl_script_installed]] tcl_script_installed | 0.3.9
| String: インストールされたスクリプトへのパスのコンマ区切りリスト
| Tcl スクリプトをインストール

| tcl | [[hook_signal_tcl_script_removed]] tcl_script_removed | 0.3.9
| String: 削除されたスクリプトへのパスのコンマ区切りリスト
| Tcl スクリプトを削除

// TRANSLATION MISSING
| typing | [[hook_signal_typing_self_typing]] typing_self_typing | 3.3
| Pointer: buffer.
| User is typing a message (sent by typing plugin, used by irc plugin).

// TRANSLATION MISSING
| typing | [[hook_signal_typing_self_paused]] typing_self_paused | 3.3
| Pointer: buffer.
| User paused during typing (sent by typing plugin, used by irc plugin).

// TRANSLATION MISSING
| typing | [[hook_signal_typing_self_cleared]] typing_self_cleared | 3.3
| Pointer: buffer.
| User cleared the input without sending the message (sent by typing plugin, used by irc plugin).

// TRANSLATION MISSING
| typing | [[hook_signal_typing_self_sent]] typing_self_sent | 3.3
| Pointer: buffer.
| Message (not a command) sent to the buffer (sent by typing plugin, used by irc plugin).

// TRANSLATION MISSING
| typing | [[hook_signal_typing_set_nick]] typing_set_nick | 3.3
| String: buffer pointer + ";" + state (one of: "off", "typing", "paused",
  "cleared") + ";" + nick.
| Set typing state for a nick on a buffer (sent by irc plugin, handled by typing plugin).

// TRANSLATION MISSING
| typing | [[hook_signal_typing_reset_buffer]] typing_reset_buffer | 3.3
| Pointer: buffer.
| Remove typing state for all nicks on a buffer (sent by irc plugin, handled by typing plugin).

| weechat | [[hook_signal_buffer_opened]] buffer_opened |
| Pointer: バッファ
| バッファを開いた

| weechat | [[hook_signal_buffer_closing]] buffer_closing |
| Pointer: バッファ
| バッファを閉じている

| weechat | [[hook_signal_buffer_closed]] buffer_closed |
| Pointer: バッファ
| バッファを閉じた

| weechat | [[hook_signal_buffer_cleared]] buffer_cleared |
| Pointer: バッファ
| バッファをクリア

| weechat | [[hook_signal_buffer_filters_enabled]] buffer_filters_enabled | 2.0
| Pointer: バッファ
| バッファでフィルタが有効化されています。

| weechat | [[hook_signal_buffer_filters_disabled]] buffer_filters_disabled | 2.0
| Pointer: バッファ
| バッファでフィルタが無効化されています。

| weechat | [[hook_signal_buffer_hidden]] buffer_hidden |
| Pointer: バッファ
| バッファを隠す

| weechat | [[hook_signal_buffer_unhidden]] buffer_unhidden |
| Pointer: バッファ
| バッファを隠すことを止める

| weechat | [[hook_signal_buffer_line_added]] buffer_line_added | 0.3.7
| Pointer: 行
| バッファに行を追加

// TRANSLATION MISSING
| weechat | [[hook_signal_buffer_line_data_changed]] buffer_line_data_changed | 4.4.0
| Pointer: line data.
| Line data has been updated in a buffer.

| weechat | [[hook_signal_buffer_lines_hidden]] buffer_lines_hidden |
| Pointer: バッファ
| バッファから行を隠す

| weechat | [[hook_signal_buffer_localvar_added]] buffer_localvar_added |
| Pointer: バッファ
| ローカル変数を追加

| weechat | [[hook_signal_buffer_localvar_changed]] buffer_localvar_changed |
| Pointer: バッファ
| ローカル変数を変更

| weechat | [[hook_signal_buffer_localvar_removed]] buffer_localvar_removed |
| Pointer: バッファ
| ローカル変数を削除

| weechat | [[hook_signal_buffer_merged]] buffer_merged |
| Pointer: バッファ
| バッファをマージ

| weechat | [[hook_signal_buffer_unmerged]] buffer_unmerged |
| Pointer: バッファ
| バッファのマージを解除

| weechat | [[hook_signal_buffer_moved]] buffer_moved |
| Pointer: バッファ
| バッファを移動

| weechat | [[hook_signal_buffer_renamed]] buffer_renamed |
| Pointer: バッファ
| バッファの名前を変更

| weechat | [[hook_signal_buffer_switch]] buffer_switch |
| Pointer: バッファ
| バッファを切り替え

| weechat | [[hook_signal_buffer_title_changed]] buffer_title_changed |
| Pointer: バッファ
| バッファのタイトルを変更

// TRANSLATION MISSING
| weechat | [[hook_signal_buffer_modes_changed]] buffer_modes_changed | 4.3.0
| Pointer: buffer.
| Modes of buffer changed.

// TRANSLATION MISSING
| weechat | [[hook_signal_buffer_time_for_each_line_changed]] buffer_time_for_each_line_changed | 4.4.0
| Pointer: buffer.
| Display time for each line changed.

| weechat | [[hook_signal_buffer_type_changed]] buffer_type_changed |
| Pointer: バッファ
| バッファのタイプを変更

| weechat | [[hook_signal_buffer_zoomed]] buffer_zoomed | 0.4.3
| Pointer: バッファ
| マージされたバッファをズーム

| weechat | [[hook_signal_buffer_unzoomed]] buffer_unzoomed | 0.4.3
| Pointer: バッファ
| マージされたバッファをアンズーム

// TRANSLATION MISSING
| weechat | [[hook_signal_buffer_user_input_xxx]] buffer_user_input_xxx ^(2)^ | 3.8
| String: text sent to buffer.
| Text sent to a user buffer as input (sent only for buffers created with `/buffer add`). +
  If the return code of a callback is _WEECHAT_RC_OK_EAT_, then the string "q"
  cannot be used anymore to close the buffer.

// TRANSLATION MISSING
| weechat | [[hook_signal_buffer_user_closing_xxx]] buffer_user_closing_xxx ^(2)^ | 3.8
| -
| User buffer is closing (sent only for buffers created with `/buffer add`).

// TRANSLATION MISSING
| weechat | [[hook_signal_cursor_start]] cursor_start | 3.2
| -
| Start cursor mode.

// TRANSLATION MISSING
| weechat | [[hook_signal_cursor_end]] cursor_end | 3.2
| -
| End cursor mode.

| weechat | [[hook_signal_day_changed]] day_changed | 0.3.2
| String: 新しい日付、書式: "2010-01-31"
| システムの日付が変更された

| weechat | [[hook_signal_debug_dump]] debug_dump |
| String: プラグイン名
| リクエストをダンプ

| weechat | [[hook_signal_debug_libs]] debug_libs |
| -
| 使用中の外部ライブラリを表示

| weechat | [[hook_signal_filter_added]] filter_added |
| Pointer: フィルタ
| フィルタを追加

| weechat | [[hook_signal_filter_removing]] filter_removing |
| Pointer: フィルタ
| フィルタを削除中

| weechat | [[hook_signal_filter_removed]] filter_removed |
| -
| フィルタを削除

| weechat | [[hook_signal_filters_enabled]] filters_enabled |
| -
| フィルタを有効化

| weechat | [[hook_signal_filters_disabled]] filters_disabled |
| -
| フィルタを無効化

| weechat | [[hook_signal_hotlist_changed]] hotlist_changed |
| Pointer: バッファ (NULL も可)
| ホットリストが変更された

| weechat | [[hook_signal_input_paste_pending]] input_paste_pending |
| -
| ペーストを保留中

| weechat | [[hook_signal_input_search]] input_search |
| Pointer: バッファ
| バッファテキストの検索

// TRANSLATION MISSING
| weechat | [[hook_signal_input_prompt_changed]] input_prompt_changed | 4.3.0
| Pointer: buffer.
| Input prompt changed.

| weechat | [[hook_signal_input_text_changed]] input_text_changed |
| Pointer: バッファ
| 入力テキストが変更された

| weechat | [[hook_signal_input_text_cursor_moved]] input_text_cursor_moved |
| Pointer: バッファ
| 入力テキストカーソルを移動

| weechat | [[hook_signal_key_bind]] key_bind |
| String: キー
| キー割り当てを追加

| weechat | [[hook_signal_key_unbind]] key_unbind |
| String: キー
| キー割り当てを削除

| weechat | [[hook_signal_key_pressed]] key_pressed |
| String: 押されたキー
| キーが押された

| weechat | [[hook_signal_key_combo_default]] key_combo_default | 1.0
| String: キーの組み合わせ
| _default_ コンテキスト内のキーの組み合わせ

| weechat | [[hook_signal_key_combo_search]] key_combo_search | 1.0
| String: キーの組み合わせ
| _search_ コンテキスト内のキーの組み合わせ

| weechat | [[hook_signal_key_combo_cursor]] key_combo_cursor | 1.0
| String: キーの組み合わせ
| _cursor_ コンテキスト内のキーの組み合わせ

// TRANSLATION MISSING
| weechat | [[hook_signal_layout_buffers_applied]] layout_buffers_applied | 4.4.0
| String: layout name.
| Layout applied for buffers.

// TRANSLATION MISSING
| weechat | [[hook_signal_layout_windows_applied]] layout_windows_applied | 4.4.0
| String: layout name.
| Layout applied for windows.

| weechat | [[hook_signal_mouse_enabled]] mouse_enabled | 1.1
| -
| マウスが有効化された

| weechat | [[hook_signal_mouse_disabled]] mouse_disabled | 1.1
| -
| マウスが無効化された

| weechat | [[hook_signal_nicklist_group_added]] nicklist_group_added | 0.3.2
| String: バッファポインタ + "," + グループ名
| ニックネームリストにグループを追加

| weechat | [[hook_signal_nicklist_group_changed]] nicklist_group_changed | 0.3.4
| String: バッファポインタ + "," + グループ名
| ニックネームリストのグループを変更

| weechat | [[hook_signal_nicklist_group_removing]] nicklist_group_removing | 0.4.1
| String: バッファポインタ + "," + グループ名
| ニックネームリストからグループを削除中

| weechat | [[hook_signal_nicklist_group_removed]] nicklist_group_removed | 0.3.2
| String: バッファポインタ + "," + グループ名
| ニックネームリストからグループを削除

| weechat | [[hook_signal_nicklist_nick_added]] nicklist_nick_added | 0.3.2
| String: バッファポインタ + "," + ニックネーム
| ニックネームリストにニックネームを追加

| weechat | [[hook_signal_nicklist_nick_changed]] nicklist_nick_changed | 0.3.4
| String: バッファポインタ + "," + ニックネーム
| ニックネームリストのニックネームを変更

| weechat | [[hook_signal_nicklist_nick_removing]] nicklist_nick_removing | 0.4.1
| String: バッファポインタ + "," + ニックネーム
| ニックネームリストからニックネームを削除中

| weechat | [[hook_signal_nicklist_nick_removed]] nicklist_nick_removed | 0.3.2
| String: バッファポインタ + "," + ニックネーム
| ニックネームリストからニックネームを削除

| weechat | [[hook_signal_partial_completion]] partial_completion |
| -
| 部分補完を実行

| weechat | [[hook_signal_plugin_loaded]] plugin_loaded | 0.3.9
| String: 読み込んだプラグインへのパス
| プラグインをロード

| weechat | [[hook_signal_plugin_unloaded]] plugin_unloaded | 0.3.9
| String: リロードしたプラグインの名前 (例: "irc")
| プラグインをリロード

| weechat | [[hook_signal_quit]] quit |
| String: /quit の引数
| ユーザがコマンド `/quit` を実行

| weechat | [[hook_signal_signal_sighup]] signal_sighup | 1.3
| -
| SIGHUP シグナルを受信

| weechat | [[hook_signal_signal_sigquit]] signal_sigquit | 1.2
| -
| SIGQUIT シグナルを受信 (コアダンプ付きで終了要求)

| weechat | [[hook_signal_signal_sigterm]] signal_sigterm | 1.2
| -
| SIGTERM シグナルを受信 (WeeChat プロセスを正常に終了させる)

| weechat | [[hook_signal_signal_sigwinch]] signal_sigwinch | 0.4.3
| -
| SIGWINCH シグナルを受信しました (端末サイズが変更されました)

// TRANSLATION MISSING
| weechat | [[hook_signal_upgrade]] upgrade |
| String: "quit" if "-quit" argument was given for /upgrade, "save" if "-save"
  if "-save" argument was given for /upgrade, otherwise NULL.
| ユーザがコマンド `/upgrade` を実行

| weechat | [[hook_signal_upgrade_ended]] upgrade_ended | 0.3.4
| -
| アップグレード作業 (コマンド `/upgrade`) が終了

| weechat | [[hook_signal_weechat_highlight]] weechat_highlight |
| String: プレフィックス付のメッセージ
| メッセージがハイライトされました

| weechat | [[hook_signal_weechat_pv]] weechat_pv |
| String: プレフィックス付のメッセージ
| プライベートメッセージの表示

| weechat | [[hook_signal_window_closing]] window_closing | 0.3.6
| Pointer: ウィンドウ
| ウィンドウを閉じています

| weechat | [[hook_signal_window_closed]] window_closed | 0.3.6
| Pointer: ウィンドウ
| ウィンドウを閉じた

| weechat | [[hook_signal_window_opened]] window_opened | 0.4.1
| Pointer: ウィンドウ
| ウィンドウを開いた

| weechat | [[hook_signal_window_scrolled]] window_scrolled |
| Pointer: ウィンドウ
| ウィンドウをスクロール

| weechat | [[hook_signal_window_switch]] window_switch | 0.3.7
| Pointer: ウィンドウ
| ウィンドウを切り替え

| weechat | [[hook_signal_window_zoom]] window_zoom |
| Pointer: 現在のウィンドウ
| ウィンドウをズーム中

| weechat | [[hook_signal_window_zoomed]] window_zoomed |
| Pointer: 現在のウィンドウ
| ウィンドウをズーム

| weechat | [[hook_signal_window_unzoom]] window_unzoom |
| Pointer: 現在のウィンドウ
| ウィンドウのズームを元に戻している

| weechat | [[hook_signal_window_unzoomed]] window_unzoomed |
| Pointer: 現在のウィンドウ
| ウィンドウのズームを元に戻す

| xfer | [[hook_signal_xfer_add]] xfer_add |
| Pointer: xfer インフォを含むインフォリスト
| 新しい xfer

| xfer | [[hook_signal_xfer_send_ready]] xfer_send_ready |
| Pointer: xfer インフォを含むインフォリスト
| Xfer の準備完了

| xfer | [[hook_signal_xfer_accept_resume]] xfer_accept_resume |
| Pointer: xfer インフォを含むインフォリスト
| Xfer のレジュームを受け入れる

| xfer | [[hook_signal_xfer_send_accept_resume]] xfer_send_accept_resume |
| Pointer: xfer インフォを含むインフォリスト
| Xfer のレジュームの受け入れを完了

| xfer | [[hook_signal_xfer_start_resume]] xfer_start_resume |
| Pointer: xfer インフォを含むインフォリスト
| レジュームの開始

| xfer | [[hook_signal_xfer_resume_ready]] xfer_resume_ready |
| Pointer: xfer インフォを含むインフォリスト
| Xfer レジュームの準備完了

| xfer | [[hook_signal_xfer_ended]] xfer_ended | 0.3.2
| Pointer: xfer インフォを含むインフォリスト
| Xfer を終了
|===

[NOTE]
^(1)^ _xxx_ はサーバ名、_yyy_ は IRC コマンド名。 +
// TRANSLATION MISSING
^(2)^ _xxx_ is buffer name.

C 言語での使用例:

[source,c]
----
int
my_signal_cb (const void *pointer, void *data, const char *signal,
              const char *type_data, void *signal_data)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* catch signals "quit" and "upgrade" */
struct t_hook *my_signal_hook = weechat_hook_signal ("quit;upgrade",
                                                     &my_signal_cb, NULL, NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hook_signal(signal: str, callback: str, callback_data: str) -> str: ...

# 例
def my_signal_cb(data: str, signal: str, signal_data: str) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

# catch signals "quit" and "upgrade"
hook = weechat.hook_signal("quit;upgrade", "my_signal_cb", "")
----

==== hook_signal_send

_WeeChat バージョン 1.0, 4.5.0 で更新。_

シグナルを送信。

プロトタイプ:

[source,c]
----
int weechat_hook_signal_send (const char *signal, const char *type_data,
                              void *signal_data);
----

引数:

// TRANSLATION MISSING
* _signal_: 送信するシグナル; flags are allowed before the signal name (see below)
  _(WeeChat ≥ 4.5.0)_
* _type_data_: シグナルと一緒に送信するデータの型
  (<<_hook_signal,hook_signal>> を参照)
* _signal_data_: シグナルと一緒に送信するデータ

// TRANSLATION MISSING
The signal name can contain flags with the following format: `[flags:xxx,yyy]signal`
where `xxx` and `yyy` are names of flags, and `signal` the signal name. +
The following flags are supported:

* _stop_on_error_: exit immediately if a callback returns WEECHAT_RC_ERROR
  (remaining callbacks are then NOT executed) _(WeeChat ≥ 4.5.0)_
* _ignore_eat_: consider any callback returning WEECHAT_RC_OK_EAT is in fact
  WEECHAT_RC_OK and execute remaining callbacks _(WeeChat ≥ 4.5.0)_

戻り値 _(WeeChat バージョン 1.0 以上で利用可)_:

* 最後に実行したコールバックの戻り値
  (コールバックを実行しなかった場合は _WEECHAT_RC_OK_):
** _WEECHAT_RC_OK_
** _WEECHAT_RC_OK_EAT_
** _WEECHAT_RC_ERROR_

C 言語での使用例:

[source,c]
----
int rc = weechat_hook_signal_send ("my_signal", WEECHAT_HOOK_SIGNAL_STRING, my_string);
int rc2 = weechat_hook_signal_send ("[flags:stop_on_error,ignore_eat]my_signal2",
                                    WEECHAT_HOOK_SIGNAL_STRING, my_string);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hook_signal_send(signal: str, type_data: str, signal_data: str) -> int: ...

# 例
rc = weechat.hook_signal_send("my_signal", weechat.WEECHAT_HOOK_SIGNAL_STRING, my_string)
rc2 = weechat.hook_signal_send("[flags:stop_on_error,ignore_eat]my_signal2",
                               weechat.WEECHAT_HOOK_SIGNAL_STRING, my_string)
----

[[signal_logger_backlog]]
===== logger_backlog シグナル

シグナル "logger_backlog" はバッファにバックログ (チャット履歴)
を表示するために送信することができます (例えば、プラグインやスクリプトでバッファを開く際など)。

引数はバッファへのポインタ。

C 言語での使用例:

[source,c]
----
weechat_hook_signal_send ("logger_backlog", WEECHAT_HOOK_SIGNAL_POINTER, buffer);
----

スクリプト (Python) での使用例:

[source,python]
----
weechat.hook_signal_send("logger_backlog", weechat.WEECHAT_HOOK_SIGNAL_POINTER, buffer)
----

[[signals_xxx_script_install]]
===== xxx_script_install シグナル

プログラミング言語ごとに、スクリプトをインストールするために送信するシグナルが 5 種類あります:

* _perl_script_install_
* _python_script_install_
* _ruby_script_install_
* _lua_script_install_
* _tcl_script_install_
* _guile_script_install_
* _javascript_script_install_
* _php_script_install_

シグナルを受け取ったらコールバックは以下のように働きます:

. インストール済みスクリプトをリロードして削除。
. 新しいスクリプトをディレクトリ _~/.local/share/weechat/xxx/_ に移動 (_xxx_ はプログラミング言語)
. 新しいスクリプトへのリンクをディレクトリ _~/.local/share/weechat/xxx/autoload/_ に作成
  (古いスクリプトがすでに自動ロードされていた場合、もしくは新しいスクリプトに対してオプション
  _script.scripts.autoload_ が有効化されている場合のみ作成されます)
. 新しいスクリプトを読み込む (古いスクリプトがロードされていた場合のみ)

_script_ プラグインはスクリプトをインストールする際にこれらのシグナルを使っています。

引数はインストールするスクリプトのパスを収めた文字列です。

C 言語での使用例:

[source,c]
----
weechat_hook_signal_send ("python_script_install", WEECHAT_HOOK_SIGNAL_STRING, "/path/to/test.py");
----

スクリプト (Python) での使用例:

[source,python]
----
weechat.hook_signal_send("python_script_install", WEECHAT_HOOK_SIGNAL_STRING, "/path/to/test.py")
----

[[signals_xxx_script_remove]]
===== xxx_script_remove シグナル

プログラミング言語ごとに、リスト文字列に含まれるスクリプトを削除するために送信するシグナルが 5 種類あります:

* _perl_script_remove_
* _python_script_remove_
* _ruby_script_remove_
* _lua_script_remove_
* _tcl_script_remove_
* _guile_script_remove_
* _javascript_script_remove_
* _php_script_remove_

リスト文字列に含まれるそれぞれのスクリプトについて、コールバックはスクリプトをリロードして削除します。

_script_ プラグインはスクリプトを削除する際にこれらのシグナルを使っています。

引数は削除したいスクリプトのコンマ区切りリスト文字列です
(パスを含まないスクリプトの名前を使います、例えば _script.py_).

C 言語での使用例:

[source,c]
----
/* unload and remove scripts test.py and script.py */
weechat_hook_signal_send ("python_script_remove", WEECHAT_HOOK_SIGNAL_STRING,
                          "test.py,script.py");
----

スクリプト (Python) での使用例:

[source,python]
----
# unload and remove scripts test.py and script.py
weechat.hook_signal_send("python_script_remove", WEECHAT_HOOK_SIGNAL_STRING,
                         "test.py,script.py")
----

[[signal_irc_input_send]]
===== irc_input_send シグナル

_WeeChat バージョン 0.3.4 以上で利用可、バージョン 1.5 で更新。_

irc バッファ(サーバ、チャンネル、プライベート)
への入力をシミュレートするにはシグナル "irc_input_send" を送信してください。

引数は以下の書式に従う文字列です:

* 内部サーバ名 (必須)
* セミコロン
* チャンネル名 (任意)
* セミコロン
* オプションのコンマ区切りリスト (任意):
** _priority_high_: キューに高い優先度を設定 (ユーザメッセージなど);
   特に設定しなければこの優先度が設定されます
** _priority_low_: キューに低い優先度を設定 (WeeChat
   が自動的に送信するメッセージなど)
** _user_message_: 強制的にユーザメッセージ化 (コマンドを実行しません)
* セミコロン
* メッセージを送信する際に使うタグのコンマ区切りリスト (任意)
* セミコロン
* テキストまたはコマンド (必須)

C 言語での使用例:

[source,c]
----
/* say "Hello!" on libera server, #weechat channel */
weechat_hook_signal_send ("irc_input_send", WEECHAT_HOOK_SIGNAL_STRING,
                          "libera;#weechat;priority_high,user_message;;Hello!");

/* send command "/whois FlashCode" on libera server, with low priority */
weechat_hook_signal_send ("irc_input_send", WEECHAT_HOOK_SIGNAL_STRING,
                          "libera;;priority_low;;/whois FlashCode");
----

スクリプト (Python) での使用例:

[source,python]
----
# say "Hello!" on libera server, #weechat channel
weechat.hook_signal_send("irc_input_send", weechat.WEECHAT_HOOK_SIGNAL_STRING,
                         "libera;#weechat;priority_high,user_message;;Hello!")

# send command "/whois FlashCode" on libera server, with low priority
weechat.hook_signal_send("irc_input_send", weechat.WEECHAT_HOOK_SIGNAL_STRING,
                         "libera;;priority_low;;/whois FlashCode")
----

==== hook_hsignal

_WeeChat バージョン 0.3.4 以上で利用可、バージョン 1.5, 3.6 で更新。_

hsignal (ハッシュテーブルを持つシグナル) をフック。

プロトタイプ:

[source,c]
----
struct t_hook *weechat_hook_hsignal (const char *signal,
                                     int (*callback)(const void *pointer,
                                                     void *data,
                                                     const char *signal,
                                                     struct t_hashtable *hashtable),
                                     const void *callback_pointer,
                                     void *callback_data);
----

引数:

// TRANSLATION MISSING
* _signal_: キャッチするシグナル、ワイルドカード `+*+` を使うことができます,
  multiple signals can be separated by semi-colons
  (a priority is allowed before one or more signals, see note about <<hook_priority,priority>>)
  (以下の表を参照)
* _callback_:
  シグナルを受信した際に呼び出すコールバック関数、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _const char *signal_: 受信したシグナル
** _struct t_hashtable *hashtable_: ハッシュテーブル
** 戻り値:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_OK_EAT_ (直ちにシグナルの送信を止める)
    _(WeeChat バージョン 0.4.0 以上で利用可)_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_data_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したフックが削除された時点で自動的に開放されます

戻り値:

* 新しいフックへのポインタ、エラーが起きた場合は NULL

hsignal のリスト:

[width="100%",cols="^1,^3,^1,5,5",options="header"]
|===
// TRANSLATION MISSING
| プラグイン | シグナル | Min WeeChat | 引数 | 説明

| irc | [[hook_hsignal_irc_redirection_xxx_yyy]] irc_redirection_xxx_yyy ^(1)^ | 0.3.4
| <<hsignal_irc_redirect_command,hsignal_irc_redirect_command>> を参照
| 出力の転送

| weechat | [[hook_hsignal_nicklist_group_added]] nicklist_group_added | 0.4.1
| _buffer_ (_struct t_gui_buffer *_): バッファ +
  _parent_group_ (_struct t_gui_nick_group *_): 親グループ +
  _group_ (_struct t_gui_nick_group *_): グループ
| ニックネームリストにグループを追加

| weechat | [[hook_hsignal_nicklist_nick_added]] nicklist_nick_added | 0.4.1
| _buffer_ (_struct t_gui_buffer *_): バッファ +
  _parent_group_ (_struct t_gui_nick_group *_): 親グループ +
  _nick_ (_struct t_gui_nick *_): ニックネーム
| ニックネームリストにニックネームを追加

| weechat | [[hook_hsignal_nicklist_group_removing]] nicklist_group_removing | 0.4.1
| _buffer_ (_struct t_gui_buffer *_): バッファ +
  _parent_group_ (_struct t_gui_nick_group *_): 親グループ +
  _group_ (_struct t_gui_nick_group *_): グループ
| ニックネームリストからグループを削除

| weechat | [[hook_hsignal_nicklist_nick_removing]] nicklist_nick_removing | 0.4.1
| _buffer_ (_struct t_gui_buffer *_): バッファ +
  _parent_group_ (_struct t_gui_nick_group *_): 親グループ +
  _nick_ (_struct t_gui_nick *_): ニックネーム
| ニックネームリストからニックネームを削除

| weechat | [[hook_hsignal_nicklist_group_changed]] nicklist_group_changed | 0.4.1
| _buffer_ (_struct t_gui_buffer *_): バッファ +
  _parent_group_ (_struct t_gui_nick_group *_): 親グループ +
  _group_ (_struct t_gui_nick_group *_): グループ
| ニックネームリストに含まれるグループを変更

| weechat | [[hook_hsignal_nicklist_nick_changed]] nicklist_nick_changed | 0.4.1
| _buffer_ (_struct t_gui_buffer *_): バッファ +
  _parent_group_ (_struct t_gui_nick_group *_): 親グループ +
  _nick_ (_struct t_gui_nick *_): ニックネーム
| ニックネームリストに含まれるニックネームを変更
|===

[NOTE]
^(1)^ _xxx_ は転送で送信するシグナル、_yyy_
は転送元のシグナル。

C 言語での使用例:

[source,c]
----
int
my_hsignal_cb (const void *pointer, void *data, const char *signal,
               struct t_hashtable *hashtable)
{
    /* ... */
    return WEECHAT_RC_OK;
}

struct t_hook *my_hsignal_hook = weechat_hook_hsignal ("test",
                                                       &my_hsignal_cb, NULL, NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hook_hsignal(signal: str, callback: str, callback_data: str) -> str: ...

# 例
def my_hsignal_cb(data: str, signal: str, hashtable: Dict[str, str]) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_hsignal("test", "my_hsignal_cb", "")
----

==== hook_hsignal_send

_WeeChat バージョン 0.3.4 以上で利用可、バージョン 1.0, 4.5.0 で更新。_

hsignal (ハッシュテーブルを持つシグナル) を送信。

プロトタイプ:

[source,c]
----
int weechat_hook_hsignal_send (const char *signal, struct t_hashtable *hashtable);
----

引数:

// TRANSLATION MISSING
* _signal_: 送信するシグナル; flags are allowed before the signal name
  (see function <<_hook_signal_send,hook_signal_send>>) _(WeeChat ≥ 4.5.0)_
* _hashtable_: ハッシュテーブル

戻り値 _(WeeChat バージョン 1.0 以上で利用可)_:

* 最後に実行したコールバックの戻り値
  (コールバックを実行しなかった場合は _WEECHAT_RC_OK_):
** _WEECHAT_RC_OK_
** _WEECHAT_RC_OK_EAT_
** _WEECHAT_RC_ERROR_

C 言語での使用例:

[source,c]
----
int rc, rc2;
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
if (hashtable)
{
    weechat_hashtable_set (hashtable, "key", "value");
    rc = weechat_hook_hsignal_send ("my_hsignal", hashtable);
    rc2 = weechat_hook_hsignal_send ("[flags:stop_on_error,ignore_eat]my_hsignal2", hashtable);
    weechat_hashtable_free (hashtable);
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hook_hsignal_send(signal: str, hashtable: Dict[str, str]) -> int: ...

# 例
rc = weechat.hook_hsignal_send("my_hsignal", {"key": "value"})
rc2 = weechat.hook_hsignal_send("[flags:stop_on_error,ignore_eat]my_hsignal2", {"key": "value"})
----

[[hsignal_irc_redirect_command]]
===== Hsignal irc_redirect_command

_WeeChat バージョン 0.3.4 以上で利用可。_

hsignal "irc_redirect_command" は irc
コマンドの出力をコールバックに転送するためのものです。

引数は以下のエントリを持つハッシュテーブル (キーと値は文字列) です:

* _server_: 内部サーバ名 (必須)
* _pattern_: 転送パターン (必須)、デフォルトパターン (irc プラグインが定義したもの)
  またはユーザ定義パターン (<<hsignal_irc_redirect_pattern>> を参照)
  のどちらか一方、デフォルトパターンは以下:
** _ison_
** _list_
** _mode_channel_
** _mode_channel_ban_ ("mode #channel b")
** _mode_channel_ban_exception_ ("mode #channel e")
** _mode_channel_invite_ ("mode #channel I")
** _mode_user_
** _monitor_
** _names_
** _ping_
** _time_
** _topic_
** _userhost_
** _who_
** _whois_
** _whowas_
* _signal_: シグナル名 (必須)
* _count_: 転送を行う回数 (任意、デフォルトは 1 回)
* _string_: 受信する irc メッセージに含まれる文字列
  (任意ですが推奨します、この文字列を含むメッセージだけを転送します)
* _timeout_: 転送のタイムアウト、秒単位 (任意、デフォルトは 60)
* _cmd_filter_: フィルタする irc コマンドのコンマ区切りリスト
  (これらのコマンドはコールバックに送信されます、これ以外のコマンドは無視されます) (任意)

この hsignal を送信したら必ずその直後に irc
サーバにコマンドを送信してください、そうすれば送信したコマンドに対する応答が転送されます。

コマンドに対する応答を完全に受信したら、hsignal が送信されます。この
hsignal は _irc_redirection_xxx_yyy_ という名前で、ここで _xxx_ は
_signal_、_yyy_ は _pattern_ で指定したものになります。

以下の内容からなるハッシュテーブルが hsignal で送信されます (キーと値は文字列):

* _output_: コマンドの出力 (メッセージは "\n" で区切られています)
* _output_size_: _output_ のバイト数 (文字列)
* _error_: エラー文字列 (エラーが起きた場合):
** _timeout_: タイムアウトで転送を中止
* _server_: 内部サーバ名
* _pattern_: 転送パターン
* _signal_: シグナル名
* _command_: リダイレクトされたコマンド

C 言語での使用例:

[source,c]
----
int
test_whois_cb (const void *pointer, void *data, const char *signal,
               struct t_hashtable *hashtable)
{
    weechat_printf (NULL, "error = %s", weechat_hashtable_get (hashtable, "error"));
    weechat_printf (NULL, "output = %s", weechat_hashtable_get (hashtable, "output"));
    return WEECHAT_RC_OK;
}

weechat_hook_hsignal ("irc_redirection_test_whois", &test_whois_cb, NULL, NULL);
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
if (hashtable)
{
    weechat_hashtable_set (hashtable, "server", "libera");
    weechat_hashtable_set (hashtable, "pattern", "whois");
    weechat_hashtable_set (hashtable, "signal", "test");
    weechat_hashtable_set (hashtable, "string", "FlashCode");
    weechat_hook_hsignal_send ("irc_redirect_command", hashtable);
    weechat_hook_signal_send ("irc_input_send", WEECHAT_HOOK_SIGNAL_STRING,
                              "libera;;2;;/whois FlashCode");
    weechat_hashtable_free (hashtable);
}
----

スクリプト (Python) での使用例:

[source,python]
----
def test_whois_cb(data: str, signal: str, hashtable: Dict[str, str]) -> int:
    weechat.prnt("", "error = %s" % hashtable["error"])
    weechat.prnt("", "output = %s" % hashtable["output"])
    return weechat.WEECHAT_RC_OK

weechat.hook_hsignal("irc_redirection_test_whois", "test_whois_cb", "")
weechat.hook_hsignal_send("irc_redirect_command",
                          {"server": "libera", "pattern": "whois", "signal": "test",
                           "string": "FlashCode"})
weechat.hook_signal_send("irc_input_send", weechat.WEECHAT_HOOK_SIGNAL_STRING,
                         "libera;;2;;/whois FlashCode")
----

[[hsignal_irc_redirect_pattern]]
===== Hsignal irc_redirect_pattern

_WeeChat バージョン 0.3.4 以上で利用可。_

hsignal "irc_redirect_pattern" は irc 転送用のパターンを作成するために送信します
(<<hsignal_irc_redirect_command>> を参照)。

引数は以下のエントリを持つハッシュテーブルです (キーと値は文字列):

* _pattern_: パターンの名前 (必須)
* _timeout_: パターンのデフォルトタイムアウト、秒単位 (任意、デフォルトは 60)
* _cmd_start_: 転送を開始するコマンドのコンマ区切りリスト (任意)
* _cmd_stop_: 転送を終了するコマンドのコンマ区切りリスト (必須)
* _cmd_extra_: コマンドを停止した後に受信する可能性のあるコマンドのコンマ区切りリスト
  (任意)

_cmd_start_、_cmd_stop_、_cmd_extra_
には受け取ったメッセージに必ず含まれていなければいけない
"string" の位置を示す整数を与えることが可能、例:

----
352:1,354,401:1
----

コマンド 352 と 401 の応答は最初の受信メッセージの第
1 引数に "string" が含まれていなければいけません。

[IMPORTANT]
パターンは転送で使われた後に破棄されます、複数回の転送でパターンを必要な場合は、転送前に毎回必ずパターンを作ってください。

C 言語での使用例:

[source,c]
----
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
if (hashtable)
{
    weechat_hashtable_set (hashtable, "pattern", "my_whois");
    weechat_hashtable_set (hashtable, "timeout", "30");
    weechat_hashtable_set (hashtable, "cmd_start", "311:1");
    weechat_hashtable_set (hashtable, "cmd_stop", "318:1,401:1,402:1,431:1,461");
    weechat_hashtable_set (hashtable, "cmd_extra", "318:1");
    weechat_hook_hsignal_send ("irc_redirect_pattern", hashtable);
    /*
     * now redirect irc whois command with hsignal irc_redirect_command,
     * using pattern "my_whois"
     */
    /* ... */
    weechat_hashtable_free (hashtable);
}
----

スクリプト (Python) での使用例:

[source,python]
----
weechat.hook_hsignal_send("irc_redirect_pattern",
                          {"pattern": "my_whois", "timeout": "30",
                           "cmd_start": "311:1",
                           "cmd_stop": "318:1,401:1,402:1,431:1,461",
                           "cmd_extra": "318:1"})
# now redirect irc whois command with hsignal irc_redirect_command
# using pattern "my_whois"
# ...
----

==== hook_config

_WeeChat バージョン 1.5 で更新。_

設定オプションをフック。

プロトタイプ:

[source,c]
----
struct t_hook *weechat_hook_config (const char *option,
                                    int (*callback)(const void *pointer,
                                                    void *data,
                                                    const char *option,
                                                    const char *value),
                                    const void *callback_pointer,
                                    void *callback_data);
----

引数:

// TRANSLATION MISSING
* _option_: オプション、書式は完全な名前、コマンド `/set` で使うのと同じ
  (例: `+weechat.look.item_time_format+`)、ワイルドカード `+*+` を使うことができます
  (a priority is allowed before the option, see note about <<hook_priority,priority>>)
* _callback_:
  設定オプションが変更されたら呼び出すコールバック関数、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _const char *option_: オプションの名前
** _const char *value_: オプションの新しい値
** 戻り値:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_pointer_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_data_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したフックが削除された時点で自動的に開放されます

戻り値:

* 新しいフックへのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
int
my_config_cb (const void *pointer, void *data, const char *option,
              const char *value)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* catch changes to option "weechat.look.item_time_format" */
struct t_hook *my_config_hook = weechat_hook_config ("weechat.look.item_time_format",
                                                     &my_config_cb, NULL, NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hook_config(option: str, callback: str, callback_data: str) -> str: ...

# 例
def my_config_cb(data: str, option: str, value: str) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

# catch changes to option "weechat.look.item_time_format"
hook = weechat.hook_config("weechat.look.item_time_format", "my_config_cb", "")
----

==== hook_modifier

_WeeChat バージョン 1.5 で更新。_

修飾子をフック。

プロトタイプ:

[source,c]
----
struct t_hook *weechat_hook_modifier (const char *modifier,
                                      char *(*callback)(const void *pointer,
                                                        void *data,
                                                        const char *modifier,
                                                        const char *modifier_data,
                                                        const char *string),
                                      const void *callback_pointer,
                                      void *callback_data);
----

引数:

// TRANSLATION MISSING
* _modifier_: modifier name
  (a priority is allowed before the modifier, see note about <<hook_priority,priority>>)
  (以下の表を参照)
* _callback_: 修飾子が使われた際に呼び出すコールバック関数、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _const char *modifier_: 修飾子の名前
** _const char *modifier_data_: 修飾子に渡すデータ
** _const char *string_: 修飾子に渡す文字列
** 戻り値: 新しい文字列
* _callback_pointer_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_data_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したフックが削除された時点で自動的に開放されます

戻り値:

* 新しいフックへのポインタ、エラーが起きた場合は NULL

WeeChat とプラグインが使う修飾子のリスト:

[width="100%",cols="^2,^1,3,4,4",options="header"]
|===
// TRANSLATION MISSING
| 修飾子 | Min WeeChat | 修飾子データ | 文字列 | 出力

// TRANSLATION MISSING
| [[hook_modifier_irc_batch]] irc_batch | 4.0.0
| Server name + "," + batch type + "," + batch parameters
| Content of multiple messages, separated by a newline char ("\n").
| New content of messages (number can be different), an empty string discards
  all messages in the batch.

// TRANSLATION MISSING
| [[hook_modifier_irc_cap_sync_req]] irc_cap_sync_req | 4.0.0
| Server name + "," + supported capabilities on server (separated by spaces)
| Capabilities to request (separated by spaces).
| New content of capabilities to request (separated by spaces).

// TRANSLATION MISSING
| [[hook_modifier_irc_in_xxx]] irc_in_xxx ^(1)^ |
| サーバ名
| IRC サーバから受信したメッセージの内容 (文字セットをデコードする前) +
  *Warning:* the string may contain invalid UTF-8 data; use only for raw
  operations on a message.
  Modifier <<hook_modifier_irc_in2_xxx,irc_in2_xxx>> is recommended instead.
| メッセージの新しい内容

| [[hook_modifier_irc_in2_xxx]] irc_in2_xxx ^(1)^ | 0.3.5
| サーバ名
| IRC サーバから受信したメッセージの内容 (文字セットをデコードした後)
| メッセージの新しい内容

| [[hook_modifier_irc_out1_xxx]] irc_out1_xxx ^(1)^ | 0.3.7
| サーバ名
| IRC サーバに送信するメッセージの内容
  (自動分割前、自動分割はデフォルトでメッセージを 512 バイト内に収まるように分割します)。|
  メッセージの新しい内容

| [[hook_modifier_irc_out_xxx]] irc_out_xxx ^(1)^ |
| サーバ名
| IRC サーバに送信するメッセージの内容
  (自動分割後、自動分割はデフォルトでメッセージを 512 バイト内に収まるように分割します)。|
  メッセージの新しい内容

// TRANSLATION MISSING
| [[hook_modifier_relay_client_irc_in]] relay_client_irc_in | 4.0.0
| String with relay client pointer (eg: "0x1234abcd")
| Content of message received from relay IRC client.
| New content of message.

// TRANSLATION MISSING
| [[hook_modifier_relay_client_irc_out1]] relay_client_irc_out1 | 4.0.0
| String with relay client pointer (eg: "0x1234abcd")
| Content of message about to be sent to relay IRC client before automatic split
  (to fit in 512 bytes by default).
| New content of message.

// TRANSLATION MISSING
| [[hook_modifier_relay_client_irc_out]] relay_client_irc_out | 4.0.0
| String with relay client pointer (eg: "0x1234abcd")
| Content of message about to be sent to relay IRC client after automatic split
  (to fit in 512 bytes by default).
| New content of message.

// TRANSLATION MISSING
| [[hook_modifier_bar_condition_yyy]] bar_condition_yyy ^(2)^ |
| ウィンドウへのポインタの文字列 (eg: "0x1234abcd")
| 空文字列
| バーを表示する場合は "1"、隠す場合は "0"

// TRANSLATION MISSING
| [[hook_modifier_history_add]] history_add | 0.3.2
| バッファへのポインタの文字列 (eg: "0x1234abcd")
| コマンド履歴に追加するコマンドラインの内容 (バッファとグローバル履歴)
| コマンド履歴に追加した文字列

// TRANSLATION MISSING
| [[hook_modifier_input_text_content]] input_text_content |
| バッファへのポインタの文字列 (eg: "0x1234abcd")
| コマンドラインの内容
| コマンドラインの新しい内容

// TRANSLATION MISSING
| [[hook_modifier_input_text_display]] input_text_display |
| バッファへのポインタの文字列 (eg: "0x1234abcd")
| カーソルタグを含まないコマンドラインの内容
| 新しい文字列、表示のみ (コマンドラインは変化しない)

// TRANSLATION MISSING
| [[hook_modifier_input_text_display_with_cursor]] input_text_display_with_cursor |
| バッファへのポインタの文字列 (eg: "0x1234abcd")
| カーソルタグを含むコマンドラインの内容
| 新しい文字列、表示のみ (コマンドラインは変化しない)

// TRANSLATION MISSING
| [[hook_modifier_input_text_for_buffer]] input_text_for_buffer | 0.3.7
| バッファへのポインタの文字列 (eg: "0x1234abcd")
| バッファに送信するコマンドラインの内容 (テキストまたはコマンド)
| バッファに送信するコマンドラインの新しい内容

// TRANSLATION MISSING
| [[hook_modifier_weechat_print]] weechat_print |
| buffer pointer (eg: "0x1234abcd") + ";" + tags ^(3)^
| 表示されたメッセージ
| 表示される新しいメッセージ +
  行が表示される際に呼び出されるフックについての詳細は
  <<_hook_line,hook_line>> を参照してください
|===

// TRANSLATION MISSING
[NOTE]
^(1)^ _xxx_ は IRC コマンド名。 +
^(2)^ _yyy_ はバーの名前。 +
^(3)^ With WeeChat ≤ 2.8, the format was: plugin + ";" + buffer_name + ";" + tags.

C 言語での使用例:

[source,c]
----
char *
my_modifier_cb (const void *pointer, void *data, const char *modifier,
                const char *modifier_data,
                const char *string)
{
    char *result;
    int length;

    if (!string)
        return NULL;

    length = strlen (string) + 5;
    result = malloc (length);
    if (result)
    {
        /* add "xxx" to any message printed */
        snprintf (result, length, "%s xxx", string);
    }

    return result;
}

struct t_hook *my_modifier_hook = weechat_hook_modifier ("weechat_print",
                                                         &my_modifier_cb, NULL, NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hook_modifier(modifier: str, callback: str, callback_data: str) -> str: ...

# 例
def my_modifier_cb(data: str, modifier: str, modifier_data: str, string: str) -> str:
    return "%s xxx" % string

hook = weechat.hook_modifier("weechat_print", "my_modifier_cb", "")
----

==== hook_modifier_exec

修飾子を実行。

プロトタイプ:

[source,c]
----
char *weechat_hook_modifier_exec (const char *modifier,
                                  const char *modifier_data,
                                  const char *string);
----

引数:

* _modifier_: 修飾子の名前
* _modifier_data_: 修飾子に渡すデータ
* _string_: 修正する文字列

戻り値:

* 修正された文字列、エラーが起きた場合は NULL

WeeChat とプラグインが定義する修飾子のリスト:

[width="100%",cols="^2,^1,3,4,4",options="header"]
|===
// TRANSLATION MISSING
| 修飾子 | Min WeeChat | 修飾子データ | 文字列 | 出力

| [[hook_modifier_charset_decode]] charset_decode |
| plugin.buffer_name
| 任意の文字列
| プラグインおよびバッファの文字セットから UTF-8 にデコードされた文字列

| [[hook_modifier_charset_encode]] charset_encode |
| plugin.buffer_name
| 任意の文字列
| UTF-8 からプラグインおよびバッファの文字セットにエンコードされた文字列

| [[hook_modifier_irc_color_decode]] irc_color_decode |
| 色を保持する場合は "1"、削除する場合は "0"
| 任意の文字列
| WeeChat 色コードに変換された IRC 色コードを含む (または IRC 色コードを削除された) 文字列

| [[hook_modifier_irc_color_encode]] irc_color_encode |
| 色を保持する場合は "1"、削除する場合は "0"
| 任意の文字列
| IRC 色コードを含む (または IRC 色コードを削除された) 文字列

| [[hook_modifier_irc_color_decode_ansi]] irc_color_decode_ansi | 1.0
| 色を保持する場合は "1"、削除する場合は "0"
| 任意の文字列
| IRC 色コードに変換された ANSI 色コードを含む (または ANSI 色コードを削除された) 文字列

| [[hook_modifier_irc_command_auth]] irc_command_auth | 0.4.1
| サーバ名
| 認証コマンド (例: `+/msg nickserv identify password+`)
| パスワードを隠したコマンド (例: `+/msg nickserv identify ********+`)

| [[hook_modifier_irc_message_auth]] irc_message_auth | 0.4.1
| サーバ名
| `/msg` をサーバに送信した後に表示されるメッセージ
| パスワードを隠したメッセージ

// TRANSLATION MISSING
| [[hook_modifier_irc_tag_escape_value]] irc_tag_escape_value | 3.3
| -
| Any string.
| String with IRC tag value escaped,
  see https://ircv3.net/specs/extensions/message-tags#escaping-values[this page ^↗^^].

// TRANSLATION MISSING
| [[hook_modifier_irc_tag_unescape_value]] irc_tag_unescape_value | 3.3
| -
| Any string.
| String with IRC tag value unescaped,
  see https://ircv3.net/specs/extensions/message-tags#escaping-values[this page ^↗^^].

// TRANSLATION MISSING
| [[hook_modifier_color_decode]] color_decode | 4.3.0
| Replacement string for colors removed
| Any string.
| String with WeeChat colors converted to a replacement string
  (colors stripped if the replacement string is empty).

| [[hook_modifier_color_decode_ansi]] color_decode_ansi | 1.0
| 色を保持する場合は "1"、削除する場合は "0"
| 任意の文字列
| WeeChat 色コードに変換された ANSI 色コードを含む (または ANSI 色コードを削除された) 文字列

// TRANSLATION MISSING
| [[hook_modifier_color_encode_ansi]] color_encode_ansi | 2.7
| -
| 任意の文字列
| String with WeeChat colors converted to ANSI colors.

// TRANSLATION MISSING
| [[hook_modifier_eval_path_home]] eval_path_home | 2.7
| Optional: `directory=xxx` where `xxx` can be: `config`, `data`, `cache`, `runtime`
| Any string.
| Evaluated path, result of the function
  <<_string_eval_path_home,string_eval_path_home>>.
|===

C 言語での使用例:

[source,c]
----
char *new_string = weechat_hook_modifier_exec ("my_modifier",
                                               my_data, my_string);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hook_modifier_exec(modifier: str, modifier_data: str, string: str) -> str: ...

# 例
weechat.hook_modifier_exec("my_modifier", my_data, my_string)
----

==== hook_info

_WeeChat バージョン 1.5, 2.5 で更新。_

インフォをフック (コールバックを呼び出し、文字列を返す)。

プロトタイプ:

[source,c]
----
struct t_hook *weechat_hook_info (const char *info_name,
                                  const char *description,
                                  const char *args_description,
                                  char *(*callback)(const void *pointer,
                                                    void *data,
                                                    const char *info_name,
                                                    const char *arguments),
                                  const void *callback_pointer,
                                  void *callback_data);
----

引数:

// TRANSLATION MISSING
* _info_name_: インフォの名前
  (a priority is allowed before the info name, see note about <<hook_priority,priority>>)
* _description_: 説明
* _args_description_: 引数の説明 (任意、NULL にすることも可)
* _callback_: インフォが要求されたら呼び出すコールバック関数、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _const char *info_name_: インフォの名前
** _const char *arguments_: 追加の引数、インフォに依存
** 戻り値: 要求されたインフォの値
* _callback_pointer_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_data_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したフックが削除された時点で自動的に開放されます

戻り値:

* 新しいフックへのポインタ、エラーが起きた場合は NULL

[NOTE]
WeeChat バージョン 2.5 以上の場合、コールバックは確保された文字列を返します
(WeeChat バージョン 2.4 以下の場合、コールバックは定数文字列へのポインタを返します)。

C 言語での使用例:

[source,c]
----
char *
my_info_cb (const void *pointer, void *data, const char *info_name,
            const char *arguments)
{
    /* ... */
    return strdup ("some_info");
}

/* add info "my_info" */
struct t_hook *my_info_hook = weechat_hook_info ("my_info",
                                                 "Some info",
                                                 "Info about arguments",
                                                 &my_info_cb, NULL, NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hook_info(info_name: str, description: str, args_description: str,
              callback: str, callback_data: str) -> str: ...

# 例
def my_info_cb(data: str, info_name: str, arguments: str) -> str:
    return "some_info"

hook = weechat.hook_info("my_info", "Some info", "Info about arguments",
                         "my_info_cb", "")
----

==== hook_info_hashtable

_WeeChat バージョン 0.3.4 以上で利用可、バージョン 1.5 で更新。_

インフォをフック (コールバックを呼び出し、ハッシュテーブルを返す)。

プロトタイプ:

[source,c]
----
struct t_hook *weechat_hook_info_hashtable (const char *info_name,
                                            const char *description,
                                            const char *args_description,
                                            const char *output_description,
                                            struct t_hashtable *(*callback)(const void *pointer,
                                                                            void *data,
                                                                            const char *info_name,
                                                                            struct t_hashtable *hashtable),
                                            const void *callback_pointer,
                                            void *callback_data);
----

引数:

// TRANSLATION MISSING
* _info_name_: インフォの名前
  (a priority is allowed before the info name, see note about <<hook_priority,priority>>)
* _description_: 説明
* _args_description_: 引数ハッシュテーブルの説明 (任意、NULL でも可)
* _output_description_: コールバックが返すハッシュテーブルの説明
  (任意、NULL でも可)
* _callback_: インフォを要求する際に呼び出すコールバック関数、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _const char *info_name_: インフォの名前
** _struct t_hashtable *hashtable_: ハッシュテーブル、インフォに依存
** 戻り値: 要求したハッシュテーブル
* _callback_pointer_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_data_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したフックが削除された時点で自動的に開放されます

戻り値:

* 新しいフックへのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
struct t_hashtable *
my_info_hashtable_cb (const void *pointer, void *data, const char *info_name,
                      struct t_hashtable *hashtable)
{
    /* ... */
    return pointer_to_new_hashtable;
}

/* add info "my_info_hashtable" */
struct t_hook *my_info_hook = weechat_hook_info_hashtable ("my_info_hashtable",
                                                           "Some info",
                                                           "Info about input hashtable",
                                                           "Info about output hashtable",
                                                           &my_info_hashtable_cb, NULL, NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hook_info_hashtable(info_name: str, description: str, args_description: str,
                        output_description: str, callback: str, callback_data: str) -> str: ...

# 例
def my_info_hashtable_cb(data: str, info_name: str, hashtable: Dict[str, str]) -> Dict[str, str]:
    return {"test_key": "test_value"}

hook = weechat.hook_info_hashtable("my_info_hashtable", "Some info",
                                   "Info about input hashtable",
                                   "Info about output hashtable",
                                   "my_info_hashtable_cb", "")
----

==== hook_infolist

_WeeChat バージョン 1.5 で更新。_

インフォリストをフック: コールバックは要求したインフォリストへのポインタを返す。

プロトタイプ:

[source,c]
----
struct t_hook *weechat_hook_infolist (const char *infolist_name,
                                      const char *description,
                                      const char *pointer_description,
                                      const char *args_description,
                                      struct t_infolist *(*callback)(const void *pointer,
                                                                     void *data,
                                                                     const char *infolist_name,
                                                                     void *obj_pointer,
                                                                     const char *arguments),
                                      const void *callback_pointer,
                                      void *callback_data);
----

引数:

// TRANSLATION MISSING
* _infolist_name_: インフォリストの名前
  (a priority is allowed before the infolist name, see note about <<hook_priority,priority>>)
* _description_: 説明
* _pointer_description_: ポインタの説明 (任意、NULL でも可)
* _args_description_: 引数の説明 (任意、NULL でも可)
* _callback_:
  インフォリストが要求された際に呼び出すコールバック関数、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _const char *infolist_name_: インフォリストの名前
** _void *pointer_: インフォリストが返すオブジェクトへのポインタ
   (インフォリストの要素を 1 つだけ返す)
** _const char *arguments_: 追加の引数、インフォリストに依存
** 戻り値: 要求したインフォリスト
* _callback_pointer_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_data_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したフックが削除された時点で自動的に開放されます

戻り値:

* 新しいフックへのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
struct t_infolist *
my_infolist_cb (const void *pointer, void *data, const char *infolist_name,
                void *obj_pointer, const char *arguments)
{
    struct t_infolist *my_infolist;

    /* インフォリストを作成 */
    /* ... */

    return my_infolist;
}

/* インフォリスト "my_infolist" を追加 */
struct t_hook *my_infolist = weechat_hook_infolist ("my_infolist",
                                                    "Infolist with some data",
                                                    "Info about pointer",
                                                    "Info about arguments",
                                                    &my_infolist_cb, NULL, NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hook_infolist(infolist_name: str, description: str, pointer_description: str,
                  args_description: str, callback: str, callback_data: str) -> str: ...

# 例
def my_infolist_cb(data: str, infolist_name: str, pointer: str, arguments: str) -> str:
    # build infolist
    # ...
    return my_infolist

hook = weechat.hook_infolist("my_infolist", "Infolist with some data",
                             "Info about pointer", "Info about arguments",
                             "my_infolist_cb", "")
----

==== hook_hdata

_WeeChat バージョン 1.5 で更新。_

hdata をフック: コールバックは要求した hdata へのポインタを返す。

プロトタイプ:

[source,c]
----
struct t_hook *weechat_hook_hdata (const char *hdata_name,
                                   const char *description,
                                   struct t_hdata *(*callback)(const void *pointer,
                                                               void *data,
                                                               const char *hdata_name),
                                   const void *callback_pointer,
                                   void *callback_data);
----

引数:

// TRANSLATION MISSING
* _hdata_name_: hdata の名前
  (a priority is allowed before the hdata name, see note about <<hook_priority,priority>>)
* _description_: 説明
* _callback_:
  hdata が要求された際に呼び出すコールバック関数、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _const char *hdata_name_: hdata の名前
** 戻り値: 要求された hdata
* _callback_pointer_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_data_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したフックが削除された時点で自動的に開放されます

戻り値:

* 新しいフックへのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
struct t_hdata *
my_hdata_cb (const void *pointer, void *data, const char *hdata_name)
{
    struct t_hdata *my_hdata;

    /* build hdata */
    /* ... */

    return my_hdata;
}

/* add hdata "my_hdata" */
struct t_hook *my_hdata = weechat_hook_hdata ("my_hdata",
                                              "Hdata for my structure",
                                              &my_hdata_cb, NULL, NULL);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== hook_focus

_WeeChat バージョン 1.5, 4.0.0, 4.1.0 で更新。_

フォーカス (マウスイベントやカーソルモード
(カーソルが自由に移動出来る状態) でキーが押されたこと) をフック。

プロトタイプ:

[source,c]
----
struct t_hook *weechat_hook_focus (const char *area,
                                   struct t_hashtable *(*callback)(const void *pointer,
                                                                   void *data,
                                                                   struct t_hashtable *info),
                                   const void *callback_pointer,
                                   void *callback_data);
----

引数:

// TRANSLATION MISSING
* _area_: チャットエリアの場合は "chat"、またはバー要素の名前
  (a priority is allowed before the area, see note about <<hook_priority,priority>>)
* _callback_:
  フォーカスが当たったら呼び出すコールバック関数、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _struct t_hashtable *info_: フォーカスの情報を含むハッシュテーブルと、他の
   (より高い優先度を持つ) フォーカスコールバックを呼び出して返された文字列 (以下のテーブルを参照)
** 戻り値: "info" ポインタ (完全なハッシュテーブル)
   または新しいハッシュテーブル (コールバックが作成、キーと値は
   "string" 型) へのポインタ、この新しいハッシュテーブルの内容は
   _info_ に追加され、他のフォーカスコールバックに渡されます
* _callback_pointer_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_data_: WeeChat が _callback_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したフックが削除された時点で自動的に開放されます

[IMPORTANT]
マウスジェスチャの場合、コールバックを 2 回呼び出します: 1
回目はボタンが押された時 (この時のエリアはジェスチャ対象のエリアです)、2
回目はボタンが離された時 (この時のエリアはマスジェスチャを開始したエリアとは異なる場合があります):
このため、必ず *毎回* コールバックをテストして、ハッシュテーブルに含まれる
info を使う前にエリアが一致していることを確認して下さい。

コールバックに送られるハッシュテーブルの内容 (キーと値は "string" 型):

[width="100%",cols="5,5,8,3",options="header"]
|===
| キー ^(1)^ | 説明 | 値の例 | 定義できない場合の値

| _x | 画面上での列座標
| "0" ... "n" |

| _y | 画面上での行座標
| "0" ... "n" |

| _key | キーまたはマウスイベント
| "button1"、"button2-gesture-left"、... |

| _window | ウィンドウへのポインタ
| "0x1234abcd" | ""

| _window_number | ウィンドウの番号
| "1" ... "n" | "*"

| _buffer | バッファへのポインタ
| "0x1234abcd" | ""

| _buffer_number | バッファの番号
| "1" ... "n" | "-1"

| _buffer_plugin | バッファのプラグイン名
| "core"、"irc"、... | ""

| _buffer_name | バッファの名前
| "weechat"、"libera.#weechat"、... | ""

| _buffer_full_name | バッファの完全な名前
| "core.weechat"、"irc.libera.#weechat"、... | ""

| _buffer_localvar_XXX ^(2)^ | バッファのローカル変数
| 任意の値 | 未定義

| _chat | チャットエリアインジケータ
| "0" または "1" | "0"

| _chat_line | 行へのポインタ _(WeeChat バージョン 1.2 以上で利用可)_
| "0x1234abcd" | ""

| _chat_line_x | 行中の列番号 ^(3)^
| "0" ... "n" | "-1"

| _chat_line_y | 行番号 ^(3)^
| "0" ... "n" | "-1"

| _chat_line_date | 日付/時間の行
| "1313237175" | "0"

// TRANSLATION MISSING
| _chat_line_date_usec | Microseconds of line date/time.
| "123456" | "0"

| _chat_line_date_printed | 日付/時間の行 ^(4)^
| "1313237175" | "0"

// TRANSLATION MISSING
| _chat_line_date_usec_printed | Microseconds of line printed date/time ^(4)^.
| "123456" | "0"

| _chat_line_time | 表示された時間
| "14:06:15" | ""

| _chat_line_tags | 行に設定されたタグ
| "irc_privmsg,nick_flashy,log1" | ""

| _chat_line_nick | 行を発言したニックネーム
| "FlashCode" | ""

| _chat_line_prefix | 行のプレフィックス
| "@FlashCode" | ""

| _chat_line_message | 行のメッセージ部分
| "Hello world!" | ""

// TRANSLATION MISSING
| _chat_focused_line | Line at (x, y) _(WeeChat ≥ 4.0.0)_.
| "Hello world!" | ""

// TRANSLATION MISSING
| _chat_focused_line_bol | Text from beginning of line to (x-1, y) _(WeeChat ≥ 4.1.0)_.
| "Hello" | ""

// TRANSLATION MISSING
| _chat_focused_line_eol | Text from (x, y) to end of line _(WeeChat ≥ 4.1.0)_.
| "llo world!" | ""

| _chat_word | (x,y) の位置にある単語
| "Hello" | ""

// TRANSLATION MISSING
| _chat_bol | Text from beginning of message to (x-1, y).
| "He" | ""

// TRANSLATION MISSING
| _chat_eol | Text from (x, y) to the end of message.
| "llo world!" | ""

| _bar_name | バーの名前
| "title"、"nicklist"、... | ""

| _bar_filling | バーのフィリング
| "horizontal"、"vertical"、... | ""

| _bar_item_name | バー要素の名前
| "buffer_nicklist"、"hotlist"、... | ""

| _bar_item_line | バー要素中の行座標
| "0" ... "n" | "-1"

| _bar_item_col | バー要素中の列座標
| "0" ... "n" | "-1"

// TRANSLATION MISSING
| _bar_window | Pointer to bar window _(WeeChat ≥ 2.9)_.
| "0x1234abcd" | ""
|===

[NOTE]
^(1)^ "2" を後ろにつけたキー (例: "_x2"、"_y2"、"_window2"、...)
には 2 番目の位置に関する情報が収められています
(この値に意味があるマウスジェスチャの時だけで、マウスボタンの離された位置に関する情報が収められています)。 +
^(2)^ `XXX` はバッファのローカル変数の名前です。 +
^(3)^ これは自由内容のバッファで定義されています。 +
^(4)^ WeeChat がバッファに行を追加した日付です
("_chat_line_date" よりも大きいか同じ)。

バー要素 "buffer_nicklist" の追加情報:

[width="100%",cols="^1,^1,5",options="header"]
|===
| プラグイン ^(1)^ | キー     | 説明
| weechat          | nick     | ニックネーム
| weechat          | prefix   | ニックネームのプレフィックス
| weechat          | group    | グループ名
// TRANSLATION MISSING
| irc              | irc_nick | Pointer to IRC nick _(WeeChat ≥ 3.0)_.
| irc              | irc_host | ニックネームのホスト名 (判る場合)
|===

[NOTE]
^(1)^ プラグインの名前は hook_focus
がどのバー要素に関する情報を渡したかを意味しています (したがって、例えばプラグインが
"irc" の場合、ハッシュテーブル info の内容は irc バッファに関するものになります)。

戻り値:

* 新しいフックへのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
struct t_hashtable *
my_focus_nicklist_cb (const void *pointer, void *data, struct t_hashtable *info)
{
    /* add strings in hashtable */
    /* ... */

    return info;
}

/* add focus on nicklist */
struct t_hook *my_focus = weechat_hook_focus ("buffer_nicklist",
                                              &my_focus_nicklist_cb, NULL, NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hook_focus(area: str, callback: str, callback_data: str) -> str: ...

# 例
def my_focus_nicklist_cb(data: str, info: Dict[str, str]) -> Dict[str, str]:
    # build dict
    # ...
    return my_dict

hook = weechat.hook_focus("buffer_nicklist", "my_focus_nicklist_cb", "")
----

==== hook_set

_WeeChat バージョン 0.3.9 以上で利用可 (スクリプト: WeeChat バージョン 0.4.3 以上で利用可)。_

フックプロパティの文字列値を設定。

プロトタイプ:

[source,c]
----
void weechat_hook_set (struct t_hook *hook, const char *property,
                       const char *value);
----

引数:

* _hook_: "weechat_hook_xxx()" の戻り値
* _property_: プロパティ名 (以下の表を参照)
* _value_: プロパティの新しい値

プロパティ:

[width="100%",cols="^1,^1,2,2,5",options="header"]
|===
// TRANSLATION MISSING
| 名前 | Min WeeChat | フック型 | 値 | 説明

| subplugin | | 任意の型
| 任意の文字列
| サブプラグインの名前 (通常は `/help command` で _command_
  をタイプした時のフックで表示されるスクリプト名)

// TRANSLATION MISSING
| keep_spaces_right | 4.6.0 | _command_, _command_run_
| "0" or "1"
| Keep trailing spaces in command arguments when it is executed.

| stdin | 0.4.3 | _process_、_process_hashtable_ | 任意の文字列
| 子プロセスの標準入力 (_stdin_) にデータを送信

| stdin_close | 0.4.3 | _process_、_process_hashtable_ | (非使用)
| 子プロセスの標準入力 (_stdin_) にデータを送信するパイプを閉じる

| signal | 1.0 | _process_、_process_hashtable_
| シグナル番号または以下の名前から 1 つ:
  `hup`、`int`、`quit`、`kill`、`term`、`usr1`、`usr2`
| 子プロセスにシグナルを送信
|===

C 言語での使用例:

[source,c]
----
struct t_hook *my_command_hook =
    weechat_hook_command ("abcd", "description",
                          "args", "description args",
                          "", &my_command_cb, NULL, NULL);
weechat_hook_set (my_command_hook, "subplugin", "test");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hook_set(hook: str, property: str, value: str) -> int: ...

# 例
def my_process_cb(data: str, command: str, return_code: int, out: str, err: str) -> int:
    # ...
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_process_hashtable("/path/to/command", {"stdin": "1"},
                                      20000, "my_process_cb", "")
weechat.hook_set(hook, "stdin", "data sent to stdin of child process")
weechat.hook_set(hook, "stdin_close", "")  # optional
----

==== unhook

フックを解除。

プロトタイプ:

[source,c]
----
void weechat_unhook (struct t_hook *hook);
----

引数:

* _hook_: "weechat_hook_xxx()" の戻り値

C 言語での使用例:

[source,c]
----
struct t_hook *my_hook = weechat_hook_command ( /* ... */ );
/* ... */
weechat_unhook (my_hook);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def unhook(hook: str) -> int: ...

# 例
weechat.unhook(my_hook)
----

==== unhook_all

_WeeChat バージョン 1.5 で更新。_

現在のプラグインで設定したフックをすべて解除。

プロトタイプ:

[source,c]
----
void weechat_unhook_all (const char *subplugin);
----

引数:

* _subplugin_: これが NULL でない場合、ここで指定した "subplugin" を持つフックだけを解除します
  (スクリプトから API を使う場合にはこの引数を指定できません)

C 言語での使用例:

[source,c]
----
weechat_unhook_all (NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def unhook_all() -> int: ...

# 例
weechat.unhook_all()
----

[[buffers]]
=== バッファ

バッファを作成/検索/閉じる関数

==== buffer_new

_WeeChat バージョン 1.5 で更新。_

新しいバッファを開く。

// TRANSLATION MISSING
[NOTE]
If you want to immediately set buffer properties (buffer type, local variables,
key bindings, etc.), then better use the function <<_buffer_new_props,buffer_new_props>>
which sets these properties during the buffer creation, before sending signal
<<hook_signal_buffer_opened,buffer_opened>>.

プロトタイプ:

[source,c]
----
struct t_gui_buffer *weechat_buffer_new (const char *name,
                                         int (*input_callback)(const void *pointer,
                                                               void *data,
                                                               struct t_gui_buffer *buffer,
                                                               const char *input_data),
                                         const void *input_callback_pointer,
                                         void *input_callback_data,
                                         int (*close_callback)(const void *pointer,
                                                               void *data,
                                                               struct t_gui_buffer *buffer),
                                         const void *close_callback_pointer,
                                         void *close_callback_data);
----

引数:

* _name_: バッファの名前 (プラグインに対して固有)
* _input_callback_:
  入力テキストをバッファに挿入する際に呼び出すコールバック関数、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _struct t_gui_buffer *buffer_: バッファポインタ
** _const char *input_data_: 入力データ
** 戻り値:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _input_callback_pointer_: WeeChat が _input_callback_ コールバックを呼び出す際にコールバックに渡すポインタ
* _input_callback_data_: WeeChat が _input_callback_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したバッファが閉じられた時点で自動的に開放されます
* _close_callback_:
  バッファを閉じる際に呼び出すコールバック関数、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _struct t_gui_buffer *buffer_: バッファポインタ
** 戻り値:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _close_callback_pointer_: WeeChat が _close_callback_
  コールバックを呼び出す際にコールバックに渡すポインタ
* _close_callback_data_: WeeChat が _close_callback_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したバッファが閉じられた時点で自動的に開放されます

戻り値:

* 新しいバッファへのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
int
my_input_cb (const void *pointer, void *data,
             struct t_gui_buffer *buffer, const char *input_data)
{
    weechat_printf (buffer, "Text: %s", input_data);
    return WEECHAT_RC_OK;
}

int
my_close_cb (const void *pointer, void *data, struct t_gui_buffer *buffer)
{
    weechat_printf (NULL, "Buffer _%s_ will be closed!",
                    weechat_buffer_get_string (buffer, "name"));
    return WEECHAT_RC_OK;
}

struct t_gui_buffer *my_buffer = weechat_buffer_new ("my_buffer",
                                                     &my_input_cb, NULL, NULL,
                                                     &my_close_cb, NULL, NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def buffer_new(name: str, input_callback: str, input_callback_data: str,
               close_callback: str, close_callback_data: str) -> str: ...

# 例
def my_input_cb(data: str, buffer: str, input_data: str) -> int:
    weechat.prnt(buffer, "Text: %s" % input_data)
    return weechat.WEECHAT_RC_OK

def my_close_cb(data: str, buffer: str) -> int:
    weechat.prnt("", "Buffer _%s_ will be closed!" % weechat.buffer_get_string(buffer, "name"))
    return weechat.WEECHAT_RC_OK

buffer = weechat.buffer_new("my_buffer", "my_input_cb", "", "my_close_cb", "")
----

==== buffer_new_props

_WeeChat ≥ 3.5_

// TRANSLATION MISSING
Open a new buffer and apply properties.

プロトタイプ:

[source,c]
----
struct t_gui_buffer *weechat_buffer_new_props (const char *name,
                                               struct t_hashtable *properties,
                                               int (*input_callback)(const void *pointer,
                                                                     void *data,
                                                                     struct t_gui_buffer *buffer,
                                                                     const char *input_data),
                                               const void *input_callback_pointer,
                                               void *input_callback_data,
                                               int (*close_callback)(const void *pointer,
                                                                     void *data,
                                                                     struct t_gui_buffer *buffer),
                                               const void *close_callback_pointer,
                                               void *close_callback_data);
----

引数:

* _name_: バッファの名前 (プラグインに対して固有)
// TRANSLATION MISSING
* _properties_: properties to apply
  (see function <<_buffer_set,buffer_set>> for the allowed properties)
* _input_callback_:
  入力テキストをバッファに挿入する際に呼び出すコールバック関数、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _struct t_gui_buffer *buffer_: バッファポインタ
** _const char *input_data_: 入力データ
** 戻り値:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _input_callback_pointer_: WeeChat が _input_callback_ コールバックを呼び出す際にコールバックに渡すポインタ
* _input_callback_data_: WeeChat が _input_callback_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したバッファが閉じられた時点で自動的に開放されます
* _close_callback_:
  バッファを閉じる際に呼び出すコールバック関数、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _struct t_gui_buffer *buffer_: バッファポインタ
** 戻り値:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _close_callback_pointer_: WeeChat が _close_callback_
  コールバックを呼び出す際にコールバックに渡すポインタ
* _close_callback_data_: WeeChat が _close_callback_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したバッファが閉じられた時点で自動的に開放されます

戻り値:

* 新しいバッファへのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

// TRANSLATION MISSING
[source,c]
----
int
my_input_cb (const void *pointer, void *data,
             struct t_gui_buffer *buffer, const char *input_data)
{
    weechat_printf (buffer, "Text: %s", input_data);
    return WEECHAT_RC_OK;
}

int
my_close_cb (const void *pointer, void *data, struct t_gui_buffer *buffer)
{
    weechat_printf (NULL, "Buffer _%s_ will be closed!",
                    weechat_buffer_get_string (buffer, "name"));
    return WEECHAT_RC_OK;
}

struct t_hashtable *properties = weechat_hashtable_new (8,
                                                        WEECHAT_HASHTABLE_STRING,
                                                        WEECHAT_HASHTABLE_STRING,
                                                        NULL,
                                                        NULL);
/* buffer with free content */
weechat_hashtable_set (properties, "type", "free");
/* no logging on this buffer */
weechat_hashtable_set (properties, "localvar_set_no_log", "1");
/* bind key alt-c on this buffer */
weechat_hashtable_set (properties, "key_bind_meta-c", "/my_command");

struct t_gui_buffer *my_buffer = weechat_buffer_new_props ("my_buffer",
                                                           properties,
                                                           &my_input_cb, NULL, NULL,
                                                           &my_close_cb, NULL, NULL);
----

スクリプト (Python) での使用例:

// TRANSLATION MISSING
[source,python]
----
# プロトタイプ
def buffer_new_props(name: str, properties: Dict[str, str],
                     input_callback: str, input_callback_data: str,
                     close_callback: str, close_callback_data: str) -> str: ...

# 例
def my_input_cb(data: str, buffer: str, input_data: str) -> int:
    weechat.prnt(buffer, "Text: %s" % input_data)
    return weechat.WEECHAT_RC_OK

def my_close_cb(data: str, buffer: str) -> int:
    weechat.prnt("", "Buffer _%s_ will be closed!" % weechat.buffer_get_string(buffer, "name"))
    return weechat.WEECHAT_RC_OK

properties = {
    "type": "free",                    # buffer with free content
    "localvar_set_no_log": "1",        # no logging on this buffer
    "key_bind_meta-c": "/my_command",  # bind key alt-c on this buffer
}
buffer = weechat.buffer_new_props("my_buffer", properties, "my_input_cb", "", "my_close_cb", "")
----

==== current_buffer

現在のバッファへのポインタを返す (現在のウィンドウに表示されているバッファ)。

プロトタイプ:

[source,c]
----
struct t_gui_buffer *weechat_current_buffer ();
----

戻り値:

* 現在のバッファへのポインタ

C 言語での使用例:

[source,c]
----
weechat_printf (weechat_current_buffer (), "Text on current buffer");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def current_buffer() -> str: ...

# 例
weechat.prnt(weechat.current_buffer(), "Text on current buffer")
----

==== buffer_search

_WeeChat バージョン 1.0, 4.3.0 で更新。_

// TRANSLATION MISSING
Search a buffer by plugin/name, full name or unique identifier (`id`).

プロトタイプ:

[source,c]
----
struct t_gui_buffer *weechat_buffer_search (const char *plugin,
                                            const char *name);
----

引数:

// TRANSLATION MISSING
* _plugin_: name of plugin, following special values are allowed:
** `+==+`: name 引数でバッファの完全な名前を使う (例:
   `libera.#weechat` ではなく `irc.libera.#weechat`)
   _(WeeChat バージョン 1.0 以上で利用可)_
// TRANSLATION MISSING
** `+==id+`: the name used is the buffer unique identifier (`id`) _(WeeChat ≥ 4.3.0)_
* _name_: バッファの名前、NULL または空文字列の場合、現在のバッファ
  (現在のウィンドウに表示されているバッファ) を返す; 名前が `(?i)`
  で始まる場合、検索は大文字小文字を区別せずに検索 _(WeeChat バージョン 1.0 以上で利用可)_

戻り値:

* 見つかったバッファへのポインタ、見つからない場合 NULL

C 言語での使用例:

[source,c]
----
struct t_gui_buffer *buffer1 = weechat_buffer_search ("irc", "libera.#weechat");
struct t_gui_buffer *buffer2 = weechat_buffer_search ("==", "irc.libera.#test");  /* WeeChat バージョン 1.0 以上で利用可 */
struct t_gui_buffer *buffer3 = weechat_buffer_search ("==id", "1709797810942688");  /* WeeChat バージョン 4.3.0 以上で利用可 */
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def buffer_search(plugin: str, name: str) -> str: ...

# 例
buffer = weechat.buffer_search("my_plugin", "my_buffer")
----

==== buffer_search_main

WeeChat メインバッファ (_core_ バッファ、WeeChat
を実行して最初に表示されるバッファ) を検索。

プロトタイプ:

[source,c]
----
struct t_gui_buffer *weechat_buffer_search_main ();
----

戻り値:

* WeeChat メインバッファ (_core_ バッファ) へのポインタ

C 言語での使用例:

[source,c]
----
struct t_gui_buffer *weechat_buffer = weechat_buffer_search_main ();
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def buffer_search_main() -> str: ...

# 例
buffer = weechat.buffer_search_main()
----

==== buffer_clear

バッファの内容を消去。

プロトタイプ:

[source,c]
----
void weechat_buffer_clear (struct t_gui_buffer *buffer);
----

引数:

* _buffer_: バッファへのポインタ

C 言語での使用例:

[source,c]
----
struct t_gui_buffer *my_buffer = weechat_buffer_search ("my_plugin",
                                                        "my_buffer");
if (my_buffer)
{
    weechat_buffer_clear (my_buffer);
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def buffer_clear(buffer: str) -> int: ...

# 例
buffer = weechat.buffer_search("my_plugin", "my_buffer")
if buffer:
    weechat.buffer_clear(buffer)
----

==== buffer_close

バッファを閉じる。

プロトタイプ:

[source,c]
----
void weechat_buffer_close (struct t_gui_buffer *buffer);
----

引数:

* _buffer_: バッファへのポインタ

C 言語での使用例:

[source,c]
----
struct t_gui_buffer *my_buffer = weechat_buffer_new ("my_buffer",
                                                     &my_input_cb, NULL,
                                                     &my_close_cb, NULL);
/* ... */
weechat_buffer_close (my_buffer);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def buffer_close(buffer: str) -> int: ...

# 例
buffer = weechat.buffer_new("my_buffer", "my_input_cb", "", "my_close_cb", "")
# ...
weechat.buffer_close(buffer)
----

==== buffer_merge

バッファを他のバッファにマージする:
両方のバッファは同じバッファ番号を持つ独立したバッファになり、WeeChat
は両方のバッファからの行を表示する (行は混合されます)。

プロトタイプ:

[source,c]
----
void weechat_buffer_merge (struct t_gui_buffer *buffer,
                           struct t_gui_buffer *target_buffer);
----

引数:

* _buffer_: バッファへのポインタ
* _target_buffer_: ターゲットバッファ、マージ先のバッファ

C 言語での使用例:

[source,c]
----
/* merge current buffer with weechat "core" buffer */
weechat_buffer_merge (weechat_current_buffer (),
                      weechat_buffer_search_main ());
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def buffer_merge(buffer: str, target_buffer: str) -> int: ...

# 例
# merge current buffer with WeeChat "core" buffer
weechat.buffer_merge(weechat.current_buffer(), weechat.buffer_search_main())
----

==== buffer_unmerge

マージされたバッファからバッファのマージを解除する。

プロトタイプ:

[source,c]
----
void weechat_buffer_unmerge (struct t_gui_buffer *buffer,
                             int number);
----

引数:

* _buffer_: バッファへのポインタ
* _number_: 分離したバッファの宛先番号、1
  より小さい場合、バッファは _buffer_ の番号 + 1 になる

C 言語での使用例:

[source,c]
----
weechat_buffer_unmerge (weechat_current_buffer (), 1);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def buffer_unmerge(buffer: str, number: int) -> int: ...

# 例
weechat.buffer_unmerge(weechat.current_buffer(), 1)
----

==== buffer_get_integer

バッファプロパティの整数値を返す。

プロトタイプ:

[source,c]
----
int weechat_buffer_get_integer (struct t_gui_buffer *buffer,
                                const char *property);
----

引数:

* _buffer_: バッファへのポインタ
* _property_: プロパティ名:
// TRANSLATION MISSING
** _opening_: 1 if buffer is opening, otherwise 0 _(WeeChat ≥ 4.2.0)_
** _number_: バッファの番号 (1 以上)
** _layout_number_: レイアウトに保存されたバッファの番号
** _layout_number_merge_order_: レイアウトのマージをする際の順番
** _type_: バッファタイプ (0: 書式あり、1: 自由内容)
** _notify_: バッファの通知レベル
** _num_displayed_: バッファを表示しているウィンドウの数
** _active_: バッファがマージされて選択されている場合は 2、バッファが選択されている場合は 1、バッファがマージされ選択されていない場合は 0
** _hidden_: バッファが隠されている場合は 1、そうでない場合は 0 _(WeeChat バージョン 1.0 以上で利用可)_
** _zoomed_: バッファがマージとズームされている場合は 1、そうでない場合は 0 _(WeeChat バージョン 1.0 以上で利用可)_
** _print_hooks_enabled_: プリントフックが有効化されている場合は 1、そうでない場合は 0
** _day_change_: 日付変更メッセージを表示する場合は 1、そうでない場合は 0 _(WeeChat バージョン 0.4.3 以上で利用可)_
** _clear_: コマンド `/buffer clear` でバッファをクリアできる場合は 1、そうでない場合は 0 _(WeeChat バージョン 1.0 以上で利用可)_
** _filter_: バッファでフィルタが有効な場合は 1、そうでない場合は 0 _(WeeChat バージョン 1.0 以上で利用可)_
// TRANSLATION MISSING
** _closing_: 1 if buffer is closing, otherwise 0 _(WeeChat ≥ 1.0)_
** _lines_hidden_: バッファに非表示 (フィルタされた) メッセージが 1 行以上含まれる場合は 1、すべてのメッセージが表示冴えている場合は 0
** _prefix_max_length_: バッファプレフィックスの最大長
// TRANSLATION MISSING
** _next_line_id_: next line id in buffer _(WeeChat ≥ 3.8)_
** _time_for_each_line_: バッファの各行に時間を表示する場合は 1 (デフォルト)、そうでない場合は 0
** _nicklist_: ニックネームリストが有効化されている場合は 1、そうでない場合は 0
** _nicklist_case_sensitive_: ニックネームの大文字小文字を区別する場合は 1、そうでない場合は 0
** _nicklist_max_length_: ニックネームの最大長
** _nicklist_display_groups_: グループを表示する場合 1、そうでない場合は 0
** _nicklist_count_: ニックネームリストに含まれるニックネームとグループの数
// TRANSLATION MISSING
** _nicklist_visible_count_: number of nicks/groups displayed
** _nicklist_groups_count_: ニックネームリストに含まれるグループの数
// TRANSLATION MISSING
** _nicklist_groups_visible_count_: number of groups displayed
** _nicklist_nicks_count_: ニックネームリストに含まれるニックネームの数
// TRANSLATION MISSING
** _nicklist_nicks_visible_count_: number of nicks displayed
** _input_: 入力可能な場合は 1、そうでない場合は 0
// TRANSLATION MISSING
** _input_get_any_user_data_: 1 if any user data, including commands, are sent to input callback, otherwise 0
** _input_get_unknown_commands_: 未定義のコマンドを入力コールバックに送信する場合は 1、そうでない場合は 0
** _input_get_empty_: 入力コールバックに何も送信されなかった場合は 1、そうでない場合は 0
// TRANSLATION MISSING
** _input_multiline_: 1 if multiple lines are sent as one message to input callback, otherwise 0
** _input_size_: 入力サイズ (バイト単位)
** _input_length_: 入力長 (文字数)
** _input_pos_: バッファ入力におけるカーソル位置
** _input_1st_display_: バッファ入力における 1 文字目
** _num_history_: コマンド履歴の数
** _text_search_: テキスト検索タイプ:
*** 0: 現在検索していない
// TRANSLATION MISSING
*** 1: search in buffer lines
// TRANSLATION MISSING
*** 2: search in commands history
// TRANSLATION MISSING
** _text_search_direction_: direction for search:
// TRANSLATION MISSING
*** 0: backward search (direction: oldest messages/commands)
// TRANSLATION MISSING
*** 1: forward search (direction: newest messages/commands)
** _text_search_exact_: テキスト検索で大文字小文字を区別する場合は 1
// TRANSLATION MISSING
** _text_search_regex_: 1 if searching with a regular expression
** _text_search_where_:
*** 0: 現在検索していない
// TRANSLATION MISSING
*** 1: search in message
// TRANSLATION MISSING
*** 2: search in prefix
// TRANSLATION MISSING
*** 3: search in prefix and message
** _text_search_history_:
*** 0: 現在検索していない
// TRANSLATION MISSING
*** 1: search in buffer local history
// TRANSLATION MISSING
*** 2: search in global history
** _text_search_found_: テキストが見つかった場合は 1、そうでない場合は 0

戻り値:

* プロパティの整数値

C 言語での使用例:

[source,c]
----
weechat_printf (NULL, "my buffer number is: %d",
                weechat_buffer_get_integer (my_buffer, "number"));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def buffer_get_integer(buffer: str, property: str) -> int: ...

# 例
weechat.prnt("", "my buffer number is: %d" % weechat.buffer_get_integer(my_buffer, "number"))
----

==== buffer_get_string

バッファプロパティの文字列値を返す。

プロトタイプ:

[source,c]
----
const char *weechat_buffer_get_string (struct t_gui_buffer *buffer,
                                       const char *property);
----

引数:

* _buffer_: バッファへのポインタ
* _property_: プロパティ名:
// TRANSLATION MISSING
** _id_: unique identifier _(WeeChat ≥ 4.3.0)_
** _plugin_: バッファを作成したプラグインの名前 ("core" は WeeChat メインバッファ)
** _name_: バッファの名前
** _full_name_: バッファの完全な名前 ("plugin.name") _(WeeChat バージョン 0.3.7 以上で利用可)_
// TRANSLATION MISSING
** _old_full_name_: old full name of buffer ("plugin.name"), set before the buffer is renamed _(WeeChat ≥ 2.8)_
** _short_name_: バッファの短縮名 (注意: 表示目的以外に使用するのは禁止、ユーザは書き換えることが可能、バッファを検索する際にこれを使ってはいけない、_name_、_full_name_、またはローカル変数 _channel_ を使うこと)
// TRANSLATION MISSING
** _type_: type of buffer: "formatted" or "free" _(WeeChat ≥ 4.2.0)_
** _title_: バッファのタイトル
// TRANSLATION MISSING
** _modes_: modes _(WeeChat ≥ 4.3.0)_
// TRANSLATION MISSING
** _nicklist_last_id_assigned_: last unique identifier used in this buffer for a group or nick _(WeeChat ≥ 4.3.0)_
// TRANSLATION MISSING
** _input_prompt_: input prompt _(WeeChat ≥ 4.3.0)_
** _input_: 入力テキスト
** _text_search_input_: テキスト検索前に保存した入力テキスト
** _highlight_words_: ハイライトする単語のリスト
// TRANSLATION MISSING
** _highlight_disable_regex_: POSIX extended regular expression for disabling highlight
** _highlight_regex_: ハイライト用の POSIX 拡張正規表現
** _highlight_tags_restrict_: これらのタグを付けられたメッセージだけにハイライトを制限する
** _highlight_tags_: これらのタグを付けられたメッセージを強制的にハイライトする
** _hotlist_max_level_nicks_: 一部のニックネームに対するホットリストレベルの最大値
** _localvar_xxx_: ローカル変数 "xxx" の値 ("xxx" は読み出す変数の名前)

戻り値:

* プロパティの文字列値

C 言語での使用例:

[source,c]
----
weechat_printf (NULL, "name / short name of buffer are: %s / %s",
                weechat_buffer_get_string (my_buffer, "name"),
                weechat_buffer_get_string (my_buffer, "short_name"));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def buffer_get_string(buffer: str, property: str) -> str: ...

# 例
weechat.prnt("", "name / short name of buffer are: %s / %s"
    % (weechat.buffer_get_string(my_buffer, "name"),
    weechat.buffer_get_string(my_buffer, "short_name")))
----

==== buffer_get_pointer

バッファプロパティのポインタ値を返す。

プロトタイプ:

[source,c]
----
void *weechat_buffer_pointer (struct t_gui_buffer *buffer,
                              const char *property);
----

引数:

* _buffer_: バッファへのポインタ
* _property_: プロパティ名:
** _plugin_: このバッファを作ったプラグインへのポインタ (WeeChat メインバッファの場合は NULL)
// TRANSLATION MISSING
** _text_search_regex_compiled_: compiled regular expression
// TRANSLATION MISSING
** _text_search_ptr_history_: history found
** _highlight_disable_regex_compiled_: コンパイル済みの正規表現 _highlight_disable_regex_
** _highlight_regex_compiled_: コンパイル済みの正規表現 _highlight_regex_

戻り値:

* プロパティのポインタ値

C 言語での使用例:

[source,c]
----
weechat_printf (NULL, "plugin pointer of my buffer: %p",
                weechat_buffer_get_pointer (my_buffer, "plugin"));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def buffer_get_pointer(buffer: str, property: str) -> str: ...

# 例
weechat.prnt("", "plugin pointer of my buffer: %s" % weechat.buffer_get_pointer(my_buffer, "plugin"))
----

==== buffer_set

バッファプロパティに文字列値を設定。

プロトタイプ:

[source,c]
----
void weechat_buffer_set (struct t_gui_buffer *buffer, const char *property,
                         const char *value);
----

引数:

* _buffer_: バッファへのポインタ
* _property_: プロパティ名 (以下の表を参照)
* _value_: プロパティの新しい値

プロパティ:

[width="100%",cols="^2,^1,4,8",options="header"]
|===
// TRANSLATION MISSING
| 名前 | Min WeeChat | 値 | 説明

| hotlist | | "+", "-", WEECHAT_HOTLIST_LOW, WEECHAT_HOTLIST_MESSAGE,
  WEECHAT_HOTLIST_PRIVATE, WEECHAT_HOTLIST_HIGHLIGHT, "-1"
// TRANSLATION MISSING
| "+": ホットリストを有効化 (グローバル設定、バッファへのポインタは使われない) +
  "-": ホットリストを無効化 (グローバル設定、バッファへのポインタは使われない) +
  優先度: この優先度でホットリストにバッファを追加
  (conditions defined in option _weechat.look.hotlist_add_conditions_
  are *NOT* checked) +
  "-1": ホットリストからバッファを削除 _(WeeChat バージョン 1.0 以上で利用可)_

// TRANSLATION MISSING
| hotlist_conditions | 4.5.0 | WEECHAT_HOTLIST_LOW, WEECHAT_HOTLIST_MESSAGE,
  WEECHAT_HOTLIST_PRIVATE, WEECHAT_HOTLIST_HIGHLIGHT
| priority: add buffer to hotlist with this priority
  (conditions defined in option _weechat.look.hotlist_add_conditions_
  are checked).

| completion_freeze | | "0" または "1"
| "0": 補完を止める (デフォルト)
  (グローバル設定、バッファへのポインタは使われない) +
  "1": コマンドラインが更新された際に補完を継続する
  (グローバル設定、バッファへのポインタは使われない)

// TRANSLATION MISSING
| unread | | empty string, "0", "+N", "-N" or "N" (N is integer)
| empty string: set unread marker after last line of buffer +
  "0": remove unread marker from buffer +
  "N": move the unread marker N lines from the end towards the first line of buffer +
  "-N": move the unread marker N lines towards the first line of buffer +
  "+N": move the unread marker N lines towards the last line of buffer.

| display | | "1" または "auto"
| "1": 指定したバッファを現在のウィンドウに表示 +
  "auto": 指定したバッファを現在のウィンドウに表示、読了マーカーをリセットしない

| hidden | 1.0 | "0" または "1"
| "0": バッファを隠すことを止める +
  "1": バッファを隠す

| number | | 番号
| 指定したバッファをこの番号に移動

| name | | 任意の文字列
| 指定したバッファの新しい名前を設定

| short_name | | 任意の文字列
| 指定したバッファの新しい短縮名を設定

| type | | "formatted" または "free"
| バッファのタイプを設定: "formatted" (チャットメッセージ用)、または
  "free" (自由内容用); 値が "free" の場合、_clear_ プロパティは強制的に
  "0" に設定されます _(WeeChat バージョン 1.0 以上で利用可)_

| notify | | "0", "1", "2", "3"
| バッファの通知レベルを設定: "0" = ホットリストに追加しない、"1" =
  ハイライトされた場合のみ追加、"2" = ハイライトされた場合とメッセージを受信した場合に追加、"3" =
  任意のメッセージを受信した場合に追加

| print_hooks_enabled | | "0" or "1"
| プリントフックを無効化する場合は "0"、有効化する場合は "1" (新規バッファに対するデフォルト)

| day_change | 0.4.3 | "0" または "1"
| 日付変更メッセージを隠す場合は "0"、表示する場合は
  "1" (新規バッファに対するデフォルト)

| clear | 1.0 | "0" または "1"
| ユーザからのコマンド `/buffer clear` でバッファのクリアを禁止する場合は
  "0"、バッファのクリアを許可する場合は "1" (新規バッファに対するデフォルト)
   (注意: この値が "0" に設定されていたとしても、関数
   <<_buffer_clear,buffer_clear>> を使えばバッファをクリアすることが可能です)

| filter | 1.0 | "0" または "1"
| "0": バッファでフィルタを無効化 +
  "1": バッファでフィルタを有効化

| title | | 任意の文字列
| 指定したバッファの新しいタイトルを設定

// TRANSLATION MISSING
| modes | 4.3.0 | any string
| Set new modes for buffer.

| time_for_each_line | | "0" または "1"
| バッファのすべての行に時間を表示しない場合は "0"、表示する場合は
  "1" (新規バッファに対するデフォルト)

| nicklist | | "0" または "1"
| バッファのニックネームリストを表示しない場合は "0"、表示する場合は "1"

| nicklist_case_sensitive | | "0" または "1"
| ニックネームリストで大文字小文字を区別しない場合は "0"、区別する場合は "1"

| nicklist_display_groups | | "0" または "1"
| ニックネームリストグループを隠す場合は "0"、表示する場合は "1"

| highlight_words | | "-" または単語のコンマ区切りリスト
| 任意のハイライトを無効化する場合は特殊値
  "-"、または指定したバッファ内でハイライトする単語のコンマ区切りリスト、例:
  "abc,def,ghi"

| highlight_words_add | | 単語のコンマ区切りリスト
| 指定したバッファ内でハイライトする単語のコンマ区切りリスト、これらの単語を指定したバッファ内でハイライトする単語に追加します

| highlight_words_del | | 単語のコンマ区切りリスト
| 指定したバッファ内でハイライトする単語から削除する単語のコンマ区切りリスト

// TRANSLATION MISSING
| highlight_disable_regex | | any string
| POSIX extended regular expression for disabling highlight.

| highlight_regex | | 任意の文字列
| ハイライトする POSIX 拡張正規表現

| highlight_tags_restrict | | タグのコンマ区切りリスト
| 指定したバッファ内でこれらのタグをつけられたメッセージだけを対象にハイライトする
  (区切り文字 "+" で論理 "and" を表現することにより複数のタグを組み合わせて使うことができます、例:
  "nick_toto+irc_action")

| highlight_tags | | タグのコンマ区切りリスト
| 指定したバッファ内でこれらのタグをつけられたメッセージを強制的にハイライトする
  (区切り文字 "+" で論理 "and" を表現することにより複数のタグを組み合わせて使うことができます、例:
  "nick_toto+irc_action")

| hotlist_max_level_nicks | | "nick:level" のコンマ区切りリスト
| 指定したバッファに対するホットリストの最大レベルを付けたニックネームのコンマ区切りリスト
  (レベル: -1: ホットリストに追加しない、0: 低い、1: メッセージ、2:
  プライベート、3: ハイライト)、例: "joe:2,mike:-1,robert:-1" (joe
  さんのメッセージはハイライトされない、mike さんと robert さんはホットリストを変更しない)

| hotlist_max_level_nicks_add | | "nick:level" のコンマ区切りリスト
| ホットリストの最大レベルを付けたニックネームのコンマ区切りリスト、これらのニックネームを指定したバッファ内のニックネームに追加します

| hotlist_max_level_nicks_del | | ニックネームのコンマ区切りリスト
| ホットリストの最大レベルから削除するニックネームのコンマ区切りリスト

| key_bind_xxx | | 任意の文字列
| 指定したバッファに対して新しいキー _xxx_
  を割り当てる、値はキーを押して実行するコマンド

| key_unbind_xxx | | -
| 指定したバッファに対してキー _xxx_ の割り当てを解除する

// TRANSLATION MISSING
| input_prompt | 4.3.0 | any string
| Set new value for input prompt.

| input | | 任意の文字列
| バッファ入力に新しい値を設定

| input_pos | | 位置
| バッファ入力のカーソル位置を設定

// TRANSLATION MISSING
| input_get_any_user_data | 4.3.0 | "0" or "1"
| "0" to get only user messages (default behavior), "1" to get everything,
  including commands.

| input_get_unknown_commands | | "0" または "1"
| 指定したバッファに対する未定義のコマンドを無効にする場合は "0"
  (デフォルト)、未定義のコマンドを受け入れる場合は "1"、例えばユーザが "/unknowncmd"
  を入力した場合、バッファはこれを受け入れる (未定義のコマンドに対するエラーを出さない)

| input_get_empty | | "0" または "1"
| バッファに対する空入力を受け取らない場合は "0" (デフォルト)、空入力を受け取る場合は "1"

// TRANSLATION MISSING
| input_multiline | | "0" または "1"
| "0" to send each line separately to this buffer (default behavior), "1" to
  send multiple lines as a single message.

| localvar_set_xxx | | 任意の文字列
| ローカル変数 _xxx_ の新しい値を設定
  (存在しない変数の場合は変数を作成する)

| localvar_del_xxx | | -
| ローカル変数 _xxx_ を削除
|===

C 言語での使用例:

[source,c]
----
/* disable hotlist (for all buffers) */
weechat_buffer_set (NULL, "hotlist", "-");

/* enable again hotlist */
weechat_buffer_set (NULL, "hotlist", "+");

/* change buffer name */
weechat_buffer_set (my_buffer, "name", "my_new_name");

/* add new local variable "toto" with value "abc" */
weechat_buffer_set (my_buffer, "localvar_set_toto", "abc");

/* remove local variable "toto" */
weechat_buffer_set (my_buffer, "localvar_del_toto", "");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def buffer_set(buffer: str, property: str, value: str) -> int: ...

# 例

# disable hotlist (for all buffers)
weechat.buffer_set("", "hotlist", "-")

# enable again hotlist
weechat.buffer_set("", "hotlist", "+")

# change buffer name
weechat.buffer_set(my_buffer, "name", "my_new_name")

# add new local variable "toto" with value "abc"
weechat.buffer_set(my_buffer, "localvar_set_toto", "abc")

# remove local variable "toto"
weechat.buffer_set(my_buffer, "localvar_del_toto", "")
----

==== buffer_set_pointer

バッファプロパティのポインタ値を設定。

プロトタイプ:

[source,c]
----
void weechat_buffer_set_pointer (struct t_gui_buffer *buffer, const char *property,
                                 void *pointer);
----

引数:

* _buffer_: バッファへのポインタ
* _property_: プロパティ名:
** _close_callback_: バッファを閉じる際に呼び出すコールバック関数を設定
** _close_callback_data_: バッファを閉じる際に呼び出すコールバック関数に渡すデータを設定
** _input_callback_: 入力テキストをバッファに挿入する際に呼び出すコールバック関数を設定
** _input_callback_data_: 入力テキストをバッファに挿入する際に呼び出すコールバック関数に渡すデータを設定
** _nickcmp_callback_: ニックネーム比較コールバック関数を設定
  (ニックネームリストからニックネームを検索する際にこのコールバックを使用) _(WeeChat バージョン 0.3.9 以上で利用可)_
** _nickcmp_callback_data_: ニックネーム比較コールバック関数に渡すデータを設定
   _(WeeChat バージョン 0.3.9 以上で利用可)_
* _pointer_: プロパティの新しいポインタ値

コールバックのプロトタイプ:

[source,c]
----
int close_callback (const void *pointer, void *data,
                    struct t_gui_buffer *buffer);

int input_callback (const void *pointer, void *data,
                    struct t_gui_buffer *buffer, const char *input_data);

int nickcmp_callback (const void *pointer, void *data,
                      struct t_gui_buffer *buffer,
                      const char *nick1, const char *nick2);
----

C 言語での使用例:

[source,c]
----
int
my_close_cb (const void *pointer, void *data, struct t_gui_buffer *buffer)
{
    /* ... */
    return WEECHAT_RC_OK;
}

weechat_buffer_set_pointer (my_buffer, "close_callback", &my_close_cb);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== buffer_string_replace_local_var

文字列に含まれるバッファローカル変数をその値で展開する。

プロトタイプ:

[source,c]
----
char *weechat_buffer_string_replace_local_var (struct t_gui_buffer *buffer,
                                               const char *string);
----

引数:

* _buffer_: バッファへのポインタ
* _string_: テキストおよび書式 "$var" のローカル変数を含む文字列

戻り値:

* ローカル変数を展開した文字列

C 言語での使用例:

[source,c]
----
weechat_buffer_set (my_buffer, "localvar_set_toto", "abc");

char *str = weechat_buffer_string_replace_local_var (my_buffer,
                                                     "test with $toto");
/* str contains "test with abc" */
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def buffer_string_replace_local_var(buffer: str, string: str) -> str: ...

# 例
weechat.buffer_set(my_buffer, "localvar_set_toto", "abc")
str = weechat.buffer_string_replace_local_var(my_buffer, "test with $toto")
# str contains "test with abc"
----

==== buffer_match_list

// TRANSLATION MISSING
_WeeChat ≥ 0.3.5, updated in 4.0.0._

バッファがバッファのリストにマッチすることを確認。

プロトタイプ:

[source,c]
----
int weechat_buffer_match_list (struct t_gui_buffer *buffer, const char *string);
----

引数:

* _buffer_: バッファへのポインタ
* _string_: バッファのコンマ区切りリスト:
** `+*+` 任意のバッファにマッチ
** 名前の最初に `+!+` がある場合はその名前を含まない場合にマッチ
** 名前にワイルドカード `+*+` を使うことができます

// TRANSLATION MISSING
[NOTE]
Since version 4.0.0, comparison of buffer names is case-sensitive.

戻り値:

* バッファがバッファリストにマッチする場合は 1、そうでない場合は 0

C 言語での使用例:

[source,c]
----
struct t_gui_buffer *buffer = weechat_buffer_search ("irc", "libera.#weechat");
if (buffer)
{
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "*"));                    /* 1 */
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "*,!*#weechat*"));        /* 0 */
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "irc.libera.*"));         /* 1 */
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "irc.oftc.*,python.*"));  /* 0 */
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def buffer_match_list(buffer: str, string: str) -> int: ...

# 例
buffer = weechat.buffer_search("irc", "libera.#weechat")
if buffer:
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "*"))                    # 1
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "*,!*#weechat*"))        # 0
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "irc.libera.*"))         # 1
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "irc.oftc.*,python.*"))  # 0
----

// TRANSLATION MISSING
[[buffer_lines]]
=== Buffer lines

// TRANSLATION MISSING
Functions for buffer lines.

==== line_search_by_id

_WeeChat ≥ 4.4.0._

// TRANSLATION MISSING
Search line in buffer by identifier.

プロトタイプ:

[source,c]
----
struct t_gui_line *weechat_line_search_by_id (struct t_gui_buffer *buffer, int id);
----

戻り値:

// TRANSLATION MISSING
* pointer to line found, NULL if not found

C 言語での使用例:

[source,c]
----
struct t_gui_line *line = weechat_line_search_by_id (buffer, 123);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def line_search_by_id(buffer: str, line_id: int) -> str: ...

# 例
line = weechat.line_search_by_id(buffer, 123)
----

[[windows]]
=== ウィンドウ

ウィンドウを操作する関数。

==== current_window

現在のウィンドウへのポインタを返す。

プロトタイプ:

[source,c]
----
struct t_gui_window *weechat_current_window ();
----

戻り値:

* 現在のウィンドウへのポインタ

C 言語での使用例:

[source,c]
----
struct t_gui_window *current_window = weechat_current_window ();
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def current_window() -> str: ...

# 例
current_window = weechat.current_window()
----

==== window_search_with_buffer

_WeeChat バージョン 0.3.5 以上で利用可。_

バッファを表示しているウィンドウへのポインタを返す。

プロトタイプ:

[source,c]
----
struct t_gui_window *weechat_window_search_with_buffer (struct t_gui_buffer *buffer);
----

引数:

* _buffer_: バッファへのポインタ

戻り値:

* バッファを表示しているウィンドウへのポインタ (バッファを表示しているウィンドウが無い場合は NULL)

C 言語での使用例:

[source,c]
----
weechat_printf (NULL,
                "window displaying core buffer: %p",
                weechat_window_search_with_buffer (weechat_buffer_search_main ()));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def window_search_with_buffer(buffer: str) -> str: ...

# 例
weechat.prnt("", "window displaying core buffer: %s"
    % weechat.window_search_with_buffer(weechat.buffer_search_main()))
----

==== window_get_integer

ウィンドウプロパティの整数値を返す。

プロトタイプ:

[source,c]
----
int weechat_window_get_integer (struct t_gui_window *window,
                                const char *property);
----

引数:

* _window_: ウィンドウへのポインタ
* _property_: プロパティ名:
** _number_: ウィンドウ番号 (1 以上)
** _win_x_: 端末内でのウィンドウの X 座標 (1 列目は 0)
** _win_y_: 端末内でのウィンドウの Y 座標 (1 行目は 0)
** _win_width_: ウィンドウの横幅、文字単位
** _win_height_: ウィンドウの縦幅、文字単位
** _win_width_pct_: ウィンドウ横幅の百分率、親ウィンドウに対する割合
   (例えば 50 は半分を意味する)
** _win_height_pct_: ウィンドウ縦幅の百分率、親ウィンドウに対する割合
   (例えば 50 は半分を意味する)
** _win_chat_x_: チャットウィンドウの X 座標 (1 列目は 0)
** _win_chat_y_: チャットウィンドウの Y 座標 (1 行目は 0)
** _win_chat_width_: チャットウィンドウの横幅、文字単位
** _win_chat_height_: チャットウィンドウの縦幅、文字単位
** _first_line_displayed_: バッファの 1
   行目が画面に表示されている場合は 1、そうでなければ 0
** _scrolling_: ウィンドウでスクロールが有効化されている場合 (最後の行が表示されていない場合) は 1
** _lines_after_: バッファの最終行を表示した後にバッファに追加された行の数
   (スクロール中)

戻り値:

* プロパティの整数値

C 言語での使用例:

[source,c]
----
weechat_printf (NULL, "current window is at position (x,y): (%d,%d)",
                weechat_window_get_integer (weechat_current_window (), "win_x"),
                weechat_window_get_integer (weechat_current_window (), "win_y"));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def window_get_integer(window: str, property: str) -> int: ...

# 例
weechat.prnt("", "current window is at position (x,y): (%d,%d)"
    % (weechat.window_get_integer(weechat.current_window(), "win_x"),
    weechat.window_get_integer(weechat.current_window(), "win_y")))
----

==== window_get_string

ウィンドウプロパティの文字列値を返す。

[NOTE]
現在この関数を使うことはできません、将来のバージョン用に予約されています。

プロトタイプ:

[source,c]
----
const char *weechat_window_get_string (struct t_gui_window *window,
                                       const char *property);
----

引数:

* _window_: ウィンドウへのポインタ
* _property_: プロパティ名

戻り値:

* プロパティの文字列値

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def window_get_string(window: str, property: str) -> str: ...
----

==== window_get_pointer

ウィンドウプロパティのポインタ値を返す。

プロトタイプ:

[source,c]
----
void *weechat_window_get_pointer (struct t_gui_window *window,
                                  const char *property);
----

引数:

* _window_: ウィンドウへのポインタ
* _property_: プロパティ名:
** _current_: 現在のウィンドウへのポインタ
** _buffer_: 指定したウィンドウが表示しているバッファへのポインタ

戻り値:

* プロパティのポインタ値

C 言語での使用例:

[source,c]
----
weechat_printf (NULL,
                "buffer displayed in current window: %p",
                weechat_window_get_pointer (weechat_current_window (), "buffer"));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def window_get_pointer(window: str, property: str) -> str: ...

# 例
weechat.prnt("", "buffer displayed in current window: %s"
    % weechat.window_get_pointer(weechat.current_window(), "buffer"))
----

==== window_set_title

端末のタイトルを設定。

プロトタイプ:

[source,c]
----
void weechat_window_set_title (const char *title);
----

引数:

* _title_: 端末の新しいタイトル (タイトルをリセットする場合は NULL);
  この文字列は評価されるため、文字列内に `${info:version}` などの変数を含めることが可能です
  (<<_string_eval_expression,string_eval_expression>> を参照)

C 言語での使用例:

[source,c]
----
weechat_window_set_title ("new title here");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def window_set_title(title: str) -> int: ...

# 例
weechat.window_set_title("new title here")
----

[[nicklist]]
=== ニックネームリスト

バッファのニックネームリストを操作する関数。

==== nicklist_add_group

ニックネームリストにグループを追加。

プロトタイプ:

[source,c]
----
struct t_gui_nick_group *weechat_nicklist_add_group (struct t_gui_buffer *buffer,
                                                     struct t_gui_nick_group *parent_group,
                                                     const char *name,
                                                     const char *color,
                                                     int visible);
----

引数:

* _buffer_: バッファへのポインタ
* _parent_group_: グループの親へのポインタ、グループに親がない場合 NULL
  (ニックネームリスト)
* _name_: グループ名
* _color_: 色オプション名:
** WeeChat オプション名、例えば _weechat.color.nicklist_group_
** 任意で背景色をつけた色、例えば _yellow_ や _yellow,red_
** バーの色名:
*** _bar_fg_: バーの前景色
*** _bar_delim_: バーの区切り文字
*** _bar_bg_: バーの背景色
* _visible_:
** _1_: グループとサブグループおよびニックネームを表示
** _0_: グループとサブグループおよびニックネームを非表示

[NOTE]
グループ名の前に、1
桁以上の数字とパイプ文字を付けると、この数字を使ってニックネームリスト内のグループをソートします。例えば、グループ
"1|test" と "2|abc" はこの順番で表示されます:
最初に "test" その後に "abc"。

戻り値:

* 新しいグループへのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
struct t_gui_nick_group *my_group =
    weechat_nicklist_add_group (my_buffer,
                                my_parent_group,
                                "test_group",
                                "weechat.color.nicklist_group",
                                1);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def nicklist_add_group(buffer: str, parent_group: str, name: str, color: str, visible: int) -> str: ...

# 例
group = weechat.nicklist_add_group(my_buffer, my_parent_group, "test_group",
    "weechat.color.nicklist_group", 1)
----

==== nicklist_search_group

_WeeChat バージョン 4.3.0 で更新。_

// TRANSLATION MISSING
Search a group in a nicklist by name or unique identifier (`id`).

プロトタイプ:

[source,c]
----
struct t_gui_nick_group *weechat_nicklist_search_group (struct t_gui_buffer *buffer,
                                                        struct t_gui_nick_group *from_group,
                                                        const char *name);
----

引数:

* _buffer_: バッファへのポインタ
* _from_group_:
  このグループのみを検索、全てのニックネームリストから検索する場合は NULL
// TRANSLATION MISSING
* _name_: group name to search; with WeeChat ≥ 4.3.0, a unique identifier can
  be given with the format: `==id:xxx` (where `xxx` is the identifier)

戻り値:

* 見つかったグループへのポインタ、見つからなかった場合は NULL

C 言語での使用例:

[source,c]
----
struct t_gui_nick_group *ptr_group1 = weechat_nicklist_search_group (my_buffer,
                                                                     NULL, "test_group");
struct t_gui_nick_group *ptr_group2 = weechat_nicklist_search_group (my_buffer,
                                                                     NULL, "==id:1714382231198764");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def nicklist_search_group(buffer: str, from_group: str, name: str) -> str: ...

# 例
group1 = weechat.nicklist_search_group(my_buffer, "", "test_group")
group2 = weechat.nicklist_search_group(my_buffer, "", "==id:1714382231198764")
----

==== nicklist_add_nick

ニックネームをグループに追加。

プロトタイプ:

[source,c]
----
struct t_gui_nick *weechat_nicklist_add_nick (struct t_gui_buffer *buffer,
                                              struct t_gui_nick_group *group,
                                              const char *name,
                                              const char *color,
                                              const char *prefix,
                                              const char *prefix_color,
                                              int visible);
----

引数:

* _buffer_: バッファへのポインタ
* _group_: グループへのポインタ
* _name_: ニックネーム
* _color_: 色オプション名:
*** WeeChat オプション名 (weechat.color.xxx のオプション部分)、例えば _chat_delimiters_
*** 任意で背景色をつけた色、例えば _yellow_ や _yellow,red_
*** バーの色名:
**** _bar_fg_: バーの前景色
**** _bar_delim_: バーの区切り文字
**** _bar_bg_: バーの背景色
* _prefix_: ニックネームの前に表示するプレフィックス
* _prefix_color_: 色オプション名:
** WeeChat オプション名 (weechat.color.xxx のオプション部分)、例えば _chat_delimiters_
** 任意で背景色をつけた色、例えば _yellow_ や _yellow,red_
** バーの色名:
*** _bar_fg_: バーの前景色
*** _bar_delim_: バーの区切り文字
*** _bar_bg_: バーの背景色
* _visible_:
** _1_: ニックネームを表示
** _0_: ニックネームを非表示

戻り値:

* 新しいニックネームへのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
struct t_gui_nick *my_nick =
    weechat_nicklist_add_nick (my_buffer, my_group,
                               "test_nick",
                               (nick_away) ? "weechat.color.nicklist_away" : "bar_fg",
                               "@", "lightgreen",
                               1);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def nicklist_add_nick(buffer: str, group: str, name: str, color: str, prefix: str, prefix_color: str, visible: int) -> str: ...

# 例
if nick_away:
    color = "weechat.color.nicklist_away"
else:
    color = "bar_fg"
nick = weechat.nicklist_add_nick(my_buffer, my_group, "test_nick", color, "@", "lightgreen", 1)
----

==== nicklist_search_nick

_WeeChat バージョン 4.3.0 で更新。_

// TRANSLATION MISSING
Search a nick in a nicklist by name or unique identifier (`id`).

プロトタイプ:

[source,c]
----
struct t_gui_nick *weechat_nicklist_search_nick (struct t_gui_buffer *buffer,
                                                 struct t_gui_nick_group *from_group,
                                                 const char *name);
----

引数:

* _buffer_: バッファへのポインタ
* _from_group_:
  このグループのみを検索、全てのニックネームリストから検索する場合は NULL
// TRANSLATION MISSING
* _name_: nick name to search; with WeeChat ≥ 4.3.0, a unique identifier can
  be given with the format: `==id:xxx` (where `xxx` is the identifier)

戻り値:

* 見つかったニックネームへのポインタ、見つからなかった場合は NULL

C 言語での使用例:

[source,c]
----
struct t_gui_nick *ptr_nick1 = weechat_nicklist_search_nick (my_buffer,
                                                             NULL, "test_nick");
struct t_gui_nick *ptr_nick2 = weechat_nicklist_search_nick (my_buffer,
                                                             NULL, "==id:1714382252187496");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def nicklist_search_nick(buffer: str, from_group: str, name: str) -> str: ...

# 例
nick1 = weechat.nicklist_search_nick(my_buffer, "", "test_nick")
nick2 = weechat.nicklist_search_nick(my_buffer, "", "==id:1714382252187496")
----

==== nicklist_remove_group

ニックネームリストからグループを削除。

プロトタイプ:

[source,c]
----
void weechat_nicklist_remove_group (struct t_gui_buffer *buffer,
                                    struct t_gui_nick_group *group);
----

引数:

* _buffer_: バッファへのポインタ
* _group_: 削除するグループへのポインタ (同時に全てのサブグループおよびニックネームを削除)

C 言語での使用例:

[source,c]
----
weechat_nicklist_remove_group (my_buffer, my_group);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def nicklist_remove_group(buffer: str, group: str) -> int: ...

# 例
weechat.nicklist_remove_group(my_buffer, my_group)
----

==== nicklist_remove_nick

ニックネームリストからニックネームを削除。

プロトタイプ:

[source,c]
----
void weechat_nicklist_remove_nick (struct t_gui_buffer *buffer,
                                   struct t_gui_nick *nick);
----

引数:

* _buffer_: バッファへのポインタ
* _nick_: 削除するニックネームへのポインタ

C 言語での使用例:

[source,c]
----
weechat_nicklist_remove_nick (my_buffer, my_nick);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def nicklist_remove_nick(buffer: str, nick: str) -> int: ...

# 例
weechat.nicklist_remove_nick(my_buffer, my_nick)
----

==== nicklist_remove_all

ニックネームリストから全てのグループおよびニックネームを削除。

プロトタイプ:

[source,c]
----
void weechat_nicklist_remove_all (struct t_gui_buffer *buffer);
----

引数:

* _buffer_: バッファへのポインタ

C 言語での使用例:

[source,c]
----
weechat_nicklist_remove_all (my_buffer);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def nicklist_remove_all(buffer: str) -> int: ...

# 例
weechat.nicklist_remove_all(my_buffer)
----

==== nicklist_get_next_item

_WeeChat バージョン 0.3.7 以上で利用可。_

ニックネームリストから次のグループまたはニックネームを取得 (主にニックネームリストを表示する際に利用)。

プロトタイプ:

[source,c]
----
void weechat_nicklist_get_next_item (struct t_gui_buffer *buffer,
                                     struct t_gui_nick_group **group,
                                     struct t_gui_nick **nick);
----

引数:

* _buffer_: バッファへのポインタ
* _group_: グループへのポインタへのポインタ
* _nick_: ニックネームへのポインタへのポインタ

C 言語での使用例:

[source,c]
----
struct t_gui_nick_group *ptr_group;
struct t_gui_nick *ptr_nick;

ptr_group = NULL;
ptr_nick = NULL;
weechat_nicklist_get_next_item (buffer, &ptr_group, &ptr_nick);
while (ptr_group || ptr_nick)
{
    if (ptr_nick)
    {
        /* nick */
        /* ... */
    }
    else
    {
        /* group */
        /* ... */
    }
    weechat_nicklist_get_next_item (buffer, &ptr_group, &ptr_nick);
}
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== nicklist_group_get_integer

_WeeChat バージョン 0.3.4 以上で利用可。_

グループプロパティの整数値を返す。

プロトタイプ:

[source,c]
----
int weechat_nicklist_group_get_integer (struct t_gui_buffer *buffer,
                                        struct t_gui_nick_group *group,
                                        const char *property);
----

引数:

* _buffer_: バッファへのポインタ
* _group_: グループへのポインタ
* _property_: プロパティ名:
** _visible_: グループが表示されている場合は 1、そうでない場合は 0
** _level_: グループレベル (ルートは 0)

戻り値:

* プロパティの整数値

C 言語での使用例:

[source,c]
----
int visible = weechat_nicklist_group_get_integer (buffer, group, "visible");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def nicklist_group_get_integer(buffer: str, group: str, property: str) -> int: ...

# 例
visible = weechat.nicklist_group_get_integer(buffer, group, "visible")
----

==== nicklist_group_get_string

_WeeChat バージョン 0.3.4 以上で利用可。_

グループプロパティの文字列値を返す。

プロトタイプ:

[source,c]
----
const char *weechat_nicklist_group_get_string (struct t_gui_buffer *buffer,
                                               struct t_gui_nick_group *group,
                                               const char *property);
----

引数:

* _buffer_: バッファへのポインタ
* _group_: グループへのポインタ
* _property_: プロパティ名:
// TRANSLATION MISSING
** _id_: unique identifier _(WeeChat ≥ 4.3.0)_
** _name_: グループの名前
** _color_: ニックネームリストのグループ色

戻り値:

* プロパティの文字列値

C 言語での使用例:

[source,c]
----
const char *color = weechat_nicklist_group_get_string (buffer, group, "color");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def nicklist_group_get_string(buffer: str, group: str, property: str) -> str: ...

# 例
color = weechat.nicklist_group_get_string(buffer, group, "color")
----

==== nicklist_group_get_pointer

_WeeChat バージョン 0.3.4 以上で利用可。_

グループプロパティのポインタ値を返す。

プロトタイプ:

[source,c]
----
void *weechat_nicklist_group_get_pointer (struct t_gui_buffer *buffer,
                                          struct t_gui_nick_group *group,
                                          const char *property);
----

引数:

* _buffer_: バッファへのポインタ
* _group_: グループへのポインタ
* _property_: プロパティ名:
** _parent_: 親グループへのポインタ

戻り値:

* プロパティのポインタ値

C 言語での使用例:

[source,c]
----
struct t_gui_nick_group *parent = weechat_nicklist_group_get_pointer (buffer, group, "parent");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def nicklist_group_get_pointer(buffer: str, group: str, property: str) -> str: ...

# 例
parent = weechat.nicklist_group_get_pointer(buffer, group, "parent")
----

==== nicklist_group_set

// TRANSLATION MISSING
_WeeChat ≥ 0.3.4, updated in 4.3.0._

グループプロパティの文字列値。

プロトタイプ:

[source,c]
----
void weechat_nicklist_group_set (struct t_gui_buffer *buffer,
                                 struct t_gui_nick_group *group,
                                 const char *property,
                                 const char *value);
----

引数:

* _buffer_: バッファへのポインタ
* _group_: グループへのポインタ
* _property_: プロパティ名 (以下の表を参照)
* _value_: プロパティの新しい値

プロパティ:

[width="100%",cols="^2,^1,4,8",options="header"]
|===
// TRANSLATION MISSING
| 名前 | Min WeeChat | 値 | 説明

// TRANSLATION MISSING
| id | 4.3.0 | long long integer ≥ 0
| New id for the group (it must be unique in the buffer). +
  Note: it is not recommended to change this identifier.

| color | | WeeChat 色オプション名
| 関数 <<_nicklist_add_group,nicklist_add_group>>
  の引数 "color" を参照

| visible | | "0"、"1"
| "0" = 非表示状態のグループ、"1" = 表示状態のグループ
|===

C 言語での使用例:

[source,c]
----
/* change group color to "bar_fg" */
weechat_nicklist_group_set (buffer, group, "color", "bar_fg");

/* change group color to yellow */
weechat_nicklist_group_set (buffer, group, "color", "yellow");

/* hide group in nicklist */
weechat_nicklist_group_set (buffer, group, "visible", "0");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def nicklist_group_set(buffer: str, group: str, property: str, value: str) -> int: ...

# 例

# change group color to "bar_fg"
weechat.nicklist_group_set(buffer, group, "color", "bar_fg")

# change group color to yellow
weechat.nicklist_group_set(buffer, group, "color", "yellow")

# hide group in nicklist
weechat.nicklist_group_set(buffer, group, "visible", "0")
----

==== nicklist_nick_get_integer

_WeeChat バージョン 0.3.4 以上で利用可。_

ニックネームプロパティの整数値を返す。

プロトタイプ:

[source,c]
----
int weechat_nicklist_nick_get_integer (struct t_gui_buffer *buffer,
                                       struct t_gui_nick *nick,
                                       const char *property);
----

引数:

* _buffer_: バッファへのポインタ
* _nick_: ニックネームへのポインタ
* _property_: プロパティ名:
** _visible_: 表示状態のニックネームの場合 1、それ以外の場合は 0

戻り値:

* プロパティの整数値

C 言語での使用例:

[source,c]
----
int visible = weechat_nicklist_nick_get_integer (buffer, nick, "visible");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def nicklist_nick_get_integer(buffer: str, nick: str, property: str) -> int: ...

# 例
visible = weechat.nicklist_nick_get_integer(buffer, nick, "visible")
----

==== nicklist_nick_get_string

_WeeChat バージョン 0.3.4 以上で利用可。_

ニックネームプロパティの文字列値を返す。

プロトタイプ:

[source,c]
----
const char *weechat_nicklist_nick_get_string (struct t_gui_buffer *buffer,
                                              struct t_gui_nick *nick,
                                              const char *property);
----

引数:

* _buffer_: バッファへのプロパティ
* _nick_: ニックネームへのポインタ
* _property_: プロパティ名:
// TRANSLATION MISSING
** _id_: unique identifier _(WeeChat ≥ 4.3.0)_
** _name_: ニックネームの名前
** _color_: ニックネームリスト内でのニックネームの色
** _prefix_: ニックネームのプレフィックス
** _prefix_color_: ニックネームリスト内でのプレフィックスの色

戻り値:

* プロパティの文字列値

C 言語での使用例:

[source,c]
----
const char *color = weechat_nicklist_nick_get_string (buffer, nick, "color");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def nicklist_nick_get_string(buffer: str, nick: str, property: str) -> str: ...

# 例
color = weechat.nicklist_nick_get_string(buffer, nick, "color")
----

==== nicklist_nick_get_pointer

_WeeChat バージョン 0.3.4 以上で利用可。_

ニックネームプロパティのポインタ値を返す。

プロトタイプ:

[source,c]
----
void *weechat_nicklist_nick_get_pointer (struct t_gui_buffer *buffer,
                                         struct t_gui_nick *nick,
                                         const char *property);
----

引数:

* _buffer_: バッファへのポインタ
* _nick_: ニックネームへのポインタ
* _property_: プロパティ名:
** _group_: 指定したニックネームを含むグループへのポインタ

戻り値:

* プロパティのポインタ値

C 言語での使用例:

[source,c]
----
struct t_gui_nick_group *group = weechat_nicklist_nick_get_pointer (buffer, nick, "group");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def nicklist_nick_get_pointer(buffer: str, nick: str, property: str) -> str: ...

# 例
group = weechat.nicklist_nick_get_pointer(buffer, nick, "group")
----

==== nicklist_nick_set

// TRANSLATION MISSING
_WeeChat ≥ 0.3.4, updated in 4.3.0._

ニックネームプロパティの文字列値を設定。

プロトタイプ:

[source,c]
----
void weechat_nicklist_nick_set (struct t_gui_buffer *buffer,
                                struct t_gui_nick *nick,
                                const char *property,
                                const char *value);
----

引数:

* _buffer_: バッファへのポインタ
* _nick_: ニックネームへのポインタ
* _property_: プロパティ名 (以下の表を参照)
* _value_: プロパティの新しい値

プロパティ:

[width="100%",cols="^2,^1,4,8",options="header"]
|===
// TRANSLATION MISSING
| 名前 | Min WeeChat | 値 | 説明

// TRANSLATION MISSING
| id | 4.3.0 | long long integer ≥ 0
| New id for the nick (it must be unique in the buffer). +
  Note: it is not recommended to change this identifier.

| color | | WeeChat 色オプション名
| 関数 <<_nicklist_add_nick,nicklist_add_nick>>
  の引数 "color" を参照

| prefix | | 任意の文字列
| 指定したニックネームのプレフィックス

| prefix_color | | WeeChat color option name
| 関数 <<_nicklist_add_nick,nicklist_add_nick>>
  の引数 "prefix_color" を参照

| visible | | "0", "1"
| "0" = 非表示状態のニックネーム、"1" = 表示状態のニックネーム
|===

C 言語での使用例:

[source,c]
----
/* change nick color to cyan */
weechat_nicklist_nick_set (buffer, nick, "color", "cyan");

/* change prefix to "+" */
weechat_nicklist_nick_set (buffer, nick, "prefix", "+");

/* change prefix color to yellow */
weechat_nicklist_nick_set (buffer, nick, "prefix_color", "yellow");

/* hide nick in nicklist */
weechat_nicklist_nick_set (buffer, nick, "visible", "0");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def nicklist_nick_set(buffer: str, nick: str, property: str, value: str) -> int: ...

# 例

# change nick color to cyan
weechat.nicklist_nick_set(buffer, nick, "color", "cyan")

# change prefix to "+"
weechat.nicklist_nick_set(buffer, nick, "prefix", "+")

# change prefix color to yellow
weechat.nicklist_nick_set(buffer, nick, "prefix_color", "yellow")

# hide nick in nicklist
weechat.nicklist_nick_set(buffer, nick, "visible", "0")
----

[[bars]]
=== バー

バーを操作する関数。

==== bar_item_search

バー要素を検索。

プロトタイプ:

[source,c]
----
struct t_gui_bar_item *weechat_bar_item_search (const char *name);
----

引数:

* _name_: バー要素の名前

戻り値:

* 見つかったバー要素へのポインタ、バー要素が見つからない場合 NULL

C 言語での使用例:

[source,c]
----
struct t_gui_bar_item *bar_item = weechat_bar_item_search ("myitem");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def bar_item_search(name: str) -> str: ...

# 例
bar_item = weechat.bar_item_search("myitem")
----

==== bar_item_new

_WeeChat バージョン 0.4.2 と 1.5 で更新。_

新しいバー要素を作成。

プロトタイプ:

[source,c]
----
struct t_gui_bar_item *weechat_bar_item_new (const char *name,
                                             char *(*build_callback)(const void *pointer,
                                                                     void *data,
                                                                     struct t_gui_bar_item *item,
                                                                     struct t_gui_window *window,
                                                                     struct t_gui_buffer *buffer,
                                                                     struct t_hashtable *extra_info),
                                             const void *build_callback_pointer,
                                             void *build_callback_data);
----

引数:

* _name_: バー要素の名前
* _build_callback_:
  バー要素を作成する際に呼び出すコールバック関数、引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _struct t_gui_bar_item *item_: 要素へのポインタ
** _struct t_gui_window *window_:
   ウィンドウへのポインタ (ルートバーの場合は NULL)
** _struct t_gui_buffer *buffer_: ウィンドウに表示されているバッファ
   (ウィンドウが NULL の場合、現在のバッファ) または以下の構文で指定したバー要素に含まれるバッファ:
   "@buffer:item" _(WeeChat バージョン 0.4.2 以上で利用可)_
** _struct t_hashtable *extra_info_: 常に NULL
   (この引数は将来のバージョン用に予約されています) _(WeeChat バージョン 0.4.2 以上で利用可)_
** 戻り値: バー要素の内容
* _build_callback_pointer_: WeeChat が _build_callback_
  コールバックを呼び出す際にコールバックに渡すポインタ
* _build_callback_data_: WeeChat が _build_callback_ コールバックを呼び出す際にコールバックに渡すポインタ
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはここで作成したバー要素が削除された時点で自動的に開放されます

戻り値:

* バー要素へのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
char *
my_build_callback (const void *pointer, void *data,
                   struct t_gui_bar_item *item,
                   struct t_gui_window *window,
                   struct t_gui_buffer *buffer,
                   struct t_hashtable *extra_info)
{
    return strdup ("my content");
}

struct t_gui_bar_item *my_item = weechat_bar_item_new ("myitem",
                                                       &my_build_callback,
                                                       NULL, NULL);
----

スクリプト (Python) での使用例:

[IMPORTANT]
WeeChat バージョン 0.4.1 以下に対する互換性のために、デフォルトのコールバックに渡す引数の個数は
3 個です: _data_、_item_、_window_ (_buffer_ と _extra_info_ は渡されません)。 +
全ての引数を受け取るコールバックを使う場合は、名前の前に "(extra)"
をつけてください、以下の例を参照 (WeeChat バージョン 0.4.2 以上で利用可)。

[source,python]
----
# プロトタイプ
def bar_item_new(name: str, build_callback: str, build_callback_data: str) -> str: ...

# 例 (コールバックに "buffer" と "extra_info" を除いた引数を渡す)
def my_build_callback(data: str, item: str, window: str) -> str:
    return "my content"

bar_item = weechat.bar_item_new("myitem", "my_build_callback", "")

# 例 (コールバックに全ての引数を渡す、WeeChat バージョン 0.4.2 以上で利用可)
def my_build_callback2(data: str, item: str, window: str, buffer: str, extra_info: Dict[str, str]) -> str:
    return "my content"

bar_item2 = weechat.bar_item_new("(extra)myitem2", "my_build_callback2", "")  # WeeChat バージョン 0.4.2 以上で利用可
----

==== bar_item_update

_build_callback_ コールバックを呼び出してバー要素の内容を更新。

プロトタイプ:

[source,c]
----
void weechat_bar_item_update (const char *name);
----

引数:

* _name_: バー要素の名前

C 言語での使用例:

[source,c]
----
weechat_bar_item_update ("myitem");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def bar_item_update(name: str) -> int: ...

# 例
weechat.bar_item_update("myitem")
----

==== bar_item_remove

バー要素を削除。

プロトタイプ:

[source,c]
----
void weechat_bar_item_remove (struct t_gui_bar_item *item);
----

引数:

* _item_: バー要素へのポインタ

C 言語での使用例:

[source,c]
----
weechat_bar_item_remove (&my_item);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def bar_item_remove(item: str) -> int: ...

# 例
weechat.bar_item_remove(myitem)
----

==== bar_search

バーを検索。

プロトタイプ:

[source,c]
----
struct t_gui_bar *weechat_bar_search (const char *name);
----

引数:

* _name_: バーの名前

戻り値:

* 見つかったバーへのポインタ、見つからなかった場合は NULL

C 言語での使用例:

[source,c]
----
struct t_gui_bar *bar = weechat_bar_search ("mybar");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def bar_search(name: str) -> str: ...

# 例
bar = weechat.bar_search("mybar")
----

==== bar_new

_WeeChat バージョン 2.9, 4.0.0 で更新。_

新しいバーを作成。

プロトタイプ:

[source,c]
----
struct t_gui_bar *weechat_bar_new (const char *name,
                                   const char *hidden,
                                   const char *priority,
                                   const char *type,
                                   const char *condition,
                                   const char *position,
                                   const char *filling_top_bottom,
                                   const char *filling_left_right,
                                   const char *size,
                                   const char *size_max,
                                   const char *color_fg,
                                   const char *color_delim,
                                   const char *color_bg,
                                   const char *color_bg_inactive,
                                   const char *separator,
                                   const char *items);
----

引数:

* _name_: バーの名前
* _hidden_:
** _on_: バーを非表示
** _off_: バーを表示
* _priority_: バーの優先度 (整数)
* _type_:
** _root_: ウィンドウの外に 1 回だけ表示されたバー
** _window_: 各ウィンドウに表示されたバー
* _condition_: バーの表示位置:
** _active_: アクティブウィンドウのみに表示されているバー
** _inactive_: 非アクティブウィンドウのみに表示されているバー
** _nicklist_: ニックネームリストを持つウィンドウに表示されているバー
** 評価された式:
   link:weechat_user.ja.html#bar_conditions[WeeChat ユーザーズガイド / バー状態 ^↗^^]を参照してください
* _position_: _top_、_bottom_、_left_、_right_
* _filling_top_bottom_:
** _horizontal_: 要素は水平方向に詰め込まれている (各要素の後に間隔)
** _vertical_: 要素は垂直方向に詰め込まれている (各要素の後に行)
** _columns_horizontal_: 要素は水平方向に詰め込まれている、列と一緒に表示
** _columns_vertical_: 要素は垂直方向に詰め込まれている、列と一緒に表示
* _filling_left_right_:
** _horizontal_: 要素は水平方向に詰め込まれている (各要素の後に間隔)
** _vertical_: 要素は垂直方向に詰め込まれている (各要素の後に行)
** _columns_horizontal_: 要素は水平方向に詰め込まれている、列と一緒に表示
** _columns_vertical_: 要素は垂直方向に詰め込まれている、列と一緒に表示
* _size_: バーのサイズ、文字単位 (0 は自動サイズ)
* _size_max_: バーの最大サイズ (0 は最大サイズが指定されていない)
* _color_fg_: バーのテキスト色
// TRANSLATION MISSING
* _color_bg_inactive_: background color for window bar which is not displayed
  in active window
* _color_delim_: バーの区切り文字の色
* _color_bg_: バーの背景色
* _separator_:
** _on_: バーには他のウィンドウおよびバーとの区切り行がある
** _off_: 区切り無し
* _items_: バーの要素のリスト、コンマ (要素の間に間隔)、または
  "+" (要素の間に間隔を開けない) 区切り

戻り値:

* 新しいバーへのポインタ、エラーが起きた場合は NULL

// TRANSLATION MISSING
[NOTE]
Since version 4.0.0, if the bar already exists, WeeChat sets the values received
as default values for bar options and returns the bar pointer instead of NULL.

C 言語での使用例:

[source,c]
----
struct t_gui_bar *my_bar = weechat_bar_new (
    "mybar", "off", "100", "window", "", "top", "horizontal", "vertical",
    "0", "5", "default", "cyan", "blue", "darkgray", "off",
    "time,buffer_number+buffer_name");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def bar_new(name: str, hidden: str, priority: str, type: str, condition: str, position: str,
            filling_top_bottom: str, filling_left_right: str, size: str, size_max: str,
            color_fg: str, color_delim: str, color_bg: str, color_bg_inactive: str,
            separator: str, items: str) -> str: ...

# 例
bar = weechat.bar_new("mybar", "off", "100", "window", "", "top", "horizontal", "vertical",
    "0", "5", "default", "cyan", "blue", "darkgray", "off", "time,buffer_number+buffer_name")
----

// TRANSLATION MISSING
[NOTE]
With WeeChat ≥ 2.9, in Ruby, the 4 colors (color_fg, color_delim, color_bg,
color_bg_inactive) must be given in an array of 4 strings (due to a Ruby
limitation of 15 arguments by function), see the
link:++weechat_scripting.ja.html#_ruby++[WeeChat scripting guide ^↗^^]
for more info.

==== bar_set

バープロパティに新しい値を設定。

プロトタイプ:

[source,c]
----
int weechat_bar_set (struct t_gui_bar *bar, const char *property,
                     const char *value);
----

引数:

* _bar_: バーへのポインタ
* _property_: name、hidden、priority、conditions、position、filling_top_bottom、filling_left_right、size、size_max、color_fg、color_delim、color_bg、separator、items (<<_bar_new,bar_new>> を参照)
* _value_: プロパティの新しい値

戻り値:

* 新しい値を設定した場合は 1、エラーが起きた場合は 0

C 言語での使用例:

[source,c]
----
weechat_bar_set (mybar, "position", "bottom");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def bar_set(bar: str, property: str, value: str) -> int: ...

# 例
weechat.bar_set(my_bar, "position", "bottom")
----

==== bar_update

画面上のバーの内容を更新。

プロトタイプ:

[source,c]
----
void weechat_bar_update (const char *name);
----

引数:

* _name_: バーの名前

C 言語での使用例:

[source,c]
----
weechat_bar_update ("mybar");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def bar_update(name: str) -> int: ...

# 例
weechat.bar_update("mybar")
----

==== bar_remove

バーを削除。

プロトタイプ:

[source,c]
----
void weechat_bar_remove (struct t_gui_bar *bar);
----

引数:

* _bar_: バーへのポインタ

C 言語での使用例:

[source,c]
----
weechat_bar_remove (mybar);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def bar_remove(bar: str) -> int: ...

# 例
weechat.bar_remove(my_bar)
----

[[commands]]
=== コマンド

WeeChat コマンドを実行する関数。

==== command

// TRANSLATION MISSING
_Updated in 1.1, 4.0.0._

コマンドを実行するか、バッファにテキストを送信。

プロトタイプ:

[source,c]
----
int weechat_command (struct t_gui_buffer *buffer, const char *command);
----

引数:

* _buffer_: バッファへのポインタ
  (コマンドは指定したバッファで実行されます、現在のバッファで実行するには NULL を指定してください)
* _command_: 実行するコマンド ("/"
  で始まっている場合)、またはバッファに送信するテキスト

// TRANSLATION MISSING
[NOTE]
On buffer with `input_multiline` set to `0` (default), only the first command
is executed (before the first newline char: `\n`).

戻り値 _(WeeChat バージョン 1.1 以上で利用可)_:

* _WEECHAT_RC_OK_ 成功した場合
* _WEECHAT_RC_ERROR_ エラーが起きた場合

C 言語での使用例:

[source,c]
----
int rc;
rc = weechat_command (weechat_buffer_search ("irc", "libera.#weechat"),
                      "/whois FlashCode");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def command(buffer: str, command: str) -> int: ...

# 例
rc = weechat.command(weechat.buffer_search("irc", "libera.#weechat"), "/whois FlashCode")
----

==== command_options

// TRANSLATION MISSING
_WeeChat ≥ 2.5, updated in 4.0.0, 4.5.0._

バッファにてオプション付きでコマンドを実行またはテキストを送信

プロトタイプ:

[source,c]
----
int weechat_command_options (struct t_gui_buffer *buffer, const char *command,
                             struct t_hashtable *options);
----

引数:

* _buffer_: バッファへのポインタ
  (コマンドは指定したバッファで実行されます、現在のバッファで実行するには NULL を指定してください)
// TRANSLATION MISSING
* _command_: 実行するコマンド (if beginning with a `/` or a command char)、またはバッファに送信するテキスト
* _options_: オプションを含むハッシュテーブル (キーと値は文字列です)
  (NULL は使えません):
* _options_: a hashtable with some options (keys and values must be string)
  (can be NULL):
// TRANSLATION MISSING
** _commands_: 指定したコマンドの中で実行を許可するコマンドのカンマ区切りリスト、リストの書式は関数
   <<_string_match_list,string_match_list>> を参考にしてください;
   the special value `-` (hyphen-minus) disables the execution of commands
   and the string in _command_ is sent as-is to the buffer (_WeeChat ≥ 4.5.0_)
** _delay_: コマンド実行までの遅延時間、ミリ秒単位
// TRANSLATION MISSING
** _split_newline_: `1` to split commands on newline char (`\n`) (_WeeChat ≥ 4.0.0_)

戻り値:

* _WEECHAT_RC_OK_ 成功した場合
* _WEECHAT_RC_ERROR_ エラーが起きた場合

C 言語での使用例:

[source,c]
----
/* /exec 以外のコマンド実行を許可、2 秒後にコマンドを実行 */
int rc;
struct t_hashtable *options = weechat_hashtable_new (8,
                                                     WEECHAT_HASHTABLE_STRING,
                                                     WEECHAT_HASHTABLE_STRING,
                                                     NULL,
                                                     NULL);
weechat_hashtable_set (options, "commands", "*,!exec");
weechat_hashtable_set (options, "delay", "2000");
rc = weechat_command_options (NULL, "/some_command arguments", options);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def command_options(buffer: str, command: str, options: Dict[str, str]) -> int: ...

# 例: /exec 以外のコマンド実行を許可
rc = weechat.command_options("", "/some_command arguments", {"commands": "*,!exec", "delay": "2000"})
----

// TRANSLATION MISSING
[[completion]]
=== Completion

Functions to complete a command line.

// TRANSLATION MISSING
==== completion_new

_WeeChat ≥ 2.9._

Create a new completion.

プロトタイプ:

[source,c]
----
struct t_gui_completion *weechat_completion_new (struct t_gui_buffer *buffer);
----

引数:

* _buffer_: buffer pointer

Return value:

* pointer to new completion

C 言語での使用例:

[source,c]
----
struct t_gui_completion *completion = weechat_completion_new (weechat_buffer_search_main ());
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def completion_new(buffer: str) -> str: ...

# 例
completion = weechat.completion_new(weechat.buffer_search_main())
----

// TRANSLATION MISSING
==== completion_search

_WeeChat ≥ 2.9._

Search possible words at a given position of a string, in the completion
context.

プロトタイプ:

[source,c]
----
int weechat_completion_search (struct t_gui_completion *completion, const char *data,
                               int position, int direction);
----

引数:

* _completion_: completion pointer
* _data_: the string to complete
* _position_: index of the char in string to complete (starts to 0)
* _direction_: 1 for next completion, -1 for previous completion

戻り値:

* 成功した場合は 1、失敗した場合は 0

C 言語での使用例:

[source,c]
----
struct t_gui_completion *completion = weechat_completion_new (weechat_buffer_search_main ());
if (weechat_completion_search (completion, "/help filt", 10, 1))
{
    /* ... */
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def completion_search(completion: str, data: str, position: int, direction: int) -> int: ...

# 例
completion = weechat.completion_new(weechat.buffer_search_main())
if weechat.completion_search(completion, "/help filt", 10, 1):
    # ...
----

==== completion_get_string

_WeeChat バージョン 2.9 以上で利用可。_

補完プロパティを文字列で取得。

プロトタイプ:

[source,c]
----
const char *weechat_completion_get_string (struct t_gui_completion *completion,
                                           const char *property);
----

引数:

* _completion_: 補完へのポインタ
* _property_: プロパティ名:
** _base_command_: 補完に使ったコマンド
** _base_word_: 補完された単語
** _args_: コマンド引数 (元の単語を含む)

C 言語での使用例:

[source,c]
----
int
my_completion_cb (const void *pointer, void *data, const char *completion_item,
                  struct t_gui_buffer *buffer,
                  struct t_gui_completion *completion)
{
    /* get arguments of command */
    const char *args = weechat_completion_get_string (completion, "args");

    /* completion depending on args */
    /* ... */

    return WEECHAT_RC_OK;
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def completion_get_string(completion: str, property: str) -> str: ...

# 例
def my_completion_cb(data: str, completion_item: str, buffer: str, completion: str) -> int:
    # get arguments of command
    args = weechat.completion_get_string(completion, "args")
    # completion depending on args
    # ...
    return weechat.WEECHAT_RC_OK
----

==== completion_set

_WeeChat バージョン 4.6.0 以上で利用可。_

// TRANSLATION MISSING
Set a completion property.

プロトタイプ:

[source,c]
----
void weechat_completion_get_string (struct t_gui_completion *completion,
                                    const char *property,
                                    const char *value);
----

引数:

* _completion_: 補完へのポインタ
* _property_: プロパティ名 (以下の表を参照)
* _value_: プロパティの新しい値

プロパティ:

[width="100%",cols="^2,^1,4,8",options="header"]
|===
// TRANSLATION MISSING
| Name | Min WeeChat | Value | Description

// TRANSLATION MISSING
| add_space | 4.6.0 | "0" or "1"
| "0": do not add space after completion +
  "1": add space after completion (default).
|===

C 言語での使用例:

[source,c]
----
int
my_completion_cb (const void *pointer, void *data, const char *completion_item,
                  struct t_gui_buffer *buffer,
                  struct t_gui_completion *completion)
{
    /* do not add space after completion */
    weechat_completion_set (completion, "add_space", "0");

    /* ... */

    return WEECHAT_RC_OK;
}
----

スクリプト (Python) での使用例:

[source,python]
----
# prototype
def completion_set(completion: str, property: str, value: str) -> int: ...

# example
def my_completion_cb(data: str, completion_item: str, buffer: str, completion: str) -> int:
    # do not add space after completion
    weechat.completion_set(completion, "add_space", "0")
    # ...
    return weechat.WEECHAT_RC_OK
----

==== completion_list_add

_WeeChat バージョン 2.9 以上で利用可。_

補完用に単語を追加。

プロトタイプ:

[source,c]
----
void weechat_completion_list_add (struct t_gui_completion *completion,
                                  const char *word,
                                  int nick_completion,
                                  const char *where);
----

引数:

* _completion_: 補完へのポインタ
* _word_: 追加する単語
* _nick_completion_: 単語がニックネームの場合は 1、そうでなければ 0
* _where_: 単語を追加するリスト上での位置:
** _WEECHAT_LIST_POS_SORT_: リストがソートされた状態になるような位置
** _WEECHAT_LIST_POS_BEGINNING_: リストの最初
** _WEECHAT_LIST_POS_END_: リストの最後

C 言語での使用例: <<_hook_completion,hook_completion>> を参照。

スクリプト (Python) での使用例:

// TRANSLATION MISSING
[source,python]
----
# プロトタイプ
def completion_list_add(completion: str, word: str, nick_completion: int, where: str) -> int: ...

# 例: see function hook_completion
----

// TRANSLATION MISSING
==== completion_free

_WeeChat ≥ 2.9._

Free a completion.

プロトタイプ:

[source,c]
----
void weechat_completion_free (struct t_gui_completion *completion);
----

引数:

* _completion_: completion pointer

C 言語での使用例:

[source,c]
----
weechat_completion_free (completion);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def completion_free(completion: str) -> int: ...

# 例
weechat.completion_free(completion)
----

[[network]]
=== ネットワーク

ネットワーク関数。

==== network_pass_proxy

プロキシへの接続および認証を確立する。

[IMPORTANT]
この関数は connect() の呼び出しを遮断します、このため connect() を呼び出す場合は
WeeChat がこれを遮断しないように必ずフォークしたプロセスの中で行ってください。

プロトタイプ:

[source,c]
----
int weechat_network_pass_proxy (const char *proxy,
                                int sock,
                                const char *address,
                                int port);
----

引数:

* _proxy_: 使用するプロキシ名
* _sock_: 使用するソケット
* _address_: アドレス (ホスト名または IP アドレス)
* _port_: ポート番号

戻り値:

* 接続が確立された場合は 1、エラーが起きた場合は 0

C 言語での使用例:

[source,c]
----
if (weechat_network_pass_proxy ("my_proxy", sock, "irc.libera.chat", 6667))
{
    /* OK */
}
else
{
    /* error */
}
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== network_connect_to

_WeeChat バージョン 0.4.3 で更新。_

リモートホストとの接続を確立する。

[IMPORTANT]
この関数は connect() の呼び出しを遮断します、このため connect() を呼び出す場合は
WeeChat がこれを遮断しないように必ずフォークしたプロセスの中で行ってください。

プロトタイプ:

[source,c]
----
int weechat_network_connect_to (const char *proxy,
                                struct sockaddr *address,
                                socklen_t address_length);
----

引数:

* _proxy_: 使用するプロキシ名
* _address_: 接続先のアドレス (ポート番号を含む)
* _address_length_: 引数 _address_ の長さ

戻り値:

* 接続が確立した場合はソケット番号 (≥ 0)、エラーが起きた場合は -1

C 言語での使用例:

[source,c]
----
struct sockaddr *addr;
socklen_t length;
int sock;

/* allocate/set address and port in _addr_, set _length_ */
/* ... */

sock = weechat_network_connect_to (NULL, addr, length);
if (sock >= 0)
{
    /* OK */
}
else
{
    /* error */
}
----

[NOTE]
スクリプト API ではこの関数を利用できません。

[[infos]]
=== インフォ

インフォを取得する関数。

==== info_get

_WeeChat バージョン 2.5 で更新。_

文字列型で WeeChat またはプラグインからのインフォを返す。

プロトタイプ:

[source,c]
----
char *weechat_info_get (const char *info_name, const char *arguments);
----

引数:

* _info_name_: 読み出すインフォの名前 (以下の表を参照)
* _arguments_: 指定したインフォに対する引数
  (任意、引数を指定しない場合は NULL)

戻り値:

* 指定したインフォを含む文字列、エラーが起きた場合は NULL
  (使用後には必ず "free" を呼び出して領域を開放してください)

[NOTE]
WeeChat バージョン 2.5 以上の場合、返却される値は確保された文字列です
(WeeChat バージョン 2.4 以下の場合、返却される値は定数文字列へのポインタです)。

インフォ:

include::{autogendir}/autogen_api_infos.ja.adoc[tag=infos]

C 言語での使用例:

[source,c]
----
char *version = weechat_info_get ("version", NULL);
char *date = weechat_info_get ("date", NULL);
weechat_printf (NULL, "Current WeeChat version is: %s (compiled on %s)",
                version, date);
if (version)
    free (version);
if (date)
    free (date);

char *weechat_config_dir = weechat_info_get ("weechat_config_dir", NULL);
weechat_printf (NULL, "WeeChat config directory is: %s", weechat_config_dir);
if (weechat_config_dir)
    free (weechat_config_dir);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def info_get(info_name: str, arguments: str) -> str: ...

# 例
weechat.prnt("", "Current WeeChat version is: %s (compiled on %s)"
    % (weechat.info_get("version", ""), weechat.info_get("date", ""))
weechat.prnt("", "WeeChat config directory is: %s" % weechat.info_get("weechat_config_dir", ""))
----

==== info_get_hashtable

_WeeChat バージョン 0.3.4 以上で利用可。_

ハッシュテーブルで WeeChat またはプラグインからのインフォを返す。

プロトタイプ:

[source,c]
----
struct t_hashtable *weechat_info_get_hashtable (const char *info_name,
                                                struct t_hashtable *hashtable);
----

引数:

* _info_name_: 読み出すインフォの名前 (以下の表を参照)
* _hashtable_: 引数を含むハッシュテーブル (指定したインフォに依存)
  (任意、引数を指定しない場合は NULL)

戻り値:

// TRANSLATION MISSING
* 指定したインフォを含むハッシュテーブル、エラーが起きた場合は NULL (must be
  freed by calling <<_hashtable_free,hashtable_free>> after use)

インフォ:

include::{autogendir}/autogen_api_infos_hashtable.ja.adoc[tag=infos_hashtable]

C 言語での使用例:

[source,c]
----
struct t_hashtable *hashtable_in, *hashtable_out;

hashtable_in = weechat_hashtable_new (8,
                                      WEECHAT_HASHTABLE_STRING,
                                      WEECHAT_HASHTABLE_STRING,
                                      NULL,
                                      NULL);
if (hashtable_in)
{
    weechat_hashtable_set (
        hashtable_in,
        "message",
        "@time=2015-06-27T16:40:35.000Z;tag2=value\\sspace :nick!user@host PRIVMSG #weechat :Hello world!");
    hashtable_out = weechat_info_get_hashtable ("irc_message_parse",
                                                hashtable_in);
    /*
     * now hashtable_out has following keys/values:
     *   "tags"                : "time=2015-06-27T16:40:35.000Z;tag2=value\\sspace"
     *   "tag_time"            : "2015-06-27T16:40:35.000Z"
     *   "tag_tag2"            : "value space"
     *   "message_without_tags": ":nick!user@host PRIVMSG #weechat :Hello world!"
     *   "nick"                : "nick"
     *   "user"                : "user"
     *   "host"                : "nick!user@host"
     *   "command"             : "PRIVMSG"
     *   "channel"             : "#weechat"
     *   "arguments"           : "#weechat :Hello world!"
     *   "text"                : "Hello world!"
     *   "param1"              : "#weechat"
     *   "param2"              : "Hello world!"
     *   "num_params"          : "2"
     *   "pos_command"         : "65"
     *   "pos_arguments"       : "73"
     *   "pos_channel"         : "73"
     *   "pos_text"            : "83"
     */
    weechat_hashtable_free (hashtable_in);
    weechat_hashtable_free (hashtable_out);
}
----

[NOTE]
"irc_message_parse" の出力に関するより詳しい情報は
link:weechat_scripting.ja.html#irc_message_parse[WeeChat スクリプト作成ガイド / メッセージの構文解析 ^↗^^]を参照してください。

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def info_get_hashtable(info_name: str, dict_in: Dict[str, str]) -> Dict[str, str]: ...

# 例
dict_in = {"message": ":nick!user@host PRIVMSG #weechat :message here"}
weechat.prnt("", "message parsed: %s"
             % weechat.info_get_hashtable("irc_message_parse", dict_in))
----

[[infolists]]
=== インフォリスト

インフォリストは「要素」の配列であり、各要素には変数が含まれています。

例えば、インフォリスト "irc_server" には N 個 (N は定義済みの IRC サーバの数)
の要素が含まれています。それぞれの要素には "name"、"buffer"、"is_connected"
などの変数が含まれています。

各要素には型と値があり、以下の型を使うことができます:

* _integer_: 任意の整数値
* _string_: 任意の文字列値
* _pointer_: 任意のポインタ
* _buffer_: 任意のデータを含む固定長のバッファ
* _time_: 時刻値

==== infolist_new

新しいインフォリストを作成。

プロトタイプ:

[source,c]
----
struct t_infolist *weechat_infolist_new ();
----

戻り値:

* 新しいインフォリストへのポインタ

C 言語での使用例:

[source,c]
----
struct t_infolist *infolist = weechat_infolist_new ();
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def infolist_new() -> str: ...

# 例
infolist = weechat.infolist_new()
----

==== infolist_new_item

インフォリストに要素を追加。

プロトタイプ:

[source,c]
----
struct t_infolist_item *weechat_infolist_new_item (struct t_infolist *infolist);
----

引数:

* _infolist_: インフォリストへのポインタ

戻り値:

* 新しい要素へのポインタ

C 言語での使用例:

[source,c]
----
struct t_infolist_item *item = weechat_infolist_new_item (infolist);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def infolist_new_item(infolist: str) -> str: ...

# 例
item = weechat.infolist_new_item(infolist)
----

==== infolist_new_var_integer

インフォリストの要素に整数変数を追加。

プロトタイプ:

[source,c]
----
struct t_infolist_var *weechat_infolist_new_var_integer (struct t_infolist_item *item,
                                                         const char *name,
                                                         int value);
----

引数:

* _item_: インフォリストの要素へのポインタ
* _name_: 変数名
* _value_: 整数値

戻り値:

* 新しい値へのポインタ

C 言語での使用例:

[source,c]
----
struct t_infolist_var *var = weechat_infolist_new_var_integer (item,
                                                               "my_integer",
                                                               123);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def infolist_new_var_integer(item: str, name: str, value: int) -> str: ...

# 例
var = weechat.infolist_new_var_integer(item, "my_integer", 123)
----

==== infolist_new_var_string

インフォリストの要素に文字列変数を追加。

プロトタイプ:

[source,c]
----
struct t_infolist_var *weechat_infolist_new_var_string (struct t_infolist_item *item,
                                                        const char *name,
                                                        const char *value);
----

引数:

* _item_: インフォリストの要素へのポインタ
* _name_: 変数名
* _value_: 文字列値

戻り値:

* 新しい値へのポインタ

C 言語での使用例:

[source,c]
----
struct t_infolist_var *var = weechat_infolist_new_var_string (item,
                                                              "my_string",
                                                              "value");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def infolist_new_var_string(item: str, name: str, value: str) -> str: ...

# 例
var = weechat.infolist_new_var_string(item, "my_string", "value")
----

==== infolist_new_var_pointer

インフォリストの要素にポインタ変数を追加。

プロトタイプ:

[source,c]
----
struct t_infolist_var *weechat_infolist_new_var_pointer (struct t_infolist_item *item,
                                                         const char *name,
                                                         void *pointer);
----

引数:

* _item_: インフォリストの要素へのポインタ
* _name_: 変数名
* _pointer_: ポインタ

戻り値:

* 新しい値へのポインタ

C 言語での使用例:

[source,c]
----
struct t_infolist_var *var = weechat_infolist_new_var_pointer (item,
                                                               "my_pointer",
                                                               &pointer);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def infolist_new_var_pointer(item: str, name: str, pointer: str) -> str: ...

# 例
var = weechat.infolist_new_var_pointer(item, "my_pointer", pointer)
----

==== infolist_new_var_buffer

インフォリストの要素にバッファ変数を追加。

プロトタイプ:

[source,c]
----
struct t_infolist_var *weechat_infolist_new_var_buffer (struct t_infolist_item *item,
                                                        const char *name,
                                                        void *pointer,
                                                        int size);
----

引数:

* _item_: インフォリストの要素へのポインタ
* _name_: 変数名
* _pointer_: バッファへのポインタ
* _size_: バッファのサイズ

戻り値:

* 新しい値へのポインタ

C 言語での使用例:

[source,c]
----
char buffer[256];
/* ... */
struct t_infolist_var *var = weechat_infolist_new_var_buffer (item,
                                                              "my_buffer",
                                                              &buffer,
                                                              sizeof (buffer));
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== infolist_new_var_time

インフォリストの要素に時刻変数を追加。

プロトタイプ:

[source,c]
----
struct t_infolist_var *weechat_infolist_new_var_time (struct t_infolist_item *item,
                                                      const char *name,
                                                      time_t time);
----

引数:

* _item_: インフォリストの要素へのポインタ
* _name_: 変数名
* _time_: 時刻値

戻り値:

* 新しい値へのポインタ

C 言語での使用例:

[source,c]
----
struct t_infolist_var *var = weechat_infolist_new_var_time (item,
                                                            "my_time",
                                                            time (NULL));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def infolist_new_var_time(item: str, name: str, time: int) -> str: ...

# 例
var = weechat.infolist_new_var_time(item, "my_time", int(time.time()))
----

==== infolist_get

WeeChat またはプラグインからインフォリストを返す。

[IMPORTANT]
インフォリストの内容は実データの複製です。そのため多くのデータを含むインフォリスト
("buffer_lines" など) を要求した場合、WeeChat
は全てのデータを複製するのに必要なメモリを確保し、これにはある程度時間がかかります。 +
大きなインフォリストを使う代わりに、hdata を使うほうが望ましいです
(ただしインフォリストは生データである hdata よりも多くの情報を含む場合があります)、<<hdata,hdata>> を参照してください。

プロトタイプ:

[source,c]
----
struct t_infolist *weechat_infolist_get (const char *infolist_name,
                                         void *pointer,
                                         const char *arguments);
----

引数:

* _infolist_name_: 読み出すインフォリストの名前 (以下の表を参照)
* _pointer_: 要素へのポインタ、インフォリストからこの要素のみを取得する場合に指定
  (任意、NULL でも可)
* _arguments_: 指定したインフォリストに対する引数
  (任意、引数が不要の場合は NULL)

戻り値:

* インフォリストへのポインタ、エラーが起きた場合は NULL

インフォリスト:

include::{autogendir}/autogen_api_infolists.ja.adoc[tag=infolists]

C 言語での使用例:

[source,c]
----
struct t_infolist *infolist = weechat_infolist_get ("irc_server", NULL, NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def infolist_get(infolist_name: str, pointer: str, arguments: str) -> str: ...

# 例
infolist = weechat.infolist_get("irc_server", "", "")
----

==== infolist_next

「カーソル」をインフォリスト内の 1 つ後の要素に移動する。あるインフォリストに対するこの関数の呼び出し回数が
1 回目のの場合は、カーソルをインフォリスト内の最初の要素に移動する。

プロトタイプ:

[source,c]
----
int weechat_infolist_next (struct t_infolist *infolist);
----

引数:

* _infolist_: インフォリストへのポインタ

戻り値:

* カーソルが 1 つ後の要素に移動した場合は 1、リストの最後に到達した場合は 0

C 言語での使用例:

[source,c]
----
if (weechat_infolist_next (infolist))
{
    /* read variables in item... */
}
else
{
    /* no more item available */
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def infolist_next(infolist: str) -> int: ...

# 例
rc = weechat.infolist_next(infolist)
if rc:
    # read variables in item...
else:
    # no more item available
----

==== infolist_prev

「カーソル」をインフォリスト内の 1 つ前の要素に移動する。あるインフォリストに対するこの関数の呼び出し回数が
1 回目のの場合は、カーソルをインフォリスト内の最後の要素に移動する。

プロトタイプ:

[source,c]
----
int weechat_infolist_prev (struct t_infolist *infolist);
----

引数:

* _infolist_: インフォリストへのポインタ

戻り値:

*  カーソルが 1 つ前の要素に移動した場合は
  1、リストの最初に到達した場合は 0

C 言語での使用例:

[source,c]
----
if (weechat_infolist_prev (infolist))
{
    /* read variables in item... */
}
else
{
    /* no more item available */
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def infolist_prev(infolist: str) -> int: ...

# 例
rc = weechat.infolist_prev(infolist)
if rc:
    # read variables in item...
else:
    # no more item available
----

==== infolist_reset_item_cursor

インフォリストの「カーソル」をリセット。

プロトタイプ:

[source,c]
----
void weechat_infolist_reset_item_cursor (struct t_infolist *infolist);
----

引数:

* _infolist_: インフォリストへのポインタ

C 言語での使用例:

[source,c]
----
weechat_infolist_reset_item_cursor (infolist);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def infolist_reset_item_cursor(infolist: str) -> int: ...

# 例
weechat.infolist_reset_item_cursor(infolist)
----

==== infolist_search_var

_WeeChat バージョン 0.4.3 以上で利用可。_

現在のインフォリスト要素から変数を検索。

プロトタイプ:

[source,c]
----
struct t_infolist_var *weechat_infolist_search_var (struct t_infolist *infolist,
                                                    const char *name);
----

引数:

* _infolist_: インフォリストへのポインタ
* _name_: 変数名

戻り値:

* 見つかった変数へのポインタ、見つからない場合は NULL

C 言語での使用例:

[source,c]
----
if (weechat_infolist_search_var (infolist, "name"))
{
    /* 変数 "name" が存在する場合 */
    /* ... */
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def infolist_search_var(infolist: str, name: str) -> str: ...

# 例
if weechat.infolist_search_var(infolist, "name"):
    # 変数 "name" が存在する場合
    # ...
----

==== infolist_fields

現在のインフォリストの要素に対するフィールドのリストを返す。

プロトタイプ:

[source,c]
----
const char *weechat_infolist_fields (struct t_infolist *infolist);
----

引数:

* _infolist_: インフォリストへのポインタ

戻り値:

* 指定したインフォリストの要素に含まれる変数名のリスト。以下の変数名に対応する型の文字を含むコンマ区切りリスト、型は:
  "i" (整数)、"s" (文字列)、"p"
  (ポインタ)、"b" (バッファ)、"t" (時刻)。

C 言語での使用例:

[source,c]
----
const char *fields = weechat_infolist_fields (infolist);
/* fields contains something like:
   "i:my_integer,s:my_string,p:my_pointer,b:my_buffer,t:my_time" */
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def infolist_fields(infolist: str) -> str: ...

# 例
fields = weechat.infolist_fields(infolist)
# fields contains something like:
# "i:my_integer,s:my_string,p:my_pointer,b:my_buffer,t:my_time"
----

==== infolist_integer

現在のインフォリストの要素に含まれる整数変数の値を返す。

プロトタイプ:

[source,c]
----
int weechat_infolist_integer (struct t_infolist *infolist, const char *var);
----

引数:

* _infolist_: インフォリストへのポインタ
* _var_: 変数名 (必ず「整数」型)

戻り値:

* 変数の整数値

C 言語での使用例:

[source,c]
----
weechat_printf (NULL, "integer = %d",
                weechat_infolist_integer (infolist, "my_integer"));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def infolist_integer(infolist: str, var: str) -> int: ...

# 例
weechat.prnt("", "integer = %d" % weechat.infolist_integer(infolist, "my_integer"))
----

==== infolist_string

現在のインフォリストの要素に含まれる文字列変数の値を返す。

プロトタイプ:

[source,c]
----
const char *weechat_infolist_string (struct t_infolist *infolist, const char *var);
----

引数:

* _infolist_: インフォリストへのポインタ
* _var_: 変数名 (必ず「文字列」型)

戻り値:

* 変数の文字列値

C 言語での使用例:

[source,c]
----
weechat_printf (NULL, "string = %s",
                weechat_infolist_string (infolist, "my_string"));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def infolist_string(infolist: str, var: str) -> str: ...

# 例
weechat.prnt("", "string = %s" % weechat.infolist_string(infolist, "my_string"))
----

==== infolist_pointer

現在のインフォリストの要素に含まれるポインタ変数の値を返す。

プロトタイプ:

[source,c]
----
void *weechat_infolist_pointer (struct t_infolist *infolist, const char *var);
----

引数:

* _infolist_: インフォリストへのポインタ
* _var_: 変数名 (必ず「ポインタ」型)

戻り値:

* 変数のポインタ値

C 言語での使用例:

[source,c]
----
weechat_printf (NULL, "pointer = %p", weechat_infolist_pointer (infolist, "my_pointer"));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def infolist_pointer(infolist: str, var: str) -> str: ...

# 例
weechat.prnt("", "pointer = 0x%s" % weechat.infolist_pointer(infolist, "my_pointer"))
----

==== infolist_buffer

現在のインフォリストの要素に含まれるバッファ変数の値を返す。

プロトタイプ:

[source,c]
----
void *weechat_infolist_buffer (struct t_infolist *infolist, const char *var,
                               int *size);
----

引数:

* _infolist_: インフォリストへのポインタ
* _var_: 変数名 (必ず「バッファ」型)
* _size_: 整数変数へのポインタ、バッファサイズを返す

戻り値:

* バッファへのポインタ

C 言語での使用例:

[source,c]
----
int size;
void *pointer = weechat_infolist_buffer (infolist, "my_buffer", &size);
weechat_printf (NULL, "buffer = %p, size = %d", pointer, size);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== infolist_time

現在のインフォリストの要素に含まれる時刻変数の値を返す。

プロトタイプ:

[source,c]
----
time_t weechat_infolist_time (struct t_infolist *infolist, const char *var);
----

引数:

* _infolist_: インフォリストへのポインタ
* _var_: 変数名 (必ず「時刻」型)

戻り値:

* 変数の時刻値

C 言語での使用例:

[source,c]
----
weechat_printf (NULL, "time = %ld",
                weechat_infolist_time (infolist, "my_time"));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def infolist_time(infolist: str, var: str) -> int: ...

# 例
weechat.prnt("", "time = %d" % weechat.infolist_time(infolist, "my_time"))
----

==== infolist_free

インフォリストの領域を開放。

プロトタイプ:

[source,c]
----
void weechat_infolist_free (struct t_infolist *infolist);
----

引数:

* _infolist_: インフォリストへのポインタ

C 言語での使用例:

[source,c]
----
weechat_infolist_free (infolist);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def infolist_free(infolist: str) -> int: ...

# 例
weechat.infolist_free(infolist)
----

[[hdata]]
=== Hdata

hdata に対する関数 (WeeChat またはプラグインデータへの直アクセス)。

[IMPORTANT]
hdata を使うことで読み取り専用でデータにアクセスできます。hdata
変数が示すメモリ領域に何かを書き込むことは *厳禁* です。 +
データを更新する場合は必ず関数
<<_hdata_update,hdata_update>> を使ってください。

==== hdata_new

_WeeChat バージョン 0.3.6 以上で利用可、バージョン 0.3.9 と 0.4.0 で更新。_

新規の hdata を作成。

[NOTE]
.hdata vs インフォリスト
====
Hdata を使うことで高速に WeeChat およびプラグインのデータを読み出す事ができます。hdata
はインフォリストと似ていますが、異なる点もあります:

* hdata はインフォリストに比べて高速でメモリを節約できる: データを複製せずに直接読み出す。
* hdata とインフォリストのデータは異なる場合がある: hdata 構造体には生データ以外は含まれない
  (利便性を考慮してインフォリストには余分なデータが追加されている)
====

プロトタイプ:

[source,c]
----
struct t_hdata *weechat_hdata_new (const char *hdata_name, const char *var_prev, const char *var_next,
                                   int create_allowed, int delete_allowed,
                                   int (*callback_update)(void *data,
                                                          struct t_hdata *hdata,
                                                          void *pointer,
                                                          struct t_hashtable *hashtable),
                                   void *callback_update_data);
----

引数:

* _hdata_name_: hdata の名前
* _var_prev_: 構造体に含まれる変数名。構造体は配列の 1 つ前の要素へのポインタ
  (変数が利用不可能な場合は NULL でも可)
* _var_next_: 構造体に含まれる変数名。構造体は配列の 1 つ後の要素へのポインタ
  (変数が利用不可能な場合は NULL でも可)
* _create_allowed_: 構造体の作成を許可する場合は 1、それ以外の場合は 0
  _(WeeChat バージョン 0.4.0 以上で利用可)_
* _delete_allowed_: 構造体の削除を許可する場合は 1、それ以外の場合は 0
  _(WeeChat バージョン 0.3.9 以上で利用可)_
* _callback_update_: hdata 内のデータを更新する際のコールバック関数、データの更新を禁止する場合は NULL
  _(WeeChat バージョン 0.3.9 以上で利用可)_、引数と戻り値:
** _void *data_: ポインタ
** _struct t_hdata *hdata_: hdata へのポインタ
** _struct t_hashtable *hashtable_: 更新する変数を含むハッシュテーブル
   (<<_hdata_update,hdata_update>> を参照)
** return value: 更新された変数の数
* _callback_update_data_: WeeChat が _callback_update_ コールバックを呼び出す際にコールバックに渡すポインタ
  _(WeeChat バージョン 0.3.9 以上で利用可)_

戻り値:

* 新しい hdata へのポインタ

C 言語での使用例:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_new ("myplugin_list", "prev", "next", 0, 0, &callback_update, NULL);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== hdata_new_var

// TRANSLATION MISSING
_WeeChat ≥ 0.3.6, updated in 0.3.7, 0.3.9, 0.4.3, 3.4, 4.3.0._

hdata に新しい変数を作成。

プロトタイプ:

[source,c]
----
void weechat_hdata_new_var (struct t_hdata *hdata, const char *name, int offset, int type,
                            int update_allowed, const char *array_size, const char *hdata_name);
----

引数:

* _hdata_: hdata へのポインタ
* _name_: 変数名
* _offset_: 構造体における変数のオフセット
* _type_: 変数型、以下の 1 つ:
** _WEECHAT_HDATA_CHAR_
** _WEECHAT_HDATA_INTEGER_
** _WEECHAT_HDATA_LONG_
** _WEECHAT_HDATA_LONGLONG_ (_WeeChat ≥ 4.3.0_)
** _WEECHAT_HDATA_STRING_
** _WEECHAT_HDATA_SHARED_STRING_ (_WeeChat ≥ 0.4.3_)
** _WEECHAT_HDATA_POINTER_
** _WEECHAT_HDATA_TIME_
** _WEECHAT_HDATA_HASHTABLE_ (_WeeChat ≥ 0.3.7_)
** _WEECHAT_HDATA_OTHER_
* _update_allowed_: 変数の更新を許可する場合は 1、禁止する場合は 0
  _(WeeChat バージョン 0.3.9 以上で利用可)_
* _array_size_: 配列でない場合は必ず NULL、配列の場合の値は:
  _(WeeChat バージョン 0.3.9 以上で利用可)_
** hdata に含まれる変数の名前: 配列のサイズはこの名前の変数に収められている
   (配列サイズは動的に変化)
** 整数 (文字列): 配列のサイズは固定
** _*_: 自動サイズ: 配列のサイズは値の中に見つかる最初の NULL を元に計算されます
   (文字列、ポインタ、ハッシュテーブル型以外では使えません)
* _hdata_name_: hdata の名前 (変数が hdata を含む構造体へのポインタの場合)

// TRANSLATION MISSING
With WeeChat ≥ 3.4, the _array_size_ parameter can be prefixed with `*,` for
pointer to dynamically allocated array (without this prefix, the array is
considered static).

// TRANSLATION MISSING
Examples of variables and the corresponding array size (_WeeChat ≥ 3.4_):

// TRANSLATION MISSING
[width="100%",cols="3,3m,2,7",options="header"]
|===
| Variable declaration in C | Hdata type | Array size | Description

| `+int *numbers;+` | WEECHAT_HDATA_INTEGER | `+*,2+`
| Allocated array of 2 integers.

| `+int *numbers;+` | WEECHAT_HDATA_INTEGER | `+*,array_size+`
| Allocated array of integers, the size is stored in another variable called
  "array_size".

| `+int numbers[3];+` | WEECHAT_HDATA_INTEGER | `+3+`
| Static array of 3 integers.

| `+char **words;+` | WEECHAT_HDATA_STRING | `+*,*+`
| Allocated array of strings, dynamic size (NULL pointer must be present after
  last word).

| `+char **words;+` | WEECHAT_HDATA_STRING | `+*,count_words+`
| Allocated array of strings, the size is stored in another variable called
  "count_words".
|===

C 言語での使用例:

[source,c]
----
struct t_myplugin_list
{
    char *name;
    struct t_gui_buffer *buffer;
    int numbers[3];
    int tags_count;
    char **tags_array;
    char **string_split;
    struct t_myplugin_list *prev;
    struct t_myplugin_list *next;
};

/* ... */

struct t_hdata *hdata = weechat_hdata_new ("myplugin_list", "prev", "next");
weechat_hdata_new_var (hdata, "name", offsetof (struct t_myplugin_list, name), WEECHAT_HDATA_STRING, 0, NULL, NULL);
weechat_hdata_new_var (hdata, "buffer", offsetof (struct t_myplugin_list, buffer), WEECHAT_HDATA_POINTER, 0, NULL, NULL);
weechat_hdata_new_var (hdata, "numbers", offsetof (struct t_myplugin_list, numbers), WEECHAT_HDATA_INTEGER, 0, "3", NULL);
weechat_hdata_new_var (hdata, "tags_count", offsetof (struct t_myplugin_list, tags_count), WEECHAT_HDATA_INTEGER, 0, NULL, NULL);
weechat_hdata_new_var (hdata, "tags_array", offsetof (struct t_myplugin_list, tags_array), WEECHAT_HDATA_STRING, 0, "*,tags_count", NULL);
weechat_hdata_new_var (hdata, "string_split", offsetof (struct t_myplugin_list, string_split), WEECHAT_HDATA_STRING, 0, "*,*", NULL);
weechat_hdata_new_var (hdata, "prev", offsetof (struct t_myplugin_list, prev), WEECHAT_HDATA_POINTER, 0, NULL, "myplugin_list");
weechat_hdata_new_var (hdata, "next", offsetof (struct t_myplugin_list, next), WEECHAT_HDATA_POINTER, 0, NULL, "myplugin_list");
----

コードを短くするためにはマクロ "WEECHAT_HDATA_VAR" を使います。

[source,c]
----
WEECHAT_HDATA_VAR(struct t_myplugin_list, name, STRING, 0, NULL, NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, buffer, POINTER, 0, NULL, NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, numbers, INTEGER, 0, "3", NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, tags_count, INTEGER, 0, NULL, NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, tags_array, STRING, 0, "*,tags_count", NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, string_split, STRING, 0, "*,*", NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, prev, POINTER, 0, NULL, "myplugin_list");
WEECHAT_HDATA_VAR(struct t_myplugin_list, next, POINTER, 0, NULL, "myplugin_list");
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== hdata_new_list

_WeeChat バージョン 0.3.6 以上で利用可、バージョン 1.0 で更新。_

hdata に新しいリストへのポインタを作成。

プロトタイプ:

[source,c]
----
void weechat_hdata_new_list (struct t_hdata *hdata, const char *name, void *pointer, int flags);
----

引数:

* _hdata_: hdata へのポインタ
* _name_: 変数名
* _pointer_: リストへのポインタ
* _flags_: 以下の値の組み合わせ: _(WeeChat バージョン 1.0 以上)_
** _WEECHAT_HDATA_LIST_CHECK_POINTERS_: ポインタをチェックする際に使うリスト

C 言語での使用例:

[source,c]
----
struct t_myplugin_list
{
    char *name;
    struct t_gui_buffer *buffer;
    int tags_count;
    char **tags_array;
    char **string_split;
    struct t_myplugin_list *prev;
    struct t_myplugin_list *next;
};

/* ... */

struct t_hdata *hdata = weechat_hdata_new ("myplugin_list", "prev", "next");
weechat_hdata_new_var (hdata, "name", offsetof (struct t_myplugin_list, name), WEECHAT_HDATA_STRING, NULL, NULL);
weechat_hdata_new_var (hdata, "buffer", offsetof (struct t_myplugin_list, buffer), WEECHAT_HDATA_POINTER, NULL, NULL);
weechat_hdata_new_var (hdata, "tags_count", offsetof (struct t_myplugin_list, tags_count), WEECHAT_HDATA_INTEGER, NULL, NULL);
weechat_hdata_new_var (hdata, "tags_array", offsetof (struct t_myplugin_list, tags_array), WEECHAT_HDATA_STRING, "tags_count", NULL);
weechat_hdata_new_var (hdata, "string_split", offsetof (struct t_myplugin_list, string_split), WEECHAT_HDATA_STRING, "*", NULL);
weechat_hdata_new_var (hdata, "prev", offsetof (struct t_myplugin_list, prev), WEECHAT_HDATA_POINTER, NULL, "myplugin_list");
weechat_hdata_new_var (hdata, "next", offsetof (struct t_myplugin_list, next), WEECHAT_HDATA_POINTER, NULL, "myplugin_list");

weechat_hdata_new_list (hdata, "buffers", &buffers, WEECHAT_HDATA_LIST_CHECK_POINTERS);
weechat_hdata_new_list (hdata, "last_buffer", &last_buffer, 0);
----

コードを短くするためにはマクロ "WEECHAT_HDATA_LIST" を使います。

[source,c]
----
WEECHAT_HDATA_LIST(buffers, WEECHAT_HDATA_LIST_CHECK_POINTERS);
WEECHAT_HDATA_LIST(last_buffer, 0);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== hdata_get

_WeeChat バージョン 0.3.6 以上で利用可。_

WeeChat およびプラグイン構造体に対する hdata を返す。

[NOTE]
hdata はデータを含みません、hdata
は構造体における変数の位置を含むただのハッシュテーブル。つまりデータを読み出すためには
hdata と WeeChat およびプラグインへのポインタが必要です。

プロトタイプ:

[source,c]
----
struct t_hdata *weechat_hdata_get (const char *hdata_name);
----

引数:

* _hdata_name_: hdata の名前

戻り値:

* hdata へのポインタ、エラーが起きた場合は NULL

hdata のリスト:

include::{autogendir}/autogen_api_hdata.ja.adoc[tag=hdata]

C 言語での使用例:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("irc_server");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hdata_get(hdata_name: str) -> str: ...

# 例
hdata = weechat.hdata_get("irc_server")
----

==== hdata_get_var_offset

_WeeChat バージョン 0.3.6 以上で利用可。_

hdata における変数のオフセットを返す。

プロトタイプ:

[source,c]
----
int weechat_hdata_get_var_offset (struct t_hdata *hdata, const char *name);
----

引数:

* _hdata_: hdata へのポインタ
* _name_: 変数名

戻り値:

* オフセットの値、エラーが起きた場合は -1

C 言語での使用例:

[source,c]
----
int offset = weechat_hdata_get_var_offset (hdata, "name");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hdata_get_var_offset(hdata: str, name: str) -> int: ...

# 例
offset = weechat.hdata_get_var_offset(hdata, "name")
----

==== hdata_get_var_type

_WeeChat バージョン 0.3.6 以上で利用可。_

hdata 内の変数の型を (整数で) 返す。

プロトタイプ:

[source,c]
----
int weechat_hdata_get_var_type (struct t_hdata *hdata, const char *name);
----

引数:

* _hdata_: hdata へのポインタ
* _name_: 変数名

戻り値:

* 変数の型、エラーが起きた場合は -1

C 言語での使用例:

[source,c]
----
int type = weechat_hdata_get_var_type (hdata, "name");
switch (type)
{
    case WEECHAT_HDATA_CHAR:
        /* ... */
        break;
    case WEECHAT_HDATA_INTEGER:
        /* ... */
        break;
    case WEECHAT_HDATA_LONG:
        /* ... */
        break;
    case WEECHAT_HDATA_LONGLONG:
        /* ... */
        break;
    case WEECHAT_HDATA_STRING:
        /* ... */
        break;
    case WEECHAT_HDATA_SHARED_STRING:
        /* ... */
        break;
    case WEECHAT_HDATA_POINTER:
        /* ... */
        break;
    case WEECHAT_HDATA_TIME:
        /* ... */
        break;
    case WEECHAT_HDATA_HASHTABLE:
        /* ... */
        break;
    case WEECHAT_HDATA_OTHER:
        /* ... */
        break;
    default:
        /* variable not found */
        break;
}
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== hdata_get_var_type_string

_WeeChat バージョン 0.3.6 以上で利用可。_

変数の型を (文字列で) 返す。

プロトタイプ:

[source,c]
----
const char *weechat_hdata_get_var_type_string (struct t_hdata *hdata, const char *name);
----

引数:

* _hdata_: hdata へのポインタ
* _name_: 変数名

戻り値:

* 変数の型、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
weechat_printf (NULL, "type = %s", weechat_hdata_get_var_type_string (hdata, "name"));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hdata_get_var_type_string(hdata: str, name: str) -> str: ...

# 例
weechat.prnt("", "type = %s" % weechat.hdata_get_var_type_string("name"))
----

==== hdata_get_var_array_size

_WeeChat バージョン 0.3.9 以上で利用可。_

hdata に含まれる配列変数のサイズを返す。

プロトタイプ:

[source,c]
----
int weechat_hdata_get_var_array_size (struct t_hdata *hdata, void *pointer, const char *name);
----

引数:

* _hdata_: hdata へのポインタ
* _pointer_: WeeChat および plugin オブジェクトへのポインタ
* _name_: 変数名

戻り値:

* 配列変数のサイズ、配列変数でない場合とエラーが起きた場合は -1

C 言語での使用例:

[source,c]
----
int array_size = weechat_hdata_get_var_array_size (hdata, pointer, "name");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hdata_get_var_array_size(hdata: str, pointer: str, name: str) -> int: ...

# 例
array_size = weechat.hdata_get_var_array_size(hdata, pointer, "name")
----

==== hdata_get_var_array_size_string

_WeeChat バージョン 0.3.9 以上で利用可。_

hdata に含まれる配列変数のサイズを (文字列で) 返す。

プロトタイプ:

[source,c]
----
const char *weechat_hdata_get_var_array_size_string (struct t_hdata *hdata, void *pointer,
                                                     const char *name);
----

引数:

* _hdata_: hdata へのポインタ
* _pointer_: WeeChat および plugin オブジェクトへのポインタ
* _name_: 変数名

戻り値:

* 配列変数のサイズの文字列、配列変数でない場合とエラーが起きた場合は
  NULL

C 言語での使用例:

[source,c]
----
const char *array_size = weechat_hdata_get_var_array_size_string (hdata, pointer, "name");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hdata_get_var_array_size_string(hdata: str, pointer: str, name: str) -> str: ...

# 例
array_size = weechat.hdata_get_var_array_size_string(hdata, pointer, "name")
----

==== hdata_get_var_hdata

_WeeChat バージョン 0.3.6 以上で利用可。_

hdata に含まれる変数に対応する hdata を返す。

プロトタイプ:

[source,c]
----
const char *weechat_hdata_get_var_hdata (struct t_hdata *hdata, const char *name);
----

引数:

* _hdata_: hdata へのポインタ
* _name_: 変数名

戻り値:

* 変数に対応する、hdata がない場合とエラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
weechat_printf (NULL, "hdata = %s", weechat_hdata_get_var_hdata (hdata, "name"));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hdata_get_var_hdata(hdata: str, name: str) -> str: ...

# 例
weechat.prnt("", "hdata = %s" % weechat.hdata_get_var_hdata(hdata, "name"))
----

==== hdata_get_var

_WeeChat バージョン 0.3.6 以上で利用可。_

hdata に含まれる変数の内容へのポインタを返す。

プロトタイプ:

[source,c]
----
void *weechat_hdata_get_var (struct t_hdata *hdata, void *pointer, const char *name);
----

引数:

* _hdata_: hdata へのポインタ
* _pointer_: WeeChat および plugin オブジェクトへのポインタ
* _name_: 変数名

戻り値:

* 変数の内容へのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
void *pointer = weechat_hdata_get_var (hdata, buffer, "name");
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== hdata_get_var_at_offset

_WeeChat バージョン 0.3.6 以上で利用可。_

オフセットを使って hdata に含まれる変数を指定し、この内容へのポインタを返す。

プロトタイプ:

[source,c]
----
void *weechat_hdata_get_var_at_offset (struct t_hdata *hdata, void *pointer, int offset);
----

引数:

* _hdata_: hdata へのポインタ
* _pointer_: WeeChat および plugin オブジェクトへのポインタ
* _name_: 変数名

戻り値:

* 変数の内容へのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
int offset = weechat_hdata_get_var_offset (hdata, "name");
void *pointer = weechat_hdata_get_var_at_offset (hdata, buffer, offset);
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== hdata_get_list

_WeeChat バージョン 0.3.6 以上で利用可。_

hdata からリストへのポインタを返す。

プロトタイプ:

[source,c]
----
void *weechat_hdata_get_list (struct t_hdata *hdata, const char *name);
----

引数:

* _hdata_: hdata へのポインタ
* _name_: リスト名

戻り値:

* リストへのポインタ、エラーが起きた場合は NULL

C 言語での使用例:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffers = weechat_hdata_get_list (hdata, "gui_buffers");
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hdata_get_list(hdata: str, name: str) -> str: ...

# 例
hdata = weechat.hdata_get("buffer")
buffers = weechat.hdata_get_list(hdata, "gui_buffers")
----

==== hdata_check_pointer

_WeeChat バージョン 0.3.7 以上で利用可、バージョン 1.0 で更新。_

hdata とリストへのポインタを使ってポインタの妥当性を確認する。

プロトタイプ:

[source,c]
----
int weechat_hdata_check_pointer (struct t_hdata *hdata, void *list, void *pointer);
----

引数:

* _hdata_: hdata へのポインタ
* _list_: リストポインタ; NULL の場合 _(WeeChat バージョン 1.0 以上)_、ポインタは
   hdata に含まれる "check pointers" フラグを持つリストでチェックされます
  (<<_hdata_new_list,hdata_new_list>>
  を参照)、このフラグを持つリストがない場合、ポインタは妥当とされます。
* _pointer_: 確認するポインタ

戻り値:

* リスト内にポインタが有る場合は 1、無い場合は 0

C 言語での使用例:

[source,c]
----
/* check if a buffer pointer is valid */
struct t_hdata *hdata = weechat_hdata_get ("buffer");
if (weechat_hdata_check_pointer (hdata,
                                 weechat_hdata_get_list (hdata, "gui_buffers"),
                                 ptr_buffer))
{
    /* valid pointer */
}
else
{
    /* invalid pointer */
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hdata_check_pointer(hdata: str, list: str, pointer: str) -> int: ...

# 例
hdata = weechat.hdata_get("buffer")
if weechat.hdata_check_pointer(hdata, weechat.hdata_get_list(hdata, "gui_buffers"), ptr_buffer):
    # valid pointer
    # ...
else:
    # invalid pointer
    # ...
----

==== hdata_move

_WeeChat バージョン 0.3.6 以上で利用可。_

リスト内の他の要素にポインタを移動する。

プロトタイプ:

[source,c]
----
void *weechat_hdata_move (struct t_hdata *hdata, void *pointer, int count);
----

引数:

* _hdata_: hdata へのポインタ
* _pointer_: WeeChat および plugin オブジェクトへのポインタ
* _count_: 移動を実行する回数
  (負および正の整数、ゼロは禁止)

戻り値:

* 移動に成功した場合は移動先へのポインタ、要素が見つからないかエラーが発生した場合
  (例えばリストの最後に到達した場合) は NULL

C 言語での使用例:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();

/* バッファを次のバッファに 2 回移動 */
buffer = weechat_hdata_move (hdata, buffer, 2);

/* 1 つ前のバッファに移動 */
if (buffer)
    buffer = weechat_hdata_move (hdata, buffer, -1);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hdata_move(hdata: str, pointer: str, count: int) -> str: ...

# 例
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()

# バッファを次のバッファに 2 回移動
buffer = weechat.hdata_move(hdata, buffer, 2)

# 1 つ前のバッファに移動
if buffer:
    buffer = weechat.hdata_move(hdata, buffer, -1)
----

==== hdata_search

_WeeChat バージョン 0.4.1 以上で利用可、バージョン 3.4 で更新。_

リストから要素を検索: リスト内の各要素に対して _search_
の内容を評価し、マッチする要素が見つかるかリストの最後に到達するまでこれを続ける。

プロトタイプ:

[source,c]
----
void *weechat_hdata_search (struct t_hdata *hdata, void *pointer, const char *search,
                            struct t_hashtable *pointers, struct t_hashtable *extra_vars,
                            struct t_hashtable *options, int move);
----

引数:

* _hdata_: hdata へのポインタ
* _pointer_: WeeChat および plugin オブジェクトへのポインタ
* _search_: 評価する式、式中のデフォルトポインタは hdata の名前
  (デフォルトポインタはリストに含まれる各要素で置換されます); 式に関する詳細は
  link:weechat_user.ja.html#command_weechat_eval[WeeChat ユーザーズガイド / WeeChat コマンド / eval ^↗^^] を参照してください
* _pointers_: 関数に渡されるハッシュテーブル
  <<_string_eval_expression,string_eval_expression>>
* _extra_vars_: 関数に渡されるハッシュテーブル
  <<_string_eval_expression,string_eval_expression>>
* _options_: 関数に渡されるハッシュテーブル
  <<_string_eval_expression,string_eval_expression>>
* _move_: 検索に失敗した後に移動を実行する回数
  (負および正の整数、ゼロは禁止)

// TRANSLATION MISSING
[IMPORTANT]
You must ensure the _search_ expression is safe and does not include any
user data. Such unsafe data must be given in the hashtable _extra_vars_ and
referenced by `${xxx}` in the _search_ expression (see the example below).

戻り値:

* 見つかった要素へのポインタ、見つからなかった場合は NULL

C 言語での使用例:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("irc_server");
void *servers = weechat_hdata_get_list (hdata, "irc_servers");
struct t_hashtable *extra_vars = weechat_hashtable_new (8,
                                                        WEECHAT_HASHTABLE_STRING,
                                                        WEECHAT_HASHTABLE_STRING,
                                                        NULL,
                                                        NULL);

/* search irc server with name "libera" */
weechat_hashtable_set (extra_vars, "server_name", "libera");
void *server = weechat_hdata_search (hdata, servers, "${irc_server.name} == ${server_name}",
                                     NULL, extra_vars, NULL, 1);
if (server)
{
    /* ... */
}
weechat_hashtable_free (extra_vars);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hdata_search(hdata: str, pointer: str, search: str,
                 pointers: Dict[str, str], extra_vars: Dict[str, str], options: Dict[str, str],
                 count: int) -> str: ...

# 例
hdata = weechat.hdata_get("irc_server")
servers = weechat.hdata_get_list(hdata, "irc_servers")

# search irc server with name "libera"
server = weechat.hdata_search(hdata, servers, "${irc_server.name} == ${server_name}",
                              {}, {"server_name": "libera"}, {}, 1)
if server:
    # ...
----

==== hdata_char

_WeeChat バージョン 0.3.7 以上で利用可。_

hdata を使って構造体に含まれる文字型変数の値を返す。

プロトタイプ:

[source,c]
----
char weechat_hdata_char (struct t_hdata *hdata, void *pointer, const char *name);
----

引数:

* _hdata_: hdata へのポインタ
* _pointer_: WeeChat および plugin オブジェクトへのポインタ
* _name_: 変数名 (必ず「文字型」であること); 配列の場合、"N|name"
  のように名前を指定することが可能。ここで N は配列のインデックス (1 番目は 0)、例: "2|name"

戻り値:

* 文字型変数の値

C 言語での使用例:

[source,c]
----
weechat_printf (NULL, "letter = %c", weechat_hdata_char (hdata, pointer, "letter"));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hdata_char(hdata: str, pointer: str, name: str) -> int: ...

# 例
weechat.prnt("", "letter = %c" % weechat.hdata_char(hdata, pointer, "letter"))
----

==== hdata_integer

_WeeChat バージョン 0.3.6 以上で利用可。_

hdata を使って構造体に含まれる整数型変数の値を返す。

プロトタイプ:

[source,c]
----
int weechat_hdata_integer (struct t_hdata *hdata, void *pointer, const char *name);
----

引数:

* _hdata_: hdata へのポインタ
* _pointer_: WeeChat および plugin オブジェクトへのポインタ
* _name_: 変数名 (必ず「整数型」であること); 配列の場合、"N|name"
  のように名前を指定することが可能。ここで N は配列のインデックス (1 番目は 0)、例: "2|name"

戻り値:

* 整数型変数の値

C 言語での使用例:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
weechat_printf (NULL, "number = %d", weechat_hdata_integer (hdata, buffer, "number"));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hdata_integer(hdata: str, pointer: str, name: str) -> int: ...

# 例
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
weechat.prnt("", "number = %d" % weechat.hdata_integer(hdata, buffer, "number"))
----

==== hdata_long

_WeeChat バージョン 0.3.6 以上で利用可。_

hdata を使って構造体に含まれる "long" 型変数の値を返す。

プロトタイプ:

[source,c]
----
long weechat_hdata_long (struct t_hdata *hdata, void *pointer, const char *name);
----

引数:

* _hdata_: hdata へのポインタ
* _pointer_: WeeChat および plugin オブジェクトへのポインタ
* _name_: 変数名 (必ず「long 型」であること); 配列の場合、"N|name"
  のように名前を指定することが可能。ここで N は配列のインデックス (1 番目は 0)、例: "2|name"

戻り値:

* long 変数の値

C 言語での使用例:

[source,c]
----
weechat_printf (NULL, "longvar = %ld", weechat_hdata_long (hdata, pointer, "longvar"));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hdata_long(hdata: str, pointer: str, name: str) -> int: ...

# 例
weechat.prnt("", "longvar = %d" % weechat.hdata_long(hdata, pointer, "longvar"))
----

==== hdata_longlong

_WeeChat バージョン 4.3.0 以上で利用可。_

// TRANSLATION MISSING
Return value of "long long" variable in structure using hdata.

プロトタイプ:

[source,c]
----
long long weechat_hdata_longlong (struct t_hdata *hdata, void *pointer, const char *name);
----

引数:

* _hdata_: hdata へのポインタ
* _pointer_: WeeChat および plugin オブジェクトへのポインタ
* _name_: 変数名 (必ず「long long 型」であること); 配列の場合、"N|name"
  のように名前を指定することが可能。ここで N は配列のインデックス (1 番目は 0)、例: "2|name"

戻り値:

// TRANSLATION MISSING
* "long long" value of variable

C 言語での使用例:

[source,c]
----
weechat_printf (NULL, "longlongvar = %lld", weechat_hdata_longlong (hdata, pointer, "longlongvar"));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hdata_longlong(hdata: str, pointer: str, name: str) -> int: ...

# 例
weechat.prnt("", "longlongvar = %d" % weechat.hdata_longlong(hdata, pointer, "longlongvar"))
----

==== hdata_string

_WeeChat バージョン 0.3.6 以上で利用可。_

hdata を使って構造体に含まれる文字列型変数の値を返す。

プロトタイプ:

[source,c]
----
const char *weechat_hdata_string (struct t_hdata *hdata, void *pointer, const char *name);
----

引数:

* _hdata_: hdata へのポインタ
* _pointer_: WeeChat および plugin オブジェクトへのポインタ
* _name_: 変数名 (必ず「文字列型」であること); 配列の場合、"N|name"
  のように名前を指定することが可能。ここで N は配列のインデックス (1 番目は 0)、例: "2|name"

戻り値:

* 文字列変数の値

C 言語での使用例:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
weechat_printf (NULL, "name = %s", weechat_hdata_string (hdata, buffer, "name"));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hdata_string(hdata: str, pointer: str, name: str) -> str: ...

# 例
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
weechat.prnt("", "name = %s" % weechat.hdata_string(hdata, buffer, "name"))
----

==== hdata_pointer

_WeeChat バージョン 0.3.6 以上で利用可。_

hdata を使って構造体に含まれるポインタ型変数の値を返す。

プロトタイプ:

[source,c]
----
void *weechat_hdata_pointer (struct t_hdata *hdata, void *pointer, const char *name);
----

引数:

* _hdata_: hdata へのポインタ
* _pointer_: WeeChat および plugin オブジェクトへのポインタ
* _name_: 変数名 (必ず「ポインタ型」であること); 配列の場合、"N|name"
  のように名前を指定することが可能。ここで N は配列のインデックス (1 番目は 0)、例: "2|name"

戻り値:

* ポインタ型変数の値

C 言語での使用例:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
weechat_printf (NULL, "lines = %p", weechat_hdata_pointer (hdata, buffer, "lines"));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hdata_pointer(hdata: str, pointer: str, name: str) -> str: ...

# 例
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
weechat.prnt("", "lines = %x" % weechat.hdata_pointer(hdata, buffer, "lines"))
----

==== hdata_time

_WeeChat バージョン 0.3.6 以上で利用可。_

hdata を使って構造体に含まれる時刻型変数の値を返す。

プロトタイプ:

[source,c]
----
time_t weechat_hdata_time (struct t_hdata *hdata, void *pointer, const char *name);
----

引数:

* _hdata_: hdata へのポインタ
* _pointer_: WeeChat および plugin オブジェクトへのポインタ
* _name_: 変数名 (必ず「時刻型」であること); 配列の場合、"N|name"
  のように名前を指定することが可能。ここで N は配列のインデックス (1 番目は 0)、例: "2|name"

戻り値:

* 時刻型変数の値

C 言語での使用例:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *ptr = weechat_buffer_search_main ();
ptr = weechat_hdata_pointer (hdata, ptr, "lines");
if (ptr)
{
    hdata = weechat_hdata_get ("lines");
    ptr = weechat_hdata_pointer (hdata, ptr, "first_line");
    if (ptr)
    {
        hdata = weechat_hdata_get ("line");
        ptr = weechat_hdata_pointer (hdata, ptr, "data");
        if (ptr)
        {
            hdata = weechat_hdata_get ("line_data");
            time_t date = weechat_hdata_time (hdata, hdata, "date");
            weechat_printf (NULL, "time of last line displayed = %s", ctime (&date));
        }
    }
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hdata_time(hdata: str, pointer: str, name: str) -> int: ...

# 例
buf = weechat.buffer_search_main()
ptr = weechat.hdata_pointer(weechat.hdata_get("buffer"), buf, "lines")
if ptr:
    ptr = weechat.hdata_pointer(weechat.hdata_get("lines"), ptr, "first_line")
    if ptr:
        ptr = weechat.hdata_pointer(weechat.hdata_get("line"), ptr, "data")
        if ptr:
            date = weechat.hdata_time(weechat.hdata_get("line_data"), ptr, "date")
            weechat.prnt("", "time of first line displayed = %s" % time.strftime("%F %T", time.localtime(int(date))))
----

==== hdata_hashtable

_WeeChat バージョン 0.3.7 以上で利用可。_

hdata を使って構造体に含まれるハッシュテーブル型変数の値を返す。

プロトタイプ:

[source,c]
----
struct t_hashtable *weechat_hdata_hashtable (struct t_hdata *hdata, void *pointer, const char *name);
----

引数:

* _hdata_: hdata へのポインタ
* _pointer_: WeeChat および plugin オブジェクトへのポインタ
* _name_: 変数名 (必ず「ハッシュテーブル型」であること); 配列の場合、"N|name"
  のように名前を指定することが可能。ここで N は配列のインデックス (1 番目は 0)、例: "2|name"

戻り値:

* ハッシュテーブル型変数の値 (ハッシュテーブルへのポインタ)

C 言語での使用例:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
struct t_hashtable *hashtable = weechat_hdata_hashtable (hdata, buffer, "local_variables");
weechat_printf (NULL, "%d local variables in core buffer",
                weechat_hashtable_get_integer (hashtable, "items_count"));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hdata_hashtable(hdata: str, pointer: str, name: str) -> Dict[str, str]: ...

# 例
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
hash = weechat.hdata_hashtable(hdata, buffer, "local_variables")
weechat.prnt("", "local variables in core buffer:")
for key in hash:
    weechat.prnt("", "  %s == %s" % (key, hash[key]))
----

==== hdata_compare

// TRANSLATION MISSING
_WeeChat ≥ 1.9, updated in 4.1.0._

2 つのオブジェクトの hdata 変数を比較。

プロトタイプ:

[source,c]
----
int weechat_hdata_compare (struct t_hdata *hdata, void *pointer1, void *pointer2, const char *name, int case_sensitive);
----

引数:

* _hdata_: hdata へのポインタ
* _pointer1_: 1 番目の WeeChat およびプラグインオブジェクトへのポインタ
* _pointer2_: 2 番目の WeeChat およびプラグインオブジェクトへのポインタ
// TRANSLATION MISSING
* _name_: variable name or path to a variable name; 配列の場合、変数名を "N|name"
  のように指定できます。ここで N は配列のインデックス番号です (番号は 0 から始まります)。例: "2|name"
* _case_sensitive_: 大文字小文字を区別する場合 1、それ以外の場合 0

戻り値:

* variable1 < variable2 の場合は -1
* variable1 == variable2 の場合は 0
* variable1 > variable2 の場合は 1

C 言語での使用例:

[source,c]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer1 = weechat_buffer_search ("irc", "libera.#weechat");
struct t_gui_buffer *buffer2 = weechat_buffer_search ("irc", "libera.#weechat-fr");
weechat_printf (NULL, "comparison of buffer number = %d",
                weechat_hdata_compare (hdata, buffer1, buffer2, "number", 0));
weechat_printf (NULL, "comparison of number of lines = %d",
                weechat_hdata_compare (hdata, buffer1, buffer2, "own_lines.lines_count", 0));
weechat_printf (NULL, "comparison of local variable = %d",
                weechat_hdata_compare (hdata, buffer1, buffer2, "local_variables.myvar", 0));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hdata_compare(hdata: str, pointer1: str, pointer2: str, name: str, case_sensitive: int) -> int: ...

# 例
hdata = weechat.hdata_get("buffer")
buffer1 = weechat.buffer_search("irc", "libera.#weechat")
buffer2 = weechat.buffer_search("irc", "libera.#weechat-fr")
weechat.prnt("", "comparison of buffer number = %d" % weechat.hdata_compare(hdata, buffer1, buffer2, "number", 0))
weechat.prnt("", "comparison of number of lines = %d" % weechat.hdata_compare(hdata, buffer1, buffer2, "own_lines.lines_count", 0))
weechat.prnt("", "comparison of local variable = %d" % weechat.hdata_compare(hdata, buffer1, buffer2, "local_variables.myvar", 0))
----

==== hdata_set

_WeeChat バージョン 0.3.9 以上で利用可。_

hdata の変数に新しい値を設定。

[NOTE]
変数の更新を許可している場合に、この関数呼び出して良いのは update
コールバックの中だけです (<<_hdata_new,hdata_new>>
と <<_hdata_update,hdata_update>> を参照)

プロトタイプ:

[source,c]
----
int weechat_hdata_set (struct t_hdata *hdata, void *pointer, const char *name, const char *value);
----

引数:

* _hdata_: hdata へのポインタ
* _pointer_: WeeChat および plugin オブジェクトへのポインタ
* _name_: 変数名 (許可されている型: 文字型、整数型、long
  型、文字列型、ポインタ型、時刻型)
* _value_: 変数の新しい値

戻り値:

* 成功した場合は 1、エラーが起きた場合は 0

C 言語での使用例:

[source,c]
----
weechat_hdata_set (hdata, pointer, "message", "test");
----

[NOTE]
スクリプト API ではこの関数を利用できません。

==== hdata_update

_WeeChat バージョン 0.3.9 以上で利用可。_

hdata 内のデータを更新。

プロトタイプ:

[source,c]
----
int weechat_hdata_update (struct t_hdata *hdata, void *pointer, struct t_hashtable *hashtable);
----

引数:

* _hdata_: hdata へのポインタ
* _pointer_: WeeChat および plugin オブジェクトへのポインタ
* _hashtable_: 更新する変数:
  キーは変数の名前、値は変数の新しい値
  (キーと値は文字列)、以下の特別なキーを使うことができます:
** キー `+__create_allowed+` (値は任意): 構造体の作製を許可する場合は
   1、許可しない場合は 0 を返す _(WeeChat バージョン 0.4.0 以上で利用可)_
** キー `+__delete_allowed+` (値は任意): 構造体の削除を許可する場合は
   1、許可しない場合は 0 を返す
** キー `+__update_allowed+`、値は変数の名前: この変数の更新を許可する場合は
   1、許可しない場合は 0 を返す
** キー `+__delete+` (値は任意): 構造体を削除 (許可されている場合)

戻り値:

* 更新された変数の個数

C 言語での使用例:

[source,c]
----
/* 現在のバッファに表示されている最後のメッセージの時間を 1 時間前にする */

struct t_gui_lines *own_lines;
struct t_gui_line *line;
struct t_gui_line_data *line_data;
struct t_hdata *hdata;
struct t_hashtable *hashtable;
char str_date[64];

own_lines = weechat_hdata_pointer (weechat_hdata_get ("buffer"), weechat_current_buffer (), "own_lines");
if (own_lines)
{
    line = weechat_hdata_pointer (weechat_hdata_get ("lines"), own_lines, "last_line");
    if (line)
    {
        line_data = weechat_hdata_pointer (weechat_hdata_get ("line"), line, "data");
        hdata = weechat_hdata_get ("line_data");
        hashtable = weechat_hashtable_new (8,
                                           WEECHAT_HASHTABLE_STRING,
                                           WEECHAT_HASHTABLE_STRING,
                                           NULL,
                                           NULL);
        if (hashtable)
        {
            snprintf (str_date, sizeof (str_date), "%ld", ((long int)weechat_hdata_time (hdata, line_data, "date")) - 3600);
            weechat_hashtable_set (hashtable, "date", str_date);
            weechat_hdata_update (hdata, line_data, hashtable);
            weechat_hashtable_free (hashtable);
        }
    }
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hdata_update(hdata: str, pointer: str, hashtable: Dict[str, str]) -> int: ...

# 例: 現在のバッファに表示されている最後のメッセージの時間を 1 時間前にする
own_lines = weechat.hdata_pointer(weechat.hdata_get("buffer"), weechat.current_buffer(), "own_lines")
if own_lines:
    line = weechat.hdata_pointer(weechat.hdata_get("lines"), own_lines, "last_line")
    if line:
        line_data = weechat.hdata_pointer(weechat.hdata_get("line"), line, "data")
        hdata = weechat.hdata_get("line_data")
        weechat.hdata_update(hdata, line_data, {"date": str(weechat.hdata_time(hdata, line_data, "date") - 3600)})
----

==== hdata_get_string

_WeeChat バージョン 0.3.6 以上で利用可。_

hdata プロパティの文字列値を返す。

プロトタイプ:

[source,c]
----
const char *weechat_hdata_get_string (struct t_hdata *hdata, const char *property);
----

引数:

* _hdata_: hdata へのポインタ
* _property_: プロパティ名:
** _var_keys_: hdata に含まれる変数のキーのリストを含む文字列
   (書式: "key1,key2,key3")
** _var_values_: hdata に含まれる変数の値のリストを含む文字列
   (書式: "value1,value2,value3")
** _var_keys_values_: hdata に含まれる変数のキーと値のリストを含む文字列
   (書式: "key1:value1,key2:value2,key3:value3")
** _var_prev_:
   構造体に含まれる変数の名前、構造体はリスト内の 1 つ前の要素へのポインタ
** _var_next_:
   構造体に含まれる変数の名前、構造体はリスト内の 1 つ後の要素へのポインタ
** _list_keys_: hdata に含まれるリストのキーのリストを含む文字列
   (書式: "key1,key2,key3")
** _list_values_: hdata に含まれるリストの値のリストを含む文字列
   (書式: "value1,value2,value3")
** _list_keys_values_: hdata に含まれるリストのキーと値のリストを含む文字列
   (書式: "key1:value1,key2:value2,key3:value3")

戻り値:

* プロパティの文字列値

C 言語での使用例:

[source,c]
----
weechat_printf (NULL, "variables in hdata: %s", weechat_hdata_get_string (hdata, "var_keys"));
weechat_printf (NULL, "lists in hdata: %s", weechat_hdata_get_string (hdata, "list_keys"));
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def hdata_get_string(hdata: str, property: str) -> str: ...

# 例
weechat.prnt("", "variables in hdata: %s" % weechat.hdata_get_string(hdata, "var_keys"))
weechat.prnt("", "lists in hdata: %s" % weechat.hdata_get_string(hdata, "list_keys"))
----

[[upgrade]]
=== アップグレード

WeeChat をアップグレードする (コマンド "/upgrade") 関数。

==== upgrade_new

_WeeChat バージョン 1.5 で更新。_

アップグレード用のファイルを作成またはロード。

プロトタイプ:

[source,c]
----
struct t_upgrade_file *upgrade_file_new (const char *filename,
                                         int (*callback_read)(const void *pointer,
                                                              void *data,
                                                              struct t_upgrade_file *upgrade_file,
                                                              int object_id,
                                                              struct t_infolist *infolist),
                                         const void *callback_read_pointer,
                                         void *callback_read_data);
----

引数:

* _filename_: ファイルの名前 (WeeChat
  はこの名前に拡張子 ".upgrade" を追加します)
* _callback_read_: アップグレードファイル内の各オブジェクトを読み込む際に呼び出すコールバック関数
  引数と戻り値:
** _const void *pointer_: ポインタ
** _void *data_: ポインタ
** _struct t_upgrade_file *upgrade_file_: アップグレードファイルへのポインタ
** _int object_id_: オブジェクトの識別番号
** _struct t_infolist *infolist_: オブジェクトの内容を含むインフォリスト
** 戻り値:
*** _WEECHAT_RC_OK_
*** _WEECHAT_RC_ERROR_
* _callback_read_pointer_: WeeChat が _callback_read_
  コールバックを呼び出す際にコールバックに渡すポインタ
* _callback_read_data_: WeeChat が _callback_read_ コールバックを呼び出す際にコールバックに渡すポインタ;
  このポインタが NULL でない場合、このポインタは malloc (または類似の関数)
  によって割り当てられたものでなければいけません。さらに、このポインタはアップグレードファイルが閉じられた時点で自動的に開放されます

戻り値:

* アップグレードファイルへのポインタ

C 言語での使用例:

[source,c]
----
struct t_upgrade_file *upgrade_file = weechat_upgrade_new ("my_file",
                                                           NULL, NULL, NULL);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def upgrade_new(filename: str, callback_read: str, callback_read_data: str) -> str: ...

# 例
upgrade_file = weechat.upgrade_new("my_file", "", "")
----

==== upgrade_write_object

アップグレードファイルにオブジェクトを書き込む。

プロトタイプ:

[source,c]
----
int weechat_upgrade_write_object (struct t_upgrade_file *upgrade_file,
                                  int object_id,
                                  struct t_infolist *infolist);
----

引数:

* _upgrade_file_: アップグレードファイルへのポインタ
* _object_id_: オブジェクトの識別番号
* _infolist_: ファイルに書き込むインフォリスト

戻り値:

* 成功した場合は 1、エラーが起きた場合は 0

C 言語での使用例:

[source,c]
----
if (weechat_upgrade_write_object (upgrade_file, 1, &infolist))
{
    /* OK */
}
else
{
    /* error */
}
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def upgrade_write_object(upgrade_file: str, object_id: int, infolist: str) -> int: ...

# 例
weechat.upgrade_write_object(upgrade_file, 1, infolist)
----

==== upgrade_read

_WeeChat バージョン 1.5 で更新。_

アップグレードファイルを読み込む。

プロトタイプ:

[source,c]
----
int weechat_upgrade_read (struct t_upgrade_file *upgrade_file);
----

引数:

* _upgrade_file_: アップグレードファイルへのポインタ

戻り値:

* 成功した場合は 1、エラーが起きた場合は 0

C 言語での使用例:

[source,c]
----
weechat_upgrade_read (upgrade_file);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def upgrade_read(upgrade_file: str) -> int: ...

# 例
weechat.upgrade_read(upgrade_file)
----

==== upgrade_close

アップグレードファイルを閉じる。

プロトタイプ:

[source,c]
----
void weechat_upgrade_close (struct t_upgrade_file *upgrade_file);
----

引数:

* _upgrade_file_: アップグレードファイルへのポインタ

C 言語での使用例:

[source,c]
----
weechat_upgrade_close (upgrade_file);
----

スクリプト (Python) での使用例:

[source,python]
----
# プロトタイプ
def upgrade_close(upgrade_file: str) -> int: ...

# 例
weechat.upgrade_close(upgrade_file)
----
