= Referenze API per Plugin di WeeChat
:author: Sébastien Helleu
:email: flashcode@flashtux.org
:lang: it
:toc:
:toclevels: 4


Questo manuale documenta il client di chat WeeChat, ed è parte
del programma stesso.

La versione più recente di questo documento si trova qui:
https://weechat.org/doc


[[introduction]]
== Introduzione

WeeChat (Wee Enhanced Environment for Chat) è un client di chat
libero, veloce e leggero, realizzato per molti sistemi operativi.

Questo manuale documenta le API per i plugin di WeeChat, utilizzate
dai plugin C per interagire con il core di WeeChat.

[[plugins_in_weechat]]
== Plugin in WeeChat

Un plugin è un programma C che può richiamare le funzioni di WeeChat
definite in un'interfaccia.

Questo programma C non richiede i sorgenti di WeeChat per essere compilato
e può essere caricato dinamicamente in WeeChat con il comano `/plugin`.

Il plugin deve essere una libreria dinamica, per essere caricato dinamicamente
dal del sistema operativo.
In GNU/Linux, il file ha estensione ".so", ".dll" in Windows.

Il plugin deve includere il file "weechat-plugin.h" (disponibile nel codice
sorgente di WeeChat).
Il file definisce strutture e tipi utilizzati per comunicare con WeeChat.

[[macros]]
=== Macro

Il plugin deve utilizzare alcune macro (per definire alcune variabili):

WEECHAT_PLUGIN_NAME("nome")::
    nome del plugin

WEECHAT_PLUGIN_DESCRIPTION("descrizione")::
    breve descrizione del plugin

WEECHAT_PLUGIN_VERSION("1.0")::
    versione del plugin

WEECHAT_PLUGIN_LICENSE("GPL3")::
    licenza del plugin

[[main_functions]]
=== Funzioni principali

Il plugin deve usare due funzioni:

* weechat_plugin_init
* weechat_plugin_end

==== weechat_plugin_init

Questa funzione viene chiamata quando il plugin è caricato.
da WeeChat.

Prototipo:

[source,C]
----
int weechat_plugin_init (struct t_weechat_plugin *plugin,
                         int argc, char *argv[]);
----

Argomenti:

* 'plugin': puntatore alla struttura del plugin di WeeChat
* 'argc': numero di argomenti per il plugin (fornito dalla riga di comando
  dall'utente)
* 'argv': argomenti per il plugin

Valori restituiti:

* 'WEECHAT_RC_OK' se l'operazione ha successo (il plugin
  verrà caricato)
* 'WEECHAT_RC_ERROR' se c'è un errore (il plugin NON
  verrà caricato)

==== weechat_plugin_end

Questa funzione viene chiamata quando il plugin viene
scaricato da WeeChat.

Prototipo:

[source,C]
----
int weechat_plugin_end (struct t_weechat_plugin *plugin);
----

Argomenti:

* 'plugin': puntatore alla struttura plugin di WeeChat

Valori restituiti:

* 'WEECHAT_RC_OK' se l'operazione ha successo
* 'WEECHAT_RC_ERROR' se c'è un errore

[[compile_plugin]]
=== Compilazione del plugin

La compilazione non richiede i sorgenti di WeeChat, è richiesto solo
il file 'weechat-plugin.h'.

Per compilare un plugin che ha un file "tizio.c" (in GNU/Linux):

----
$ gcc -fPIC -Wall -c tizio.c
$ gcc -shared -fPIC -o libtizio.so tizio.o
----

[[load_plugin]]
=== Caricamento del plugin

Copiare il file 'libtizio.so' nella cartella plugin di sistema (ad
esempio '/usr/local/lib/weechat/plugins') oppure nella cartella
plugin dell'utente (ad esempio '/home/xxx/.weechat/plugins').

In WeeChat:

----
/plugin load tizio
----

[[plugin_example]]
=== Plugin di esempio

Un esempio completo di plugin, che aggiunge un comando '/double':
visualizza due volte gli argomenti nel buffer corrente, oppure esegue un
comando due volte (ok, non sarà molto utile, ma è solo un esempio!):

[source,C]
----
#include <stdlib.h>

#include "weechat-plugin.h"

WEECHAT_PLUGIN_NAME("double");
WEECHAT_PLUGIN_DESCRIPTION("Test plugin for WeeChat");
WEECHAT_PLUGIN_AUTHOR("Sébastien Helleu <flashcode@flashtux.org>");
WEECHAT_PLUGIN_VERSION("0.1");
WEECHAT_PLUGIN_LICENSE("GPL3");

struct t_weechat_plugin *weechat_plugin = NULL;


/* callback per il comando "/double" */

int
command_double_cb (void *data, struct t_gui_buffer *buffer, int argc,
                   char **argv, char **argv_eol)
{
    /* fa felice il compilatore C */
    (void) data;
    (void) buffer;
    (void) argv;

    if (argc > 1)
    {
        weechat_command (NULL, argv_eol[1]);
        weechat_command (NULL, argv_eol[1]);
    }

    return WEECHAT_RC_OK;
}

int
weechat_plugin_init (struct t_weechat_plugin *plugin,
                     int argc, char *argv[])
{
    weechat_plugin = plugin;

    weechat_hook_command ("double",
                          "Visualizza due volte un messaggio "
                          "oppure esegue un comando due volte",
                          "messaggio | comando",
                          "messaggio: messaggio da visualizzare due volte\n"
                          "comando: comando da eseguire due volte",
                          NULL,
                          &command_double_cb, NULL);

    return WEECHAT_RC_OK;
}

int
weechat_plugin_end (struct t_weechat_plugin *plugin)
{
    /* fa felice il compilatore C */
    (void) plugin;

    return WEECHAT_RC_OK;
}
----

[[plugin_api]]
== Plugin API

I capitoli seguenti descrivono le funzioni  nelle API, organizzate
in categorie.

Per ogni funzione, viene fornita:

* descrizione della funzione,
* prototipo C,
* dettaglio degli argomenti,
* valore restituito,
* esempio C,
* esempio nello script Python (la sintassi è simile per gli altri linguaggi di
  scripting).

[[plugins]]
=== Plugin

Funzioni per ottenere informazioni sui plugin.

==== weechat_plugin_get_name

Ottiene il nome del plugin.

Prototipo:

[source,C]
----
const char *weechat_plugin_get_name (struct t_weechat_plugin *plugin);
----

Argomenti:

* 'plugin': puntatore alla struttura plugin di WeeChat (può essere NULL)

Valore restituito:

* nome del plugin, "core" per il core di WeeChat (se il puntatore al plugin
  è NULL)

Esempio in C:

[source,C]
----
const char *name = weechat_plugin_get_name (plugin);
----

Script (Python):

[source,python]
----
# prototipo
name = weechat.plugin_get_name(plugin)

# esempio
plugin = weechat.buffer_get_pointer(weechat.current_buffer(), "plugin")
name = weechat.plugin_get_name(plugin)
----

[[strings]]
=== Stringhe

Molte delle funzioni stringa che seguono sono già disponibili tramite
funzioni standard in C, ma si raccomanda di utilizzare le funzioni in
questa API perché compatibili con UTF-8 e il locale.

==== weechat_charset_set

Imposta il nuovo set caratteri del nuovo plugin (il set caratteri predefinito
è 'UTF-8', così se il plugin usa 'UTF-8' non è necessario chiamare questa
funzione).

Prototipo:

[source,C]
----
void weechat_charset_set (const char *charset);
----

Argomenti:

* 'charset': nuovo set caratteri da usare

Esempio in C:

[source,C]
----
weechat_charset_set ("iso-8859-1");
----

Script (Python):

[source,python]
----
# prototipo
weechat.charset_set(charset)

# esempio
weechat.charset_set("iso-8859-1")
----

==== weechat_iconv_to_internal

Converte le stringhe per il set caratteri interno di
WeeChat (UTF-8).

Prototipo:

[source,C]
----
char *weechat_iconv_to_internal (const char *charset, const char *string);
----

Argomenti:

* 'charset': set caratteri da convertire
* 'string': stringa da convertire

Valore restituito:

* la stringa convertita (deve essere liberata richiamando "free"
  dopo l'utilizzo)

Esempio in C:

[source,C]
----
char *str = weechat_iconv_to_internal ("iso-8859-1", "iso string: é à");
/* ... */
free (str);
----

Script (Python):

[source,python]
----
# prototipo
str = weechat.iconv_to_internal(charset, string)

# esempio
str = weechat.iconv_to_internal("iso-8859-1", "iso string: é à")
----

==== weechat_iconv_from_internal

Converte la stringa dal set caratteri interno di WeeChat (UTF-8)
in un'altra.

Prototipo:

[source,C]
----
char *weechat_iconv_from_internal (const char *charset, const char *string);
----

Argomenti:

* 'charset': set caratteri in uscita
* 'string': stringa da convertire

Valore restituito:

* la stringa convertita (deve essere liberata richiamando "free"
  dopo l'utilizzo

Esempio in C:

[source,C]
----
char *str = weechat_iconv_from_internal ("iso-8859-1", "utf-8 string: é à");
/* ... */
free (str);
----

Script (Python):

[source,python]
----
# prototipo
str = weechat.iconv_from_internal(charset, string)

# esempio
str = weechat.iconv_from_internal("iso-8859-1", "utf-8 string: é à")
----

==== weechat_gettext

Restituisce la stringa tradotta (dipende dalla lingua).

Prototipo:

[source,C]
----
const char *weechat_gettext (const char *string);
----

Argomenti:

* 'string': stringa da tradurre

Valore restituito:

* stringa tradotta

Esempio in C:

[source,C]
----
char *str = weechat_gettext ("hello");
----

Script (Python):

[source,python]
----
# prototipo
str = weechat.gettext(string)

# esempio
str = weechat.gettext("hello")
----

==== weechat_ngettext

Restituisce la stringa tradotta, utilizzando il singolare o il plurale, in base
all'argomento 'count' (contatore).

Prototipo:

[source,C]
----
const char *weechat_ngettext (const char *string, const char *plural,
                              int count);
----

Argomenti:

* 'string': stringa da tradurre, singolare
* 'plural': stringa da tradurre, plurale
* 'count': utilizzato per scegliere tra singolare e plurale (la scelta viene
  fatta in base alla lingua locale)

Valore restituito:

* stringa tradotta

Esempio in C:

[source,C]
----
char *str = weechat_ngettext ("file", "files", num_files);
----

Script (Python):

[source,python]
----
# prototipo
str = weechat.ngettext(string, plural, count)

# esempio
num_files = 2
str = weechat.ngettext("file", "files", num_files)
----

==== weechat_strndup

Restituisce una stringa duplicata, con un massimo di caratteri
impostato su 'chars'.

Prototipo:

[source,C]
----
char *weechat_strndup (const char *string, int length);
----

Argomenti:

* 'string': stringa da duplicare
* 'length': caratteri massimi da duplicare

Valore restituito:

* stringa duplicata (deve essere liberata chiamando "free" dopo
  l'utilizzo)

Esempio in C:

[source,C]
----
char *str = weechat_strndup ("abcdef", 3);  /* result: "abc" */
/* ... */
free (str);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_string_tolower

Converte una stringa UTF-8 in minuscolo.

Prototipo:

[source,C]
----
void weechat_string_tolower (char *string);
----

Argomenti:

* 'string': stringa da convertire

Esempio in C:

[source,C]
----
char str[] = "AbCdé";
weechat_string_tolower (str);  /* str ora è: "abcdé" */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_string_toupper

Converte una stringa UTF-8 in maiuscolo.

Prototipo:

[source,C]
----
void weechat_string_toupper (char *string);
----

Argomenti:

* 'string': stringa da convertire

Esempio in C:

[source,C]
----
char str[] = "AbCdé";
weechat_string_toupper (str);  /* str ora è: "ABCDé" */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_strcasecmp

// TRANSLATION MISSING
_Updated in 1.0._

Confronta stringa non sensibile alle maiuscole e alla localizzazione.

Prototipo:

[source,C]
----
int weechat_strcasecmp (const char *string1, const char *string2);
----

Argomenti:

* 'string1': prima stringa da comparare
* 'string2': seconda stringa da comparare

Valore restituito:

* -1 se stringa1 < stringa2
* 0 se stringa1 == stringa1
* 1 se stringa1 > stringa2

Esempio in C:

[source,C]
----
int diff = weechat_strcasecmp ("aaa", "CCC");  /* == -2 */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_strcasecmp_range

// TRANSLATION MISSING
_WeeChat ≥ 0.3.7, updated in 1.0._

Confronta stringa non sensibile alle maiuscole e alla localizzazione, usando una
serie per il confronto.

Prototipo:

[source,C]
----
int weechat_strcasecmp_range (const char *string1, const char *string2, int range);
----

Argomenti:

* 'string1': prima stringa da comparare
* 'string2': seconda stringa da comparare
* 'range': numero di caratteri nel confronto maiuscole/minuscole, ad esempio:
** 26: "A-Z" vengono ridotti ad "a-z"
** 29: "A-Z [ \ ]" vengono ridotti ad "a-z { | }"
** 30: "A-Z [ \ ] ^" vengono ridotti ad "a-z { | } ~"

[NOTE]
I valori 29 e 30 vengono usati da alcuni protocolli come IRC.

Valore restituito:

* -1 se stringa1 < stringa2
* 0 se stringa1 == stringa1
* 1 se stringa1 > stringa2

Esempio in C:

[source,C]
----
int diff = weechat_strcasecmp_range ("nick{away}", "NICK[away]", 29);  /* == 0 */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_strncasecmp

// TRANSLATION MISSING
_Updated in 1.0._

Confronta stringa indipendente non sensibile alle maiuscole e alla
localizzazione, per un numero 'max' di caratteri.

Prototipo:

[source,C]
----
int weechat_strncasecmp (const char *string1, const char *string2, int max);
----

Argomenti:

* 'string1': prima stringa da comparare
* 'string2': seconda stringa da comparare
* 'max': numero massimo di caratteri da comparare

Valore restituito:

* -1 se stringa1 < stringa2
* 0 se stringa1 == stringa1
* 1 se stringa1 > stringa2

Esempio in C:

[source,C]
----
int diff = weechat_strncasecmp ("aabb", "aacc", 2);  /* == 0 */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_strncasecmp_range

// TRANSLATION MISSING
_WeeChat ≥ 0.3.7, updated in 1.0._

Confronta una stringa non sensibile alle maiuscole e alla localizzazione, per un
numero 'max' di caratteri, usando una serie per il confronto.

Prototipo:

[source,C]
----
int weechat_strncasecmp_range (const char *string1, const char *string2, int max, int range);
----

Argomenti:

* 'string1': prima stringa da comparare
* 'string2': seconda stringa da comparare
* 'max': numero massimo di caratteri da comparare
* 'range': numero di caratteri nel confronto maiuscole/minuscole, ad esempio:
** 26: "A-Z" vengono ridotti ad "a-z"
** 29: "A-Z [ \ ]" vengono ridotti ad "a-z { | }"
** 30: "A-Z [ \ ] ^" vengono ridotti ad "a-z { | } ~"

[NOTE]
I valori 29 e 30 vengono usati da alcuni protocolli come IRC.

Valore restituito:

* -1 se stringa1 < stringa2
* 0 se stringa1 == stringa1
* 1 se stringa1 > stringa2

Esempio in C:

[source,C]
----
int diff = weechat_strncasecmp_range ("nick{away}", "NICK[away]", 6, 29);  /* == 0 */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_strcmp_ignore_chars

// TRANSLATION MISSING
_Updated in 1.0._

Confronta una stringa localizzata (e opzionalmente non sensibile alle
maiuscole), ignorando alcuni caratteri.

Prototipo:

[source,C]
----
int weechat_strcmp_ignore_chars (const char *string1, const char *string2,
                                 const char *chars_ignored,
                                 int case_sensitive);
----

Argomenti:

* 'string1': prima stringa per il confronto
* 'string2': seconda stringa per il confronto
* 'chars_ignored': stringa con caratteri da ignorare
* 'case_sensitive': 1 per il confronto sensibile alle maiuscole, altrimenti 0

Valore restituito:

* -1 se stringa1 < stringa2
* 0 se stringa1 == stringa1
* 1 se stringa1 > stringa2

Esempio in C:

[source,C]
----
int diff = weechat_strcmp_ignore_chars ("a-b", "--a-e", "-", 1);  /* == -3 */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_strcasestr

Cerca una stringa non sensibile alle maiuscole e indipendente dalla
localizzazione.

Prototipo:

[source,C]
----
char *weechat_strcasestr (const char *string, const char *search);
----

Argomenti:

* 'string': stringa
* 'search': stringa da cercare in 'string'

Valore restituito:

* puntatore alla stringa trovata, o NULL se non trovata

Esempio in C:

[source,C]
----
char *pos = weechat_strcasestr ("aBcDeF", "de");  /* risultato: puntatore a "DeF" */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_strlen_screen

_WeeChat ≥ 0.4.2._

Restituisce il numero di caratteri necessari per visualizzare la stringa
UTF-8 su schermo.
// TRANSLATION MISSING
Non-printable chars have a width of 1 (this is the difference with the function
<<_weechat_utf8_strlen_screen,weechat_utf8_strlen_screen>>).

Prototipo:

[source,C]
----
int weechat_strlen_screen (const char *string);
----

Argomenti:

* 'string': stringa

Valore restituito:

* numero di caratteri necessari per visualizzare la stringa UTF-8
su schermo

Esempio in C:

[source,C]
----
int length_on_screen = weechat_strlen_screen ("é");  /* == 1 */
----

Script (Python):

[source,python]
----
# prototipo
length = weechat.strlen_screen(string)

# esempio
length = weechat.strlen_screen("é")  # 1
----

==== weechat_string_match

// TRANSLATION MISSING
_Updated in 1.0._

Verifica se una stringa coincide ad una mask.

Prototipo:

[source,C]
----
int weechat_string_match (const char *string, const char *mask,
                          int case_sensitive);
----

Argomenti:

* 'string': stringa
// TRANSLATION MISSING
* 'mask': mask with wildcards ("*"), each wildcard matches 0 or more chars in
  the string
* 'case_sensitive': 1 per il confronto sensibile alle maiuscole, altrimenti 0

// TRANSLATION MISSING
[NOTE]
Since version 1.0, wildcards are allowed inside the mask
(not only beginning/end of mask).

Valore restituito:

* 1 se la stringa coincide alla mask, altrimenti 0

Esempio in C:

[source,C]
----
int match1 = weechat_string_match ("abcdef", "abc*", 0);   /* == 1 */
int match2 = weechat_string_match ("abcdef", "*dd*", 0);   /* == 0 */
int match3 = weechat_string_match ("abcdef", "*def", 0);   /* == 1 */
int match4 = weechat_string_match ("abcdef", "*de*", 0);   /* == 1 */
int match5 = weechat_string_match ("abcdef", "*b*d*", 0);  /* == 1 */
----

Script (Python):

[source,python]
----
# prototipo
match = weechat.string_match(string, mask, case_sensitive)

# esempio
match1 = weechat.string_match("abcdef", "abc*", 0)   # 1
match2 = weechat.string_match("abcdef", "*dd*", 0)   # 0
match3 = weechat.string_match("abcdef", "*def", 0)   # 1
match4 = weechat.string_match("abcdef", "*de*", 0)   # 1
match5 = weechat.string_match("abcdef", "*b*d*", 0)  # 1
----

==== weechat_string_expand_home

_WeeChat ≥ 0.3.3._

Sostituisce la `~` iniziale con la stringa con la cartella home. Se la stringa
non inizia con `~`, viene restituita la stessa stringa.

Prototipo:

[source,C]
----
char *weechat_string_expand_home (const char *path);
----

Argomenti:

* 'path': percorso

Valore restituito:

* percorso con la `~` iniziale sostituita dalla cartella home (deve essere
  liberata chiamando "free" dopo l'uso)

Esempio in C:

[source,C]
----
char *str = weechat_string_expand_home ("~/file.txt");
/* result: "/home/xxx/file.txt" */
/* ... */
free (str);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_string_remove_quotes

Rimuove le virgolette all'inizio e alla fine della stringa (ignora gli
spazi se presenti prima delle prime virgolette o dopo le ultime virgolette).

Prototipo:

[source,C]
----
char *weechat_string_remove_quotes (const char *string, const char *quotes);
----

Argomenti:

* 'string': stringa
* 'quotes': stringa con elenco di virgolette

Valore restituito:

* stringa senza virgolette all'inizio/fine (deve essere liberata chiamando "free"
  dopo l'uso)

Esempio in C:

[source,C]
----
char *str = weechat_string_remove_quotes (string, " 'Non posso' ", "'");
/* risultato: "Non posso" */
/* ... */
free (str);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_string_strip

Rimuove i caratteri ad inizio/fine della stringa.

Prototipo:

[source,C]
----
char *weechat_string_strip (const char *string, int left, int right,
                            const char *chars);
----

Argomenti:

* 'string': stringa
* 'left': rimuove i caratteri a sinistra se diversi da 0
* 'right': rimuove i caratteri a destra se diversi da 0
* 'chars': stringa con i caratteri da rimuovere

Valore restituito:

* stringa corretta (deve essere liberata chiamando "free" dopo l'uso)

Esempio in C:

[source,C]
----
char *str = weechat_string_strip (".abc -", 0, 1, "- .");  /* risultato: ".abc" */
/* ... */
free (str);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_string_convert_escaped_chars

_WeeChat ≥ 1.0._

// TRANSLATION MISSING
Convert escaped chars to their value:

* `\"`: double quote
* `\\`: backslash
* `\a`: alert (BEL)
* `\b`: backspace
* `\e`: escape
* `\f`: form feed
* `\n`: new line
* `\r`: carriage return
* `\t`: horizontal tab
* `\v`: vertical tab
* `\0ooo`: char as octal value (ooo is 0 to 3 digits)
* `\xhh`: char as hexadecimal value (hh is 1 to 2 digits)
* `\uhhhh`: unicode char as hexadecimal value (hhhh is 1 to 4 digits)
* `\Uhhhhhhhh`: unicode char as hexadecimal value (hhhhhhhh is 1 to 8 digits)

Prototipo:

[source,C]
----
char *weechat_string_convert_escaped_chars (const char *string);
----

Argomenti:

* 'string': stringa

Valore restituito:

// TRANSLATION MISSING
* string with escaped chars replaced by their value (deve essere liberata
  chiamando "free" dopo l'uso)

Esempio in C:

[source,C]
----
char *str = weechat_string_convert_escaped_chars ("snowman: \\u2603");
/* str == "snowman: ☃" */
/* ... */
free (str);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_string_mask_to_regex

Restituisce una espressione regolare con una mask, dove l'unico carattere
speciale è "`*`". Tutti gli altri caratteri speciali per le espressioni regolari
non vengono riconosciuti.

Prototipo:

[source,C]
----
char *weechat_string_mask_to_regex (const char *mask);
----

Argomenti:

* 'mask': mask

Valore restituito:

* espressione regolare, come stringa (deve essere liberata chiamando "free"
  dopo l'uso)

Esempio in C:

[source,C]
----
char *str_regex = weechat_string_mask_to_regex ("test*mask");
/* result: "test.*mask" */
/* ... */
free (str_regex);
----

Script (Python):

[source,python]
----
# prototipo
regex = weechat.string_mask_to_regex(mask)

# esempio
regex = weechat.string_mask_to_regex("test*mask")  # "test.*mask"
----

==== weechat_string_regex_flags

_WeeChat ≥ 0.3.7._

Restituisce sia il puntatore sulla stringa dopo le flag che la mask con le flag
per compilare l'espressione regolare.

Prototipo:

[source,C]
----
const char *weechat_string_regex_flags (const char *regex, int default_flags, int *flags)
----

Argomenti:

// TRANSLATION MISSING
* 'regex': POSIX extended regular expression
* 'default_flags': combinazione dei seguenti valori (consultare `man regcomp`):
** REG_EXTENDED
** REG_ICASE
** REG_NEWLINE
** REG_NOSUB
// TRANSLATION MISSING
* 'flags': pointer value is set with flags used in regular expression (default
  flags + flags set in regular expression)

// TRANSLATION MISSING
Flags must be at beginning of regular expression. Format is:
"(?eins-eins)string".

// TRANSLATION MISSING
Allowed flags are:

// TRANSLATION MISSING
* 'e': POSIX extended regular expression ('REG_EXTENDED')
* 'i': case insensitive ('REG_ICASE')
* 'n': match-any-character operators don't match a newline ('REG_NEWLINE')
* 's': support for substring addressing of matches is not required ('REG_NOSUB')

Valore restituito:

// TRANSLATION MISSING
* pointer in 'regex', after flags

Esempio in C:

[source,C]
----
const char *regex = "(?i)test";
int flags;
const char *ptr_regex = weechat_string_regex_flags (regex, REG_EXTENDED, &flags);
/* ptr_regex == "test", flags == REG_EXTENDED | REG_ICASE */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_string_regcomp

_WeeChat ≥ 0.3.7._

// TRANSLATION MISSING
Compile a POSIX extended regular expression using optional flags at beginning
of string (for format of flags, see
<<_weechat_string_regex_flags,weechat_string_regex_flags>>).

Prototipo:

[source,C]
----
int weechat_string_regcomp (void *preg, const char *regex, int default_flags)
----

Argomenti:

// TRANSLATION MISSING
* 'preg': pointer to 'regex_t' structure
* 'regex': POSIX extended regular expression
* 'default_flags': combination of following values (see `man regcomp`):
** REG_EXTENDED
** REG_ICASE
** REG_NEWLINE
** REG_NOSUB

Valore restituito:

// TRANSLATION MISSING
* same return code as function `regcomp` (0 if ok, other value for error,
  see `man regcomp`)

Esempio in C:

[source,C]
----
regex_t my_regex;
if (weechat_string_regcomp (&my_regex, "(?i)test", REG_EXTENDED) != 0)
{
    /* error */
}
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_string_has_highlight

Controlla se una stringa ha uno o più eventi, usando la lista di parole per
gli eventi.

Prototipo:

[source,C]
----
int weechat_string_has_highlight (const char *string,
                                  const char highlight_words);
----

Argomenti:

* 'string': stringa
* 'highlight_words': lista di parole per gli eventi, separate da virgole

Valore restituito:

* 1 se la stringa ha uno o più eventi, altrimenti 0

Esempio in C:

[source,C]
----
int hl = weechat_string_has_highlight ("my test string", "test,word2");  /* == 1 */
----

Script (Python):

[source,python]
----
# prototipo
highlight = weechat.string_has_highlight(string, highlight_words)

# esempio
highlight = weechat.string_has_highlight("my test string", "test,word2")  # 1
----

==== weechat_string_has_highlight_regex

_WeeChat ≥ 0.3.4._

// TRANSLATION MISSING
Check if a string has one or more highlights, using a POSIX extended regular
expression. +
For at least one match of regular expression on string, it must be surrounded
by delimiters (chars different from: alphanumeric, "-", "_" and "|").

Prototipo:

[source,C]
----
int weechat_string_has_highlight_regex (const char *string, const char *regex);
----

Argomenti:

* 'string': stringa
// TRANSLATION MISSING
* 'regex': POSIX extended regular expression

Valore restituito:

* 1 se la stringa ha uno o più eventi, altrimenti 0

Esempio in C:

[source,C]
----
int hl = weechat_string_has_highlight_regex ("my test string", "test|word2");  /* == 1 */
----

Script (Python):

[source,python]
----
# prototipo
highlight = weechat.string_has_highlight_regex(string, regex)

# esempio
highlight = weechat.string_has_highlight_regex("my test string", "test|word2")  # 1
----

==== weechat_string_replace

Sostituisce tutte le ricorrenze di una stringa con un'altra.

Prototipo:

[source,C]
----
char *weechat_string_replace (const char *string, const char *search,
                              const char *replace);
----

Argomenti:

* 'string': stringa
* 'search': stringa da sostituire
* 'replace': sostituzione per la stringa 'search'

Valore restituito:

* la stringa dopo 'search' sostituita da 'replace' (deve essere liberata
  chiamando "free" dopo l'uso)

Esempio in C:

[source,C]
----
char *str = weechat_string_replace ("test", "s", "x");  /* result: "text" */
/* ... */
free (str);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_string_replace_regex

_WeeChat ≥ 1.0._

// TRANSLATION MISSING
Replace text in a string using a regular expression, replacement text and
optional callback.

Prototipo:

[source,C]
----
char *weechat_string_replace_regex (const char *string, void *regex,
                                    const char *replace, const char reference_char,
                                    char *(*callback)(void *data, const char *text),
                                    void *callback_data);
----

Argomenti:

// TRANSLATION MISSING
* 'string': string
* 'regex': pointer to a regular expression ('regex_t' structure) compiled with
  WeeChat function <<_weechat_string_regcomp,weechat_string_regcomp>> or regcomp
  (see `man regcomp`)
* 'replace': replacement text, where following references are allowed:
** `$0` to `$99`: match 0 to 99 in regular expression (0 is the whole match,
   1 to 99 are groups captured between parentheses)
** `$+`: the last match (with highest number)
** `$.*N`: match `N` (can be `+` or `0` to `99`), with all chars replaced by `*`
   (the `*` char can be any char between space (32) and `~` (126))
* 'reference_char': the char used for reference to match (commonly '$')
* 'callback': an optional callback called for each reference in 'replace'
  (except for matches replaced by a char); the callback must return:
** newly allocated string: it is used as replacement text (it is freed after
   use)
** NULL: the text received in callback is used as replacement text (without
   changes)
* 'callback_data': pointer given to callback when it is called

Valore restituito:

// TRANSLATION MISSING
* string with text replaced, NULL if problem (must be freed by calling "free"
  after use)

Esempio in C:

[source,C]
----
regex_t my_regex;
char *string;
if (weechat_string_regcomp (&my_regex, "([0-9]{4})-([0-9]{2})-([0-9]{2})",
                            REG_EXTENDED) == 0)
{
    string = weechat_string_replace_regex ("date: 2014-02-14", &my_regex,
                                           "$3/$2/$1", '$', NULL, NULL);
    /* string == "date: 14/02/2014" */
    if (string)
        free (string);
    regfree (&my_regex);
}
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_string_split

Divide una stringa in base a uno o più delimitatori.

Prototipo:

[source,C]
----
char **weechat_string_split (const char *string, const char *separators,
                             int keep_eol, int num_items_max,
                             int *num_items);
----

Argomenti:

* 'string': stringa da dividere
* 'separators': delimitatori usati per dividere
* 'keep_eol':
** 0: ogni stringa conterrà una parola
** 1: ogni stringa conterrà tutte le stringhe fino a fine riga
   (consultare il seguente esempio)
** 2: come il punto 1, ma non rimuove i delimitatori alla fine della stringa
   prima della divisione _(WeeChat ≥ 0.3.6)_
* 'num_items_max': numero massimo di elementi creati (0 = nessun limite)
* 'num_items': puntatore ad int che conterrà il numero di elementi creati

Valore restituito:

* array di stringhe, NULL se si verifica un problema (deve essere liberata chiamando
  <<_weechat_string_free_split,weechat_string_free_split>> dopo l'uso)

Esempi:

[source,C]
----
char **argv;
int argc;
argv = weechat_string_split ("abc de  fghi", " ", 0, 0, &argc);
/* result: argv[0] == "abc"
           argv[1] == "de"
           argv[2] == "fghi"
           argv[3] == NULL
           argc == 3
*/
weechat_string_free_split (argv);

argv = weechat_string_split ("abc de  fghi", " ", 1, 0, &argc);
/* result: argv[0] == "abc de  fghi"
           argv[1] == "de  fghi"
           argv[2] == "fghi"
           argv[3] == NULL
           argc == 3
*/
weechat_string_free_split (argv);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_string_split_shell

_WeeChat ≥ 1.0._

// TRANSLATION MISSING
Split a string like the shell does for a command with arguments.

// TRANSLATION MISSING
This function is a C conversion of Python class "shlex" (file: Lib/shlex.py in
Python repository), see: http://docs.python.org/3/library/shlex.html.

Prototipo:

[source,C]
----
char **weechat_string_split_shell (const char *string, int *num_items);
----

Argomenti:

* 'string': stringa da dividere
* 'num_items': puntatore ad int che conterrà il numero di elementi creati

Valore restituito:

* array di stringhe, NULL se si verifica un problema (deve essere liberata chiamando
  <<_weechat_string_free_split,weechat_string_free_split>> dopo l'uso)

Esempio in C:

[source,C]
----
char **argv;
int argc;
argv = weechat_string_split_shell ("test 'first arg'  \"second arg\"", &argc);
/* result: argv[0] == "test"
           argv[1] == "first arg"
           argv[2] == "second arg"
           argv[3] == NULL
           argc == 3
*/
weechat_string_free_split (argv);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_string_free_split

Libera la memoria usata per la divisione di una stringa.

Prototipo:

[source,C]
----
void weechat_string_free_split (char **split_string);
----

Argomenti:

* 'split_string': stringa divisa dalla funzione
  <<_weechat_string_split,weechat_string_split>>

Esempio in C:

[source,C]
----
char *argv;
int argc;
argv = weechat_string_split (string, " ", 0, 0, &argc);
/* ... */
weechat_string_free_split (argv);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_string_build_with_split_string

Compila una stringa con una stringa divisa.

Prototipo:

[source,C]
----
char *weechat_string_build_with_split_string (char **split_string,
                                              const char *separator);
----

Argomenti:

* 'split_string': stringa divisa dalla funzione
  <<_weechat_string_split,weechat_string_split>>
* 'separator': stringa usata per separare le stringhe

Valore restituito:

* stringa compilata con la stringa divisa (deve essere liberata chiamando
  "free" dopo l'uso)

Esempio in C:

[source,C]
----
char **argv;
int argc;
argv = weechat_string_split ("abc def ghi", " ", 0, 0, &argc);
char *str = weechat_string_build_with_split_string (argv, ";");
/* str == "abc;def;ghi" */
/* ... */
free (str);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_string_split_command

Divide una lista di comandi separata da 'separator' (che può essere
omesso aggiungendo "\" nella stringa).

Prototipo:

[source,C]
----
char **weechat_string_split_command (const char *command, char separator);
----

Argomenti:

* 'command': comando da dividere
* 'separator': separatore

Valore restituito:

* array di stringhe, NULL in caso di problemi (deve essere liberata chiamando
  <<_weechat_free_split_command,weechat_free_split_command>> dopo l'uso)

Esempio in C:

[source,C]
----
char **argv = weechat_string_split_command ("/command1 arg;/command2", ';');
/* result: argv[0] == "/command1 arg"
           argv[1] == "/command2"
*/
weechat_free_split_command (argv);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_string_free_split_command

Libera la memoria utilizzata dalla divisione di un comando.

Prototipo:

[source,C]
----
void weechat_string_free_split_command (char **split_command);
----

Argomenti:

* 'split_command': comando diviso da
  <<_weechat_string_split_command,weechat_string_split_command>>

Esempio in C:

[source,C]
----
char **argv = weechat_string_split_command ("/command1 arg;/command2", ';');
/* ... */
weechat_free_split_command (argv);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_string_format_size

Compila una stringa con un file di dimensione fissa ed una unità
tradotta nella lingua locale.

Prototipo:

[source,C]
----
char *weechat_string_format_size (unsigned long long size);
----

Argomenti:

* 'size': dimensione (in byte)

Valore restituito:

* stringa formattata (deve essere liberata chiamando "free" dopo l'uso)

Esempi in C:

[source,C]
----
/* esempi in lingua inglese */

char *str = weechat_string_format_size (0);  /* str == "0 bytes" */
/* ... */
free (str);

char *str = weechat_string_format_size (1);  /* str == "1 byte" */
/* ... */
free (str);

char *str = weechat_string_format_size (200);  /* str == "200 bytes" */
/* ... */
free (str);

char *str = weechat_string_format_size (15200);  /* str == "15.2 KB" */
/* ... */
free (str);

char *str = weechat_string_format_size (2097152);  /* str == "2.10 MB" */
/* ... */
free (str);
----

==== weechat_string_remove_color

Rimuove i colori di WeeChat da una stringa.

Prototipo:

[source,C]
----
char *weechat_string_remove_color (const char *string,
                                   const char *replacement);
----

Argomenti:

* 'string': stringa
* 'replacement': se non NULL e non vuota, i codici colore di WeeChat sono
  sostituiti dal primo carattere di questa stringa, altrimenti i codici colori di
  WeeChat ed i caratteri seguenti (se correlate al colore) sono rimossi dalla
  stringa

Valore restituito:

* stringa senza un colore (deve essere liberata chiamando "free" dopo l'uso)

Esempi:

[source,C]
----
/* rimuove i codici colore */
char *str = weechat_string_remove_color (my_string1, NULL);
/* ... */
free (str);

/* sostituisce i codici colore con "?" */
char *str = weechat_string_remove_color (my_string2, "?");
/* ... */
free (str);
----

Script (Python):

[source,python]
----
# prototipo
str = weechat.string_remove_color(string, replacement)

# esempio
str = weechat.string_remove_color(my_string, "?")
----

==== weechat_string_encode_base64

_WeeChat ≥ 0.3.2._

Codifica una stringa in base64.

Prototipo:

[source,C]
----
void weechat_string_encode_base64 (const char *from, int length, char *to);
----

Argomenti:

* 'from': stringa da codificare
* 'length': lunghezza della stringa da codificare (ad esempio `strlen(from)`)
* 'to': puntatore alla stringa per memorizzare il risultato (deve essere
  sufficientemente lunga, il risultato è più lungo della stringa iniziale)

Esempio in C:

[source,C]
----
char *string = "abcdefgh", result[128];
weechat_string_encode_base64 (string, strlen (string), result);
/* result == "YWJjZGVmZ2g=" */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_string_decode_base64

_WeeChat ≥ 0.3.2._

Decodifica una stringa in base64.

Prototipo:

[source,C]
----
int weechat_string_decode_base64 (const char *from, char *to);
----

Argomenti:

* 'from': stringa da decodificare
* 'to': puntatore alla stringa per memorizzare il risultato (deve essere
  sufficientemente lunga, il risultato è più lungo della stringa iniziale)

Valore restituito:

* lunghezza della stringa memorizzata in *to (lo '\0' finale non conta)

Esempio in C:

[source,C]
----
char *string = "YWJjZGVmZ2g=", result[128];
int length;
length = weechat_string_decode_base64 (string, result);
/* length == 8, result == "abcdefgh" */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_string_is_command_char

_WeeChat ≥ 0.3.2._

Verifica che il primo carattere della stringa sia un carattere comando
(il comando carattere predefinito è '/').

Prototipo:

[source,C]
----
int weechat_string_is_command_char (const char *string);
----

Argomenti:

* 'string': stringa

Valore restituito:

* 1 se il primo carattere della stringa è un comando carattere,
  altrimenti 0

Esempi in C:

[source,C]
----
int command_char1 = weechat_string_is_command_char ("/test");  /* == 1 */
int command_char2 = weechat_string_is_command_char ("test");   /* == 0 */
----

Script (Python):

[source,python]
----
# prototipo
is_cmdchar = weechat.string_is_command_char(string)

# esempi
command_char1 = weechat.string_is_command_char("/test")  # == 1
command_char2 = weechat.string_is_command_char("test")   # == 0
----

==== weechat_string_input_for_buffer

_WeeChat ≥ 0.3.2._

Restituisce il puntatore al testo in input per il buffer (puntatore all'interno
dell'argomento "string"), oppure NULL se è un comando.

Prototipo:

[source,C]
----
const char *weechat_string_input_for_buffer (const char *string);
----

Argomenti:

* 'string': stringa

Valore restituito:

* puntatore all'interno di "string", oppure NULL

Esempi in C:

[source,C]
----
const char *str1 = weechat_string_input_for_buffer ("test");    /* "test"  */
const char *str2 = weechat_string_input_for_buffer ("/test");   /* NULL    */
const char *str3 = weechat_string_input_for_buffer ("//test");  /* "/test" */
----

Script (Python):

[source,python]
----
# prototipo
str = weechat.string_input_for_buffer(string)

# esempi
str1 = weechat.string_input_for_buffer("test")    # "test"
str2 = weechat.string_input_for_buffer("/test")   # ""
str3 = weechat.string_input_for_buffer("//test")  # "/test"
----

==== weechat_string_eval_expression

// TRANSLATION MISSING
_WeeChat ≥ 0.4.0, updated in 0.4.2 and 1.1._

// TRANSLATION MISSING
Evaluate an expression and return result as a string.
Special variables with format `${variable}` are expanded (see table below).

// TRANSLATION MISSING
[NOTE]
Since version 1.0, nested variables are supported, for example:
`${color:${variable}}`.

Prototipo:

[source,C]
----
char *weechat_string_eval_expression (const char *expr,
                                      struct t_hashtable *pointers,
                                      struct t_hashtable *extra_vars,
                                      struct t_hashtable *options);
----

Argomenti:

// TRANSLATION MISSING
* 'expr': the expression to evaluate (see table below)
* 'pointers': hashtable with pointers (keys must be string, values must be
  pointer); pointers "window" and "buffer" are automatically added if they are
  not in hashtable (with pointer to current window/buffer) (can be NULL):
** 'regex': pointer to a regular expression ('regex_t' structure) compiled with
   WeeChat function <<_weechat_string_regcomp,weechat_string_regcomp>> or
   regcomp (see `man regcomp`); this option is similar to 'regex' in hashtable
   'options' (below), but is used for better performance
* 'extra_vars': extra variables that will be expanded (can be NULL)
* 'options': a hashtable with some options (keys and values must be string)
  (can be NULL):
** 'type': default behavior is just to replace values in expression, other
   types can be selected:
*** 'condition': the expression is evaluated as a condition: operators and
    parentheses are used, result is a boolean ("0" or "1")
** 'prefix': prefix before variables to replace (default: "${")
** 'suffix': suffix after variables to replace (default: "}")
** 'regex': a regex used to replace text in 'expr' (which is then not
   evaluated)
** 'regex_replace': the replacement text to use with 'regex', to replace
   text in 'expr' (the 'regex_replace' is evaluated on each match of 'regex'
   against 'expr', until no match is found)

Valore restituito:

// TRANSLATION MISSING
* evaluated expression (must be freed by calling "free" after use), or NULL
  if problem (invalid expression or not enough memory)

// TRANSLATION MISSING
List of variables expanded in expression (by order of priority, from first
expanded to last):

// TRANSLATION MISSING
[width="100%",cols="2,8,3,3",options="header"]
|===
| Format | Description | Examples | Results

| `${name}` | Variable `name` from hashtable 'extra_vars' |
  `${name}` | `value`

| `${esc:xxx}` +
  `${\xxx}` | String with escaped chars |
  `${esc:prefix\tmessage}` +
  `${\ua9}` |
  `prefix<TAB>message` +
  `©`

| `${hide:x,value}` |
  String with hidden chars (all chars in `value` replaced `x`) |
  `${hide:*,password}` |
 `********`

| `${re:N}` |
  Regex captured group: 0 = whole string matching, 1 to 99 = group captured,
  `+` = last group captured |
  `${re:1}` |
  `test`

| `${color:name}` |
  WeeChat color code (the name of color has optional attributes) |
  `${color:red}red text` +
  `${color:*214}bold orange text` |
  `red text` (in red) +
  `bold orange text` (in bold orange)

| `${info:name}` +
  `${indo:name,arguments}` |
  Info from WeeChat or a plugin, see function
  <<_weechat_info_get,weechat_info_get>> |
  `${info:version}` +
  `${info:irc_nick_color_name,foo}` |
  `1.0` +
  `lightblue`

| `${sec.data.name}` |
  Value of the secured data `name` |
  `${sec.data.freenode_pass}` |
  `my_password`

| `${file.section.option}` |
  Value of the option |
  `${weechat.look.buffer_time_format}` |
  `%H:%M:%S`

| `${name}` |
  Value of local variable `name` in buffer |
  `${nick}` |
  `FlashCode`

| `${hdata.var1.var2...}` +
  `${hdata[list].var1.var2...}` |
  Hdata value (pointers `window` and `buffer` are set by default with current
  window/buffer) |
  `${buffer[gui_buffers].full_name}` +
  `${window.buffer.number}` |
  `core.weechat` +
  `1`
|===

Esempi in C:

[source,C]
----
/* conditions */
struct t_hashtable *options1 = weechat_hashtable_new (8,
                                                      WEECHAT_HASHTABLE_STRING,
                                                      WEECHAT_HASHTABLE_STRING,
                                                      NULL,
                                                      NULL);
weechat_hashtable_set (options1, "type", "condition");
char *str1 = weechat_string_eval_expression ("${window.win_width} > 100", NULL, NULL, options1);  /* "1" */
char *str2 = weechat_string_eval_expression ("abc =~ def", NULL, NULL, options1);                 /* "0" */

/* simple expression */
char *str3 = weechat_string_eval_expression ("${buffer.full_name}", NULL, NULL, NULL);  /* "core.weechat" */

/* replace with regex */
struct t_hashtable *options2 = weechat_hashtable_new (8,
                                                      WEECHAT_HASHTABLE_STRING,
                                                      WEECHAT_HASHTABLE_STRING,
                                                      NULL,
                                                      NULL);
/* add brackets around URLs */
weechat_hashtable_set (options2, "regex", "\\w+://\\S+");
weechat_hashtable_set (options2, "regex_replace", "[ ${re:0} ]");
char *str4 = weechat_string_eval_expression ("test: https://weechat.org", NULL, NULL, NULL);  /* "test: [ https://weechat.org ]" */

/* hide passwords */
weechat_hashtable_set (options2, "regex", "(password=)(\\S+)");
weechat_hashtable_set (options2, "regex_replace", "${re:1}${hide:*,${re:2}}");
char *str5 = weechat_string_eval_expression ("password=abc password=def", NULL, NULL, NULL);  /* "password=*** password=***" */
----

Script (Python):

[source,python]
----
# prototipo
str = weechat.string_eval_expression(expr, pointers, extra_vars, options)

# esempi

# conditions
str1 = weechat.string_eval_expression("${window.win_width} > 100", {}, {}, {"type": "condition"})  # "1"
str2 = weechat.string_eval_expression("abc =~ def", {}, {}, {"type": "condition"})                 # "0"

# simple expression
str3 = weechat.string_eval_expression("${buffer.full_name}", {}, {}, {}) # "core.weechat"

# replace with regex: add brackets around URLs
options = {
    "regex": "\\w+://\\S+",
    "regex_replace": "[ ${re:0} ]",
}
str4 = weechat.string_eval_expression("test: https://weechat.org", {}, {}, options)  # "test: [ https://weechat.org ]"

# replace with regex: hide passwords
options = {
    "regex": "(password=)(\\S+)",
    "regex_replace": "${re:1}${hide:*,${re:2}}",
}
str5 = weechat.string_eval_expression("password=abc password=def", {}, {}, options)  # "password=*** password=***"
----

[[utf-8]]
=== UTF-8

Alcune funzioni stringa UTF-8.

==== weechat_utf8_has_8bits

Verifica che una stringa abbia caratteri a 8-bit.

Prototipo:

[source,C]
----
int weechat_utf8_has_8bits (const char *string);
----

Argomenti:

* 'string': stringa

Valore restituito:

* 1 se la stringa ha caratteri a 8-bit, 0 se solo a 7-bit

Esempio in C:

[source,C]
----
if (weechat_utf8_has_8bits (string))
{
    /* ... */
}
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_utf8_is_valid

Verifica che una stringa sia valida in UTF-8.

Prototipo:

[source,C]
----
int weechat_utf8_is_valid (const char *string, char **error);
----

Argomenti:

* 'string': stringa
* 'error': se non NULL, '*error*' è impostato con il puntatore al primo
  carattere UTF-8 non valido nella stringa, se esiste

Valore restituito:

* 1 se la stringa UTF-8 è valida, altrimenti 0

Esempio in C:

[source,C]
----
char *error;
if (weechat_utf8_is_valid (string, &error))
{
    /* ... */
}
else
{
    /* "error" punta al primo carattere non valido */
}
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_utf8_normalize

Normalizza le stringhe UTF-8: rimuove i caratteri non UTF-8 e li sostituisce con
un carattere.

Prototipo:

[source,C]
----
void weechat_utf8_normalize (char *string, char replacement);
----

Argomenti:

* 'string': stringa
* 'replacement': carattere sotitutivo per i caratteri non validi

Esempio in C:

[source,C]
----
weechat_utf8_normalize (string, '?');
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_utf8_prev_char

Restituisce il puntatore al carattere UTF-8 precedente in una stringa.

Prototipo:

[source,C]
----
char *weechat_utf8_prev_char (const char *string_start, const char *string);
----

Argomenti:

* 'string_start': inizio della stringa (la funzione non restituirà un carattere prima
  di questo puntatore)
* 'string': puntatore alla stringa (deve essere ≥ 'string_start')

Valore restituito:

* puntatore al precedente carattere UTF-8, NULL se non trovata (raggiunta
  l'inizio della stringa)

Esempio in C:

[source,C]
----
char *prev_char = weechat_utf8_prev_char (string, ptr_in_string);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_utf8_next_char

Restituisce il puntatore al successivo carattere UTF-8 in una stringa.

Prototipo:

[source,C]
----
char *weechat_utf8_next_char (const char *string);
----

Argomenti:

* 'string': stringa

Valore restituito:

* puntatore al carattere UTF-8 successivo, NULL se non trovato
  (raggiunta la fine della stringa)

Esempio in C:

[source,C]
----
char *next_char = weechat_utf8_next_char (string);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_utf8_char_int

Restituisce un carattere UTF-8 come intero.

Prototipo:

[source,C]
----
int weechat_utf8_char_int (const char *string);
----

Argomenti:

* 'string': stringa

Valore restituito:

* carattere UTF-8 come intero

Esempio in C:

[source,C]
----
int char_int = weechat_utf8_char_int ("être");  /* "ê" come intero */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_utf8_char_size

Restituisce la dimensione di un carattere UTF-8 (in byte).

Prototipo:

[source,C]
----
int weechat_utf8_char_size (const char *string);
----

Argomenti:

* 'string': stringa

Valore restituito:

* dimensione carattere UTF-8 (in byte)

Esempio in C:

[source,C]
----
int char_size = weechat_utf8_char_size ("être");  /* == 2 */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_utf8_strlen

Restituisce la lunghezza della stringa UTF-8 (nei caratteri UTF-8).

Prototipo:

[source,C]
----
int weechat_utf8_strlen (const char *string);
----

Argomenti:

* 'string': stringa

Valore restituito:

* lunghezza della stringa UTF-8 (numero di caratteri UTF-8)

Esempio in C:

[source,C]
----
int length = weechat_utf8_strlen ("chêne");  /* == 5 */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_utf8_strnlen

Restituisce la lunghezza della stringa UTF-8 (in caratteri UTF-8), per
un massimo di 'bytes' nella stringa.

Prototipo:

[source,C]
----
int weechat_utf8_strnlen (const char *string, int bytes);
----

Argomenti:

* 'string': stringa
* 'bytes': massimo di byte

Valore restituito:

* lunghezza della stringa UTF-8 (numero di caratteri UTF-8)

Esempio in C:

[source,C]
----
int length = weechat_utf8_strnlen ("chêne", 4);  /* == 3 */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_utf8_strlen_screen

Restituisce il numero di caratteri necessari per visualizzare la stringa
UTF-8 su schermo.

Prototipo:

[source,C]
----
int weechat_utf8_strlen_screen (const char *string);
----

Argomenti:

* 'string': stringa

Valore restituito:

* numero di caratteri necessari per visualizzare la stringa UTF-8
su schermo

Esempio in C:

[source,C]
----
int length_on_screen = weechat_utf8_strlen_screen ("é");  /* == 1 */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_utf8_charcmp

// TRANSLATION MISSING
_Updated in 1.0._

Confronta due caratteri UTF-8.

Prototipo:

[source,C]
----
int weechat_utf8_charcmp (const char *string1, const char *string2);
----

Argomenti:

* 'string1': prima stringa da comparare
* 'string2': seconda stringa da comparare

Valore restituito:

* -1 se string1 < string2
* 0 se string1 == string2
* 1 se string1 > string2

Esempio in C:

[source,C]
----
int diff = weechat_utf8_charcmp ("aaa", "ccc");  /* == -2 */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_utf8_charcasecmp

// TRANSLATION MISSING
_Updated in 1.0._

Confronta due caratteri UTF-8, ignorando la sensibilità alle maiuscole.

Prototipo:

[source,C]
----
int weechat_utf8_charcasecmp (const char *string1, const char *string2);
----

Argomenti:

* 'string1': prima stringa da comparare
* 'string2': seconda stringa da comparare

Valore restituito:

* -1 se string1 < string2
* 0 se string1 == string2
* 1 se string1 > string2

Esempio in C:

[source,C]
----
int diff = weechat_utf8_charcasecmp ("aaa", "CCC");  /* == -2 */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_utf8_char_size_screen

Restituisce il numero di caratteri necessari per visualizzare il
carattere UTF-8 sullo schermo.

Prototipo:

[source,C]
----
int weechat_utf8_char_size_screen (const char *string);
----

Argomenti:

* 'string': stringa

Valore restituito:

* numero di caratteri necessario per visualizzare il carattere
  UTF-8 su schermo

Esempio in C:

[source,C]
----
int length_on_screen = weechat_utf8_char_size_screen ("é");  /* == 1 */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_utf8_add_offset

Si sposta in avanti di N caratteri in una stringa UTF-8.

Prototipo:

[source,C]
----
char *weechat_utf8_add_offset (const char *string, int offset);
----

Argomenti:

* 'string': stringa
* 'offset': numero di caratteri

Valore restituito:

* puntatore alla stringa, N caratteri dopo (NULL se non raggiungibile)

Esempio in C:

[source,C]
----
char *str = "chêne";
char *str2 = weechat_utf8_add_offset (str, 3);  /* points to "ne" */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_utf8_real_pos

Restituisce la posizione reale nella stringa UTF-8.

Prototipo:

[source,C]
----
int weechat_utf8_real_pos (const char *string, int pos);
----

Argomenti:

* 'string': stringa
* 'pos': posizione (numero di caratteri)

Valore restituito:

* pozisione reale (in byte)

Esempio in C:

[source,C]
----
int pos = weechat_utf8_real_pos ("chêne", 3);  /* == 4 */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_utf8_pos

Restituisce la posizione nella stringa UTF-8.

Prototipo:

[source,C]
----
int weechat_utf8_pos (const char *string, int real_pos);
----

Argomenti:

* 'string': stringa
* 'real_pos': posizione (byte)

Valore restituito:

* posizione (numero di caratteri)

Esempio in C:

[source,C]
----
int pos = weechat_utf8_pos ("chêne", 4);  /* == 3 */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_utf8_strndup

Restituisce la stringa duplicata, di lunghezza massima 'lenght'.

Prototipo:

[source,C]
----
char *weechat_utf8_strndup (const char *string, int length);
----

Argomenti:

* 'string': stringa
* 'length': caratteri massimi da duplicare

Valore restituito:

* stringa duplicata (deve essere liberata chiamando "free" dopo l'uso)

Esempio in C:

[source,C]
----
char *string = weechat_utf8_strndup ("chêne", 3);  /* restituisce "chê" */
/* ... */
free (string);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

[[directories]]
=== Cartelle

Alcune funzioni legate alle cartelle.

==== weechat_mkdir_home

Crea una cartella nella home di WeeChat.

Prototipo:

[source,C]
----
int weechat_mkdir_home (char *directory, int mode);
----

Argomenti:

* 'directory': nome della cartella da creare
* 'mode': modalità per la cartella

Valore restituito:

* 1 se la cartella è stata creata con successo, 0 in caso di errore

Esempio in C:

[source,C]
----
if (!weechat_mkdir_home ("temp", 0755))
{
    /* errore */
}
----

Script (Python):

[source,python]
----
# prototipo
weechat.mkdir_home(directory, mode)

# esempio
weechat.mkdir_home("temp", 0755)
----

==== weechat_mkdir

Crea una cartella.

Prototipo:

[source,C]
----
int weechat_mkdir (char *directory, int mode);
----

Argomenti:

* 'directory': nome della cartella da creare
* 'mode': modalità per la cartella

Valore restituito:

* 1 se la cartella è stata creata con successo, 0 in caso di errore

Esempio in C:

[source,C]
----
if (!weechat_mkdir ("/tmp/mydir", 0755))
{
    /* errore */
}
----

Script (Python):

[source,python]
----
# prototipo
weechat.mkdir(directory, mode)

# esempio
weechat.mkdir("/tmp/mydir", 0755)
----

==== weechat_mkdir_parents

Crea una cartella e le cartelle genitore se necessario.

Prototipo:

[source,C]
----
int weechat_mkdir_parents (char *directory, int mode);
----

Argomenti:

* 'directory': nome della cartella da creare
* 'mode': modalità per la cartella

Valore restituito:

* 1 se la cartella è stata creata con successo, 0 in caso di errore

Esempio in C:

[source,C]
----
if (!weechat_mkdir_parents ("/tmp/my/dir", 0755))
{
    /* errore */
}
----

Script (Python):

[source,python]
----
# prototipo
weechat.mkdir_parents(directory, mode)

# esempio
weechat.mkdir_parents("/tmp/my/dir", 0755)
----

==== weechat_exec_on_files

Cerca i file in una cartella ed esegue una callback su ogni file.

Prototipo:

[source,C]
----
void weechat_exec_on_files (const char *directory,
                            int hidden_files,
                            void *data,
                            void (*callback)(void *data,
                                             const char *filename));
----

Argomenti:

* 'directory': cartella in cui cercare i file
* 'hidden_files': 1 per includere i file nascosti, altrimenti 0
* 'data': puntatore fornito alla callback quando chiamata da WeeChat
* 'callback': funzione chiamata per ogni file trovato, argomenti:
** 'void *data': puntatore
** 'const char *filename': nome file trovato

Esempio in C:

[source,C]
----
void callback (void *data, const char *filename)
{
    /* ... */
}
...
weechat_exec_on_files ("/tmp", 0, NULL, &callback);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_file_get_content

_WeeChat ≥ 0.3.1._

Ottiene il contenuto del file di testo in una stringa.

Prototipo:

[source,C]
----
char *weechat_file_get_content (const char *filename);
----

Argomenti:

* 'filename': percorso e nome file

Valore restituito:

* contenuto del file come stringa (deve essere liberata chiamando "free dopo
  l'uso)

Esempio in C:

[source,C]
----
char *content;

content = weechat_file_get_content ("/tmp/test.txt");
/* ... */
free (content);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

[[util]]
=== Utilità

Alcune funzioni utili.

==== weechat_util_timeval_cmp

Confronta due strutture "timeval".

Prototipo:

[source,C]
----
int weechat_util_timeval_cmp (struct timeval *tv1, struct timeval *tv2);
----

Argomenti:

* 'tv1': prima struttura "timeval"
* 'tv2': seconda struttura "timeval"

Valore restituito:

* -1 se tv1 < tv2
* zero se tv1 == tv2
* +1 se tv1 > tv2

Esempio in C:

[source,C]
----
if (weechat_util_timeval_cmp (&tv1, &tv2) > 0)
{
    /* tv1 > tv2 */
}
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_util_timeval_diff

// TRANSLATION MISSING
_Updated in 1.1._

// TRANSLATION MISSING
Return difference (in microseconds) between two "timeval" structures.

Prototipo:

[source,C]
----
long long weechat_util_timeval_diff (struct timeval *tv1, struct timeval *tv2);
----

Argomenti:

* 'tv1': prima struttura "timeval"
* 'tv2': seconda struttura "timeval"

Valore restituito:

// TRANSLATION MISSING
* difference in microseconds

// TRANSLATION MISSING
[NOTE]
With WeeChat ≤ 1.0, the returned value was in milliseconds.

Esempio in C:

[source,C]
----
long long diff = weechat_util_timeval_diff (&tv1, &tv2);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_util_timeval_add

// TRANSLATION MISSING
_Updated in 1.1._

// TRANSLATION MISSING
Add interval (in microseconds) to a timeval structure.

Prototipo:

[source,C]
----
void weechat_util_timeval_add (struct timeval *tv, long long interval);
----

Argomenti:

* 'tv': struttura timeval
// TRANSLATION MISSING
* 'interval': interval (in microseconds)

// TRANSLATION MISSING
[NOTE]
With WeeChat ≤ 1.0, the interval was expressed in milliseconds.

Esempio in C:

[source,C]
----
weechat_util_timeval_add (&tv, 2000000);  /* aggiunge 2 secondi */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_util_get_time_string

_WeeChat ≥ 0.3.2._

Riceve data/ora come stringa compilata con "strftime".

Prototipo:

[source,C]
----
char *weechat_util_get_time_string (const time_t *date);
----

Argomenti:

* 'date': puntatore alla data

Esempio in C:

[source,C]
----
time_t date = time (NULL);
weechat_printf (NULL, "date: %s",
                weechat_util_get_time_string (&date));
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_util_version_number

_WeeChat ≥ 0.3.9._

// TRANSLATION MISSING
Convert a string with WeeChat version to a number.

Prototipo:

[source,C]
----
int weechat_util_version_number (const char *version);
----

Argomenti:

// TRANSLATION MISSING
* 'version': WeeChat version as string (example: "0.3.9" or "0.3.9-dev")

Esempio in C:

[source,C]
----
version_number = weechat_util_version_number ("0.3.8");      /* == 0x00030800 */
version_number = weechat_util_version_number ("0.3.9-dev");  /* == 0x00030900 */
version_number = weechat_util_version_number ("0.3.9-rc1");  /* == 0x00030900 */
version_number = weechat_util_version_number ("0.3.9");      /* == 0x00030900 */
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

[[sorted_lists]]
=== Elenchi ordinati

Funzioni lista ordinata.

==== weechat_list_new

Crea una nuova lista.

Prototipo:

[source,C]
----
struct t_weelist *weechat_list_new ();
----

Valore restituito:

* puntatore alla nuova lista

Esempio in C:

[source,C]
----
struct t_weelist *list = weechat_list_new ();
----

Script (Python):

[source,python]
----
# prototipo
list = weechat.list_new()

# esempio
list = weechat.list_new()
----

==== weechat_list_add

Aggiunge un elemento in una lista.

Prototipo:

[source,C]
----
struct t_weelist_item *weechat_list_add (struct t_weelist *weelist,
                                         const char *data,
                                         const char *where,
                                         void *user_data);
----

Argomenti:

* 'weelist': puntatore alla lista
* 'data': dati da inserire nella lista
* 'where': posizione nella lista:
** 'WEECHAT_LIST_POS_SORT': aggiunge alla lista, mantenendola ordinata
** 'WEECHAT_LIST_POS_BEGINNING': aggiunge all'inizio della lista
** 'WEECHAT_LIST_POS_END': aggiunge alla fine della lista
* 'user_data': qualsiasi puntatore

Valore restituito:

* puntatore al nuovo elemento

Esempio in C:

[source,C]
----
struct t_weelist_item *my_item =
    weechat_list_add (list, "my data", WEECHAT_LIST_POS_SORT, NULL);
----

Script (Python):

[source,python]
----
# prototipo
item = weechat.list_add(list, data, where, user_data)

# esempio
item = weechat.list_add(list, "my data", weechat.WEECHAT_LIST_POS_SORT, "")
----

==== weechat_list_search

Cerca un elemento nella lista.

Prototipo:

[source,C]
----
struct t_weelist_item *weechat_list_search (struct t_weelist *weelist,
                                            const char *data);
----

Argomenti:

* 'weelist': puntatore alla lista
* 'data': dati da cercare nella lista

Valore restituito:

* puntatore all'elemento trovato, NULL se non trovato

Esempio in C:

[source,C]
----
struct t_weelist_item *item = weechat_list_search (list, "my data");
----

Script (Python):

[source,python]
----
# prototipo
item = weechat.list_search(list, data)

# esempio
item = weechat.list_search(list, "my data")
----

==== weechat_list_search_pos

_WeeChat ≥ 0.3.4._

Cerca la posizione di un elemento nella lista.

Prototipo:

[source,C]
----
int weechat_list_search_pos (struct t_weelist *weelist,
                             const char *data);
----

Argomenti:

* 'weelist': puntatore alla lista
* 'data': dati da cercare nella lista

Valore restituito:

* posizione dell'elemento trovato, -1 se non trovato

Esempio in C:

[source,C]
----
int pos_item = weechat_list_search_pos (list, "my data");
----

Script (Python):

[source,python]
----
# prototipo
pos_item = weechat.list_search_pos(list, data)

# esempio
pos_item = weechat.list_search_pos(list, "my data")
----

==== weechat_list_casesearch

Cerca un elemento nella lista, senza effettuare una ricerca
esatta.

Prototipo:

[source,C]
----
struct t_weelist_item *weechat_list_casesearch (struct t_weelist *weelist,
                                                const char *data);
----

Argomenti:

* 'weelist': puntatore alla lista
* 'data': dati da cercare nella lista

Valore restituito:

* puntatore all'elemento trovato, NULL se non trovato

Esempio in C:

[source,C]
----
struct t_weelist_item *item = weechat_list_casesearch (list, "my data");
----

Script (Python):

[source,python]
----
# prototipo
item = weechat.list_casesearch(list, data)

# esempio
item = weechat.list_casesearch(list, "my data")
----

==== weechat_list_casesearch_pos

_WeeChat ≥ 0.3.4._

Cerca la posizione di un elemento in una lista, ricerca normale.

Prototipo:

[source,C]
----
int weechat_list_casesearch_pos (struct t_weelist *weelist,
                                 const char *data);
----

Argomenti:

* 'weelist': puntatore alla lista
* 'data': dati da cercare nella lista

Valore restituito:

* posizione dell'elemento trovato, -1 se non trovato

Esempio in C:

[source,C]
----
int pos_item = weechat_list_casesearch_pos (list, "my data");
----

Script (Python):

[source,python]
----
# prototipo
pos_item = weechat.list_casesearch_pos(list, data)

# esempio
pos_item = weechat.list_casesearch_pos(list, "my data")
----

==== weechat_list_get

Restituisce un elemento in una lista in base alla sua posizione.

Prototipo:

[source,C]
----
struct t_weelist_item *weechat_list_get (struct t_weelist *weelist,
                                         int position);
----

Argomenti:

* 'weelist': puntatore alla lista
* 'position': posizione nella lista (il primo elemento è 0)

Valore restituito:

* puntatore all'elemento trovato, NULL se non trovato

Esempio in C:

[source,C]
----
struct t_weelist_item *item = weechat_list_get (list, 0);  /* primo elemento */
----

Script (Python):

[source,python]
----
# prototipo
item = weechat.list_get(list, position)

# esempio
item = weechat.list_get(list, 0)
----

==== weechat_list_set

Imposta un nuovo valore per un elemento.

Prototipo:

[source,C]
----
void weechat_list_set (struct t_weelist_item *item, const char *value);
----

Argomenti:

* 'item': puntatore all'elemento
* 'value': nuovo valore per l'elemento

Esempio in C:

[source,C]
----
weechat_list_set (item, "nuovi dati");
----

Script (Python):

[source,python]
----
# prototipo
weechat.list_set(item, value)

# esempio
weechat.list_set(item, "nuovi dati")
----

==== weechat_list_next

Restituisce l'elemento successivo nella lista.

Prototipo:

[source,C]
----
struct t_weelist_item *weechat_list_next (struct t_weelist_item *item);
----

Argomenti:

* 'item': puntatore all'elemento

Valore restituito:

* puntatore all'elemento successivo, NULL se il puntatore è
  l'ultimo oggetto nella lista

Esempio in C:

[source,C]
----
struct t_weelist_item *next_item = weechat_list_next (item);
----

Script (Python):

[source,python]
----
# prototipo
item = weechat.list_next(item)

# esempio
item = weechat.list_next(item)
----

==== weechat_list_prev

Restituisce l'elemento precedente nella lista.

Prototipo:

[source,C]
----
struct t_weelist_item *weechat_list_prev (struct t_weelist_item *item);
----

Argomenti:

* 'item': puntatore all'elemento

Valore restituito:

// TRANSLATION MISSING
* pointer to previous item, NULL if pointer was first item in list

Esempio in C:

[source,C]
----
struct t_weelist_item *prev_item = weechat_list_prev (item);
----

Script (Python):

[source,python]
----
# prototipo
item = weechat.list_prev(item)

# esempio
item = weechat.list_prev(item)
----

==== weechat_list_string

Restituisce il valore stringa di un elemento.

Prototipo:

[source,C]
----
const char *weechat_list_string (struct t_weelist_item *item);
----

Argomenti:

* 'item': puntatore all'elemento

Valore restituito:

* valore stringa di un elemento

Esempio in C:

[source,C]
----
weechat_printf (NULL, "valore dell'elemento: %s", weechat_list_string (item));
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.list_string(item)

# esempio
weechat.prnt("", "valore dell'elemento: %s" % weechat.list_string(item))
----

==== weechat_list_size

Restituisce la dimensione della lista (numero di elementi).

Prototipo:

[source,C]
----
char *weechat_list_size (struct t_weelist *weelist);
----

Argomenti:

* 'weelist': puntatore alla lista

Valore restituito:

* dimensione della lista (numero di elementi), 0 se la lista
  è vuota

Esempio in C:

[source,C]
----
weechat_printf (NULL, "dimensione della lista: %d", weechat_list_size (list));
----

Script (Python):

[source,python]
----
# prototipo
size = weechat.list_size(list)

# esempio
weechat.prnt("", "dimensione della lista: %d" % weechat.list_size(list))
----

==== weechat_list_remove

Rimuove un elemento in una lista.

Prototipo:

[source,C]
----
void weechat_list_remove (struct t_weelist *weelist,
                          struct t_weelist_item *item);
----

Argomenti:

* 'weelist': puntatore alla lista
* 'item': puntatore all'elemento

Esempio in C:

[source,C]
----
weechat_list_remove (list, item);
----

Script (Python):

[source,python]
----
# prototipo
weechat.list_remove(list, item)

# esempio
weechat.list_remove(list, item)
----

==== weechat_list_remove_all

Rimuove tutti gli elementi in una lista.

Prototipo:

[source,C]
----
void weechat_list_remove_all (struct t_weelist *weelist);
----

Argomenti:

* 'weelist': puntatore alla lista

Esempio in C:

[source,C]
----
weechat_list_remove_all (list);
----

Script (Python):

[source,python]
----
# prototipo
weechat.list_remove_all(list)

# esempio
weechat.list_remove_all(list)
----

==== weechat_list_free

Libera una lista.

Prototipo:

[source,C]
----
void weechat_list_free (struct t_weelist *weelist);
----

Argomenti:

* 'weelist': puntatore alla lista

Esempio in C:

[source,C]
----
weechat_list_free (list);
----

Script (Python):

[source,python]
----
# prototipo
weechat.list_free(list)

# esempio
weechat.list_free(list)
----

[[hashtables]]
=== Tabelle hash

Funzioni per le tabelle hash.

==== weechat_hashtable_new

_WeeChat ≥ 0.3.3._

Crea una nuova tabella hash.

Prototipo:

[source,C]
----
struct t_hashtable *weechat_hashtable_new (int size,
                                           const char *type_keys,
                                           const char *type_values,
                                           unsigned long long (*callback_hash_key)(struct t_hashtable *hashtable,
                                                                                   const void *key),
                                           int (*callback_keycmp)(struct t_hashtable *hashtable,
                                                                  const void *key1,
                                                                  const void *key2));
----

Argomenti:

* 'size': dimensione dell'array interno per memorizzare le chiavi con hash, un
  valore più alto usa più memoria, ma ha migliori performance. (questo *non* è
  un limite per il numero di elementi nella tabella hash)
* 'type_keys': tipo per le chiavi nella tabella hash:
** 'WEECHAT_HASHTABLE_INTEGER'
** 'WEECHAT_HASHTABLE_STRING'
** 'WEECHAT_HASHTABLE_POINTER'
** 'WEECHAT_HASHTABLE_BUFFER'
** 'WEECHAT_HASHTABLE_TIME'
* 'type_values': tipo per i valori nella tabella hash:
** 'WEECHAT_HASHTABLE_INTEGER'
** 'WEECHAT_HASHTABLE_STRING'
** 'WEECHAT_HASHTABLE_POINTER'
** 'WEECHAT_HASHTABLE_BUFFER'
** 'WEECHAT_HASHTABLE_TIME'
// TRANSLATION MISSING
* 'callback_hash_key': callback used to "hash" a key (key as integer value), can
  be NULL if key type is not "buffer" (a default hash function is used),
  arguments and return value:
** 'struct t_hashtable *hashtable': puntatore alla tabella hash
** 'const void *key': chiave
** return value: hash della chiave
// TRANSLATION MISSING
* 'callback_keycmp': callback used to compare two keys, can be NULL if key type
  is not "buffer" (a default comparison function is used), arguments and return
  value:
** 'struct t_hashtable *hashtable': puntatore alla tabella hash
** 'const void *key1': prima chiave
** 'const void *key2': seconda chiave
** valore restituito:
*** numero negativo se 'key1' è minore di 'key2'
*** 0 se 'key1' è uguale a 'key2'
*** numero positivo se 'key1' è maggiore di 'key2'

Valore restituito:

* puntatore alla nuova tabella hash, NULL in caso di errore

Esempio in C:

[source,C]
----
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_hashtable_set_with_size

// TRANSLATION MISSING
_WeeChat ≥ 0.3.3, updated in 0.4.2._

Aggiunge o aggiorna un elemento nella tabella hash con la dimensione per la
chiave ed il valore.

Prototipo:

[source,C]
----
struct t_hashtable_item *weechat_hashtable_set_with_size (struct t_hashtable *hashtable,
                                                          const void *key, int key_size,
                                                          const void *value, int value_size);
----

Argomenti:

* 'hashtable': puntatore alla tabella hash
* 'key': puntatore alla chiave
* 'key_size': dimensione della chiave (in byte), usata solo se il tipo delle
   chiavi nella tabella hash è "buffer"
* 'value': puntatore al valore
* 'value_size': dimensione del valore (in byte), utilizzata solo se il tipo dei
   valori nella tabella è "buffer"

Valore restituito:

// TRANSLATION MISSING
* pointer to item created/updated, NULL if error

Esempio in C:

[source,C]
----
weechat_hashtable_set_with_size (hashtable, "my_key", 0,
                                 my_buffer, sizeof (my_buffer_struct));
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_hashtable_set

// TRANSLATION MISSING
_WeeChat ≥ 0.3.3, updated in 0.4.2._

Aggiunge o aggiorna un elemento nella tabella hash.

Prototipo:

[source,C]
----
struct t_hashtable_item *weechat_hashtable_set (struct t_hashtable *hashtable,
                                                const void *key, const void *value);
----

Argomenti:

* 'hashtable': puntatore alla tabella hash
* 'key': puntatore alla chiave
* 'value': puntatore al valore

Valore restituito:

// TRANSLATION MISSING
* pointer to item created/updated, NULL if error

Esempio in C:

[source,C]
----
weechat_hashtable_set (hashtable, "my_key", "my_value");
----

==== weechat_hashtable_get

_WeeChat ≥ 0.3.3._

Ottiene il valore associato ad una chiave in una tabella hash.

Prototipo:

[source,C]
----
void *weechat_hashtable_get (struct t_hashtable *hashtable, void *key);
----

Argomenti:

* 'hashtable': puntatore alla tabella hash
* 'key': puntatore alla chiave

Valore restituito:

* valore per la chiave, NULL se non trovata

Esempio in C:

[source,C]
----
void *value = weechat_hashtable_get (hashtable, "my_key");
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_hashtable_has_key

_WeeChat ≥ 0.3.4._

// TRANSLATION MISSING
Check if a key is in the hashtable.

Prototipo:

[source,C]
----
int weechat_hashtable_has_key (struct t_hashtable *hashtable, void *key);
----

Argomenti:

* 'hashtable': puntatore alla tabella hash
* 'key': puntatore alla chiave

Valore restituito:

* 1 se la chiave si trova nella tabella hash, 0 in caso contrario

Esempio in C:

[source,C]
----
if (weechat_hashtable_has_key (hashtable, "my_key"))
{
    /* la chiave è nella tabella hash */
    /* ... */
}
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_hashtable_map

_WeeChat ≥ 0.3.3._

Chiama una funzione su tutte le voci della tabella hash.

Prototipo:

[source,C]
----
void weechat_hashtable_map (struct t_hashtable *hashtable,
                            void (*callback_map)(void *data,
                                                 struct t_hashtable *hashtable,
                                                 const void *key,
                                                 const void *value),
                            void *callback_map_data);
----

Argomenti:

* 'hashtable': puntatore alla tabella hash
* 'callback_map': funzione chiamata per ogni voce nella tabella hash
* 'callback_map_data': puntatore fornito alla mappa di callback quando chiamata

Esempio in C:

[source,C]
----
void
map_cb (void *data, struct t_hashtable *hashtable,
        const void *key, const void *value)
{
    /* display key and value (they are both strings here) */
    weechat_printf (NULL, "key: '%s', value: '%s'",
                    (const char *)key,
                    (const char *)value);
}
/* ... */
weechat_hashtable_map (hashtable, &map_cb, NULL);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_hashtable_map_string

_WeeChat ≥ 0.3.7._

Chiama una funzione su tutte le voci della tabella hash, inviando chiavi e
valori come stringhe.

Prototipo:

[source,C]
----
void weechat_hashtable_map_string (struct t_hashtable *hashtable,
                                   void (*callback_map)(void *data,
                                                        struct t_hashtable *hashtable,
                                                        const char *key,
                                                        const char *value),
                                   void *callback_map_data);
----

Argomenti:

* 'hashtable': puntatore alla tabella hash
* 'callback_map': funzione chiamata per ogni voce nella tabella hash
* 'callback_map_data': puntatore fornito alla mappa di callback quando chiamata

[NOTE]
Le stringhe 'key' e 'value' inviate alla callback sono temporanee, vengono
eliminate dopo la chiamata alla callback.

Esempio in C:

[source,C]
----
void
map_cb (void *data, struct t_hashtable *hashtable,
        const char *key, const char *value)
{
    /* display key and value */
    weechat_printf (NULL, "key: '%s', value: '%s'",
                    key, value);
}
/* ... */
weechat_hashtable_map_string (hashtable, &map_cb, NULL);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_hashtable_dup

_WeeChat ≥ 1.0._

// TRANSLATION MISSING
Duplicate a hashtable.

Prototipo:

[source,C]
----
struct t_hashtable *weechat_hashtable_dup (struct t_hashtable *hashtable);
----

Argomenti:

* 'hashtable': puntatore alla tabella hash

Valore restituito:

// TRANSLATION MISSING
* duplicated hashtable

Esempio in C:

[source,C]
----
struct t_hashtable *new_hashtable = weechat_hashtable_dup (hashtable);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_hashtable_get_integer

_WeeChat ≥ 0.3.3._

Restituisce un valore intero per la proprietà di una tabella hash.

Prototipo:

[source,C]
----
int weechat_hashtable_get_integer (struct t_hashtable *hashtable,
                                   void *property);
----

Argomenti:

* 'hashtable': puntatore alla tabella hash
* 'property': nome della proprietà:
** 'size': dimensione dell'array interno "htable" nella tabella hash
** 'items_count': numero di elementi nella tabella hash

Valore restituito:

* valore intero della proprietà

Esempio in C:

[source,C]
----
int items_count = weechat_hashtable_get_integer (hashtable, "items_count");
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_hashtable_get_string

_WeeChat ≥ 0.3.4._

Restituisce il valore stringa della proprietà di una tabella hash.

Prototipo:

[source,C]
----
const char *weechat_hashtable_get_string (struct t_hashtable *hashtable,
                                          const char *property);
----

Argomenti:

* 'hashtable': puntatore alla tabella hash
* 'property': nome della proprietà:
** 'type_keys': tipo per le chiavi:
*** 'integer': intero
*** 'string': stringa
*** 'pointer': puntatore
*** 'buffer': buffer
*** 'time': tempo
** 'type_values': tipo per i valori:
*** 'integer': intero
*** 'string': stringa
*** 'pointer': puntatore
*** 'buffer': buffer
*** 'time': tempo
** 'keys': stringa con la lista di chiavi (formato: "chiave1,chiave2,chiave3")
** 'keys_sorted': stringa con l'elenco di chiavi ordinate (formato: "chiave1,chiave2,chiave3")
** 'values': stringa  con la lista di valori (formato: "valore1,valore2,valore3")
** 'keys_values': stringa con la lista di valori e chiavi
   (formato: "chiave1:valore1,chiave2:valore2,chiave3:valore3")
** 'keys_values_sorted': stringa con la lista di chiavi e valori (ordinata per chiavi)
   (formato: "chiave1:valore1,chiave2:valore2,chiave3:valore3")

Valore restituito:

* valore stringa della proprietà

Esempio in C:

[source,C]
----
weechat_printf (NULL, "keys are type: %s",
                weechat_hashtable_get_string (hashtable, "type_keys"));
weechat_printf (NULL, "list of keys: %s",
                weechat_hashtable_get_string (hashtable, "keys"));
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_hashtable_set_pointer

_WeeChat ≥ 0.3.4._

Imposta il valore puntatore della proprietà di una tabella hash.

Prototipo:

[source,C]
----
void weechat_hashtable_set_pointer (struct t_hashtable *hashtable,
                                    const char *property, void *pointer);
----

Argomenti:

* 'hashtable': puntatore alla tabella hash
* 'property': nome della proprietà:
// TRANSLATION MISSING
** 'callback_free_key': set callback function used to free keys in hashtable
   _(WeeChat ≥ 0.4.2)_
** 'callback_free_value': imposta la funzione callback usata per
   liberare i valori nella tabella hash
// TRANSLATION MISSING
* 'pointer': new pointer value for property

Esempio in C:

[source,C]
----
void
my_free_value_cb (struct t_hashtable *hashtable, const void *key, void *value)
{
    /* ... */
}

void
my_free_key_cb (struct t_hashtable *hashtable, void *key)
{
    /* ... */
}

weechat_hashtable_set_pointer (hashtable, "callback_free_value", &my_free_value_cb);
weechat_hashtable_set_pointer (hashtable, "callback_free_key", &my_free_key_cb);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_hashtable_add_to_infolist

_WeeChat ≥ 0.3.3._

Aggiunge elementi della tabella hash ad un elemento della lista info.

Prototipo:

[source,C]
----
int weechat_hashtable_add_to_infolist (struct t_hashtable *hashtable,
                                       struct t_infolist_item *infolist_item,
                                       const char *prefix);
----

Argomenti:

* 'hashtable': puntatore alla tabella hash
* 'infolist_item': puntatore all'elemento della lista info
* 'prefix': stringa usata come prefisso per i nomi nella lista info

Valore restituito:

* 1 se ok, 0 in caso di errore

Esempio in C:

[source,C]
----
weechat_hashtable_add_to_infolist (hashtable, infolist_item, "testhash");

/* se la tabella hash contiene:
     "key1" => "value 1"
     "key2" => "value 2"
   allora le seguenti variabili verranno aggiunti all'elemento  della lista info:
     "testhash_name_00000"  = "key1"
     "testhash_value_00000" = "value 1"
     "testhash_name_00001"  = "key2"
     "testhash_value_00001" = "value 2"
*/
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_hashtable_remove

_WeeChat ≥ 0.3.3._

Rimuove un elemento in una tabella hash.

Prototipo:

[source,C]
----
void weechat_hashtable_remove (struct t_hashtable *hashtable, const void *key);
----

Argomenti:

* 'hashtable': puntatore alla tabella hash
* 'key': puntatore alla chiave

Esempio in C:

[source,C]
----
weechat_hashtable_remove (hashtable, "my_key");
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_hashtable_remove_all

_WeeChat ≥ 0.3.3._

Rimuove tutti gli elementi in una tabella hash.

Prototipo:

[source,C]
----
void weechat_hashtable_remove_all (struct t_hashtable *hashtable);
----

Argomenti:

* 'hashtable': puntatore alla tabella hash

Esempio in C:

[source,C]
----
weechat_hashtable_remove_all (hashtable);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_hashtable_free

_WeeChat ≥ 0.3.3._

Libera una tabella hash.

Prototipo:

[source,C]
----
void weechat_hashtable_free (struct t_hashtable *hashtable);
----

Argomenti:

* 'hashtable': puntatore alla tabella hash

Esempio in C:

[source,C]
----
weechat_hashtable_free (hashtable);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

[[configuration_files]]
=== File di configurazione

Funzioni per i file di configurazione.

==== weechat_config_new

Crea un nuovo file di configurazione.

Prototipo:

[source,C]
----
struct t_config_file *weechat_config_new (const char *name,
                                          int (*callback_reload)(void *data,
                                                                 struct t_config_file *config_file),
                                          void *callback_reload_data);
----

Argomenti:

* 'name': nome del file di configurazione (senza percorso o estensione)
* 'callback_reload': funzione chiamata quando il file di configurazione viene
  ricaricato con `/reload` (opzionale, può essere NULL), argomenti e valore
  restituito:
** 'void *data': puntatore
** 'struct t_config_file *config_file': puntatore al file di configurazione
** valore restituito:
*** 'WEECHAT_CONFIG_READ_OK'
*** 'WEECHAT_CONFIG_READ_MEMORY_ERROR'
*** 'WEECHAT_CONFIG_READ_FILE_NOT_FOUND'
* 'callback_reload_data': puntatore fornito per ricaricare il callback
  quando richiesto da WeeChat

Valore restituito:

* puntatore al nuovo file di configurazione, NULL in caso di errore

[NOTE]
Il file NON viene creato su disco da questa funzione. Verrà creato chiamando
la funzione <<_weechat_config_write,weechat_config_write>>.
Si dovrebbe chiamare questa funzione solo dopo aver aggiunto alcune sezioni
(con <<_weechat_config_new_section,weechat_config_new_section>>) e le
opzioni (con <<_weechat_config_new_option,weechat_config_new_option>>).

Esempio in C:

[source,C]
----
int
my_config_reload_cb (void *data, struct t_config_file *config_file)
{
    /* ... */

    return WEECHAT_RC_OK;
}

struct t_config_file *config_file = weechat_config_new ("test",
                                                        &my_config_reload_cb,
                                                        NULL);
----

Script (Python):

[source,python]
----
# prototipo
config_file = weechat.config_new(name, calback_reload, callback_reload_data)

# esempio
def my_config_reload_cb(data, config_file):
    # ...
    return weechat.WEECHAT_RC_OK

config_file = weechat.config_new("test", "my_config_reload_cb", "")
----

==== weechat_config_new_section

Crea una nuova sezione nel file di configurazione.

Prototipo:

[source,C]
----
struct t_config_section *weechat_config_new_section (
    struct t_config_file *config_file,
    const char *name,
    int user_can_add_options,
    int user_can_delete_options,
    int (*callback_read)(void *data,
                         struct t_config_file *config_file,
                         struct t_config_section *section,
                         const char *option_name,
                         const char *value),
    void *callback_read_data,
    int (*callback_write)(void *data,
                          struct t_config_file *config_file,
                          const char *section_name),
    void *callback_write_data,
    int (*callback_write_default)(void *data,
                                  struct t_config_file *config_file,
                                  const char *section_name);
    void *callback_write_default_data,
    int (*callback_create_option)(void *data,
                                  struct t_config_file *config_file,
                                  struct t_config_section *section,
                                  const char *option_name,
                                  const char *value),
    void *callback_create_option_data,
    int (*callback_delete_option)(void *data,
                                  struct t_config_file *config_file,
                                  struct t_config_section *section,
                                  struct t_config_option *option),
    void *callback_delete_option_data);
----

Argomenti:

* 'config_file': puntatore al file di configurazione
* 'name': nome della sezione
* 'user_can_add_options': 1 se l'utente può creare nuove opzioni nella sezione,
  oppure 0 se non gli è consentito
* 'user_can_delete_options': 1 se l'utente può eliminare le opzioni nella sezione,
  oppure 0 se non gli è consentito
* 'callback_read': funzione chiamata quando un'opzione nella sezione viene letta
  da disco (dovrebbe essere NULL in molti casi, tranne se l'opzione nella sezione
  necessita di una funzione personalizza), argomenti e valore restituito:
** 'void *data': puntatore
** 'struct t_config_file *config_file': puntatore al file di configurazione
** 'struct t_config_section *section': puntatore alla sezione
** 'const char *option_name': nome dell'opzione
** 'const char *value': valore
** valore restituito:
*** 'WEECHAT_CONFIG_READ_OK'
*** 'WEECHAT_CONFIG_READ_MEMORY_ERROR'
*** 'WEECHAT_CONFIG_READ_FILE_NOT_FOUND'
* 'callback_read_data': puntatore fornito alla callback quando chiamata da WeeChat
* 'callback_write': funzione chiamata quando la sezione è scritta nel file (dovrebbe
  essere NULL in molti casi, tranne se la sezione necessita di una funzione
  personalizzata), argomenti e valore restituito:
** 'void *data': puntatore
** 'struct t_config_file *config_file': puntatore al file di configurazione
** 'struct t_config_section *section': puntatore alla sezione
** 'const char *option_name': nome dell'opzione
** valore restituito:
*** 'WEECHAT_CONFIG_WRITE_OK'
*** 'WEECHAT_CONFIG_WRITE_ERROR'
*** 'WEECHAT_CONFIG_WRITE_MEMORY_ERROR'
* callback_write_data: puntatore fornito alla callback quando chiamata da WeeChat
* callback_write_default: funzione chiamata quando i valori predefiniti per la sezione
  devono essere scritti in un file, argomenti e valore restituito:
** 'void *data': puntatore
** 'struct t_config_file *config_file': puntatore al file di configurazione
** 'const char *section_name': nome della sezione
** valore restituito:
*** 'WEECHAT_CONFIG_WRITE_OK'
*** 'WEECHAT_CONFIG_WRITE_ERROR'
*** 'WEECHAT_CONFIG_WRITE_MEMORY_ERROR'
* 'callback_write_default_data': puntatore fornito alla callback quando chiamata da
  WeeChat
* 'callback_create_option': funzione chiamata quando viene creata una nuova
  opzione nella sezione (NULL se la sezione non consente di creare nuove
  opzioni), argomenti e valore restituito:
** 'void *data': puntatore
** 'struct t_config_file *config_file': puntatore al file di configurazione
** 'struct t_config_section *section': puntatore alla sezione
** 'const char *option_name': nome dell'opzione
** 'const char *value': valore
** valore restituito:
*** 'WEECHAT_CONFIG_OPTION_SET_OK_CHANGED'
*** 'WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE'
*** 'WEECHAT_CONFIG_OPTION_SET_ERROR'
*** 'WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND'
* 'callback_create_option_data': puntatore fornito alla callback quando chiamata
  da WeeChat
* 'callback_delete_option': funzione chiamata quando un'opzione viene eliminata
  nella sezione (NULL se la sezione non consente di eliminare delle opzioni),
  argomenti e valore restituito:
** 'void *data': puntatore
** 'struct t_config_file *config_file': puntatore al file di configurazione
** 'struct t_config_section *section': puntatore alla sezione
** 'struct t_config_option *option': puntatore all'opzione
** valore restituito:
*** 'WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET'
*** 'WEECHAT_CONFIG_OPTION_UNSET_OK_RESET'
*** 'WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED'
*** 'WEECHAT_CONFIG_OPTION_UNSET_ERROR'
* 'callback_delete_option_data': puntatore fornito alla callback quando chiamata
  da WeeChat

Valore restituito:

* puntatore alla nuova sezione nel file di configurazione, NULL in caso di errore

Esempio in C:

[source,C]
----
int
my_section_read_cb (void *data, struct t_config_file *config_file,
                    struct t_config_section *section, const char *option_name,
                    const char *value)
{
    /* ... */

    return WEECHAT_CONFIG_OPTION_SET_OK_CHANGED;
    /* return WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE; */
    /* return WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND; */
    /* return WEECHAT_CONFIG_OPTION_SET_ERROR; */
}

int
my_section_write_cb (void *data, struct t_config_file *config_file,
                     const char *section_name)
{
    /* ... */

    return WEECHAT_CONFIG_WRITE_OK;
    /* return WEECHAT_CONFIG_WRITE_ERROR; */
}

int
my_section_write_default_cb (void *data, struct t_config_file *config_file,
                             const char *section_name)
{
    /* ... */

    return WEECHAT_CONFIG_WRITE_OK;
    /* return WEECHAT_CONFIG_WRITE_ERROR; */
}

int
my_section_create_option_cb (void *data, struct t_config_file *config_file,
                             struct t_config_section *section,
                             const char *option_name, const char *value)
{
    /* ... */

    return WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE;
    /* return WEECHAT_CONFIG_OPTION_SET_ERROR; */
}

int
my_section_delete_option_cb (void *data, struct t_config_file *config_file,
                             struct t_config_section *section,
                             struct t_config_option *option)
{
    /* ... */

    return WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED;
    /* return WEECHAT_CONFIG_OPTION_UNSET_ERROR; */
}

/* sezione standard, l'utente non può aggiungere/rimuovere opzioni */
struct t_config_section *new_section1 =
    weechat_config_new_section (config_file, "section1", 0, 0,
                                NULL, NULL,  /* read callback */
                                NULL, NULL,  /* write callback */
                                NULL, NULL,  /* write default callback */
                                NULL, NULL,  /* create option callback */
                                NULL, NULL);  /* delete option callback */

/* sezione speciale, l'utente può aggiungere/eliminare opzioni, e le
   opzioni necessitano di un callback per essere lette/scritte */
struct t_config_section *new_section2 =
    weechat_config_new_section (config_file, "section2", 1, 1,
                                &my_section_read_cb, NULL,
                                &my_section_write_cb, NULL,
                                &my_section_write_default_cb, NULL,
                                &my_section_create_option_cb, NULL,
                                &my_section_delete_option_cb, NULL);
----

Script (Python):

[source,python]
----
# prototipo
section = weechat.config_new_section(config_file, name,
    user_can_add_options, user_can_delete_options,
    callback_read, callback_read_data,
    callback_write, callback_write_data,
    callback_create_option, callback_create_option_data,
    callback_delete_option, callback_delete_option_data)

# esempio
def my_section_read_cb(data, config_file, section, option_name, value):
    # ...
    return weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED
    # return weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE
    # return weechat.WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND
    # return weechat.WEECHAT_CONFIG_OPTION_SET_ERROR

def my_section_write_cb(data, config_file, section_name):
    # ...
    return weechat.WEECHAT_CONFIG_WRITE_OK

def my_section_write_default_cb(data, config_file, section_name):
    # ...
    return weechat.WEECHAT_CONFIG_WRITE_OK

def my_section_create_option_cb(data, config_file, section, option_name, value):
    # ...
    return weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE

def my_section_delete_option_cb(data, config_file, section, option):
    # ...
    return weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED

section = weechat.config_new_section(config_file, "section1", 1, 1,
    "my_section_read_cb", "",
    "my_section_write_cb", "",
    "my_section_write_default_cb", "",
    "my_section_create_option_cb", "",
    "my_section_delete_option_cb", "")
----

==== weechat_config_search_section

Cerca una sezione in un file di configurazione.

Prototipo:

[source,C]
----
struct t_config_section *weechat_config_search_section (
    struct t_config_file *config_file,
    const char *section_name);
----

Argomenti:

* 'config_file': puntatore al file di configurazione
* 'section_name': nome della sezione da cercare

Valore restituito:

* puntatore alla sezione trovata, NULL se non trovata

Esempio in C:

[source,C]
----
struct t_config_section *section = weechat_config_search_section (config_file,
                                                                  "section");
----

Script (Python):

[source,python]
----
# prototipo
section = weechat.config_search_section(config_file, section_name)

# esempio
section = weechat.config_search_section(config_file, "section")
----

==== weechat_config_new_option

Crea una nuova opzione nella sezione di un file di configurazione.

Prototipo:

[source,C]
----
struct t_config_option *weechat_config_new_option (
    struct t_config_file *config_file,
    struct t_config_section *section,
    const char *name,
    const char *type,
    const char *description,
    const char *string_values,
    int min,
    int max,
    const char *default_value,
    const char *value,
    int null_value_allowed,
    int (*callback_check_value)(void *data,
                                struct t_config_option *option,
                                const char *value),
    void *callback_check_value_data,
    void (*callback_change)(void *data,
                            struct t_config_option *option),
    void *callback_change_data,
    void (*callback_delete)(void *data,
                            struct t_config_option *option),
    void *callback_delete_data);
----

Argomenti:

* 'config_file': puntatore al file di configurazione
* 'section': puntatore alla sezione
* 'name': nome dell'opzione
* 'type': tipo dell'opzione:
** 'boolean': valore booleano (on/off)
** 'integer': valore intero (con stringhe opzionali per i valori)
** 'string': valore stringa
** 'color': colore
* 'description': descrizione dell'opzione
* 'string_values': valori come stringa (separati da "|"), usato dal tipo 'integer'
  (opzionale)
* 'min': valore minimo (per il tipo 'integer')
* 'max': valore massimo (per il tipo 'integer')
* 'default_value': valore predefinito per l'opzione (usato per il reset dell'opzione)
* 'value': valore per l'opzione
* 'null_value_allowed': 1 se 'null' (valore non definito) è consentito per l'opzione,
  altrimenti 0
* 'callback_check_value': funzione chiamata per verificare il nuovo valore per
  l'opzione (ozionale), argomenti e valore restituito:
** 'void *data': puntatore
** 'struct t_config_option *option': puntatore all'opzione
** 'const char *value': nuovo valore per l'opzione
** valore restituito:
*** 1 se il valore è corretto
*** 0 se il valore non è valido
* 'callback_check_value_data': puntatore fornito alla callback check_value
  quando chiamata da WeeChat
* 'callback_change': funzione chiamata quando il valore dell'opzione è stata
  cambiata (opzionale), argomenti:
** 'void *data': puntatore
** 'struct t_config_option *option': puntatore all'opzione
* 'callback_change_data': puntatore fornito per cambiare alla callback quando
  chiamato da WeeChat
* 'callback_delete': funzione chiamata quando l'opzione verrà eliminata
  (opzionale), argomenti:
** 'void *data': puntatore
** 'struct t_config_option *option': puntatore all'opzione
* 'callback_delete_data': puntatore fornito per eiliminare alla callback quando
  chiamato da WeeChat

Valore restituito:

 alla nuova opzione nella sezione, NULL in caso di errore

Esempio in C:

[source,C]
----
/* booleano */
struct t_config_option *option1 =
    weechat_config_new_option (config_file, section, "option1", "boolean",
                               "My option, type boolean"
                               NULL,  /* valori stringa */
                               0, 0,  /* min, max */
                               "on",  /* predefinito */
                               "on",  /* valore */
                               0,  /* null value allowed */
                               NULL, NULL,  /* verifica callback */
                               NULL, NULL,  /* modifica callback */
                               NULL, NULL);  /* elimina callback */

/* intero */
struct t_config_option *option2 =
    weechat_config_new_option (config_file, section, "option2", "integer",
                               "My option, type integer"
                               NULL,  /* string values */
                               0, 100,  /* min, max */
                               "15",  /* default */
                               "15",  /* value */
                               0,  /* null value allowed */
                               NULL, NULL,  /* verifica callback */
                               NULL, NULL,  /* modifica callback */
                               NULL, NULL);  /* elimina callback */

/* intero (con valori stringa) */
struct t_config_option *option3 =
    weechat_config_new_option (config_file, section, "option3", "integer",
                               "My option, type integer (with string values)"
                               "top|bottom|left|right",  /* string values */
                               0, 0,  /* min, max */
                               "bottom",  /* predefinito */
                               "bottom",  /* valoree */
                               0,  /* null value allowed */
                               NULL, NULL,  /* verifica callback */
                               NULL, NULL,  /* modifica callback */
                               NULL, NULL);  /* elimina callback */

/* stringa */
struct t_config_option *option4 =
    weechat_config_new_option (config_file, section, "option4", "string",
                               "My option, type string"
                               NULL,  /* valori stringa */
                               0, 0,  /* min, max */
                               "test",  /* predefinito */
                               "test",  /* valore */
                               1,  /* valore null consentito */
                               NULL, NULL,  /* verifica callback */
                               NULL, NULL,  /* modifica callback */
                               NULL, NULL);  /* elimina callback */

/* colore */
struct t_config_option *option5 =
    weechat_config_new_option (config_file, section, "option5", "color",
                               "My option, type color"
                               NULL,  /* valori stringa */
                               0, 0,  /* min, max */
                               "lightblue",  /* predefinito */
                               "lightblue",  /* valore */
                               0,  /* valore null consentito */
                               NULL, NULL,  /* verifica callback */
                               NULL, NULL,  /* modifica callback */
                               NULL, NULL);  /* elimina callback */
----

Script (Python):

[source,python]
----
# prototipo
option = weechat.config_new_option(config_file, section, name, type, description,
    string_values, min, max, default_value, value, null_value_allowed,
    callback_check_value, callback_check_value_data,
    callback_change, callback_change_data,
    callback_delete, callback_delete_data)

# esempio
def option4_check_value_cb(data, option, value):
    # ...
    return 1
    # return 0

def option4_change_cb(data, option):
    # ...

def option4_delete_cb(data, option):
    # ...

option1 = weechat.config_new_option(config_file, section, "option1", "boolean",
    "My option, type boolean",
    "", 0, 0, "on", "on", 0,
    "", "",
    "", "",
    "", "")

option2 = weechat.config_new_option(config_file, section, "option2", "integer",
    "My option, type integer",
    "", 0, 100, "15", "15", 0,
    "", "",
    "", "",
    "", "")

option3 = weechat.config_new_option(config_file, section, "option3", "integer",
    "My option, type integer (with string values)",
    "top|bottom|left|right",
    0, 0, "bottom", "bottom", 0,
    "", "",
    "", "",
    "", "")

option4 = weechat.config_new_option(config_file, section, "option4", "string",
    "My option, type string",
    "", 0, 0, "test", "test", 1,
    "option4_check_value_cb", ""
    "option4_change_cb", "",
    "option4_delete_cb", "")

option5 = weechat.config_new_option(config_file, section, "option5", "color",
    "My option, type color",
    "", 0, 0, "lightblue", "lightblue", 0,
    "", "",
    "", "",
    "", "")
----

// TRANSLATION MISSING
[NOTE]
In Ruby, the 3 callbacks + data (6 strings) must be given in an array of 6
strings (due to a Ruby limitation of 15 arguments by function), see the
'WeeChat Scripting Guide' for more info _(fixed in version 0.4.1)_.

==== weechat_config_search_option

Cerca un'opzione nella sezione di un file di configurazione.

Prototipo:

[source,C]
----
struct t_config_option *weechat_config_search_option (
    struct t_config_file *config_file,
    struct t_config_section *section,
    const char *option_name);
----

Argomenti:

* 'config_file': puntatore al file di configurazione
* 'section': puntatore alla sezione
* 'name': nome dell'opzione da cercare

Valore restituito:

* puntatore all'opzione trovata, NULL se non trovata

Esempio in C:

[source,C]
----
struct t_config_option *option =
    weechat_config_search_option (config_file, section, "option");
----

Script (Python):

[source,python]
----
# prototipo
option = weechat.config_search_option(config_file, section, option_name)

# esempio
option = weechat.config_search_option(config_file, section, "option")
----

==== weechat_config_search_section_option

Cerca una sezione ed un'opzione in un file di configurazione o sezione.

Prototipo:

[source,C]
----
void weechat_config_search_section_option (struct t_config_file *config_file,
                                           struct t_config_section *section,
                                           const char *option_name,
                                           struct t_config_section **section_found,
                                           struct t_config_option **option_found);
----

Argomenti:

* 'config_file': puntatore al file di configurazione
* 'section': puntatore alla sezione
* 'option_name': nome dell'opzione
* 'section_found': puntatore al puntatore della sezione, sarà impostato alla
  sezione dell'opzione, se viene trovata
* 'option_found': puntatore al puntatore dell'opzione, sarà impostato al
  puntatore di un'opzione, se viene trovata

Esempio in C:

[source,C]
----
struct t_config_section *ptr_section;
struct t_config_option *ptr_option;

weechat_config_search_section_option(config_file,
                                     section,
                                     "option",
                                     &ptr_section,
                                     &ptr_option);
if (ptr_option)
{
    /* opzione trovata */
}
else
{
    /* opzione non trovata */
}
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_config_search_with_string

// TRANSLATION MISSING
Get file/section/option info about an option with full name.

Prototipo:

[source,C]
----
void weechat_config_search_with_string (const char *option_name,
                                        struct t_config_file **config_file,
                                        struct t_config_section **section,
                                        struct t_config_option **option,
                                        char **pos_option_name);
----

Argomenti:

* 'option_name': nome completo dell'opzione (formato: "file.section.option")
* 'config_file': puntatore al puntatore del file di configurazione, sarà impostato
  al puntatore al file di configurazione se l'opzione viene trovata
* 'section': puntatore al puntatore della sezione, sarà impostato alla sezione
  dell'opzione, se viene trovata
* 'option': puntatore al puntatore dell'opzione, sarà impostato al puntatore di
  un'opzione, se viene trovata
// TRANSLATION MISSING
* 'pos_option_name': pointer to a string pointer, will be set to pointer to
  name of option, if found

Esempio in C:

[source,C]
----
struct t_config_file *ptr_config_file;
struct t_config_section *ptr_section;
struct t_config_option *ptr_option;
char *option_name;

weechat_config_search_with_string ("file.section.option",
                                   &ptr_config_file,
                                   &ptr_section,
                                   &ptr_option,
                                   &option_name);
if (ptr_option)
{
    /* opzione trovata */
}
else
{
    /* opzione non trovata */
}
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_config_string_to_boolean

Verifica se un testo è "vero" o "falso", come valore booleano.

Prototipo:

[source,C]
----
int weechat_config_string_to_boolean (const char *text);
----

Argomenti:

* 'text': testo da analizzare

Valore restituito:

* 1 se il testo è "true" ("on", "yes", "y", "true", "t", "1")
* 0 se il testo è "false" ("off", "no", "n", "false", "f", "0")

Esempio in C:

[source,C]
----
if (weechat_config_string_to_boolean (option_value))
{
    /* il valore è "true" */
}
else
{
    /* il valore è "false" */
}
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.config_string_to_boolean(text)

# esempio
if weechat.config_string_to_boolean(text):
    # ...
----

==== weechat_config_option_reset

Resetta un'opzione al proprio valore predefinito.

Prototipo:

[source,C]
----
int weechat_config_option_reset (struct t_config_option *option,
                                 int run_callback);
----

Argomenti:

* 'option': puntatore all'opzione
* 'run_callback': 1 per la chiamata alla callbackse il valore dell'opzione
  è cambiato, altrimenti 0

Valore restituito:

* 'WEECHAT_CONFIG_OPTION_SET_OK_CHANGED' se il valore dell'opzione è stato
  resettato
* 'WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE' se il valore non è stato
  modificato
* 'WEECHAT_CONFIG_OPTION_SET_ERROR' in caso di errore

Esempio in C:

[source,C]
----
switch (weechat_config_option_reset (option, 1))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* .... */
        break;
}
----

Script (Python):

[source,python]
----
# prototipo
rc = weechat.config_option_reset(option, run_callback)

# esempio
rc = weechat.config_option_reset(option, 1)
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----

==== weechat_config_option_set

Imposta un nuovo valore per l'opzione.

Prototipo:

[source,C]
----
int weechat_config_option_set (struct t_config_option *option,
                               const char *value, int run_callback);
----

Argomenti:

* 'option': puntatore all'opzione
* 'value': nuovo valore per l'opzione
* 'run_callback': 1 per la chiamata alla callback chang se il valore dell'opzione
  è cambiato, altrimenti 0

Valore restituito:

* 'WEECHAT_CONFIG_OPTION_SET_OK_CHANGED' se il valore dell'opzione è
  cambiato
* 'WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE' se il valore non è cambiato
* 'WEECHAT_CONFIG_OPTION_SET_ERROR' in caso di errore

Esempio in C:

[source,C]
----
switch (weechat_config_option_set (option, "new_value", 1))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* .... */
        break;
}
----

Script (Python):

[source,python]
----
# prototipo
rc = weechat.config_option_set(option, value, run_callback)

# esempio
rc = weechat.config_option_set(option, "new_value", 1)
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----

==== weechat_config_option_set_null

Imposta null (valore non definito) per un'opzione.

Prototipo:

[source,C]
----
int weechat_config_option_set_null (struct t_config_option *option,
                                    int run_callback);
----

Argomenti:

* 'option': puntatore all'opzione
* 'run_callback': 1 per la chiamata alla callback chang se il valore
  dell'opzione è cambiato (se non è null), altrimenti 0

[NOTE]
È possibile impostare il valore a null solo se è consentito per l'opzione
(consultare <<_weechat_config_new_option,weechat_config_new_option>>).

Valore restituito:

* 'WEECHAT_CONFIG_OPTION_SET_OK_CHANGED' se il valore dell'opzione è
  cambiato
* 'WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE' se il valore non è cambiato
* 'WEECHAT_CONFIG_OPTION_SET_ERROR' in caso di errore

Esempio in C:

[source,C]
----
switch (weechat_config_option_set_null (option, 1))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* .... */
        break;
}
----

Script (Python):

[source,python]
----
# prototipo
rc = weechat.config_option_set_null(option, run_callback)

# esempio
rc = weechat.config_option_set_null(option, 1)
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----

==== weechat_config_option_unset

Rimuove/ripristina un'opzione.

Prototipo:

[source,C]
----
int weechat_config_option_unset (struct t_config_option *option);
----

Argomenti:

* 'option': puntatore all'opzione

Valore restituito:

* 'WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET' se il valore dell'opzione non è
  stato ripristinato
* 'WEECHAT_CONFIG_OPTION_UNSET_OK_RESET' se il valore dell'opzione è stato
  ripristinato
* 'WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED' se l'opzione è stata rimossa
* 'WEECHAT_CONFIG_OPTION_UNSET_ERROR' in caso di errore

Esempio in C:

[source,C]
----
switch (weechat_config_option_unset (option))
{
    case WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
        /* .... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_ERROR:
        /* .... */
        break;
}
----

Script (Python):

[source,python]
----
# prototipo
rc = weechat.config_option_unset(option)

# esempio
rc = weechat.config_option_unset(option)
if rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_ERROR:
    # ...
----

==== weechat_config_option_rename

Rinomina un'opzione.

Prototipo:

[source,C]
----
void weechat_config_option_rename (struct t_config_option *option,
                                   const char *new_name);
----

Argomenti:

* 'option': puntatore all'opzione
* 'new_name': nuovo nome per l'opzione

Esempio in C:

[source,C]
----
weechat_config_option_rename (option, "new_name");
----

Script (Python):

[source,python]
----
# prototipo
weechat.config_option_rename(option, new_name)

# esempio
weechat.config_option_rename(option, "new_name")
----

==== weechat_config_option_get_pointer

Restituisce un puntatore alla proprietà di un'opzione.

Prototipo:

[source,C]
----
void *weechat_config_option_get_pointer (struct t_config_option *option,
                                         const char *property);
----

Argomenti:

* 'option': puntatore all'opzione
* 'property': nome della proprietà:
** 'config_file': puntatore al file di configurazione ('struct t_config_file *')
** 'section': puntatore alla sezione ('struct t_config_section *')
** 'name': nome dell'opzione ('char *')
** 'type': tipo dell'opzione ('int *')
** 'description': descrizione dell'opzione ('char *')
** 'string_values': valori stringa ('char *')
** 'min': valore minimo ('int *')
** 'max': valore massimo ('int *')
** 'default_value': valore predefinito (dipende dal tipo)
** 'value': valore corrente (dipende dal tipo)
** 'prev_option': puntatore all'opzione precedente ('struct t_config_option *')
** 'next_option': puntatore all'opzione successiva ('struct t_config_option *')

Valore restituito:

* puntatore alla proprietà richiesta

Esempio in C:

[source,C]
----
char *description = weechat_config_option_get_pointer (option, "description");
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_config_option_is_null

Verifica se un opzione è "null" (valore non definito).

Prototipo:

[source,C]
----
int weechat_config_option_is_null (struct t_config_option *option);
----

Argomenti:

* 'option': puntatore all'opzione

Valore restituito:

* 1 se il valore dell'opzione è "null"
* 0 se il valore dell'opzione non è "null"

Esempio in C:

[source,C]
----
if (weechat_config_option_is_null (option))
{
    /* il valore è "null" */
}
else
{
    /* il valore non è "null" */
}
----

Script (Python):

[source,python]
----
# prototipo
weechat.config_option_is_null(option)

# esempio
if weechat.config_option_is_null(option):
    # ...
----

==== weechat_config_option_default_is_null

Verifica che il valore predefinito di un'opzione sia "null" (valore non definito).

Prototipo:

[source,C]
----
int weechat_config_option_default_is_null (struct t_config_option *option);
----

Argomenti:

* 'option': puntatore all'opzione

Valore restituito:

* 1 se il valore predefinito di un'opzione è "null"
* 0 se il valore predefinito di un'opzione non è  "null"

Esempio in C:

[source,C]
----
if (weechat_config_option_default_is_null (option))
{
    /* il valore predefinito è "null" */
}
else
{
    /* il valore predefinito non è "null" */
}
----

Script (Python):

[source,python]
----
# prototipo
weechat.config_option_default_is_null(option)

# esempio
if weechat.config_option_default_is_null(option):
    # ...
----

==== weechat_config_boolean

Restituisce il valore bool di un'opzione.

Prototipo:

[source,C]
----
int weechat_config_boolean (struct t_config_option *option);
----

Argomenti:

* 'option': puntatore all'opzione

Valore restituito:

* valore bool di un'opzione (0 o 1)

Esempio in C:

[source,C]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
if (weechat_config_boolean (option))
{
    /* il valore è "true" */
}
else
{
    /* il valore è "false" */
}
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.config_boolean(option)

# esempio
option = weechat.config_get("plugin.section.option")
if weechat.config_boolean(option):
    # ...
----

==== weechat_config_boolean_default

Restituisce il valore bool predefinito di un'opzione.

Prototipo:

[source,C]
----
int weechat_config_boolean_default (struct t_config_option *option);
----

Argomenti:

* 'option': puntatore all'opzione

Valore restituito:

* il valore bool predefinito di un'opzione (0 o 1)

Esempio in C:

[source,C]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
if (weechat_config_boolean_default (option))
{
    /* il valore è "true" */
}
else
{
    /* il valore è "false" */
}
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.config_boolean_default(option)

# esempio
option = weechat.config_get("plugin.section.option")
if weechat.config_boolean_default(option):
    # ...
----

==== weechat_config_integer

Restituisce il valore intero di un'opzione.

Prototipo:

[source,C]
----
int weechat_config_integer (struct t_config_option *option);
----

Argomenti:

* 'option': puntatore all'opzione

Valore restituito:

* valore intero di un'opzione

Esempio in C:

[source,C]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
int value = weechat_config_integer (option);
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.config_integer(option)

# esempio
option = weechat.config_get("plugin.section.option")
value = weechat.config_integer(option)
----

==== weechat_config_integer_default

Restituisce il valore intero predefinito di un'opzione.

Prototipo:

[source,C]
----
int weechat_config_integer_default (struct t_config_option *option);
----

Argomenti:

* 'option': puntatore all'opzione

Valore restituito:

* valore intero predefinito di un'opzione

Esempio in C:

[source,C]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
int value = weechat_config_integer_default (option);
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.config_integer_default(option)

# esempio
option = weechat.config_get("plugin.section.option")
value = weechat.config_integer_default(option)
----

==== weechat_config_string

Restituisce il valore stringa di un'opzione.

Prototipo:

[source,C]
----
const char *weechat_config_string (struct t_config_option *option);
----

Argomenti:

* 'option': puntatore all'opzione

Valore restituito:

* valore stringa di un'opzione

Esempio in C:

[source,C]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
const char *value = weechat_config_string (option);
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.config_string(option)

# esempio
option = weechat.config_get("plugin.section.option")
value = weechat.config_string(option)
----

==== weechat_config_string_default

Restituisce il valore stringa predefinito di un'opzione.

Prototipo:

[source,C]
----
const char *weechat_config_string_default (struct t_config_option *option);
----

Argomenti:

* 'option': puntatore all'opzione

Valore restituito:

* valore stringa predefinito di un'opzione

Esempio in C:

[source,C]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
const char *value = weechat_config_string_default (option);
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.config_string_default(option)

# esempio
option = weechat.config_get("plugin.section.option")
value = weechat.config_string_default(option)
----

==== weechat_config_color

Restituisce il valore colore di un'opzione.

Prototipo:

[source,C]
----
const char *weechat_config_color (struct t_config_option *option);
----

Argomenti:

* 'option': puntatore all'opzione

Valore restituito:

* valore colore dell'opzione (stringa con il nome del colore)

Esempio in C:

[source,C]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
const char *color = weechat_config_color (option);
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.config_color(option)

# esempio
option = weechat.config_get("plugin.section.option")
value = weechat.config_color(option)
----

==== weechat_config_color_default

Restituisce il valore colore predefinito di un'opzione.

Prototipo:

[source,C]
----
const char *weechat_config_color_default (struct t_config_option *option);
----

Argomenti:

* 'option': puntatore all'opzione

Valore restituito:

* valore colore predefinito di un'opzione (stringa con il nome del colore)

Esempio in C:

[source,C]
----
struct t_config_option *option = weechat_config_get ("plugin.section.option");
const char *color = weechat_config_color_default (option);
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.config_color_default(option)

# esempio
option = weechat.config_get("plugin.section.option")
value = weechat.config_color_default(option)
----

==== weechat_config_write_option

Scrive una riga nel file di configurazione con l'opzione ed il suo valore
(questa funzione dovrebbe essere chiamata solo nelle callback "write"
o "write_default" per una sezione).

Prototipo:

[source,C]
----
void weechat_config_write_option (struct t_config_file *config_file,
                                  struct t_config_option *option);
----

Argomenti:

* 'config_file': puntatore al file di configurazione
* 'option': puntatore all'opzione

Esempio in C:

[source,C]
----
int
my_section_write_cb (void *data, struct t_config_file *config_file,
                     const char *section_name)
{
    weechat_config_write_line (config_file, "my_section", NULL);

    weechat_config_write_option (config_file, option);

    return WEECHAT_RC_OK;
}
----

Script (Python):

[source,python]
----
# prototipo
weechat.config_write_option(config_file, option)

# esempio
def my_section_write_cb(data, config_file, section_name):
    weechat.config_write_line(config_file, "my_section", "")
    weechat.config_write_option(config_file, option)
    return weechat.WEECHAT_RC_OK
----

==== weechat_config_write_line

Scrive una riga nel file di configurazione (questa funzione dovrebbe
essere chiamata solo nelle callback "write" o "write_default" per una
sezione).

Prototipo:

[source,C]
----
void weechat_config_write_line (struct t_config_file *config_file,
                                const char *option_name,
                                const char *value, ...);
----

Argomenti:

* 'config_file': puntatore al file di configurazione
* 'option_name': nome dell'opzione
* 'value': valore (se NULL, allora la riga con il nome della sezione viene
  scritto, ad esempio: "[section]")

Esempio in C:

[source,C]
----
int
my_section_write_cb (void *data, struct t_config_file *config_file,
                     const char *section_name)
{
    weechat_config_write_line (config_file, "my_section", NULL);

    weechat_config_write_line (config_file, "option", "%s;%d",
                               "value", 123);

    return WEECHAT_RC_OK;
}
----

Script (Python):

[source,python]
----
# prototipo
weechat.config_write_line(config_file, option_name, value)

# esempio
def my_section_write_cb(data, config_file, section_name):
    weechat.config_write_line(config_file, "my_section", "")
    weechat.config_write_line(config_file, "option", "value")
    return weechat.WEECHAT_RC_OK
----

==== weechat_config_write

Scrive il file di configurazione su disco.

Prototipo:

[source,C]
----
int weechat_config_write (struct t_config_file *config_file);
----

Argomenti:

* 'config_file': puntatore al file di configurazione

Valore restituito:

* 'WEECHAT_CONFIG_WRITE_OK' se la configurazione è stata scritta
* 'WEECHAT_CONFIG_WRITE_MEMORY_ERROR' se non c'è memoria sufficiente
* 'WEECHAT_CONFIG_WRITE_ERROR' se si è verificato un altro errore

Esempio in C:

[source,C]
----
switch (weechat_config_write (config_file))
{
    case WEECHAT_CONFIG_WRITE_OK:
        /* ... */
        break;
    case WEECHAT_CONFIG_WRITE_MEMORY_ERROR:
        /* ... */
        break;
    case WEECHAT_CONFIG_WRITE_ERROR:
        /* ... */
        break;
}
----

Script (Python):

[source,python]
----
# prototipo
rc = weechat.config_write(config_file)

# esempio
rc = weechat.config_write(config_file)
if rc == weechat.WEECHAT_CONFIG_WRITE_OK:
    # ...
elif rc == weechat.WEECHAT_CONFIG_WRITE_MEMORY_ERROR:
    # ...
elif rc == weechat.WEECHAT_CONFIG_WRITE_ERROR:
    # ...
----

==== weechat_config_read

Legge il file di configurazione da disco.

Prototipo:

[source,C]
----
int weechat_config_read (struct t_config_file *config_file);
----

Argomenti:

* 'config_file': puntatore al file di configurazione

Valore restituito:

* 'WEECHAT_CONFIG_READ_OK' se la configurazione è stata caricata
* 'WEECHAT_CONFIG_READ_MEMORY_ERROR' se non c'è memoria sufficiente
* 'WEECHAT_CONFIG_READ_FILE_NOT_FOUND' se il file non è stato trovato

Esempio in C:

[source,C]
----
switch (weechat_config_read (config_file))
{
    case WEECHAT_CONFIG_READ_OK:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_MEMORY_ERROR:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
        /* ... */
        break;
}
----

Script (Python):

[source,python]
----
# prototipo
rc = weechat.config_read(config_file)

# esempio
rc = weechat.config_read(config_file)
if rc == weechat.WEECHAT_CONFIG_READ_OK:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_MEMORY_ERROR:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
    # ...
----

==== weechat_config_reload

Ricarica il file di configurazione da disco.

Prototipo:

[source,C]
----
int weechat_config_reload (struct t_config_file *config_file);
----

Argomenti:

* 'config_file': configuration file pointer

Valore restituito:

* 'WEECHAT_CONFIG_READ_OK' se il file di configurazione è stato ricaricato
* 'WEECHAT_CONFIG_READ_MEMORY_ERROR' se non c'è memoria sufficiente
* 'WEECHAT_CONFIG_READ_FILE_NOT_FOUND' se il file non è stato trovato

Esempio in C:

[source,C]
----
switch (weechat_config_reload (config_file))
{
    case WEECHAT_CONFIG_READ_OK:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_MEMORY_ERROR:
        /* ... */
        break;
    case WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
        /* ... */
        break;
}
----

Script (Python):

[source,python]
----
# prototipo
rc = weechat.config_reload(config_file)

# esempio
rc = weechat.config_reload(config_file)
if rc == weechat.WEECHAT_CONFIG_READ_OK:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_MEMORY_ERROR:
    # ...
elif rc == weechat.WEECHAT_CONFIG_READ_FILE_NOT_FOUND:
    # ...
----

==== weechat_config_option_free

Libera un'opzione.

Prototipo:

[source,C]
----
void weechat_config_option_free (struct t_config_option *option);
----

Argomenti:

* 'option': puntatore all'opzione

Esempio in C:

[source,C]
----
weechat_config_option_free (option);
----

Script (Python):

[source,python]
----
# prototipo
weechat.config_option_free(option)

# esempio
weechat.config_option_free(option)
----

==== weechat_config_section_free_options

Libera tutte le opzioni in una sessione.

Prototipo:

[source,C]
----
void weechat_config_section_free_options (struct t_config_section *section);
----

Argomenti:

* 'section': puntatore alla sezione

Esempio in C:

[source,C]
----
weechat_config_section_free_options (section);
----

Script (Python):

[source,python]
----
# prototipo
weechat.config_section_free_options(section)

# esempio
weechat.config_section_free_options(section)
----

==== weechat_config_section_free

Libera una sezione.

Prototipo:

[source,C]
----
void weechat_config_section_free (struct t_config_section *section);
----

Argomenti:

* 'section': puntatore alla sezione

Esempio in C:

[source,C]
----
weechat_config_section_free (section);
----

Script (Python):

[source,python]
----
# prototipo
weechat.config_section_free(section)

# esempio
weechat.config_section_free(section)
----

==== weechat_config_free

Libera un file di configurazione.

Prototipo:

[source,C]
----
void weechat_config_free (struct t_config_file *config_file);
----

Argomenti:

* 'config_file': puntatore al file di configurazione

Esempio in C:

[source,C]
----
weechat_config_free (config_file);
----

Script (Python):

[source,python]
----
# prototipo
weechat.config_free(config_file)

# esempio
weechat.config_free(config_file)
----

==== weechat_config_get

Cerca un'opzione con il nome completo.

Prototipo:

[source,C]
----
struct t_config_option *weechat_config_get (const char *option_name);
----

Argomenti:

* 'option_name': nome completo dell'opzione (formato: "file.section.option")

Valore restituito:

* puntatore all'opzione trovata, NULL se non trovata

Esempio in C:

[source,C]
----
struct t_config_option *option = weechat_config_get ("weechat.look.item_time_format");
----

Script (Python):

[source,python]
----
# prototipo
option = weechat.config_get(option_name)

# esempio
option = weechat.config_get("weechat.look.item_time_format")
----

==== weechat_config_get_plugin

Cerca un'opzione nei file di configurazione dei plugin (plugins.conf).

Prototipo:

[source,C]
----
const char *weechat_config_get_plugin (const char *option_name);
----

Argomenti:

* 'option_name': nome dell'opzione, WeeChat aggiungerà il prefisso
  "plugins.var.xxx." (dove "xxx" è il nome del plugin corrente)

Valore restituito:

* valore dell'opzione trovata, NULL se non trovata

Esempio in C:

[source,C]
----
/* se il plugin corrente è "test", allora cerca il valore
   dell'opzione "plugins.var.test.option" nel file plugins.conf */
char *value = weechat_config_get_plugin ("option");
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.config_get_plugin(option_name)

# esempio
value = weechat.config_get_plugin("option")
----

==== weechat_config_is_set_plugin

Verifica se un'opzione è impostata nel file di configurazione dei
plugin (plugins.conf).

Prototipo:

[source,C]
----
int weechat_config_is_set_plugin (const char *option_name);
----

Argomenti:

* 'option_name': nome dell'opzione, WeeChat aggiunge il prefisso "plugins.var.xxx."
  (dove "xxx" è il nome del plugin corrente)

Valore restituito:

* 1 se l'opzione è impostata, 0 se l'opzione non esiste

Esempio in C:

[source,C]
----
if (weechat_config_is_set_plugin ("option"))
{
    /* l'opzione è impostata */
}
else
{
    /* l'opzione non esiste */
}
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.config_is_set_plugin(option_name)

# esempio
if weechat.config_is_set_plugin("option"):
    # l'opzione è impostata
    # ...
else:
    # l'opzione non esiste
    # ...
----

==== weechat_config_set_plugin

Imposta il nuovo valore per l'opzione nel file di configurazione dei plugin (plugins.conf).

Prototipo:

[source,C]
----
int weechat_config_set_plugin (const char *option_name, const char *value);
----

Argomenti:

* 'option_name': nome dell'opzione, WeeChat aggiunge il prefisso "plugins.var.xxx."
  (dove "xxx" è il nome del plugin corrente)
* 'value': new value for option

Valore restituito:

* 'WEECHAT_CONFIG_OPTION_SET_OK_CHANGED' se il valore dell'opzione è stato modificato
* 'WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE' se il valore non è cambiato
* 'WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND' se l'opzione non è stata trovata
* 'WEECHAT_CONFIG_OPTION_SET_ERROR' in caso di errore

Esempio in C:

[source,C]
----
switch (weechat_config_set_plugin ("option", "test_value"))
{
    case WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_SET_ERROR:
        /* ... */
        break;
}
----

Script (Python):

[source,python]
----
# prototipo
rc = weechat.config_set_plugin(option_name, value)

# esempio
rc = weechat.config_set_plugin("option", "test_value")
if rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_CHANGED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OK_SAME_VALUE:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_OPTION_NOT_FOUND:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_SET_ERROR:
    # ...
----

==== weechat_config_set_desc_plugin

_WeeChat ≥ 0.3.5._

Imposta la descrizione per l'opzione nel file di configurazione dei plugin
(plugins.conf).

Prototipo:

[source,C]
----
void weechat_config_set_desc_plugin (const char *option_name,
                                     const char *description);
----

Argomenti:

* 'option_name': nome dell'opzione, WeeChat aggiungerà il prefisso "plugins.desc.xxx."
  (dove "xxx" è il nome del plugin corrente)
* 'description': descrizione per l'opzione

[NOTE]
Non è un problema se l'opzione (plugins.var.xx.option_name) non esiste.
Una futura creazione dell'opzione con questo nome userà questa descrizione.

Esempio in C:

[source,C]
----
weechat_config_set_desc_plugin ("option", "description of option");
----

Script (Python):

[source,python]
----
# prototipo
weechat.config_set_desc_plugin(option_name, description)

# esempio
version = weechat.info_get("version_number", "") or 0
if int(version) >= 0x00030500:
    weechat.config_set_desc_plugin("option", "description of option")
----

==== weechat_config_unset_plugin

Disattiva l'opzione nel file di configurazione dei plugin (plugins.conf).

Prototipo:

[source,C]
----
int weechat_config_unset_plugin (const char *option_name);
----

Argomenti:

* 'option_name': nome dell'opzione, WeeChat aggiunge il prefisso "plugins.var.xxx."
  (dove xxx è il nome del plugin corrente)

Valore restituito:

* 'WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET' se il valore dell'opzione non è
  stato resettato
* 'WEECHAT_CONFIG_OPTION_UNSET_OK_RESET' se il valore dell'opzione è stato
  resettato
* 'WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED' se l'opzione è stata rimossa
* 'WEECHAT_CONFIG_OPTION_UNSET_ERROR' in caso di errore

Esempio in C:

[source,C]
----
switch (weechat_config_unset_plugin ("option"))
{
    case WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
        /* ... */
        break;
    case WEECHAT_CONFIG_OPTION_UNSET_ERROR:
        /* ... */
        break;
}
----

Script (Python):

[source,python]
----
# prototipo
rc = weechat.config_unset_plugin(option_name)

# esempio
rc = weechat.config_unset_plugin("option")
if rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_NO_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_RESET:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_OK_REMOVED:
    # ...
elif rc == weechat.WEECHAT_CONFIG_OPTION_UNSET_ERROR:
    # ...
----

[[key_bindings]]
=== Combinazione tasti

Funzioni per le combinazioni dei tasti.

==== weechat_key_bind

_WeeChat ≥ 0.3.6._

Aggiunge una nuova combinazione tasto.

[NOTE]
A differenza del comando `/key bind`, questa funzione non cambia mai una
combinazione tasti esistente, ma ne vengono create di nuove. Per rimuovere
una combinazione tasti, usare <<_weechat_key_unbind,weechat_key_unbind>>.

Prototipo:

[source,C]
----
int weechat_key_bind (const char *context, struct t_hashtable *keys);
----

Argomenti:

* 'context': contesto per i tasti:
** 'default': contesto default (azioni comuni)
** 'search': contesto search (quando si cerca testo nel buffer)
** 'cursor': movimento libero del cursore sullo schermo
** 'mouse': tasti per gli eventi del mouse
* 'keys': tabella hash con le combinazioni dei tasti

Valore restituito:

* numero delle combinazioni tasti aggiunte

Esempio in C:

[source,C]
----
struct t_hashtable *keys = weechat_hashtable_new (8,
                                                  WEECHAT_HASHTABLE_STRING,
                                                  WEECHAT_HASHTABLE_STRING,
                                                  NULL,
                                                  NULL);
if (keys)
{
    weechat_hashtable_set (keys, "@chat(plugin.buffer):button1", "hsignal:test_mouse");
    weechat_hashtable_set (keys, "@chat(plugin.buffer):wheelup", "/mycommand up");
    weechat_hashtable_set (keys, "@chat(plugin.buffer):wheeldown", "/mycommand down");
    weechat_key_bind ("mouse", keys);
    weechat_hashtable_free (keys);
}
----

Script (Python):

[source,python]
----
# prototipo
num_keys = weechat.key_bind(context, keys)

# esempio
keys = {"@chat(python.test):button1": "hsignal:test_mouse",
        "@chat(python.test):wheelup": "/mycommand up",
        "@chat(python.test):wheeldown": "/mycommand down"}
weechat.key_bind("mouse", keys)
----

==== weechat_key_unbind

_WeeChat ≥ 0.3.6._

Rimuove una o più associazioni tasti.

[WARNING]
Alla chiamata di questa funzione, assicurarsi che non venga rimossa una
combinazione tasti definita dall'utente.

Prototipo:

[source,C]
----
int weechat_key_unbind (const char *context, const char *key);
----

Argomenti:

* 'context': contesto per i tasti (consultare <<_weechat_key_bind,weechat_key_bind>>)
* 'key': tasto da rimuovere o un valore speciale "area:XXX" per rimuovere tutti
  i tasti che hanno 'XXX' come prima o seconda area

Valore restituito:

* numero di combinazioni tasti rimosse

Esempio in C:

[source,C]
----
/* rimuove un singolo tasto */
weechat_key_unbind ("mouse", "@chat(plugin.buffer):button1");

/* rimuove tutti i tasti con la zona "chat(plugin.buffer)" */
weechat_key_unbind ("mouse", "area:chat(plugin.buffer)");
----

Script (Python):

[source,python]
----
# prototipo
num_keys = weechat.key_unbind(context, key)

# esempi

# rimuove un singolo tasto
weechat.key_unbind("mouse", "@chat(plugin.buffer):button1")

# rimuove tutti i tasti con la zona "chat(python.test)"
weechat.key_unbind("mouse", "area:chat(python.test)")
----

[[display]]
=== Visualizzazione

Funzioni per visualizzare il testo nei buffer.

==== weechat_prefix

Restituisce un prefisso.

Prototipo:

[source,C]
----
const char *weechat_prefix (const char *prefix);
----

Argomenti:

// TRANSLATION MISSING
* 'prefix': nome del prefisso, see table below

Valore restituito:

* valore del prefisso (stringa con prefisso e codici colori), stringa vuota
  se il prefisso non è stato trovato

// TRANSLATION MISSING
List of prefixes:

[width="70%",cols="^2e,^1,^3,5",options="header"]
|===
| Prefisso | Valore | Colore       | Descrizione
| error    | `=!=`  | giallo       | Messaggio di errore
| network  | `--`   | magenta      | Messaggio dalla rete
| action   | `*`    | bianco       | Azione automatica
| join     | `-->`  | verde chiaro | Qualcuno entra nella chat corrente
| quit     | `<--`  | rosso chiaro | Qualcuno lascia la chat corrente
|===

[NOTE]
Valori e colori possono essere personalizzati con il comando `/set`.

Esempio in C:

[source,C]
----
weechat_printf (NULL, "%sQuesto è un errore...", weechat_prefix ("error"));
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.prefix(prefix)

# esempio
weechat.prnt("", "%sQuesto è un errore..." % weechat.prefix("error"))
----

==== weechat_color

Restituisce una codice colore stringa da visualizzare.

Prototipo:

[source,C]
----
const char *weechat_color (const char *color_name);
----

Argomenti:

* 'color_name': nome del colore, uno di:
** nome opzione di WeeChat (da weechat.color.xxx), ad esempio 'chat_delimiters'
** colore con attributi/sfondo opzionali (vedi sotto)
** attributo:
*** 'bold': imposta grassetto
*** '-bold': rimuove grassetto
*** 'reverse': imposta inverso
*** '-reverse': rimuove inverso
*** 'italic': imposta corsivo
*** '-italic': rimuove corsivo
*** 'underline': imposta sottolineato
*** '-underline': rimuove sottolineato
// TRANSLATION MISSING
*** 'emphasis': toggle the emphasis for text (note: this should be used only in
    bars, because WeeChat uses text emphasis when searching text in buffer)
    _(WeeChat ≥ 0.4.2)_
** nome colore della barra:
*** 'bar_fg': colore di primo piano della barra
*** 'bar_delim': colore dei delimitatori della barra
*** 'bar_bg': colore di sfondo della barra
** reset:
*** 'reset': ripristina colore ed attributi
*** 'resetcolor': ripristina colore (mantiene attributi) _(WeeChat ≥ 0.3.6)_

Il formato del colore è: attributi (opzionale) + nome colore +",sfondo"
(opzionale). Gli attributi possibili sono:

* `*` : testo in grassetto
* `!` : video inverso
* `/` : corsivo
* `_` : testo sottolineato
* `|` : mantiene attributi: non ripristina
  grassetto/inverso/corsivo/sottolineato al cambio di colore _(WeeChat ≥ 0.3.6)_

Esempi:

* `yellow` : giallo
* `_green` : verde sottolineato
* `*214` : arancione grassetto
* `yellow,red` : giallo su rosso
* `|cyan` : ciano (e mantiene qualsiasi attributo impostato in precedenza)

Valore restituito:

* stringa con il codice colore, o una stringa vuota se non trovata

Esempio in C:

[source,C]
----
weechat_printf (NULL, "Color: %sblue %sdefault color %syellow on red",
                weechat_color ("blue"),
                weechat_color ("chat"),
                weechat_color ("yellow,red"));
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.color(color_name)

# esempio
weechat.prnt("", "Color: %sblue %sdefault color %syellow on red"
    % (weechat.color("blue"), weechat.color("chat"), weechat.color("yellow,red")))
----

==== weechat_printf

Visualizza un messaggio su un buffer.

Prototipo:

[source,C]
----
void weechat_printf (struct t_gui_buffer *buffer, const char *message, ...);
----

Argomenti:

* 'buffer': puntatore al buffer, se NULL il messaggio viene visualizzato sul buffer di WeeChat
* 'message': messaggio da visualizzare

[NOTE]
La prima tabulazione nel messaggio ("\t") è usata per separare il prefisso dal messaggio. +
Se il proprio messaggio ha alcune tabulazioni e non si vuole il prefisso, allora
bisogna utilizzare uno spazio, una tabulazione, poi il messaggio (consultare
l'esempio successivo): ciò disabilita il prefisso (lo spazio prima della
tabulazione non verrà mostrato).

// TRANSLATION MISSING
[NOTE]
With two tabs ("\t") at beginning of message, time will not be displayed and
message will have no alignment at all. Moreover, the date in message will be
set to 0.

Esempio in C:

// TRANSLATION MISSING
[source,C]
----
weechat_printf (NULL, "Benvenuto sul buffer di WeeChat");
weechat_printf (buffer, "Benvenuto su questo buffer");
weechat_printf (buffer, "%sQuesto è un errore!", weechat_prefix ("error"));
weechat_printf (buffer, " \tMessaggio senza prefisso ma con \t alcune \t tabulazioni");
weechat_printf (buffer, "\t\tMessage without time/alignment");
weechat_printf (buffer, "\t\t");  /* empty line (without time) */
----

Script (Python):

// TRANSLATION MISSING
[source,python]
----
# prototipo
weechat.prnt(buffer, message)

# esempio
weechat.prnt("", "Benvenuto sul buffer di WeeChat")
weechat.prnt(buffer, "Benvenuto su questo buffer")
weechat.prnt(buffer, "%sQuesto è un errore!" % weechat.prefix("error"))
weechat.prnt(buffer, " \tMessaggio senza prefisso ma con \t alcune \t tabulazioni")
weechat.prnt(buffer, "\t\tMessage without time/alignment")
weechat.prnt(buffer, "\t\t")  # empty line (without time)
----

[NOTE]
La funzione è chiamata "print" negli script ("prnt" in Python).

==== weechat_printf_date

Visualizza un messaggio sul buffer, utilizzando una data personalizzata.

Prototipo:

[source,C]
----
void weechat_printf_date (struct t_gui_buffer *buffer, time_t date,
                          const char *message, ...);
----

Argomenti:

* 'buffer': puntatore al buffer, se NULL, il messaggio viene visualizzato
  sul buffer di WeeChat
* 'date': data per il messaggio (0 indica data/ora corrente)
* 'message': messaggio da visualizzare

Esempio in C:

[source,C]
----
weechat_printf_date (NULL, time (NULL) - 120, "Ciao, 2 minuti fa");
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_printf_tags

Visualizza un messaggio sul buffer, utilizzando tag personalizzati.

Prototipo:

[source,C]
----
void weechat_printf_tags (struct t_gui_buffer *buffer, const char *tags,
                          const char *message, ...);
----

Argomenti:

* 'buffer': puntatore al buffer, se NULL il messaggio viene visualizzato
  sul buffer di WeeChat
* 'tags': lista di tag separati da virgole
* 'message': messaggio da visualizzare

Esempio in C:

[source,C]
----
weechat_printf_tags (NULL, "notify_message",
                     "Messaggio con tag 'notify_message'");
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_printf_date_tags

Visualizza un messaggio sul buffer, usando tag e data personalizzati.

Prototipo:

[source,C]
----
void weechat_printf_date_tags (struct t_gui_buffer *buffer, time_t date,
                               const char *tags, const char *message, ...);
----

Argomenti:

* 'buffer': puntatore al buffer, se NULL il messaggio viene visualizzato
  sul buffer di WeeChat
* 'date': data per il messaggio (0 indica data/ora corrente)
* 'tags': lista di tag separati da virgole
* 'message': messaggio da visualizzare

Tag usati di frequente (elenco non esaustivo):

[width="70%",cols="1m,4",options="header"]
|===
| Tag              | Descrizione
| no_filter        | La riga non può essere filtrata
| no_highlight     | Evidenziazione non possibile sulla riga
| no_log           | La riga non viene scritta nel file di log
| log0 ... log9    | Livello di log per la riga (consultare `/help logger`)
| notify_none      | Il buffer con la riga non viene aggiunto alla hotlist
| notify_message   | Il buffer con la riga viene aggiunto alla hotlist con il livello "message"
| notify_private   | Il buffer con la riga viene aggiunto alla hotlist con il livello "private"
| notify_highlight | Il buffer con la riga viene aggiunto alla hotlist con il livello "higlight"
| nick_xxx         | Il messaggio viene dal nick "xxx"
| prefix_nick_ccc  | Il prefisso è un nick con il colore "ccc"
// TRANSLATION MISSING
| host_xxx         | Username and host in message
| irc_xxx          | Messaggio IRC "xxx" (può essere un comando o un numero di 3 cifre)
| irc_numeric      | Messaggio IRC numerico
| irc_error        | Errore dal server IRC
| irc_action       | Azione da un nic (comando `/me`)
| irc_ctcp         | Messaggio CTCP
| irc_ctcp_reply   | Risposta ad un messaggio CTCP
| irc_smart_filter | Messaggio IRC filtrabile tramite lo "smart filter" (filtro intelligente)
| away_info        | Messagio con informazioni sull'assenza
|===

Esempio in C:

[source,C]
----
weechat_printf_date_tags (NULL, time (NULL) - 120, "notify_message",
                          "Messaggio 2 minuti fa, con tag 'notify_message'");
----

Script (Python):

[source,python]
----
# prototipo
weechat.prnt_date_tags(buffer, date, tags, message)

# esempio
time = int(time.time())
weechat.prnt_date_tags("", time - 120, "notify_message",
    "Messaggio 2 minuti fa, con tag 'notify_message'")
----

[NOTE]
La funzione è chiamata "print_date_tags" negli script ("prnt_date_tags" in Python).

==== weechat_printf_y

Visualizza un messaggio sulla riga di un buffer con contenuto libero.

Prototipo:

[source,C]
----
void weechat_printf_y (struct t_gui_buffer *buffer, int y,
                       const char *message, ...);
----

Argomenti:

* 'buffer': puntatore al buffer
// TRANSLATION MISSING
* 'y': numero di riga (la prima riga è 0); a negative value adds a line after
  last line displayed: absolute value of 'y' is the number of lines after last
  line (for example -1 is immediately after last line, -2 is 2 lines after last
  line) _(WeeChat ≥ 1.0)_
* 'message': messaggio da visualizzare

Esempio in C:

[source,C]
----
weechat_printf_y (buffer, 2, "Mio messaggio sulla terza riga");
----

Script (Python):

[source,python]
----
# prototipo
weechat.prnt_y(buffer, y, message)

# esempio
weechat.prnt_y("", 2, "Mio messaggio sulla terza riga")
----

[NOTE]
La funzione è chiamata "print_y" negli script ("prnt_y in Python).

==== weechat_log_printf

Scrive un messaggio nel file di log di WeeChat (weechat.log).

Prototipo:

[source,C]
----
void weechat_log_printf (const char *message, ...);
----

Argomenti:

* 'message': messaggio da scrivere

Esempio in C:

[source,C]
----
weechat_log_printf ("Mio messaggio nel file di log");
----

Script (Python):

[source,python]
----
# prototipo
weechat.log_print(message)

# esempio
weechat.log_print("Mio messaggio nel file di log")
----

[NOTE]
La funzione è chiamata "log_print" negli script.

[[hooks]]
=== Hook

[[hook_priority]]
[float]
==== Priorità degli hook

_WeeChat ≥ 0.3.4._

In alcuni hook è possibile impostare una priorità. Un hook con priorità
maggiore si trova all'inizio della lista, in modo da poter essere eseguita
prima di altri. Può risultare utile per i modificatori, data l'importanza
nell'ordine di esecuzione.

Per impostare la priorità, è necessario usare questa sintassi per gli
argomenti dove è consentita la priorità: "nnn|nome" dove "nnn" è un intero non
negativo con la priorità e "nome" è il nome per l'argomenti (la priorità non
compare nel nome, viene rimossa automaticamente dalla stringa).

La priorità predefinita è 1000.

Esempio in C:

[source,C]
----
/* hook per il modificatore con priorità = 2000 */
weechat_hook_modifier ("2000|input_text_display", &modifier_cb, NULL);
----

I tipi di hook che seguono consentono la priorità: command, command_run,
signal, hsignal, config, completion, modifier, info, info_hashtable, infolist,
hdata, focus.

==== weechat_hook_command

Hook su un comando.

Prototipo:

[source,C]
----
struct t_hook *weechat_hook_command (const char *command,
                                     const char *description,
                                     const char *args,
                                     const char *args_description,
                                     const char *completion,
                                     int (*callback)(void *data,
                                                     struct t_gui_buffer *buffer,
                                                     int argc,
                                                     char **argv,
                                                     char **argv_eol),
                                     void *callback_data);
----

Argomenti:

* 'command': nome del comando
  (priorità consentita, consultare la nota riguardo la <<hook_priority,priority>>)
* 'description': descrizione per il comando (visualizzata con `/help comando`)
* 'args': argomenti per il comando (visualizzati con `/help command`)
* 'args_description': descrizione degli argomenti (visualizzata con `/help command`)
* 'completion': modello di completamento per il comando:: elenco di completamenti
  per ogni argomento, separati da spazio. Sono possibili più  completamenti sono
  possibili per un singolo argomento, separati da "|". Più modelli sono possibili per
  lo stesso comando, separati da "||".
* 'callback': funzione chiamata quando viene utilizzato il comando, argomenti e
  valore restituito:
** 'void *data': puntatore
** 'struct t_gui_buffer *buffer': buffer quando il comando viene eseguito
** 'int argc': numero di argomenti forniti per un comando
** 'char **argv': argomenti forniti per un comando
** 'char **argv_eol': argomenti forniti per un comando (fino a fine riga per ogni
   argomento)
** valore restituito:
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data': puntatore fornito dalla callback quando chiamata da WeeChat

I codici predefiniti per il completamento sono:

include::autogen/plugin_api/completions.asciidoc[]

Codici speciali:

* '%%command': riutilizza il modello di completamento dal comando 'command'
* '%-': ferma completamento
* '%*': ripete l'ultimo completamento

Valore restituito:

* puntatore al nuovo hook, NULL in caso di errore

Esempio in C:

[source,C]
----
int
my_command_cb (void *data, struct t_gui_buffer *buffer, int argc,
               char **argv, char **argv_eol)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* questo esempio si ispira al comando /filter */
struct t_hook *my_command_hook =
    weechat_hook_command (/* nome comando */
                          "myfilter",
                          /* description */
                          "description of myfilter",
                          /* args */
                          "[list] | [enable|disable|toggle [name]] | "
                          "[add name plugin.buffer tags regex] | "
                          "[del name|-all]",
                          /* args description */
                          "description of arguments...",
                          /* completion */
                          "list"
                          " || enable %(filters_names)"
                          " || disable %(filters_names)"
                          " || toggle %(filters_names)"
                          " || add %(filters_names) %(buffers_plugins_names)|*"
                          " || del %(filters_names)|-all",
                          /* callback */
                          &my_command_cb,
                          /* callback_data */
                          NULL);
----

Ad esempio, se il comando chiamato è `/comando abc def ghi`, allora
'argv' e 'argv_eol' contengono i seguenti valori:

* 'argv':
** 'argv[0]' == "/command"
** 'argv[1]' == "abc"
** 'argv[2]' == "def"
** 'argv[3]' == "ghi"
* 'argv_eol':
** 'argv_eol[0]' == "/command abc def ghi"
** 'argv_eol[1]' == "abc def ghi"
** 'argv_eol[2]' == "def ghi"
** 'argv_eol[3]' == "ghi"

Per gli script, 'args' ha valore "abc def ghi".

Script (Python):

[source,python]
----
# prototipo
hook = weechat.hook_command(command, description, args, args_description,
    completion, callback, callback_data)

# esempio
def my_command_cb(data, buffer, args):
    # ...
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_command("myfilter", "descrizione di myfilter",
    "[list] | [enable|disable|toggle [name]] | "
    "[add name plugin.buffer tags regex] | "
    "[del name|-all]",
    "description of arguments...",
    "list"
    " || enable %(filters_names)"
    " || disable %(filters_names)"
    " || toggle %(filters_names)"
    " || add %(filters_names) %(buffers_plugins_names)|*"
    " || del %(filters_names)|-all",
    "my_command_cb", "")
----

==== weechat_hook_command_run

Hook su un comando quando eseguito da WeeChat.

Prototipo:

[source,C]
----
struct t_hook *weechat_hook_command_run (const char *command,
                                         int (*callback)(void *data,
                                                         struct t_gui_buffer *buffer,
                                                         const char *command),
                                         void *callback_data);
----

Argomenti:

// TRANSLATION MISSING
* 'command': comando su cui eseguire l'hook (wildcard "*" is allowed)
  (priorità consentita, consultare la nota riguardo la
  <<hook_priority,priority>>)
* 'callback': funzione chiamata quando il comando è in esecuzione, argomenti e
  valore restituito:
** 'void *data': puntatore
** 'struct t_gui_buffer *buffer': buffer dove viene eseguito il comando
** 'const char *command': il comando eseguito, con i propri argomenti
** valore restituito:
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_OK_EAT'
*** 'WEECHAT_RC_ERROR'
* 'callback_data': puntatore fornito alla callback quando chiamata da WeeChat

[NOTE]
La callback può restituire 'WEECHAT_RC_OK' o 'WEECHAT_RC_OK_EAT' (il comando
non verrà eseguito da WeeChat dopo la callback).

Valore restituito:

* puntatore al nuovo hook, NULL in caso di errore

Esempio in C:

[source,C]
----
int
my_command_run_cb (void *data, struct t_gui_buffer *buffer,
                   const char *command)
{
    weechat_printf (NULL,
                    "Vuoi completare? Sto mangiando il completamento, ahah!);
    return WEECHAT_RC_OK_EAT;
}

struct t_hook *my_command_run_hook =
    weechat_hook_command_run ("/input complete*",
                              &my_command_run_cb, NULL);
----

Script (Python):

[source,python]
----
# prototipo
hook = weechat.hook_command_run(command, callback, callback_data)

# esempio
def my_command_run_cb(data, buffer, command):
    weechat.prnt("". "Vuoi completare? Sto mangiando il completamento, ahah!")
    return weechat.WEECHAT_RC_OK_EAT

hook = weechat.hook_command_run("/input complete*", "my_command_run_cb", "")
----

==== weechat_hook_timer

Hook sul timer.

Prototipo:

[source,C]
----
struct t_hook *weechat_hook_timer (long interval,
                                   int align_second,
                                   int max_calls,
                                   int (*callback)(void *data,
                                                   int remaining_calls),
                                   void *callback_data);
----

Argomenti:

* 'interval': intervallo tra due chiamate (millisecondi, 1000 = 1 secondo)
// TRANSLATION MISSING
* 'align_second': allineamento su un secondo. Per esempio, rrent time is 09:00,
  if interval = 60000 (60 seconds), and align_second = 60, then timer is
  called each minute when second is 0
// TRANSLATION MISSING
* 'max_calls': number of calls to timer (if 0, then timer has no end)
// TRANSLATION MISSING
* 'callback': function called when time is reached, argomenti e valore
  restituito:
** 'void *data': pointer
** 'int remaining_calls': remaining calls (-1 if timer has no end)
** valore restituito:
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data': pointer given to callback when it is called by WeeChat

Valore restituito:

* puntatore al nuovo hook, NULL in caso di errore

Esempio in C:

[source,C]
----
int
my_timer_cb (void *data, int remaining_calls)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* timer chiamato ogni 20 secondi */
struct t_hook *my_timer_hook =
    weechat_hook_timer (20 * 1000, 0, 0, &my_timer_cb, NULL);
----

Script (Python):

[source,python]
----
# prototipo
hook = weechat.hook_timer(interval, align_second, max_calls, callback, callback_data)

# esempio
def my_timer_cb(data, remaining_calls):
    # ...
    return weechat.WEECHAT_RC_OK

# timer chiamato ogni 20 secondi
hook = weechat.hook_timer(20 * 1000, 0, 0, "my_timer_cb", "")
----

==== weechat_hook_fd

Hook su un descrittore file (file oppure socket).

Prototipo:

[source,C]
----
struct t_hook *weechat_hook_fd (int fd,
                                int flag_read,
                                int flag_write,
                                int flag_exception,
                                int (*callback)(void *data,
                                                int fd),
                                void *callback_data);
----

Argomenti:

* 'fd': descrittore file
* 'flag_read': 1 = cattura l'evento lettura (read), 0 = ignora
* 'flag_write': 1 = cattura l'evento scrittura (write), 0 = ignora
* 'flag_exception': 1 = cattura l'eccezione evento (event), 0 = ignora
* 'callback': funzione che chiama un evento selezionato che si verifica
  per un file (o un socket), argomenti e valore restituito:
** 'void *data': puntatore
** 'int fd': descrittore file
** valore restituito:
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data': puntatore fornito alla calback quando chiamata da WeeChat

Valore restituito:

* puntatore al nuovo hook, NULL in caso di errore

Esempio in C:

[source,C]
----
int
my_fd_cb (void *data, int fd)
{
    /* ... */
    return WEECHAT_RC_OK;
}

int sock = socket (AF_INET, SOCK_STREAM, 0);
/* imposta le opzioni del socket */
/* ... */
struct t_hook *my_fd_hook = weechat_hook_fd (sock, 1, 0, 0, &my_fd_cb, NULL);
----

Script (Python):

[source,python]
----
# prototipo
hook = weechat.hook_fd(fd, flag_read, flag_write, flag_exception, callback, callback_data)

# esempio
def my_fd_cb(data, fd):
    # ...
    return weechat.WEECHAT_RC_OK

sock = ...
hook = weechat.hook_fd(sock, 1, 0, 0, "my_fd_cb", "")
----

==== weechat_hook_process

Hook su un processo (lanciato con un fork), e cattura l'output.

[NOTE]
// TRANSLATION MISSING
Since version 0.3.9.2, the shell is not used any more to execute the command.
WeeChat makes an automatic split of command and arguments (like the shell does).
If the split is not correct (according to quotes in your command), or if you
want to use shell, you can use function
<<_weechat_hook_process_hashtable,weechat_hook_process_hashtable>> with
arguments in the hashtable 'options' _(WeeChat ≥ 0.4.0)_.

Prototipo:

[source,C]
----
struct t_hook *weechat_hook_process (const char *command,
                                     int timeout,
                                     int (*callback)(void *data,
                                                     const char *command,
                                                     int return_code,
                                                     const char *out,
                                                     const char *err),
                                     void *callback_data);
----


Argomenti:

* 'command': comando da avviare nel processo figlio o URL
  _(WeeChat ≥ 0.3.7)_, segue:
* 'timeout': timeout per il comando (in millisecondi): dopo questo timeout,
  il processo figlio viene terminato (0 indica nessun timeout)
* 'callback': funzione chiamata quando i dati dal processo figlio sono disponibili,
  oppure quando è terminato, argomenti e valore restituito:
** 'void *data': puntatore
** 'const char *command': comando eseguito dal processo figlio
** 'int return_code': codice restituito:
*** '>= 0': codice ritorno figlio per un comando, e per un URL i valori
    possibili sono:
**** '0': trasferimento riuscito
**** '1': URL non valido
**** '2': errore di trasferimento
**** '3': memoria non sufficiente
**** '4': errore con un file
*** '< 0': 'WEECHAT_HOOK_PROCESS_RUNNING' (dati disponibili, ma figlio
    ancora in esecuzione) o 'WEECHAT_HOOK_PROCESS_ERROR' (errore nella
    esecuzione del comando)
** 'out': output standard del comando (stdout)
** 'err': output di errore del comando (stderr)
** valore restituito:
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data': puntatore fornito alla callback quando chiamata da WeeChat

Valore restituito:

* puntatore al nuovo hook, NULL in caso di errore

Quando il comando ha terminato, o se viene raggiunto il timeout, WeeChat
effettua automaticamente l'unhook (e termina il processo se ancora in esecuzione).

Il comando può essere un URL con il formato: "url:http://www.esempio.com", per
scaricare il contenuto dell'URL _(WeeChat ≥ 0.3.7)_. Le opzioni per
un URL sono disponibili con la funzione
<<_weechat_hook_process_hashtable,weechat_hook_process_hashtable>>.

// TRANSLATION MISSING
[TIP]
If you want to retrieve infos about WeeChat (like current stable version,
latest git commit, ...), you can use URLs on page https://weechat.org/dev/info

[NOTE]
La dimensione del buffer per l'invio dei dati alla callback è di 64KB (ci sono
2 buffer: uno per stdout ed uno per stderr).
Se l'output che viene da un processo figlio (stdout o stderr) è più lungo di
64KB, la callback verrà chiamata più di una volta.

[IMPORTANT]
Anche se la maggior parte delle volte la callback viene chiamata una sola volta,
ci si deve assicurare che più chiamate alla callback siano corrette nel codice:
bisogna concatenare i dati forniti da più chiamate ed utilizzarli quando il
codice restituito è non-negativo.

Esempio in C:

[source,C]
----
int
my_process_cb (void *data, const char *command, int return_code,
               const char *out, const char *err)
{
    if (return_code == WEECHAT_HOOK_PROCESS_ERROR)
    {
        weechat_printf (NULL, "Errore con il comando '%s'", command);
        return WEECHAT_RC_OK;
    }

    if (return_code >= 0)
    {
        weechat_printf (NULL, "return_code = %d", return_code);
    }

    if (out)
    {
        weechat_printf (NULL, "stdout: %s", out);
    }

    if (err)
    {
        weechat_printf (NULL, "stderr: %s", err);
    }

    return WEECHAT_RC_OK;
}

struct t_hook *my_process_hook = weechat_hook_process ("ls", 5000,
                                                       &my_process_cb, NULL);
----

Script (Python):

[source,python]
----
# prototipo
hook = weechat.hook_process(command, timeout, callback, callback_data)

# esempio
def my_process_cb(data, command, return_code, out, err):
    if return_code == weechat.WEECHAT_HOOK_PROCESS_ERROR:
        weechat.prnt("", "Error with command '%s'" % command)
        return weechat.WEECHAT_RC_OK
    if return_code >= 0:
        weechat.prnt("", "return_code = %d" % return_code)
    if out != "":
        weechat.prnt("", "stdout: %s" % out)
    if err != "":
        weechat.prnt("", "stderr: %s" % err)
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_process("ls", 5000, "my_process_cb", "")
----

==== weechat_hook_process_hashtable

_WeeChat ≥ 0.3.7._

Hook su un processo (avviato con un fork) usando le opzioni nella tabella hash,
e cattura dell'output.

Prototipo:

[source,C]
----
struct t_hook *weechat_hook_process_hashtable (const char *command,
                                               struct t_hashtable *options,
                                               int timeout,
                                               int (*callback)(void *data,
                                                               const char *command,
                                                               int return_code,
                                                               const char *out,
                                                               const char *err),
                                               void *callback_data);
----

Gli argomenti sono gli stessi della funzione
<<_weechat_hook_process,weechat_hook_process>>, con un argomento aggiuntivo:

* 'options': le opzioni per il comando eseguito; la tabella hash è duplicata
  nella funzione, per cui è possibile liberarla dopo questa chiamata

// TRANSLATION MISSING
For a standard command (not beginning with "url:"), following options are
available:

// TRANSLATION MISSING
[width="100%",cols="^1,1,3",options="header"]
|===
| Option | Value | Description

// TRANSLATION MISSING
| argN (N ≥ 1) +
  _(WeeChat ≥ 0.4.0)_ |
  any string |
  Arguments for command; if no argument is given with these options,
  the command is automatically split like the shell does (and then command
  arguments are read in the 'command' argument)

// TRANSLATION MISSING
| stdin +
  _(WeeChat ≥ 0.4.3)_ |
  (not used) |
  Create a pipe for writing data on standard input (stdin) of child process
  (see function <<_weechat_hook_set,weechat_hook_set>>)

// TRANSLATION MISSING
| buffer_flush +
  _(WeeChat ≥ 1.0)_ |
  number of bytes |
  Minimum number of bytes to flush stdout/stderr (to send output to callback),
  between 1 and 65536 (default); 1 = send any output immediately to the callback

// TRANSLATION MISSING
| detached +
  _(WeeChat ≥ 1.0)_ |
  (not used) |
  Run the process in a detached mode: stdout and stderr are redirected to
  '/dev/null'
|===

Per il comando "url:..." sono disponibili le seguenti opzioni (consultare
`man curl_easy_setopt` per la descrizione di ogni opzione):

include::autogen/plugin_api/url_options.asciidoc[]

[NOTE]
^(1)^ Quando sono disponibili le costanti, esse vanno usate come valore per
l'opzione. Per le opzioni con il tipo "mask" il formato è:
"value1+value2+value3".

Per un URL, sono consentite due opzioni aggiuntive (stringhe) per il file in
input/output:

* 'file_in': file da leggere e inviare con gli URL (invio del file "post")
* 'file_out': scrive URL scaricato/file in questo file (invece dello standard
* output)

Valore restituito:

* puntatore al nuovo hook, NULL in caso di errore

Esempio in C:

[source,C]
----
int
my_process_cb (void *data, const char *command, int return_code,
               const char *out, const char *err)
{
    if (return_code == WEECHAT_HOOK_PROCESS_ERROR)
    {
        weechat_printf (NULL, "Error with command '%s'", command);
        return WEECHAT_RC_OK;
    }

    if (return_code >= 0)
    {
        weechat_printf (NULL, "return_code = %d", return_code);
    }

    if (out)
    {
        weechat_printf (NULL, "stdout: %s", out);
    }

    if (err)
    {
        weechat_printf (NULL, "stderr: %s", err);
    }

    return WEECHAT_RC_OK;
}

/* example 1: download URL */
struct t_hashtable *options = weechat_hashtable_new (8,
                                                     WEECHAT_HASHTABLE_STRING,
                                                     WEECHAT_HASHTABLE_STRING,
                                                     NULL,
                                                     NULL);
if (options)
{
    weechat_hashtable_set (options, "file_out", "/tmp/weechat.org.html");
    struct t_hook *my_process_hook = weechat_hook_process_hashtable ("url:https://weechat.org/",
                                                                     options,
                                                                     20000,
                                                                     &my_process_cb, NULL);
    weechat_hashtable_free (options);
}

/* example 2: execute a notify program with a message from someone */
struct t_hashtable *options_cmd1 = weechat_hashtable_new (8,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          NULL,
                                                          NULL);
if (options_cmd1)
{
    weechat_hashtable_set (options_cmd1, "arg1", "-from");
    weechat_hashtable_set (options_cmd1, "arg2", nick);
    weechat_hashtable_set (options_cmd1, "arg3", "-msg");
    weechat_hashtable_set (options_cmd1, "arg4", message);  /* unsafe argument */
    struct t_hook *my_process_hook = weechat_hook_process_hashtable ("my-notify-command",
                                                                     options_cmd1,
                                                                     20000,
                                                                     &my_process_cb, NULL);
    weechat_hashtable_free (options_cmd1);
}

/* example 3: call shell to execute a command (command must be SAFE) */
struct t_hashtable *options_cmd2 = weechat_hashtable_new (8,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          WEECHAT_HASHTABLE_STRING,
                                                          NULL,
                                                          NULL);
if (options_cmd2)
{
    weechat_hashtable_set (options_cmd2, "arg1", "-c");
    weechat_hashtable_set (options_cmd2, "arg2", "ls -l /tmp | grep something");
    struct t_hook *my_process_hook = weechat_hook_process_hashtable ("sh",
                                                                     options_cmd2,
                                                                     20000,
                                                                     &my_process_cb, NULL);
    weechat_hashtable_free (options_cmd2);
}
----

Script (Python):

[source,python]
----
# prototipo
hook = weechat.hook_process_hashtable(command, options, timeout, callback, callback_data)

# esempio
def my_process_cb(data, command, return_code, out, err):
    if return_code == weechat.WEECHAT_HOOK_PROCESS_ERROR:
        weechat.prnt("", "Error with command '%s'" % command)
        return weechat.WEECHAT_RC_OK
    if return_code >= 0:
        weechat.prnt("", "return_code = %d" % return_code)
    if out != "":
        weechat.prnt("", "stdout: %s" % out)
    if err != "":
        weechat.prnt("", "stderr: %s" % err)
    return weechat.WEECHAT_RC_OK

# example 1: download URL
hook1 = weechat.hook_process_hashtable("url:https://weechat.org/",
                                       {"file_out": "/tmp/weechat.org.html"},
                                       20000, "my_process_cb", "")

# example 2: execute a notify program with a message from someone
hook2 = weechat.hook_process_hashtable("my-notify-command",
                                       {"arg1": "-from",
                                        "arg2": nick,
                                        "arg3": "-msg",
                                        "arg4": message},  # unsafe argument
                                       20000, "my_process_cb", "")

# example 3: call shell to execute a command (command must be SAFE)
hook3 = weechat.hook_process_hashtable("sh",
                                       {"arg1": "-c",
                                        "arg2": "ls -l /tmp | grep something"},
                                       20000, "my_process_cb", "")
----

==== weechat_hook_connect

Hook su una connessione (connessione in secondo piano ad un host remoto).

Prototipo:

[source,C]
----
struct t_hook *weechat_hook_connect (const char *proxy,
                                     const char *address,
                                     int port,
                                     int ipv6,
                                     int retry,
                                     void *gnutls_sess,
                                     void *gnutls_cb,
                                     int gnutls_dhkey_size,
                                     const char *gnutls_priorities,
                                     const char *local_hostname,
                                     int (*callback)(void *data,
                                                     int status,
                                                     int gnutls_rc,
                                                     int sock,
                                                     const char *error,
                                                     const char *ip_address),
                                     void *callback_data);
----

Argomenti:

* 'proxy': nome del proxy da utilizzare per la connessione (opzionale,
  NULL significa connessione senza proxy)
* 'address': nome o indirizzo IP al quale connettersi
* 'port': numero della porta
// TRANSLATION MISSING
* 'ipv6': 1 to use IPv6 (with fallback to IPv4), 0 to use only IPv4
// TRANSLATION MISSING
* 'retry': retry count, used to fallback to IPv4 hosts if IPv6 hosts connect
  but then fail to accept the client
* 'gnutls_sess': sessione GnuTLS (opzionale)
* 'gnutls_cb' callback GnuTLS (opzionale)
* 'gnutls_dhkey_size': dimensione della chiave utilizzata nello Scambio
  Chiavi Diffie-Hellman (GnuTLS)
* 'gnutls_priorities': priorità per gnutls (per la sintassi, consultare la
  documentazione della funzione 'gnutls_priority_init' nel manuale di gnutls), i
  valori di base sono:
** 'PERFORMANCE'
** 'NORMAL' (predefinito)
** 'SECURE128'
** 'SECURE256'
** 'EXPORT'
** 'NONE'
* 'local_hostname': nome host locale da utilizzare per la connessione
  (opzionale)
* 'callback': funzione chiamata quando la connessione è avvenuta con
  successo oppure no, argomenti e valore restituito:
** 'void *data': puntatore
** 'int status': stato della connessione:
*** 'WEECHAT_HOOK_CONNECT_OK': connessione avvenuta con successo
*** 'WEECHAT_HOOK_CONNECT_ADDRESS_NOT_FOUND': indirizzo non trovato
*** 'WEECHAT_HOOK_CONNECT_IP_ADDRESS_NOT_FOUND': indirizzo IP non trovato
*** 'WEECHAT_HOOK_CONNECT_CONNECTION_REFUSED': connessione rifiutata
*** 'WEECHAT_HOOK_CONNECT_PROXY_ERROR': errore con il proxy
*** 'WEECHAT_HOOK_CONNECT_LOCAL_HOSTNAME_ERROR': errore con il nome host locale
*** 'WEECHAT_HOOK_CONNECT_GNUTLS_INIT_ERROR': errore inizializzazione GnuTLS
*** 'WEECHAT_HOOK_CONNECT_GNUTLS_HANDSHAKE_ERROR': errore di handshake GnuTLS
*** 'WEECHAT_HOOK_CONNECT_MEMORY_ERROR': memoria insufficiente
*** 'WEECHAT_HOOK_CONNECT_TIMEOUT': timeout
*** 'WEECHAT_HOOK_CONNECT_SOCKET_ERROR': errore nella creazione socket
** 'gnutls_rc': valore del risultato di 'gnutls_handshake()'
** 'sock': socket utilizzato per la connessione
** 'const char *error': valore del risultato di 'gnutls_strerror(gnutls_rc)'
** 'const char *ip_address': indirizzo IP trovato
** valore restituito:
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data': puntatore fornito alla callback quando chiamata da WeeChat

Valore restituito:

* puntatore al nuovo hook, NULL in caso di errore

Esempio in C:

[source,C]
----
int
my_connect_cb (void *data, int status, int gnutls_rc, int sock,
               const char *error, const char *ip_address)
{
    switch (status)
    {
        case WEECHAT_HOOK_CONNECT_OK:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_ADDRESS_NOT_FOUND:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_IP_ADDRESS_NOT_FOUND:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_CONNECTION_REFUSED:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_PROXY_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_LOCAL_HOSTNAME_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_GNUTLS_INIT_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_GNUTLS_HANDSHAKE_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_MEMORY_ERROR:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_TIMEOUT:
            /* ... */
            break;
        case WEECHAT_HOOK_CONNECT_SOCKET_ERROR:
            /* ... */
            break;
    }
    return WEECHAT_RC_OK;
}

struct t_hook *my_connect_hook = weechat_hook_connect (NULL,
                                                       "my.server.org", 1234,
                                                       1, 0,
                                                       NULL, NULL, 0,  /* GnuTLS */
                                                       NULL,
                                                       &my_connect_cb, NULL);
----

Script (Python):

[source,python]
----
# prototipo
hook = weechat.hook_connect(proxy, address, port, ipv6, retry, local_hostname,
    callback, callback_data)

# esempio
def my_connect_cb(data, status, gnutls_rc, sock, error, ip_address):
    if status == WEECHAT_HOOK_CONNECT_OK:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_ADDRESS_NOT_FOUND:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_IP_ADDRESS_NOT_FOUND:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_CONNECTION_REFUSED:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_PROXY_ERROR:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_LOCAL_HOSTNAME_ERROR:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_GNUTLS_INIT_ERROR:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_GNUTLS_HANDSHAKE_ERROR:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_MEMORY_ERROR:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_TIMEOUT:
        # ...
    elif status == WEECHAT_HOOK_CONNECT_SOCKET_ERROR:
        # ...
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_connect("", "my.server.org", 1234, 1, 0, "",
                            "my_connect_cb", "")
----

==== weechat_hook_print

// TRANSLATION MISSING
_Updated in 0.4.3 and 1.0._

Hook su un messaggio stampato.

Prototipo:

[source,C]
----
struct t_hook *weechat_hook_print (struct t_gui_buffer *buffer,
                                   const char *tags,
                                   const char *message,
                                   int strip_colors,
                                   int (*callback)(void *data,
                                                   struct t_gui_buffer *buffer,
                                                   time_t date,
                                                   int tags_count,
                                                   const char **tags,
                                                   int displayed,
                                                   int highlight,
                                                   const char *prefix,
                                                   const char *message),
                                   void *callback_data);
----

Argomenti:

* 'buffer': puntatore al buffer, se NULL, verranno catturati i messaggi da qualsiasi
  buffer
// TRANSLATION MISSING
* 'tags': catch only messages with these tags (optional):
// TRANSLATION MISSING
** with WeeChat ≥ 0.4.3: comma-separated list of tags that must be in message
   (logical "or"); it is possible to combine many tags as a logical "and" with
   separator "+"; wildcard "*" is allowed in tags
// TRANSLATION MISSING
** with WeeChat ≤ 0.4.2: comma-separated list of tags that must all be in
   message (logical "and")
* 'message': verranno catturati solo i messaggi con questa stringa (opzionale,
  non sensibile alle maiuscole)
* 'strip_colors': se 1, i colori verranno estratti dal messaggio visualizzato, prima
  di chiamare la callback
* 'callback': funzione chiamata quando viene stampato un messaggio, argomenti e
  valore restituito:
** 'void *data': puntatore
** 'struct t_gui_buffer *buffer': puntatore al buffer
** 'time_t date': data
** 'int tags_count': numero di tag per riga
** 'const char **tags': array con tag per riga
** 'int displayed': 1 se la riga è visualizzata, 0 se filtrata (nascosta)
** 'int highlight': 1 se la riga viene evidenziata, altrimenti 0
** 'const char *prefix': prefisso
** 'const char *message': messaggio
** valore restituito:
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data': puntatore fornito alla callback quando chiamata da WeeChat

Valore restituito:

* puntatore al nuovo hook, NULL in caso di errore

// TRANSLATION MISSING
[IMPORTANT]
In scripts, with WeeChat ≥ 1.0, the callback arguments 'displayed' and
'highlight' are integers (with WeeChat ≤ 0.4.3, they were strings). +
To be compatible with all versions, it is recommended to convert the argument
to integer before testing it, for example in Python: "`if int(highlight):`".

Esempio in C:

[source,C]
----
int
my_print_cb (void *data, struct t_gui_buffer *buffer, time_t date,
             int tags_count, const char **tags,
             int displayed, int highlight,
             const char *prefix, const char *message)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* cattura tutti i messaggi, su tutti i buffer, senza colore */
struct t_hook *my_print_hook =
    weechat_hook_print (NULL, NULL, NULL, 1, &my_print_cb, NULL);
----

Script (Python):

[source,python]
----
# prototipo
hook = weechat.hook_print(buffer, tags, message, strip_colors, callback, callback_data)

# esempio
def my_print_cb(data, buffer, date, tags, displayed, highlight, prefix, message):
    if int(highlight):
        # ...
    return weechat.WEECHAT_RC_OK

# cattura tutti i messaggi, su tutti i buffer, senza colore
hook = weechat.hook_print("", "", "", 1, "my_print_cb", "")
----

==== weechat_hook_signal

Hook su un segnale.

Prototipo:

[source,C]
----
struct t_hook *weechat_hook_signal (const char *signal,
                                    int (*callback)(void *data,
                                                    const char *signal,
                                                    const char *type_data,
                                                    void *signal_data),
                                    void *callback_data);
----

Argomenti:

// TRANSLATION MISSING
* 'signal': segnale da catturare, wildcard "*" is allowed
  (priorità consentita, consultare la nota riguardo la
  <<hook_priority,priority>>), see table below
* 'callback': funzione chiamata a segnale ricevuto, argomenti e valore
  restituito:
** 'void *data': puntatore
** 'const char *signal': segnale ricevuto
** 'const char *type_data': tipo di dati inviati con il segnale:
*** 'WEECHAT_HOOK_SIGNAL_STRING': stringa
*** 'WEECHAT_HOOK_SIGNAL_INT': numero intero
*** 'WEECHAT_HOOK_SIGNAL_POINTER': puntatore
** 'void *signal_data': dati inviati con il segnale
** valore restituito:
*** 'WEECHAT_RC_OK'
// TRANSLATION MISSING
*** 'WEECHAT_RC_OK_EAT' (stop sending the signal immediately)
    _(WeeChat ≥ 0.4.0)_
*** 'WEECHAT_RC_ERROR'
* 'callback_data': puntatore fornito alla callback quando chiamata da WeeChat

Valore restituito:

* puntatore al nuovo hook, NULL in caso di errore

// TRANSLATION MISSING
List of signals sent by WeeChat and plugins:

[width="100%",cols="^1,^3,^4,5",options="header"]
|===
| Plugin | Segnale | Argomenti | Descrizione

// TRANSLATION MISSING
| aspell | aspell_suggest +
  _(WeeChat ≥ 0.4.0)_ |
  Pointer: buffer |
  New suggestions for a misspelled word

// TRANSLATION MISSING
| guile | guile_script_loaded +
  _(WeeChat ≥ 0.3.9)_ |
  String: path to script |
  Scheme script loaded

// TRANSLATION MISSING
| guile | guile_script_unloaded +
  _(WeeChat ≥ 0.3.9)_ |
  String: path to script |
  Scheme script unloaded

// TRANSLATION MISSING
| guile | guile_script_installed +
  _(WeeChat ≥ 0.3.9)_ |
  String: comma-separated list of paths to scripts installed |
  Scheme script(s) installed

// TRANSLATION MISSING
| guile | guile_script_removed +
  _(WeeChat ≥ 0.3.9)_ |
  String: comma-separated list of scripts removed |
  Scheme script(s) removed

| irc | xxx,irc_in_yyy ^(1)^ |
  String: messaggio |
  Messaggio IRC dal server (prima di essere utilizzato
  dal plugin irc, il segnale viene inviato solo se il
  messaggio *non* viene ignorato)

| irc | xxx,irc_in2_yyy ^(1)^ |
  String: messaggio |
  Messaggio IRC dal server (dopo essere stato
  utilizzato dal plugin irc, il segnale viene inviato
  solo se il messaggio *non* viene ignorato)

| irc | xxx,irc_raw_in_yyy ^(1)^ +
  _(WeeChat ≥ 0.3.2)_ |
  String: messaggio |
  Messaggio IRC dal server (prima di essere utilizzato
  dal plugin irc, il segnale viene inviato anche se il
  messaggio è stato ignorato)

| irc | xxx,irc_raw_in2_yyy ^(1)^ +
  _(WeeChat ≥ 0.3.2)_ |
  String: messaggio |
  Messaggio IRC dal server (dopo essere stato
  utilizzato dal plugin irc, il segnale viene inviato
  anche se il messaggio è stato ignorato)

| irc | xxx,irc_out1_yyy ^(1)^ +
  _(WeeChat ≥ 0.3.7)_ |
  String: messaggio |
  Messaggio IRC inviato al server (prima della divisione automatica da adattare in 512 byte)

| irc | xxx,irc_out_yyy ^(1)^ |
  String: messaggio |
  Messaggio IRC inviato al server (dopo la divisione automatica da adattare in 512 byte)

| irc | xxx,irc_outtags_yyy ^(1)^ +
  _(WeeChat ≥ 0.3.4)_ |
  Stringa: tag + ";" + messaggio |
  Tag + messaggio IRC inviato al server

| irc | irc_ctcp |
  String: messaggio |
  CTCP ricevuto

| irc | irc_dcc |
  String: messaggio |
  Nuova DCC

| irc | irc_pv |
  String: messaggio |
  Messaggio privato ricevuto

| irc | irc_channel_opened |
  Puntatore: buffer |
  Canale aperto

| irc | irc_pv_opened |
  Puntatore: buffer |
  Chat privata aperta

| irc | irc_server_opened +
  _(WeeChat ≥ 0.3.7)_ |
  Puntatore: buffer |
  Server del buffer aperto

| irc | irc_server_connecting |
  String: nome server |
  Connessione al server

| irc | irc_server_connected |
  String: nome server |
  Connesso al server

| irc | irc_server_disconnected |
  String: nome server |
  Disconnesso dal server

| irc | irc_ignore_removing |
  Puntatore: ignore |
  Rimozione dell'ignore

| irc | irc_ignore_removed |
  - |
  Ignore rimosso

| irc | irc_notify_join +
  _(WeeChat ≥ 0.3.8)_ |
  String: nome server + "," + nick |
  Un nick nella lista notifiche è entrato sul server

| irc | irc_notify_quit +
  _(WeeChat ≥ 0.3.8)_ |
  String: nome server + "," + nick |
  Un nick nella lista notifiche è uscito dal server

| irc | irc_notify_away +
  _(WeeChat ≥ 0.3.8)_ |
  String: nome server + "," + nick + "," + messaggio di assenza |
  Un nick nella lista notifiche è ora assente sul server

| irc | irc_notify_still_away +
  _(WeeChat ≥ 0.3.8)_ |
  String: nome server + "," + nick + "," + messaggio di assenza |
  Un nick nella lista notifiche è ancora assente sul server (messaggio di assenza cambiato)

| irc | irc_notify_back +
  _(WeeChat ≥ 0.3.8)_ |
  String: nome server + "," + nick |
  Un nick nella lista notifiche è tornato (messaggio di assenza rimosso)

| logger | logger_start |
  Puntatore: buffer |
  Avvia il logging per il buffer

| logger | logger_stop |
  Puntatore: buffer |
  Ferma il logging per il buffer

| logger | logger_backlog |
  Puntatore: buffer |
  Visualizza log precedenti per il buffer

// TRANSLATION MISSING
| lua | lua_script_loaded +
  _(WeeChat ≥ 0.3.9)_ |
  String: path to script |
  Lua script loaded

// TRANSLATION MISSING
| lua | lua_script_unloaded +
  _(WeeChat ≥ 0.3.9)_ |
  String: path to script |
  Lua script unloaded

// TRANSLATION MISSING
| lua | lua_script_installed +
  _(WeeChat ≥ 0.3.9)_ |
  String: comma-separated list of paths to scripts installed |
  Lua script(s) installed

// TRANSLATION MISSING
| lua | lua_script_removed +
  _(WeeChat ≥ 0.3.9)_ |
  String: comma-separated list of scripts removed |
  Lua script(s) removed

// TRANSLATION MISSING
| perl | perl_script_loaded +
  _(WeeChat ≥ 0.3.9)_ |
  String: path to script |
  Perl script loaded

// TRANSLATION MISSING
| perl | perl_script_unloaded +
  _(WeeChat ≥ 0.3.9)_ |
  String: path to script |
  Perl script unloaded

// TRANSLATION MISSING
| perl | perl_script_installed +
  _(WeeChat ≥ 0.3.9)_ |
  String: comma-separated list of paths to scripts installed |
  Perl script(s) installed

// TRANSLATION MISSING
| perl | perl_script_removed +
  _(WeeChat ≥ 0.3.9)_ |
  String: comma-separated list of scripts removed |
  Perl script(s) removed

// TRANSLATION MISSING
| python | python_script_loaded +
  _(WeeChat ≥ 0.3.9)_ |
  String: path to script |
  Python script loaded

// TRANSLATION MISSING
| python | python_script_unloaded +
  _(WeeChat ≥ 0.3.9)_ |
  String: path to script |
  Python script unloaded

// TRANSLATION MISSING
| python | python_script_installed +
  _(WeeChat ≥ 0.3.9)_ |
  String: comma-separated list of paths to scripts installed |
  Python script(s) installed

// TRANSLATION MISSING
| python | python_script_removed +
  _(WeeChat ≥ 0.3.9)_ |
  String: comma-separated list of scripts removed |
  Python script(s) removed

// TRANSLATION MISSING
| relay | relay_client_connecting +
  _(WeeChat ≥ 1.0)_ |
  Pointer: relay client |
  A relay client is connecting

// TRANSLATION MISSING
| relay | relay_client_waiting_auth +
  _(WeeChat ≥ 1.0)_ |
  Pointer: relay client |
  Waiting for authentication from a relay client

// TRANSLATION MISSING
| relay | relay_client_auth_ok +
  _(WeeChat ≥ 1.0)_ |
  Pointer: relay client |
  Successful authentication from a relay client

// TRANSLATION MISSING
| relay | relay_client_connected +
  _(WeeChat ≥ 1.0)_ |
  Pointer: relay client |
  A relay client is connected

// TRANSLATION MISSING
| relay | relay_client_auth_failed +
  _(WeeChat ≥ 1.0)_ |
  Pointer: relay client |
  Authentication of a relay client has failed

// TRANSLATION MISSING
| relay | relay_client_disconnected +
  _(WeeChat ≥ 1.0)_ |
  Pointer: relay client |
  A relay client is disconnected

// TRANSLATION MISSING
| ruby | ruby_script_loaded +
  _(WeeChat ≥ 0.3.9)_ |
  String: path to script |
  Ruby script loaded

// TRANSLATION MISSING
| ruby | ruby_script_unloaded +
  _(WeeChat ≥ 0.3.9)_ |
  String: path to script |
  Ruby script unloaded

// TRANSLATION MISSING
| ruby | ruby_script_installed +
  _(WeeChat ≥ 0.3.9)_ |
  String: comma-separated list of paths to scripts installed |
  Ruby script(s) installed

// TRANSLATION MISSING
| ruby | ruby_script_removed +
  _(WeeChat ≥ 0.3.9)_ |
  String: comma-separated list of scripts removed |
  Ruby script(s) removed

// TRANSLATION MISSING
| tcl | tcl_script_loaded +
  _(WeeChat ≥ 0.3.9)_ |
  String: path to script |
  Tcl script loaded

// TRANSLATION MISSING
| tcl | tcl_script_unloaded +
  _(WeeChat ≥ 0.3.9)_ |
  String: path to script |
  Tcl script unloaded

// TRANSLATION MISSING
| tcl | tcl_script_installed +
  _(WeeChat ≥ 0.3.9)_ |
  String: comma-separated list of paths to scripts installed |
  Tcl script(s) installed

// TRANSLATION MISSING
| tcl | tcl_script_removed +
  _(WeeChat ≥ 0.3.9)_ |
  String: comma-separated list of scripts removed |
  Tcl script(s) removed

| weechat | buffer_opened |
  Puntatore: buffer |
  Buffer aperto

| weechat | buffer_closing |
  Puntatore: buffer |
  Chiusura del buffer

| weechat | buffer_closed |
  Puntatore: buffer |
  Buffer chiuso

// TRANSLATION MISSING
| weechat | buffer_cleared |
  Puntatore: buffer |
  Buffer cleared

// TRANSLATION MISSING
| weechat | buffer_hidden |
  Pointer: buffer |
  Buffer hidden

// TRANSLATION MISSING
| weechat | buffer_unhidden |
  Pointer: buffer |
  Buffer unhidden

| weechat | buffer_line_added +
  _(WeeChat ≥ 0.3.7)_ |
  Puntatore: riga |
  Riga aggiunta in un buffer

| weechat | buffer_lines_hidden |
  Puntatore: buffer |
  Righe nascoste nel buffer

| weechat | buffer_localvar_added |
  Puntatore: buffer |
  Variabili locali aggiunte

| weechat | buffer_localvar_changed |
  Puntatore: buffer |
  Variabili locali modificate

| weechat | buffer_localvar_removed |
  Puntatore: buffer |
  Variabili locali rimosse

// TRANSLATION MISSING
| weechat | buffer_merged |
  Puntatore: buffer |
  Buffer merged

// TRANSLATION MISSING
| weechat | buffer_unmerged |
  Puntatore: buffer |
  Buffer unmerged

| weechat | buffer_moved |
  Puntatore: buffer |
  Buffer spostato

| weechat | buffer_renamed |
  Puntatore: buffer |
  Buffer rinominato

| weechat | buffer_switch |
  Puntatore: buffer |
  Passaggio tra buffer

| weechat | buffer_title_changed |
  Puntatore: buffer |
  Titolo del buffer modificato

| weechat | buffer_type_changed |
  Puntatore: buffer |
  Tipo di buffer modificato

// TRANSLATION MISSING
| weechat | buffer_zoomed +
  _(WeeChat ≥ 0.4.3)_ |
  Puntatore: buffer |
  Merged buffer zoomed

// TRANSLATION MISSING
| weechat | buffer_unzoomed +
  _(WeeChat ≥ 0.4.3)_ |
  Puntatore: buffer |
  Merged buffer unzoomed

| weechat | day_changed +
  _(WeeChat ≥ 0.3.2)_ |
  String: nuova data, formato: "2010-01-31" |
  Data di sistema modificata

| weechat | debug_dump |
  Stringa: nome plugin |
  Richiesta di dump

// TRANSLATION MISSING
| weechat | debug_libs |
  - |
  Display external libraries used

| weechat | filter_added |
  Puntatore: filtro |
  Filtro aggiunto

| weechat | filter_removing |
  Puntatore: filtro |
  Rimozione del filtro

| weechat | filter_removed |
  - |
  Filtro rimosso

| weechat | filters_enabled |
  - |
  Filtri abilitati

| weechat | filters_disabled |
  - |
  Filtri disabilitati

| weechat | hotlist_changed |
  - |
  Hotlist modificata

| weechat | input_paste_pending |
  - |
  Incolla testo in attesa

| weechat | input_search |
  Puntatore: buffer |
  Ricerca testo nel buffer

| weechat | input_text_changed |
  Puntatore: buffer |
  Testo in input modificato

| weechat | input_text_cursor_moved |
  Puntatore: buffer |
  Cursore del testo di input spostato

// TRANSLATION MISSING
| weechat | key_bind |
  String: key |
  Key added

// TRANSLATION MISSING
| weechat | key_unbind |
  String: key |
  Key removed

| weechat | key_pressed |
  String: tasto digitato |
  Tasto digitato

// TRANSLATION MISSING
| weechat | key_combo_default +
  _(WeeChat ≥ 1.0)_ |
  String: key combo |
  Key combo in 'default' context

// TRANSLATION MISSING
| weechat | key_combo_search +
  _(WeeChat ≥ 1.0)_ |
  String: key combo |
  Key combo in 'search' context

// TRANSLATION MISSING
| weechat | key_combo_cursor +
  _(WeeChat ≥ 1.0)_ |
  String: key combo |
  Key combo in 'cursor' context

// TRANSLATION MISSING
| weechat | mouse_enabled +
  _(WeeChat ≥ 1.1)_ |
  - |
  Mouse enabled

// TRANSLATION MISSING
| weechat | mouse_disabled +
  _(WeeChat ≥ 1.1)_ |
  - |
  Mouse disabled

// TRANSLATION MISSING
| weechat | nicklist_group_added +
  _(WeeChat ≥ 0.3.2)_ |
  String: buffer pointer + "," + group name |
  Group added in nicklist

// TRANSLATION MISSING
| weechat | nicklist_group_changed +
  _(WeeChat ≥ 0.3.4)_ |
  String: buffer pointer + "," + group name |
  Group changed in nicklist

// TRANSLATION MISSING
| weechat | nicklist_group_removing +
  _(WeeChat ≥ 0.4.1)_ |
  String: buffer pointer + "," + group name |
  Removing group from nicklist

// TRANSLATION MISSING
| weechat | nicklist_group_removed +
  _(WeeChat ≥ 0.3.2)_ |
  String: buffer pointer + "," + group name |
  Group removed from nicklist

// TRANSLATION MISSING
| weechat | nicklist_nick_added +
  _(WeeChat ≥ 0.3.2)_ |
  String: buffer pointer + "," + nick name |
  Nick added in nicklist

// TRANSLATION MISSING
| weechat | nicklist_nick_changed +
  _(WeeChat ≥ 0.3.4)_ |
  String: buffer pointer + "," + nick name |
  Nick changed in nicklist

// TRANSLATION MISSING
| weechat | nicklist_nick_removing +
  _(WeeChat ≥ 0.4.1)_ |
  String: buffer pointer + "," + nick name |
  Removing nick from nicklist

// TRANSLATION MISSING
| weechat | nicklist_nick_removed +
  _(WeeChat ≥ 0.3.2)_ |
  String: buffer pointer + "," + nick name |
  Nick removed from nicklist

| weechat | partial_completion |
  - |
  Completamento parziale avvenuto

// TRANSLATION MISSING
| weechat | plugin_loaded +
  _(WeeChat ≥ 0.3.9)_ |
  String: path to plugin loaded |
  Plugin loaded

// TRANSLATION MISSING
| weechat | plugin_unloaded +
  _(WeeChat ≥ 0.3.9)_ |
  String: name of plugin unloaded (example: "irc") |
  Plugin unloaded

| weechat | quit |
  String: argomenti per /quit |
  Comando `/quit` digitato dall'utente

// TRANSLATION MISSING
| weechat | signal_sigwinch +
  _(WeeChat ≥ 0.4.3)_ |
  - |
  Signal SIGWINCH received (terminal was resized)

// TRANSLATION MISSING
| weechat | upgrade |
  String: "quit" if "-quit" argument was given for /upgrade, otherwise NULL |
  Comando `/upgrade` digitato dall'utente

| weechat | upgrade_ended +
  _(WeeChat ≥ 0.3.4)_ |
  - |
  Fine del processo di aggiornamento (comando `/upgrade`)

| weechat | weechat_highlight |
  String: messaggio con prefisso |
  Evento accaduto

| weechat | weechat_pv |
  String: messaggio con prefisso |
  Messaggio privato visualizzato

// TRANSLATION MISSING
| weechat | window_closing +
  _(WeeChat ≥ 0.3.6)_ |
  Puntatore: finestra |
  Closing window

// TRANSLATION MISSING
| weechat | window_closed +
  _(WeeChat ≥ 0.3.6)_ |
  Puntatore: finestra |
  Window closed

// TRANSLATION MISSING
| weechat | window_opened +
  _(WeeChat ≥ 0.4.1)_ |
  Puntatore: finestra |
  Window opened

| weechat | window_scrolled |
  Puntatore: finestra |
  Scroll nella finestra

| weechat | window_switch +
  _(WeeChat ≥ 0.3.7)_ |
  Puntatore: finestra |
  Passaggio alla finestra

| weechat | window_zoom |
  Puntatore: finestra corrente |
  Massimizzazione della finestra

| weechat | window_zoomed |
  Puntatore: finestra corrente |
  Finestra massimizzata

| weechat | window_unzoom |
  Puntatore: finestra corrente |
  Minimizzazione della finestra

| weechat | window_unzoomed |
  Puntatore: finestra corrente |
  Finestra minimizzata

| xfer | xfer_add |
  Puntatore: lista info con info per xfer|
  Nuovo xfer

| xfer | xfer_send_ready |
  Puntatore: lista info xon info per xfer |
  Xfer pronto

// TRANSLATION MISSING
| xfer | xfer_accept_resume |
  Puntatore: lista info con info per xfer |
  Accept xfer resume

// TRANSLATION MISSING
| xfer | xfer_send_accept_resume |
  Puntatore: lista info con info per xfer |
  Xfer resumed

| xfer | xfer_start_resume |
  Puntatore: lista info con info per xfer |
  Avvia ripresa

| xfer | xfer_resume_ready |
  Puntatore: lista info con info per xfer |
  Ripresa xfer pronta

| xfer | xfer_ended +
  _(WeeChat ≥ 0.3.2)_ |
  Puntatore: lista info con info per xfer |
  Xfer terminato
|===

[NOTE]
^(1)^ 'xxx' è il nome del server IRC, 'yyy' è il nome del comando IRC.

Esempio in C:

[source,C]
----
int
my_signal_cb (void *data, const char *signal, const char *type_data,
              void *signal_data)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* cattura il segnale "quit" */
struct t_hook *my_signal_hook = weechat_hook_signal ("quit",
                                                     &my_signal_cb, NULL);
----

Script (Python):

[source,python]
----
# prototipo
hook = weechat.hook_signal(signal, callback, callback_data)

# esempio
def my_signal_cb(data, signal, signal_data):
    # ...
    return weechat.WEECHAT_RC_OK

# cattura il segnale "quit"
hook = weechat.hook_signal("quit", "my_signal_cb", "")
----

==== weechat_hook_signal_send

// TRANSLATION MISSING
_Updated in 1.0._

Invia un segnale.

Prototipo:

[source,C]
----
int weechat_hook_signal_send (const char *signal, const char *type_data,
                              void *signal_data);
----

Argomenti:

* 'signal': segnale da inviare
* 'type_data': tipo di dati inviati con il segnale (consultare
  <<_weechat_hook_signal,weechat_hook_signal>>)
* 'signal_data': dati inviati con il segnale

// TRANSLATION MISSING
Return value _(WeeChat ≥ 1.0)_:

// TRANSLATION MISSING
* return code of last callback executed ('WEECHAT_RC_OK' if no callback was
  executed):
** 'WEECHAT_RC_OK'
** 'WEECHAT_RC_OK_EAT'
** 'WEECHAT_RC_ERROR'

Esempio in C:

[source,C]
----
int rc = weechat_hook_signal_send ("my_signal", WEECHAT_HOOK_SIGNAL_STRING, my_string);
----

Script (Python):

[source,python]
----
# prototipo
rc = weechat.hook_signal_send(signal, type_data, signal_data)

# esempio
rc = weechat.hook_signal_send("my_signal", weechat.WEECHAT_HOOK_SIGNAL_STRING, my_string)
----

[[signal_logger_backlog]]
===== Signal logger_backlog

Il segnale "logger_backlog" può essere inviato per visualizzare il backlog
(cronologia di chat) nel buffer (ad esempio se il proprio buffer viene aperto
in un plugin/script).

L'argomento è un puntatore al buffer.

Esempio in C:

[source,C]
----
weechat_hook_signal_send ("logger_backlog", WEECHAT_HOOK_SIGNAL_POINTER, buffer);
----

Script (Python):

[source,python]
----
weechat.hook_signal_send("logger_backlog", weechat.WEECHAT_HOOK_SIGNAL_POINTER, buffer)
----

[[signals_xxx_script_install]]
===== Signals xxx_script_install

Cinque segnali che possono essere inviati per installare uno script, a seconda
del linguaggio:

* 'perl_script_install'
* 'python_script_install'
* 'ruby_script_install'
* 'lua_script_install'
* 'tcl_script_install'

La callback compirà le seguenti azioni alla ricezione del segnale:

. scarica e rimuove lo script installato
. sposta il nuovo script nella cartella '~/.weechat/xxx/' (dove 'xxx' è il
  linguaggio)
. crea un link al nuovo script nella cartella '~/.weechat/xxx/autoload/'
. carica il nuovo script

// TRANSLATION MISSING
These signals are used by 'script' plugin to install scripts.

L'argomento è una stringa con il percorso dello script da installare.

Esempio in C:

[source,C]
----
weechat_hook_signal_send ("python_script_install", WEECHAT_HOOK_SIGNAL_STRING,
                          "/home/xxx/.weechat/test.py");
----

Script (Python):

[source,python]
----
weechat.hook_signal_send("python_script_install", WEECHAT_HOOK_SIGNAL_STRING,
                         "/home/xxx/.weechat/test.py")
----

[[signals_xxx_script_remove]]
===== Signals xxx_script_remove

Cinque segnali che possono essere inviati per rimuovere un elenco di script, a
seconda del linguaggio:

* 'perl_script_remove'
* 'python_script_remove'
* 'ruby_script_remove'
* 'lua_script_remove'
* 'tcl_script_remove'

Per ogni script nella lista, la callback scaricherà e rimuoverà lo script.

// TRANSLATION MISSING
These signals are used by 'script' plugin to remove scripts.

L'argomento è una stringa con una lista separata da virgole di script da
rimuovere (script è il nome senza percorso, ad esempio 'script.py').

Esempio in C:

[source,C]
----
/* scarica e rimuove gli script test.py e script.py */
weechat_hook_signal_send ("python_script_remove", WEECHAT_HOOK_SIGNAL_STRING,
                          "test.py,script.py");
----

Script (Python):

[source,python]
----
# scarica e rimuove gli script test.py e script.py
weechat.hook_signal_send("python_script_remove", WEECHAT_HOOK_SIGNAL_STRING,
                         "test.py,script.py")
----

[[signal_irc_input_send]]
===== Signal irc_input_send

_WeeChat ≥ 0.3.4._

Il segnale "irc_input_send" può essere inviato per simulare input in un buffer
irc (server, canale o privato).

L'argomento è una stringa con il seguente formato:

* nome interno del server (richiesto)
* punto e virgola
* nome canale (opzionale)
* punto e virgola
* flag usate per l'invio del messaggio (opzionale, la predefinita è 1):
** '1': coda con la priorità maggiore (come i messaggi utente)
** '2': coda con la priorità minore (come i messaggi inviati automaticamente
   da WeeChat)
* punto e virgola
* elenco separato da virgole di tag usate per l'invio di un messaggio
  (opzionale)
* punto e virgola
* testo o comando (richiesto)

Esempi in C:

[source,C]
----
/* dice "Hello!" sul server freenode, canale #weechat */
weechat_hook_signal_send ("irc_input_send", WEECHAT_HOOK_SIGNAL_STRING,
                          "freenode;#weechat;1;;Hello!");

/* invia il comando "/whois FlashCode" sul server freenode, con priorità minore */
weechat_hook_signal_send ("irc_input_send", WEECHAT_HOOK_SIGNAL_STRING,
                          "freenode;;2;;/whois FlashCode");
----

Script (Python):

[source,python]
----
# dice "Hello!" sul server freenode server, canale #weechat
weechat.hook_signal_send("irc_input_send", weechat.WEECHAT_HOOK_SIGNAL_STRING,
                         "freenode;#weechat;1;;Hello!")

# invia il comando "/whois FlashCode" sul server freenode, con priorità minore
weechat.hook_signal_send("irc_input_send", weechat.WEECHAT_HOOK_SIGNAL_STRING,
                         "freenode;;2;;/whois FlashCode")
----

==== weechat_hook_hsignal

_WeeChat ≥ 0.3.4._

Hook su hsignal (segnale con tabella hash).

Prototipo:

[source,C]
----
struct t_hook *weechat_hook_hsignal (const char *signal,
                                     int (*callback)(void *data,
                                                     const char *signal,
                                                     struct t_hashtable *hashtable),
                                     void *callback_data);
----

Argomenti:

// TRANSLATION MISSING
* 'signal': segnale da catturare, wildcard "*" is allowed
  (priorità consentita, consultare la nota a proposito di <<hook_priority,priority>>),
  see table below
* 'callback': funzione chiamata a segnale ricevuto, argomenti e valore
  restituito:
** 'void *data': puntatore
** 'const char *signal': segnale ricevuto
** 'struct t_hashtable *hashtable': tabella hash
** valore restituito:
*** 'WEECHAT_RC_OK'
// TRANSLATION MISSING
*** 'WEECHAT_RC_OK_EAT' (stop sending the signal immediately)
    _(WeeChat ≥ 0.4.0)_
*** 'WEECHAT_RC_ERROR'
* 'callback_data': puntatore fornito alla callback quando chiamata da WeeChat

Valore restituito:

* puntatore al nuovo hook, NULL in caso di errore

// TRANSLATION MISSING
List of hsignals sent by WeeChat and plugins:

[width="100%",cols="^1,^3,5,5",options="header"]
|===
| Plugin | Segnale | Argomenti | Descrizione

| irc | irc_redirection_xxx_yyy ^(1)^ +
  _(WeeChat ≥ 0.3.4)_ |
  Consultare <<hsignal_irc_redirect_command,hsignal_irc_redirect_command>> |
  Redirection output

// TRANSLATION MISSING
| weechat | nicklist_group_added +
  _(WeeChat ≥ 0.4.1)_ |
  'buffer' ('struct t_gui_buffer *'): buffer +
  'parent_group' ('struct t_gui_nick_group *'): parent group +
  'group' ('struct t_gui_nick_group *'): group |
  Group added in nicklist

// TRANSLATION MISSING
| weechat | nicklist_nick_added +
  _(WeeChat ≥ 0.4.1)_ |
  'buffer' ('struct t_gui_buffer *'): buffer +
  'parent_group' ('struct t_gui_nick_group *'): parent group +
  'nick' ('struct t_gui_nick *'): nick |
  Nick added in nicklist

// TRANSLATION MISSING
| weechat | nicklist_group_removing +
  _(WeeChat ≥ 0.4.1)_ |
  'buffer' ('struct t_gui_buffer *'): buffer +
  'parent_group' ('struct t_gui_nick_group *'): parent group +
  'group' ('struct t_gui_nick_group *'): group |
  Removing group from nicklist

// TRANSLATION MISSING
| weechat | nicklist_nick_removing +
  _(WeeChat ≥ 0.4.1)_ |
  'buffer' ('struct t_gui_buffer *'): buffer +
  'parent_group' ('struct t_gui_nick_group *'): parent group +
  'nick' ('struct t_gui_nick *'): nick |
  Removing nick from nicklist

// TRANSLATION MISSING
| weechat | nicklist_group_changed +
  _(WeeChat ≥ 0.4.1)_ |
  'buffer' ('struct t_gui_buffer *'): buffer +
  'parent_group' ('struct t_gui_nick_group *'): parent group +
  'group' ('struct t_gui_nick_group *'): group |
  Group changed in nicklist

// TRANSLATION MISSING
| weechat | nicklist_nick_changed +
  _(WeeChat ≥ 0.4.1)_ |
  'buffer' ('struct t_gui_buffer *'): buffer +
  'parent_group' ('struct t_gui_nick_group *'): parent group +
  'nick' ('struct t_gui_nick *'): nick |
  Nick changed in nicklist
|===

[NOTE]
^(1)^ 'xxx' è l'argomento del segnale usato nella redirezione, 'yyy' è lo schema
di redirezione.

Esempio in C:

[source,C]
----
int
my_hsignal_cb (void *data, const char *signal, struct t_hashtable *hashtable)
{
    /* ... */
    return WEECHAT_RC_OK;
}

struct t_hook *my_hsignal_hook = weechat_hook_hsignal ("test",
                                                       &my_hsignal_cb, NULL);
----

Script (Python):

[source,python]
----
# prototipo
hook = weechat.hook_hsignal(signal, callback, callback_data)

# esempio
def my_hsignal_cb(data, signal, hashtable):
    # ...
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_hsignal("test", "my_hsignal_cb", "")
----

==== weechat_hook_hsignal_send

// TRANSLATION MISSING
_WeeChat ≥ 0.3.4, updated in 1.0._

Invia un hsignal (segnale con tabella hash).

Prototipo:

[source,C]
----
int weechat_hook_hsignal_send (const char *signal, struct t_hashtable *hashtable);
----

Argomenti:

* 'signal': segnale da inviare
* 'hashtable': tabella hash

// TRANSLATION MISSING
Return value _(WeeChat ≥ 1.0)_:

// TRANSLATION MISSING
* return code of last callback executed ('WEECHAT_RC_OK' if no callback was
  executed):
** 'WEECHAT_RC_OK'
** 'WEECHAT_RC_OK_EAT'
** 'WEECHAT_RC_ERROR'

Esempio in C:

[source,C]
----
int rc;
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
if (hashtable)
{
    weechat_hashtable_set (hashtable, "key", "value");
    rc = weechat_hook_hsignal_send ("my_hsignal", hashtable);
    weechat_hashtable_free (hashtable);
}
----

Script (Python):

[source,python]
----
# prototipo
rc = weechat.hook_hsignal_send(signal, hashtable)

# esempio
rc = weechat.hook_hsignal_send("my_hsignal", {"key": "value"})
----

[[hsignal_irc_redirect_command]]
===== Hsignal irc_redirect_command

_WeeChat ≥ 0.3.4._

L'hsignal "irc_redirect_command" può essere inviato per redirigere l'output
di un comando irc ad una callback.

L'argomento è una tabella hash con le seguenti componenti (chiavi e valori
sono stringhe):

* 'server': nome interno del server (richiesto)
* 'pattern': schema di redirezione da usare (richiesto), sia uno di default
  (definito dal plugin irc), oppure definito dall'utente (consultare
  <<hsignal_irc_redirect_pattern>>), gli schemi predefiniti sono:
** 'ison'
** 'list'
** 'mode_channel'
** 'mode_channel_ban' ("mode #channel b")
** 'mode_channel_ban_exception' ("mode #channel e")
** 'mode_channel_invite' ("mode #channel I")
** 'mode_user'
** 'monitor'
** 'names'
** 'ping'
** 'time'
** 'topic'
** 'userhost'
** 'who'
** 'whois'
** 'whowas'
* 'signal': nome segnale (richiesto)
* 'count': numero di volte in  cui verrà utilizzata la redirezione (opzionale, predefinito è 1)
* 'string': stringa che deve essere presente nei messaggi irc ricevuti (opzionale, ma
  raccomandata, se una stringa può essere usata per identificare i messaggi)
* 'timeout': timeout per la redirezione, in secondi (opzionale, predefiniti sono)
* 'cmd_filter': elenco separato da virgole di comandi irc da filtrare (solo questi
  comandi verranno inviati alle callback, altri ignorati) (opzionale)

Subito dopo aver inviato questo hsignal, è necessario inviare il comando al
server irc, e la redirezione verrà usata per questo comando.

Quando è stata ricevuta la risposta completa dal proprio comando, verrà
inviato un hsignal. Questo hsignal ha il nome 'irc_redirection_xxx_yyy' dove
'xxx' è il segnale e 'yyy' lo 'schema' usato.

La tabella hash inviata in hsignal ha il seguente contenuto (chiavi e valori
sono stringhe):

* 'output': output del comando (i messaggi vengono separati da "\n")
* 'output_size': numero di byte in 'output' (come stringa)
* 'error': stringa di errore (in caso di errore):
** 'timeout': redirezione fermata dopo il timeout
* 'server': nome interno del server
* 'pattern': schema di redirezione
* 'signal': nome del segnale
* 'command': comando rediretto

Esempio in C:

[source,C]
----
int
test_whois_cb (void *data, const char *signal, struct t_hashtable *hashtable)
{
    weechat_printf (NULL, "error = %s", weechat_hashtable_get (hashtable, "error"));
    weechat_printf (NULL, "output = %s", weechat_hashtable_get (hashtable, "output"));
    return WEECHAT_RC_OK;
}

weechat_hook_hsignal ("irc_redirection_test_whois", &test_whois_cb, NULL);
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
if (hashtable)
{
    weechat_hashtable_set (hashtable, "server", "freenode");
    weechat_hashtable_set (hashtable, "pattern", "whois");
    weechat_hashtable_set (hashtable, "signal", "test");
    weechat_hashtable_set (hashtable, "string", "FlashCode");
    weechat_hook_hsignal_send ("irc_redirect_command", hashtable);
    weechat_hook_signal_send ("irc_input_send", WEECHAT_HOOK_SIGNAL_STRING,
                              "freenode;;2;;/whois FlashCode");
    weechat_hashtable_free (hashtable);
}
----

Script (Python):

[source,python]
----
def test_whois_cb(data, signal, hashtable):
    weechat.prnt("", "error = %s" % hashtable["error"])
    weechat.prnt("", "output = %s" % hashtable["output"])
    return weechat.WEECHAT_RC_OK

weechat.hook_hsignal ("irc_redirection_test_whois", "test_whois_cb", "")
weechat.hook_hsignal_send("irc_redirect_command",
                          {"server": "freenode", "pattern": "whois", "signal": "test",
                           "string": "FlashCode"})
weechat.hook_signal_send("irc_input_send", weechat.WEECHAT_HOOK_SIGNAL_STRING,
                         "freenode;;2;;/whois FlashCode")
----

[[hsignal_irc_redirect_pattern]]
===== Hsignal irc_redirect_pattern

_WeeChat ≥ 0.3.4._

L'hsignal "irc_redirect_pattern" può essere inviato per creare uno schema
per la redirezione irc (consultare <<hsignal_irc_redirect_command>>).

L'argomento è una tabella hash con le seguenti voci (chiavi e valori sono stringa):

* 'pattern': nome dello schema (richiesto)
* 'timeout': timeout predefinito per lo schema, in secondi (opzionale, predefinito è 60)
* 'cmd_start': elenco separato da virgole di comandi che avviano la redirezione (opzionale)
* 'cmd_stop': elenco separato da virgole di comandi che fermano la redirezione (richiesto)
* 'cmd_extra': elenco separato da virgole di comandi che possono essere ricevuti dopo aver
  fermato i comandi (opzionale)

Per ogni comando in 'cmd_start', 'cmd_stop' e 'cmd_extra', è possibile fornire
un intero con la posizione di "string" che va trovato nel messaggio ricevuto,
ad esempio:

----
352:1,354,401:1
----

Per i comandi 352 e 401, "string" deve essere trovata nel messaggio ricevuto,
come primo argomento.

[IMPORTANT]
Lo schema viene rimosso quando usato da una redirezione. Se uno schema si
rivelasse necessario per diverse redirezioni, è necessario crearne uno prima
di ogni redirezione.

Esempio in C:

[source,C]
----
struct t_hashtable *hashtable = weechat_hashtable_new (8,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       WEECHAT_HASHTABLE_STRING,
                                                       NULL,
                                                       NULL);
if (hashtable)
{
    weechat_hashtable_set (hashtable, "pattern", "my_whois");
    weechat_hashtable_set (hashtable, "timeout", "30");
    weechat_hashtable_set (hashtable, "cmd_start", "311:1");
    weechat_hashtable_set (hashtable, "cmd_stop", "318:1,401:1,402:1,431:1,461");
    weechat_hashtable_set (hashtable, "cmd_extra", "318:1");
    weechat_hook_hsignal_send ("irc_redirect_pattern", hashtable);
    /*
     * now redirect irc whois command with hsignal irc_redirect_command,
     * using pattern "my_whois"
     */
    /* ... */
    weechat_hashtable_free (hashtable);
}
----

Script (Python):

[source,python]
----
weechat.hook_hsignal_send("irc_redirect_pattern",
                          {"pattern": "my_whois", "timeout": "30",
                           "cmd_start": "311:1",
                           "cmd_stop": "318:1,401:1,402:1,431:1,461",
                           "cmd_extra": "318:1"})
# now redirect irc whois command with hsignal irc_redirect_command
# using pattern "my_whois"
# ...
----

==== weechat_hook_config

Hook su un'opzione di configurazione.

Prototipo:

[source,C]
----
struct t_hook *weechat_hook_config (const char *option,
                                    int (*callback)(void *data,
                                                    const char *option,
                                                    const char *value),
                                    void *callback_data);
----

Argomenti:

// TRANSLATION MISSING
* 'option': opzione, il formato è il nome completo, come usato con il comando
  `/set` (ad esempio: `weechat.look.item_time_format`), wildcard "*" is allowed
  (priorità consentita, consultare la note riguardo la
  <<hook_priority,priority>>)
* 'callback': funzione chiamata quando l'opzione di configurazione è cambiata,
  argomenti e valore restituito:
** 'void *data': puntatore
** 'const char *option': nome dell'opzione
** 'const char *value': nuovo valore per l'opzione
** valore restituito:
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data': puntatore fornito alla callback quando chiamata da WeeChat

Valore restituito:

* puntatore al nuovo hook, NULL in caso di errore

Esempio in C:

[source,C]
----
int
my_config_cb (void *data, const char *option, const char *value)
{
    /* ... */
    return WEECHAT_RC_OK;
}

/* cattura le modifiche dell'opzione "weechat.look.item_time_format" */
struct t_hook *my_config_hook = weechat_hook_config ("weechat.look.item_time_format",
                                                     &my_config_cb, NULL);
----

Script (Python):

[source,python]
----
# prototipo
hook = weechat.hook_config(option, callback, callback_data)

# esempio
def my_config_cb(data, option, value):
    # ...
    return weechat.WEECHAT_RC_OK

# cattura le modifiche dell'opzione "weechat.look.item_time_format"
hook = weechat.hook_config("weechat.look.item_time_format", "my_config_cb", "")
----

==== weechat_hook_completion

Hook su un completamento.

Prototipo:

[source,C]
----
struct t_hook *weechat_hook_completion (const char *completion_item,
                                        const char *description,
                                        int (*callback)(void *data,
                                                        const char *completion_item,
                                                        struct t_gui_buffer *buffer,
                                                        struct t_gui_completion *completion),
                                        void *callback_data);
----

Argomenti:

* 'completion_item': nome dell'elemento del completamento, è possibile usare
  in seguito '%(name)' in un comando con un hook (argomento 'completion')
  (priorità consentita, consultare la nota riguardo la
  <<hook_priority,priority>>)
* 'callback': funzione chiamata quando viene usato l'elemento completamento
  (l'utente sta completando qualcosa usando questo elemento), argomenti e valore
  restituito:
** 'void *data': puntatore
** 'const char *completion_item': nome dell'elemento del completamento
** 'struct t_gui_buffer *buffer': buffer dove viene eseguito il completamento
** 'struct t_gui_completion *completion': struttura usata per aggiungere
   parole per il completamento (consultare
   <<_weechat_hook_completion_list_add,weechat_hook_completion_list_add>>)
** valore restituito:
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data': puntatore fornito alla callback quando chiamata da WeeChat

[NOTE]
I nomi del completamento sono globali (condivisi tra WeeChat e plugin). Si
raccomanda pertanto di scegliere un nome con un prefisso unico, come
"plugin_xxx" (dove "xxx" è il nome del proprio elemento).

// TRANSLATION MISSING
[IMPORTANT]
The callback must only call function
<<_weechat_hook_completion_list_add,weechat_hook_completion_list_add>>
and must *NOT* update the command line. +
To update the command line when key[Tab] is pressed, you can use the function
<<_weechat_hook_command_run,weechat_hook_command_run>> with command:
"/input complete_next" (and you must return 'WEECHAT_RC_OK_EAT' if your callback
has updated the command line, so that WeeChat will not perform the completion).

Valore restituito:

* puntatore al nuovo hook, NULL in caso di errore

Esempio in C:

[source,C]
----
int
my_completion_cb (void *data, const char *completion_item,
                  struct t_gui_buffer *buffer,
                  struct t_gui_completion *completion)
{
    weechat_hook_completion_list_add (completion, "word1",
                                      0, WEECHAT_LIST_POS_SORT);
    weechat_hook_completion_list_add (completion, "test_word2",
                                      0, WEECHAT_LIST_POS_SORT);
    return WEECHAT_RC_OK;
}

struct t_hook *my_completion_hook = weechat_hook_completion ("plugin_item",
                                                             "my custom completion!",
                                                             &my_completion_cb, NULL);
----

Script (Python):

[source,python]
----
# prototipo
hook = weechat.hook_completion(completion_item, description, callback, callback_data)

# esempio
def my_completion_cb(data, completion_item, buffer, completion):
    weechat.hook_completion_list_add(completion, "word1", 0, weechat.WEECHAT_LIST_POS_SORT)
    weechat.hook_completion_list_add(completion, "test_word2", 0, weechat.WEECHAT_LIST_POS_SORT)
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_completion("plugin_item", "my custom completion!",
                               "my_completion_cb", "")
----

==== weechat_hook_completion_get_string

_Novità nella versioe 0.3.4._

Ottiene il completamento di una proprietà come stringa.

Prototipo:

[source,C]
----
const char *weechat_hook_completion_get_string (struct t_gui_completion *completion,
                                                const char *property);
----

Argomenti:

* 'completion': puntatore al completamento
* 'property': nome della proprietà:
** 'base_command': comando usato per il completamento
** 'base_word': parola che viene completata
** 'args': argomenti del comando (inclusa la parola base)

Esempio in C:

[source,C]
----
int
my_completion_cb (void *data, const char *completion_item,
                  struct t_gui_buffer *buffer,
                  struct t_gui_completion *completion)
{
    /* ottiene l'argomento del comando */
    const char *args = weechat_hook_completion_get_string (completion, "args");

    /* completamento che dipende dagli argomenti */
    /* ... */

    return WEECHAT_RC_OK;
}
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.hook_completion_get_string(completion, property)

# esempio
def my_completion_cb(data, completion_item, buffer, completion):
    # ottiene l'argomento del comando
    args = weechat.hook_completion_get_string(completion, "args")
    # completamento che dipende dagli argomenti
    # ...
    return weechat.WEECHAT_RC_OK
----

==== weechat_hook_completion_list_add

Aggiunge una parola per il completamento.

Prototipo:

[source,C]
----
void weechat_hook_completion_list_add (struct t_gui_completion *completion,
                                       const char *word,
                                       int nick_completion,
                                       const char *where);
----

Argomenti:

* 'completion': puntatore al completamento
* 'word': parola da aggiungere
* 'nick_completion': 1 se la parola è un nick, altrimenti 0
* 'where': posizione in cui la parola sarà inserita nella lista:
** 'WEECHAT_LIST_POS_SORT': qualunque posizione, per mantenere
   la lista ordinata
** 'WEECHAT_LIST_POS_BEGINNING': inizio della lista
** 'WEECHAT_LIST_POS_END': fine della lista

Esempio in C: consultare <<_weechat_hook_completion,weechat_hook_completion>>.

Script (Python):

[source,python]
----
# prototipo
weechat.hook_completion_list_add(completion, word, nick_completion, where)

# esempio: consultare function hook_completion precedente
----

==== weechat_hook_modifier

Hook su un modificatore.

Prototipo:

[source,C]
----
struct t_hook *weechat_hook_modifier (const char *modifier,
                                      char *(*callback)(void *data,
                                                        const char *modifier,
                                                        const char *modifier_data,
                                                        const char *string),
                                      void *callback_data);
----

Argomenti:

// TRANSLATION MISSING
* 'modifier': nome modificatore, lista di modificatori utilizzati da
  Weechat o dai plugin
  (priorità consentita, consultare la nota riguardo la
  <<hook_priority,priority>>), see table below
* 'callback': funzione chiamata quando viene usato il modificatore,
  argomenti e valore restituito:
** 'void *data': puntatore
** 'const char *modifier': nome del modificatore
** 'const char *modifier_data': dati per il modificatore
** 'const char *string': stringa da modificare
** valore restituito: nuova stringa
* 'callback_data': puntatore fornito alla callback quando chiamata da WeeChat

Valore restituito:

* puntatore al nuovo hook, NULL in caso di errore

List of modifiers used by WeeChat and plugins:

[width="100%",cols="^2,3,4,4",options="header"]
|===
| Modificatore | Dati modificatore | Stringa | Output

| charset_decode |
  plugin.buffer_name |
  Qualsiasi stringa |
  Stringa codificata dal set caratteri trovato per plugin/buffer in UTF-8

| charset_encode |
  plugin.buffer_name |
  Qualsiasi stringa |
  Stringa codificata da UTF-8 al set caratteri trovato per il plugin/buffer

// TRANSLATION MISSING
| irc_color_decode |
  "1" per mantenere i colori, "0" per rimuovere i colori |
  Qualsiasi stringa |
  String with IRC colors converted to WeeChat colors (or IRC colors removed)

// TRANSLATION MISSING
| irc_color_encode |
  "1" per mantenere i colori, "0" per rimuovere i colori |
  Qualsiasi stringa |
  String with IRC colors (or IRC colors removed)

// TRANSLATION MISSING
| irc_color_decode_ansi +
  _(WeeChat ≥ 1.0)_ |
  "1" per mantenere i colori, "0" per rimuovere i colori |
  Qualsiasi stringa |
  String with ANSI colors converted to IRC colors (or ANSI colors removed)

// TRANSLATION MISSING
| irc_command_auth +
  _(WeeChat ≥ 0.4.1)_ |
  Nome server |
  Authentication command (for example: `/msg nickserv identify password`) |
  Command with hidden password (for example: `/msg nickserv identify ********`)

// TRANSLATION MISSING
| irc_message_auth +
  _(WeeChat ≥ 0.4.1)_ |
  Nome server |
  Message displayed after `/msg` sent to nickserv |
  Message with hidden password

| irc_in_xxx ^(1)^ |
  Nome server |
  Contenuto del messaggio ricevuto dal server IRC (prima della codifica del set caratteri) |
  Nuovo contenuto del messaggio

| irc_in2_xxx ^(1)^ +
  _(WeeChat ≥ 0.3.5)_ |
  Nome server |
  Contenuto del messaggio ricevuto dal server IRC (dopo la codifica del set caratteri) |
  Nuovo contenuto del messaggio

| irc_out1_xxx ^(1)^ +
  _(WeeChat ≥ 0.3.7)_ |
  Nome server |
  Contenuto del messaggio che sta per essere inviato al server IRC (prima della divisione automatica da adattare in 512 byte) |
  Nuovo contenuto del messaggio

| irc_out_xxx ^(1)^ |
  Nome server |
  Contenuto del messaggio che sta per essere inviato al server IRC (dopo la divisione automatica da adattare in 512 byte) |
  Nuovo contenuto del messaggio

// TRANSLATION MISSING
| color_decode_ansi +
  _(WeeChat ≥ 1.0)_ |
  "1" per mantenere i colori, "0" per rimuovere i colori |
  Qualsiasi stringa |
  String with ANSI colors converted to WeeChat colors (or ANSI colors removed)

| bar_condition_yyy ^(2)^ |
  Stringa con puntatore alla finestra ("0x123..") |
  Stringa vuota |
  "1" per visualizzare la barra, "0" per nasconderla

| history_add +
  _(WeeChat ≥ 0.3.2)_ |
  Stringa con puntatore al buffer ("0x123..") |
  Contenuto della riga di comando da aggiungere nella cronologia comandi (buffer e globale |
  Stringa aggiunta alla cronologia comandi

| input_text_content |
  Stringa con puntatore al buffer ("0x123..") |
  Contenuto della riga di comando |
  Nuovo contenuto della riga di comando

| input_text_display |
  Stringa con puntatore al buffer ("0x123..") |
  Contenuto della riga di comando, senza tag al cursore |
  Nuova stringa, solo da mostrare (la riga di comando non viene modificata)

| input_text_display_with_cursor |
  Stringa con puntatore al buffer ("0x123..") |
  Contenuto della riga di comando, con tag al cursore |
  Nuova stringa, solo da mostrare (la riga di comando non viene modificata)

| input_text_for_buffer +
  _(WeeChat ≥ 0.3.7)_ |
  Stringa con puntatore al buffer ("0x123..") |
  Contenuto della riga di comando inviata al buffer (testo o comando) |
  Nuovo contenuto della riga di comando inviata al buffer

| weechat_print |
  plugin + ";" + buffer_name + ";" + tags |
  Messaggio stampato |
  Nuovo messaggio stampato
|===

[NOTE]
^(1)^ 'xxx' è il nome del comando IRC. +
^(2)^ 'yyy' è il nome della barra.

Esempio in C:

[source,C]
----
char *
my_modifier_cb (void *data, const char *modifier,
                const char *modifier_data,
                const char *string)
{
    char *result;
    int length;

    if (!string)
        return NULL;

    length = strlen (string) + 5;
    result = malloc (length);
    if (result)
    {
        /* aggiunge "xxx" ad ogni messaggio stampato */
        snprintf (result, length, "%s xxx", string);
    }

    return result;
}

struct t_hook *my_modifier_hook = weechat_hook_modifier ("weechat_print",
                                                         &my_modifier_cb, NULL);
----

Script (Python):

[source,python]
----
# prototipo
hook = weechat.hook_modifier(modifier, callback, callback_data)

# esempio
def my_modifier_cb(data, modifier, modifier_data, string):
    return "%s xxx" % string

hook = weechat.hook_modifier("weechat_print", "my_modifier_cb", "")
----

==== weechat_hook_modifier_exec

Esegue modificatore(i).

Prototipo:

[source,C]
----
char *weechat_hook_modifier_exec (const char *modifier,
                                  const char *modifier_data,
                                  const char *string);
----

Argomenti:

* 'modifier': nome modificatore
* 'modifier_data': dati modificatore
* 'string': stringa da modificare

Valore restituito:

* stringa modificata, NULL in caso di errore

Esempio in C:

[source,C]
----
char *new_string = weechat_hook_modifier_exec ("my_modifier",
                                               my_data, my_string);
----

Script (Python):

[source,python]
----
# prototipo
weechat.hook_modifier_exec(modifier, modifier_data, string)

# esempio
weechat.hook_modifier_exec("my_modifier", my_data, my_string)
----

==== weechat_hook_info

Hook su una informazione (la callback prende e restituisce una stringa).

Prototipo:

[source,C]
----
struct t_hook *weechat_hook_info (const char *info_name,
                                  const char *description,
                                  const char *args_description,
                                  const char *(*callback)(void *data,
                                                          const char *info_name,
                                                          const char *arguments),
                                  void *callback_data);
----

Argomenti:

* 'info_name': nome della info
  (priorità consentita, consultare la nota riguardo la
  <<hook_priority,priority>>)
* 'description': descrizione
* 'args_description': descrizione degli argomenti
* 'callback': funzione chiamata alla richiesta di una info, argomenti e valore
  restituito:
** 'void *data': puntatore
** 'const char *info_name': nome della info
** 'const char *arguments': argomenti addizionali, dipendono dalle info
** valore restituito: valore dell'info richiesta
* 'callback_data': puntatore fornito alla callback quando chiamata da WeeChat

Valore restituito:

* puntatore al nuovo hook, NULL in caso di errore

Esempio in C:

[source,C]
----
const char *
my_info_cb (void *data, const char *info_name, const char *arguments)
{
    /* ... */
    return pointer_to_string;
}

/* aggiunge informazione "my_info" */
struct t_hook *my_info_hook = weechat_hook_info ("my_info",
                                                 "Some info",
                                                 "Info about arguments",
                                                 &my_info_cb, NULL);
----

Script (Python):

[source,python]
----
# prototipo
hook = weechat.hook_info(info_name, description, args_description, callback, callback_data)

# esempio
def my_info_cb(data, info_name, arguments):
    return "some_info"

hook = weechat.hook_info("my_info", "Some info", "Info about arguments",
                         "my_info_cb", "")
----

==== weechat_hook_info_hashtable

_WeeChat ≥ 0.3.4._

Hook su una informazione (la callback prende e restituisce una tabella hash).

Prototipo:

[source,C]
----
struct t_hook *weechat_hook_info_hashtable (const char *info_name,
                                            const char *description,
                                            const char *args_description,
                                            const char *output_description,
                                            struct t_hashtable *(*callback)(void *data,
                                                                            const char *info_name,
                                                                            struct t_hashtable *hashtable),
                                            void *callback_data);
----

Argomenti:

* 'info_name': nome della info
  (priorità consentita, consultare la nota riguardo la
  <<hook_priority,priority>>)
* 'description': descrizione
* 'args_description': descrizione della tabella hash attesa (opzionale, può
  essere NULL)
* 'output_description': descrizione della tabella hash restituita dalla
  callback (opzionale, può essere NULL)
* 'callback': funzione chiamata alla richiesta della info, argomenti e valore
  restituito:
** 'void *data': puntatore
** 'const char *info_name': nome della info
** 'struct t_hashtable *hashtable': tabella hash, in base alla info
** valore restituito: tabella hash richiesta
* 'callback_data': puntatore fornito alla callback quando chiamata da WeeChat

Valore restituito:

* puntatore al nuovo hook, NULL in caso di errore

Esempio in C:

[source,C]
----
struct t_hashtable *
my_info_hashtable_cb (void *data, const char *info_name, struct t_hashtable *hashtable)
{
    /* ... */
    return pointer_to_new_hashtable;
}

/* add info "my_info_hashtable" */
struct t_hook *my_info_hook = weechat_hook_info_hashtable ("my_info_hashtable",
                                                           "Some info",
                                                           "Info about input hashtable",
                                                           "Info about output hashtable",
                                                           &my_info_hashtable_cb, NULL);
----

Script (Python):

[source,python]
----
# prototipo
hook = weechat.hook_info_hashtable(info_name, description, args_description,
                                   output_description, callback, callback_data)

# esempio
def my_info_hashtable_cb(data, info_name, hashtable):
    return {"test_key": "test_value"}

hook = weechat.hook_info_hashtable("my_info_hashtable", "Some info",
                                   "Info about input hashtable",
                                   "Info about output hashtable",
                                   "my_info_hashtable_cb", "")
----

==== weechat_hook_infolist

Hook su una lista info: la callback restituisce il puntatore alla lista info
richiesta.

Prototipo:

[source,C]
----
struct t_hook *weechat_hook_infolist (const char *infolist_name,
                                      const char *description,
                                      const char *pointer_description,
                                      const char *args_description,
                                      struct t_infolist *(*callback)(void *data,
                                                                     const char *infolist_name,
                                                                     void *pointer,
                                                                     const char *arguments),
                                      void *callback_data);
----

Argomenti:

* 'infolist_name': nome della lista info
  (priotità consentita, consultare la nota riguardo la
  <<hook_priority,priority>>)
* 'description': descrizione
* 'pointer_description': descrizione del puntatore (opzionale, può essere NULL)
* 'args_description': descrizione degli argomenti (opzionale, può essere NULL)
* 'callback': funzione chiamata alla richiesta della lista info, argomenti e
  valore restituito:
** 'void *data': puntatore
** 'const char *infolist_name': nome della lista info
** 'void *pointer': puntatore ad un oggetto che la lista info deve restituire
   (per ricevere un solo elemento della lista info)
** 'const char *arguments': argomento aggiuntivo, dipende dalla lista info
** valore restituito: lista info richiesta
* 'callback_data': puntatore fornito alla callback quando chiamata da WeeChat

Valore restituito:

* puntatore al nuovo hook, NULL in caso di errore

Esempio in C:

[source,C]
----
struct t_infolist *
my_infolist_cb (void *data, const char *infolist_name, void *pointer,
                const char *arguments)
{
    struct t_infolist *my_infolist;

    /* compila lista info */
    /* ... */

    return my_infolist;
}

/* aggiunge lista info "my_infolist" */
struct t_hook *my_infolist = weechat_hook_infolist ("my_infolist",
                                                    "Infolist with some data",
                                                    "Info about pointer",
                                                    "Info about arguments",
                                                    &my_infolist_cb, NULL);
----

Script (Python):

[source,python]
----
# prototipo
hook = weechat.hook_infolist(infolist_name, description, pointer_description,
                             args_description, callback, callback_data)

# esempio
def my_infolist_cb(data, infolist_name, pointer, arguments):
    # build infolist
    # ...
    return my_infolist

hook = weechat.hook_infolist("my_infolist", "Infolist with some data",
                             "Info about pointer", "Info about arguments",
                             "my_infolist_cb", "")
----

==== weechat_hook_hdata

Hook di un hdata: la callback restituisce il puntatore all'hdata richiesto.

Prototipo:

[source,C]
----
struct t_hook *weechat_hook_hdata (const char *hdata_name,
                                   const char *description,
                                   struct t_hdata *(*callback)(void *data,
                                                               const char *hdata_name),
                                   void *callback_data);
----

Argomenti:

* 'hdata_name': nome dell'hdata
  (priorità consentita, consultare la nota a proposito di <<hook_priority,priority>>)
* 'description': descrizione
* 'callback': funzione chiamata alla richiesta di hdata, argomenti e valore restituito:
** 'void *data': puntatore
** 'const char *hdata_name': nome dell'hdata
** return value: hdata richiesto
* 'callback_data': puntatore fornito alla callback quando chiamata da WeeChat

Valore restituito:

* puntatore al nuovo hook, NULL in caso di errore

Esempio in C:

[source,C]
----
struct t_hdata *
my_hdata_cb (void *data, const char *hdata_name)
{
    struct t_hdata *my_hdata;

    /* build hdata */
    /* ... */

    return my_hdata;
}

/* add hdata "my_hdata" */
struct t_hook *my_hdata = weechat_hook_hdata ("my_hdata",
                                              "Hdata for my structure",
                                              &my_hdata_cb, NULL);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_hook_focus

Hook sul foucus: evento del mouse o tasto premuto nella modalità cursore
(movimento libero del cursore).

Prototipo:

[source,C]
----
struct t_hook *weechat_hook_focus (const char *area,
                                   struct t_hashtable *(*callback)(void *data,
                                                                   struct t_hashtable *info),
                                   void *callback_data);
----

Argomenti:

* 'area': "chat" per la zona di chat, o il nome di un elemento barra
  (priorità consentita, consultare la nota a riguardo di <<hook_priority,priority>>)
* 'callback': funzione chiamata al momento del focus, argomenti e valore restituito:
** 'void *data': puntatore
** 'struct t_hashtable *info': tabella hash con informazioni sul focus e
   stringhe restituite da altre chiamate alle callback sul focus (con la
   priorità più alta) (consultare la tabella in basso)
** valore restituito: sia il puntatore "info" tabella hash completa), o il
   puntatore ad una nuova tabella hash (creata dalla callback, con chiavi e
   valori di tipo "string), questa nuovo contenuto della tabella hash verrà
   aggiunto ad 'info' per le altre chiamate alle callback del focus
* 'callback_data': puntatore fornito alla callback quando chiamata da WeeChat

[IMPORTANT]
Per l'azione di un mouse, la callback verrà chiamata due volte: la prima quando
il pulsante viene premuto (qui la zona corrisponde sempre alla propria area), la
seconda quando il pulsante viene rilasciato, e allora la zona potrà non
corrispondere con la propria: per cui bisogna *sempre* verificare nella propria
callback se l'area corrisponde prima di usare le informazioni nella tabella hash.

Contenuto della tabella hash inviata alla callback (tasti e valori sono di tipo
"string"):

[width="100%",cols="5m,5,8,3",options="header"]
|===
| Key ^(1)^                  | Descrizione                 | Valori di esempio                            | Valore se N/D
| _x                         | Colonna sullo schermo     2+| "0" ... "n"
| _y                         | Riga sullo schermo        2+| "0" ... "n"
| _key                       | Evento tasto o mouse      2+| "button1", "button2-gesture-left", ...
| _window                    | Puntatore alla finestra     | "0x12345678"                                 | ""
| _window_number             | Numero della finestra       | "1" ... "n"                                  | "*"
| _buffer                    | Puntatore al buffer         | "0x12345678"                                 | ""
| _buffer_number             | Numero del buffer           | "1" ... "n"                                  | "-1"
| _buffer_plugin             | Nome plugin del buffer      | "core", "irc", ...                           | ""
| _buffer_name               | Nome del buffer             | "weechat", "freenode.#weechat", ...          | ""
| _buffer_full_name          | Nome completo del buffer    | "core.weechat", "irc.freenode.#weechat", ... | ""
| _buffer_localvar_XXX ^(2)^ | Variabili locali del buffer | qualsiasi valore                             | non impostato
| _chat                      | Indicatore area di chat     | "0" o  "1"                                   | "0"
| _chat_line_x               | Colonna nella riga ^(3)^    | "0" ... "n"                                  | "-1"
| _chat_line_y               | Numero della riga ^(3)^     | "0" ... "n"                                  | "-1"
| _chat_line_date            | Riga con data/ora           | "1313237175"                                 | "0"
| _chat_line_date_printed    | Riga con data/ora ^(4)^     | "1313237175"                                 | "0"
| _chat_line_time            | Ora visualizzata            | "14:06:15"                                   | ""
| _chat_line_tags            | Tag della riga              | "irc_privmsg,nick_flashy,log1"               | ""
| _chat_line_nick            | Nick della riga             | "FlashCode"                                  | ""
| _chat_line_prefix          | Prefisso della riga         | "@FlashCode"                                 | ""
| _chat_line_message         | Messaggio della riga        | "Hello world!"                               | ""
| _chat_word                 | Parola a (x,y)              | "Hello"                                      | ""
| _chat_bol                  | Inizio della riga ⇒ (x-1,y) | "He"                                         | ""
| _chat_eol                  | (x,y) ⇒ fine della riga     | "llo world!"                                 | ""
| _bar_name                  | Nome della barra            | "title", "nicklist", ...                     | ""
| _bar_filling               | Riempimento della barra     | "horizontal", "vertical", ...                | ""
| _bar_item_name             | Nome dell'elemento barra    | "buffer_nicklist", "hotlist", ...            | ""
| _bar_item_line             | Riga nell'elemento barra    | "0" ... "n"                                  | "-1"
| _bar_item_col              | Colonna nell'elemento barra | "0" ... "n"                                  | "-1"
|===

[NOTE]
^(1)^ Ci sono alcune chiavi con il suffisso "2" (es: "_x2", "_y2", "_window2",
...) con informazioni sul secondo punto (utile solo per le azioni del mouse,
per sapere dove il pulsante del mouse è stato rilasciato). +
^(2)^ `XXX` è il nome della variabile locale nel buffer. +
^(3)^ È impostato solo per l buffer con contenuto libero. +
^(4)^ Data/ora in cui WeeChat aggiunge una riga nel buffer (maggiore o uguale a
"chat_line_date").

Informazioni aggiuntive per l'elemento barra "buffer_nicklist":

[width="70%",cols="3m,3,8",options="header"]
|===
| Chiave         | Plugin | Descrizione
| nick           | core   | Nick
| prefix         | core   | Prefisso per il nick
| group          | core   | Nome gruppo
| irc_host       | irc    | Host per il nick (se conosciuto)
|===

[NOTE]
^(1)^ Il nome del plugin che definisce un hook_focus per restituire
informazioni su questo elemento della barra (ad esempio se il plugin è "irc",
tale informazione sarà disponibile solo sui buffer irc).

Valore restituito:

* puntatore al nuovo hook, NULL in caso di errore

Esempio in C:

[source,C]
----
struct t_hashtable *
my_focus_nicklist_cb (void *data, struct t_hashtable *info)
{
    /* add strings in hashtable */
    /* ... */

    return info;
}

/* add focus on nicklist */
struct t_hook *my_focus = weechat_hook_focus ("buffer_nicklist",
                                              &my_focus_nicklist_cb, NULL);
----

Script (Python):

[source,python]
----
# prototipo
hook = weechat.hook_focus(area, callback, callback_data)

# esempio
def my_focus_nicklist_cb(data, info):
    # build dict
    # ...
    return my_dict

hook = weechat.hook_focus("buffer_nicklist", "my_focus_nicklist_cb", "")
----

==== weechat_hook_set

_WeeChat ≥ 0.3.9 (script: WeeChat ≥ 0.4.3)._

// TRANSLATION MISSING
Set string value of a hook property.

Prototipo:

[source,C]
----
void weechat_hook_set (struct t_hook *hook, const char *property,
                       const char *value);
----

Argomenti:

* 'hook': qualcosa su cui è presente un hook con "weechat_hook_xxx()"
// TRANSLATION MISSING
* 'property': nome della proprietà (see table below)
// TRANSLATION MISSING
* 'value': new value for property

// TRANSLATION MISSING
Properties:

// TRANSLATION MISSING
[width="100%",cols="^2,2,2,5",options="header"]
|===
| Nome | Hook type | Valore | Descrizione

// TRANSLATION MISSING
| subplugin | any type | qualsiasi stringa |
// TRANSLATION MISSING
  Name of sub plugin (commonly script name, which is displayed in
  `/help command` for a hook of type 'command')

| stdin +
  _(WeeChat ≥ 0.4.3)_ |
  'process', 'process_hashtable' | qualsiasi stringa |
// TRANSLATION MISSING
  Send data on standard input ('stdin') of child process

| stdin_close +
  _(WeeChat ≥ 0.4.3)_ |
// TRANSLATION MISSING
  'process', 'process_hashtable' | (not used) |
// TRANSLATION MISSING
  Close pipe used to send data on standard input ('stdin') of child process

| signal +
  _(WeeChat ≥ 1.0)_ |
  'process', 'process_hashtable' |
// TRANSLATION MISSING
  signal number or one of these names: `hup`, `int`, `quit`, `kill`, `term`,
  `usr1`, `usr2` |
// TRANSLATION MISSING
  Send a signal to the child process
|===

Esempio in C:

[source,C]
----
struct t_hook *my_command_hook =
    weechat_hook_command ("abcd", "description",
                          "args", "description args",
                          "", &my_command_cb, NULL);
weechat_hook_set (my_command_hook, "subplugin", "test");
----

Script (Python):

[source,python]
----
# prototipo
weechat.hook_set(hook, property, value)

# esempio
def my_process_cb(data, command, return_code, out, err):
    # ...
    return weechat.WEECHAT_RC_OK

hook = weechat.hook_process_hashtable("/path/to/command", {"stdin": "1"},
                                      20000, "my_process_cb", "")
weechat.hook_set(hook, "stdin", "data sent to stdin of child process")
weechat.hook_set(hook, "stdin_close", "")  # optional
----

==== weechat_unhook

Rimuove un hook.

Prototipo:

[source,C]
----
void weechat_unhook (struct t_hook *hook);
----

Argomenti:

* 'hook': qualcosa su cui è presente un hook con "weechat_hook_xxx()"

Esempio in C:

[source,C]
----
struct t_hook *my_hook = weechat_hook_command ( /* ... */ );
/* ... */
weechat_unhook (my_hook);
----

Script (Python):

[source,python]
----
# prototipo
weechat.unhook(hook)

# esempio
weechat.unhook(my_hook)
----

==== weechat_unhook_all

Rimuove l'hook in qualsiasi punto in cui è stato attivato dal
plugin corrente.

Prototipo:

[source,C]
----
void weechat_unhook_all ();
----

Esempio in C:

[source,C]
----
weechat_unhook_all ();
----

Script (Python):

[source,python]
----
# prototipo
weechat.unhook_all()

# esempio
weechat.unhook_all()
----

[[buffers]]
=== Buffer

Funzioni per creare/richiedere/chiudere buffer.

==== weechat_buffer_new

Apre un nuovo buffer.

Prototipo:

[source,C]
----
struct t_gui_buffer *weechat_buffer_new (const char *name,
                                         int (*input_callback)(void *data,
                                                               struct t_gui_buffer *buffer,
                                                               const char *input_data),
                                         void *input_callback_data,
                                         int (*close_callback)(void *data,
                                                               struct t_gui_buffer *buffer),
                                         void *close_callback_data);
----

Argomenti:

* 'name': nome del buffer (deve essere unico per il plugin)
* 'input_callback': funzione chiamata quando il testo in input è stato
  inserito nel buffer, argomenti e valore restituito:
** 'void *data': puntatore
** 'struct t_gui_buffer *buffer': puntatore al buffer
** 'const char *input_data': dati in input
** valore restituito:
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data': puntatore fornito alla callback quando chiamata da WeeChat
* 'close_callback': funzione chiamata alla chiusura del buffer, argomenti e
  valore restituito:
** 'void *data': puntatore
** 'struct t_gui_buffer *buffer': puntatore al buffer
** valore restituito:
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_data': puntatore fornito alla callback quando chiamata da WeeChat

Valore restituito:

* puntatore al nuovo buffer, NULL in caso di errore

Esempio in C:

[source,C]
----
int
my_input_cb (void *data, struct t_gui_buffer *buffer, const char *input_data)
{
    weechat_printf (buffer, "Testo: %s", input_data);
    return WEECHAT_RC_OK;
}

int
my_close_cb (void *data, struct t_gui_buffer *buffer)
{
    weechat_printf (NULL, "Il buffer '%s' verrà chiuso!",
                    weechat_buffer_get_string (buffer, "name"));
    return WEECHAT_RC_OK;
}

struct t_gui_buffer *my_buffer = weechat_buffer_new ("my_buffer",
                                                     &my_input_cb, NULL,
                                                     &my_close_cb, NULL);
----

Script (Python):

[source,python]
----
# prototipo
buffer = weechat.buffer_new(name, input_callback, input_callback_data,
    close_callback, close_callback_data)

# esempio
def my_input_cb(data, buffer, input_data):
    weechat.prnt(buffer, "Testo: %s" % input_data)
    return weechat.WEECHAT_RC_OK

def my_close_cb(data, buffer):
    weechat.prnt("", "Il buffer '%s' verrà chiuso!" % weechat.buffer_get_string(buffer, "name"))
    return weechat.WEECHAT_RC_OK

buffer = weechat.buffer_new("my_buffer", "my_input_cb", "", "my_close_cb", "")
----

==== weechat_current_buffer

Restituisce il puntatore al buffer corrente (buffer visualizzato nella
finestra corrente).

Prototipo:

[source,C]
----
struct t_gui_buffer *weechat_current_buffer ();
----

Valore restituito:

* puntatore al buffer corrente

Esempio in C:

[source,C]
----
weechat_printf (weechat_current_buffer (), "Testo sul buffer corrente");
----

Script (Python):

[source,python]
----
# prototipo
buffer = weechat.current_buffer()

# esempio
weechat.prnt(weechat.current_buffer(), "Testo sul buffer corrente")
----

==== weechat_buffer_search

// TRANSLATION MISSING
_Updated in 1.0._

Cerca un buffer tramite plugin e/o nome.

Prototipo:

[source,C]
----
struct t_gui_buffer *weechat_buffer_search (const char *plugin,
                                            const char *name);
----

Argomenti:

// TRANSLATION MISSING
* 'plugin': name of plugin, following special value is allowed:
** `==`: the name used is the buffer full name (for example:
   `irc.freenode.#weechat` instead of `freenode.#weechat`)
   _(WeeChat ≥ 1.0)_
// TRANSLATION MISSING
* 'name': name of buffer, if it is NULL or empty string, the current buffer is
  returned (buffer displayed by current window); if the name starts with
  `(?i)`, the search is case insensitive _(WeeChat ≥ 1.0)_

Valore restituito:

* puntatore al buffer trovato, NULL in caso contrario

Esempio in C:

[source,C]
----
struct t_gui_buffer *buffer1 = weechat_buffer_search ("irc", "freenode.#weechat");
struct t_gui_buffer *buffer2 = weechat_buffer_search ("==", "irc.freenode.#test");  /* WeeChat ≥ 1.0 */
----

Script (Python):

[source,python]
----
# prototipo
buffer = weechat.buffer_search(plugin, name)

# esempio
buffer = weechat.buffer_search("my_plugin", "my_buffer")
----

==== weechat_buffer_search_main

Cerca nel buffer principale di WeeChat (per primo nel buffer 'core', il primo
visualizzato all'avvio di WeeChat).

Prototipo:

[source,C]
----
struct t_gui_buffer *weechat_buffer_search_main ();
----

Valore restituito:

* puntatore al buffer principale di WeeChat (buffer 'core')

Esempio in C:

[source,C]
----
struct t_gui_buffer *weechat_buffer = weechat_buffer_search_main ();
----

Script (Python):

[source,python]
----
# prototipo
buffer = weechat.buffer_search_main()

# esempio
buffer = weechat.buffer_search_main()
----

==== weechat_buffer_clear

Pulisce il contenuto del buffer.

Prototipo:

[source,C]
----
void weechat_buffer_clear (struct t_gui_buffer *buffer);
----

Argomenti:

* 'buffer': puntatore al buffer

Esempio in C:

[source,C]
----
struct t_gui_buffer *my_buffer = weechat_buffer_search ("my_plugin",
                                                        "my_buffer");
if (my_buffer)
{
    weechat_buffer_clear (my_buffer);
}
----

Script (Python):

[source,python]
----
# prototipo
weechat.buffer_clear(buffer)

# esempio
buffer = weechat.buffer_search("my_plugin", "my_buffer")
if buffer != "":
    weechat.buffer_clear(buffer)
----

==== weechat_buffer_close

Chiude un buffer.

Prototipo:

[source,C]
----
void weechat_buffer_close (struct t_gui_buffer *buffer);
----

Argomenti:

* 'buffer': puntatore al buffer

Esempio in C:

[source,C]
----
struct t_gui_buffer *my_buffer = weechat_buffer_new ("my_buffer",
                                                     &my_input_cb, NULL,
                                                     &my_close_cb, NULL);
/* ... */
weechat_buffer_close (my_buffer);
----

Script (Python):

[source,python]
----
# prototipo
weechat.buffer_close(buffer)

# esempio
buffer = weechat.buffer_new("my_buffer", "my_input_cb", "", "my_close_cb", "")
# ...
weechat.buffer_close(buffer)
----

==== weechat_buffer_merge

Unisce un buffer in un altro: entrambi i buffer esistono separatamente, ma
con lo stesso numero, e WeeChat visualizzerà le righe di entrambi i
buffer (righe mischiate).

Prototipo:

[source,C]
----
void weechat_buffer_merge (struct t_gui_buffer *buffer,
                           struct t_gui_buffer *target_buffer);
----

Argomenti:

* 'buffer': puntatore al buffer
* 'target_buffer': buffer di destinazione, dove il buffer verrà unito

Esempio in C:

[source,C]
----
/* merge current buffer with weechat "core" buffer */
weechat_buffer_merge (weechat_current_buffer (),
                      weechat_buffer_search_main ());
----

Script (Python):

[source,python]
----
# prototipo
weechat.buffer_merge(buffer, target_buffer)

# esempio
# merge current buffer with WeeChat "core" buffer
weechat.buffer_merge(weechat.current_buffer(), weechat.buffer_search_main())
----

==== weechat_buffer_unmerge

Stacca un buffer da un gruppo di buffer uniti.

Prototipo:

[source,C]
----
void weechat_buffer_unmerge (struct t_gui_buffer *buffer,
                             int number);
----

Argomenti:

* 'buffer': puntatore al buffer
* 'number': numero di destinazione per il buffer staccato,
  se è < 1, allora il buffer verrà spostato al numero di
  'buffer' +1

Esempio in C:

[source,C]
----
weechat_buffer_unmerge (weechat_current_buffer (), 1);
----

Script (Python):

[source,python]
----
# prototipo
weechat.buffer_unmerge(buffer, number)

# esempio
weechat.buffer_unmerge(weechat.current_buffer(), 1)
----

==== weechat_buffer_get_integer

Restituisce il valore intero della proprietà di
un buffer.

Prototipo:

[source,C]
----
int weechat_buffer_get_integer (struct t_gui_buffer *buffer,
                                const char *property);
----

Argomenti:

* 'buffer': puntatore al buffer
* 'property': nome della proprietà:
** 'number': numero del buffer (inizia da 1)
** 'layout_number': numero del buffer salvato nel layout
** 'layout_number_merge_order': ordine di unione per i layout
** 'short_name_is_set': 1 se il nome breve è impostato, 0 in caso contrario
** 'type': tipo dibuffer (0: formattato, 1: contenuto libero)
** 'notify': livello di notifica per il buffer
** 'num_displayed': numero delle finestre che visualizzano il buffer
// TRANSLATION MISSING
** 'active': 2 if buffer is the only active (merged), 1 se il buffer è attivo,
   0 se il buffer è unito e non selezionato
// TRANSLATION MISSING
** 'hidden': 1 if buffer is hidden, otherwise 0
   _(WeeChat ≥ 1.0)_
// TRANSLATION MISSING
** 'zoomed': 1 if buffer is merged and zoomed, otherwise 0
   _(WeeChat ≥ 1.0)_
** 'print_hooks_enabled': 1 se gli hook sulla stampa sono abilitati,
   altrimenti 0
// TRANSLATION MISSING
** 'day_change': 1 if messages for the day change are displayed, otherwise 0
   _(WeeChat ≥ 0.4.3)_
// TRANSLATION MISSING
** 'clear': 1 if buffer can be cleared with command `/buffer clear`, otherwise 0
   _(WeeChat ≥ 1.0)_
// TRANSLATION MISSING
** 'filter': 1 if filters are enabled on buffer, otherwise 0
   _(WeeChat ≥ 1.0)_
** 'lines_hidden': 1 se almeno una riga è nascosta sul buffer (filtrata),
   oppure 0 se vengono visualizzate tutte le righe
** 'prefix_max_length': lunghezza massima del prefisso in questo buffer
** 'time_for_each_line': 1 se l'ora è visualizzata per ogni riga nel buffer
   (predefinito), altrimenti 0
** 'nicklist': 1 se la lista nick è abilitata, altrimenti 0
** 'nicklist_case_sensitive': 1 se i nick sono sensibili alle maiuscole,
   altrimenti 0
** 'nicklist_max_length': lunghezza massima per un nick
** 'nicklist_display_groups': 1 se i gruppi vengono visualizzati, altrimenti 0
// TRANSLATION MISSING
** 'nicklist_count': number of nicks and groups in nicklist
// TRANSLATION MISSING
** 'nicklist_groups_count': number of groups in nicklist
// TRANSLATION MISSING
** 'nicklist_nicks_count': number of nicks in nicklist
** 'nicklist_visible_count': numero di nick/gruppi visualizzati
** 'input': 1 se l'input è abilitato, altrimenti 0
** 'input_get_unknown_commands': 1 se i comandi sconosciuti vengono inviati
   alla callback di input, altrimenti 0
** 'input_size': dimensione per l'input (in byte)
** 'input_length': lunghezza dell'input (numero di caratteri)
** 'input_pos': posizione del cursore nell'input del buffer
** 'input_1st_display': primo carattere visualizzato su schermo
** 'num_history': numero di comandi nella cronologia
** 'text_search': tipo di ricerca nel testo:
*** 0: nessuna ricerca in questo momento
*** 1: ricerca all'indietro (direzione: messaggi più vecchi)
*** 2: ricerca in avanti (direzione: messaggi più nuovi)
** 'text_search_exact': 1 se la ricerca testo è esatta
** 'text_search_found': 1 se il testo viene trovato, altrimenti 0

Valore restituito:

* valore intero della proprietà

Esempio in C:

[source,C]
----
weechat_printf (NULL, "my buffer number is: %d",
                weechat_buffer_get_integer (my_buffer, "number"));
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.buffer_get_integer(buffer, property)

# esempio
weechat.prnt("", "my buffer number is: %d" % weechat.buffer_get_integer(my_buffer, "number"))
----

==== weechat_buffer_get_string

Restituisce il valore stringa di una proprietà del buffer.

Prototipo:

[source,C]
----
const char *weechat_buffer_get_string (struct t_gui_buffer *buffer,
                                       const char *property);
----

Argomenti:

* 'buffer': puntatore al buffer
* 'property': nome proprietà:
** 'plugin': nome del plugin che ha creato questo buffer ("core"
   per il buffer principale di WeeChat)
** 'name': nome del buffer
** 'full_name': nome completo del buffer ("plugin.nome") _(WeeChat ≥ 0.3.7)_
** 'short_name': nome breve del buffer (nota: usato solo per il display e può
   essere cambiato dall'utente, questo nome non va usato per trovare il nome del
   buffer, utilizzare invece 'name', 'fullname' o la variabile locale 'channel')
** 'title': titolo del buffer
** 'input': testo in ingresso
** 'text_search_input': input salvato prima della ricerca nel testo
** 'highlight_words': elenco di parole da evidenziare
// TRANSLATION MISSING
** 'highlight_regex': POSIX extended regular expression for highlight
// TRANSLATION MISSING
** 'highlight_tags_restrict': restrict highlights to messages with these tags
// TRANSLATION MISSING
** 'highlight_tags': force highlight on messages with these tags
** 'hotlist_max_level_nicks': livello massimo della hotlist per alcuni nick
** 'localvar_xxx': ottiene il contenuto della variabile locale "xxx"
   (sostituire "xxx" con il nome della variabile da leggere)

Valore restituito:

* valore stringa della proprietà

Esempio in C:

[source,C]
----
weechat_printf (NULL, "name / short name of buffer are: %s / %s",
                weechat_buffer_get_string (my_buffer, "name"),
                weechat_buffer_get_string (my_buffer, "short_name"));
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.buffer_get_string(buffer, property)

# esempio
weechat.prnt("", "name / short name of buffer are: %s / %s"
    % (weechat.buffer_get_string(my_buffer, "name"),
    weechat.buffer_get_string(my_buffer, "short_name")))
----

==== weechat_buffer_get_pointer

Restituisce il valore puntatore della proprietà di un buffer.

Prototipo:

[source,C]
----
void *weechat_buffer_pointer (struct t_gui_buffer *buffer,
                              const char *property);
----

Argomenti:

* 'buffer': puntatore al buffer
* 'property': nome proprietà:
** 'plugin': puntatore al plugin che ha creato questo buffer (NULL
   per il buffer principale di WeeChat)
** 'highlight_regex_compiled': espressione regolare 'highlight_regex' compilata

Valore restituito:

* valore puntatore della proprietà

Esempio in C:

[source,C]
----
weechat_printf (NULL, "plugin pointer of my buffer: %lx",
                weechat_buffer_get_pointer (my_buffer, "plugin"));
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.buffer_get_pointer(buffer, property)

# esempio
weechat.prnt("", "plugin pointer of my buffer: %s" % weechat.buffer_get_pointer(my_buffer, "plugin"))
----

==== weechat_buffer_set

Imposta il valore stringa della proprietà di un buffer.

Prototipo:

[source,C]
----
void weechat_buffer_set (struct t_gui_buffer *buffer, const char *property,
                         const char *value);
----

Argomenti:

* 'buffer': puntatore al buffer
// TRANSLATION MISSING
* 'property': nome della proprietà (see table below)
// TRANSLATION MISSING
* 'value': new value for property

// TRANSLATION MISSING
Properties:

[width="100%",cols="^2,4,8",options="header"]
|===
| Nome | Valore | Descrizione

// TRANSLATION MISSING
| hotlist | "+", "-", WEECHAT_HOTLIST_LOW, WEECHAT_HOTLIST_MESSAGE,
  WEECHAT_HOTLIST_PRIVATE, WEECHAT_HOTLIST_HIGHLIGHT, "-1" |
  "+": abilita hotlist (impostazione globale , il puntatore al buffer pointer non
  è utilizzato) +
  "-": disabilita hotlist (impostazione globale, il puntatore al buffer non è
  utilizzato) +
  priorità: aggiunge il buffer alla hotlist con questa proprietà +
  "-1": remove buffer from hotlist _(WeeChat ≥ 1.0)_

// TRANSLATION MISSING
| completion_freeze | "0" oppure "1" |
  "0": no freeze of completion (default value)
  (impostazione globale, il puntatore al buffer non è utilizzato) +
  "1": do not stop completion when command line is updated
  (impostazione globale, il puntatore al buffer non è utilizzato)

| unread | - |
  Imposta l'evidenziatore di lettura dopo l'ultima riga del buffer

| display | "1" oppure "auto" |
  "1": passa a questo buffer nella finestra corrente +
  "auto": passa a questo buffer nella finestra corrente, l'evidenziatore di
  lettura non viene resettato

// TRANSLATION MISSING
| hidden +
  _(WeeChat ≥ 1.0)_ | "0" oppure "1" |
  "0": unhide the buffer +
  "1": hide the buffer

| number | numero |
  Sposta buffer a questo numero

| name | qualsiasi stringa |
  Imposta nuovo nome per il buffer

| short_name | qualsiasi stringa |
  Imposta nuovo nome breve per il buffer

// TRANSLATION MISSING
| type | "formatted" oppure "free" |
  Imposta tipo per il: "formatted" (per stampare i messaggi di chat),
  oppure "free" (per contenuto libero); when the value is "free", the property
  'clear' is forced to "0" _(WeeChat ≥ 1.0)_

| notify | "0", "1", "2", "3" |
  Imposta il livello di notifica per il buffer: "0" = non aggiungere alla hotlist,
  "1" = aggiungere solo per gli eventi, "2" = aggiungere per eventi e
  messaggi, "3" = aggiungere per tutti i messaggi

// TRANSLATION MISSING
| print_hooks_enabled | "0" oppure "1" |
  "0" to disable print hooks, "1" to enable them (default for a new buffer)

// TRANSLATION MISSING
| day_change +
  _(WeeChat ≥ 0.4.3)_ | "0" oppure "1" |
  "0" to hide messages for the day change, "1" to see them
  (default for a new buffer)

// TRANSLATION MISSING
| clear +
  _(WeeChat ≥ 1.0)_ | "0" or "1" |
  "0" to prevent user from clearing buffer with the command `/buffer clear`,
  "1" to let user clear the buffer (default for a new buffer)
   (note: even when it is set to "0", the buffer can still be cleared with
   the function <<_weechat_buffer_clear,weechat_buffer_clear>>)

// TRANSLATION MISSING
| filter +
  _(WeeChat ≥ 1.0)_ | "0" or "1" |
  "0": disable filters on buffer +
  "1": enable filters on buffer

| title | qualsiasi stringa |
  Imposta nuovo titolo per il buffer

| time_for_each_line | "0" oppure "1" |
  "0" per nascondere l'orario in tutte le righe del buffer, "1" per
  visualizzarlo su tutte le righe (predefinito per un nuovo buffer)

| nicklist | "0" oppure "1" |
  "0" per rimuovere la lista nick per il buffer, "1" per aggiungere
  la lista nick per il buffer

| nicklist_case_sensitive | "0" oppure "1" |
  "0" per avere una lista nick non sensibile alle maiuscole, "1" per
  una lista nick sensibile alle maiuscole

| nicklist_display_groups | "0" oppure "1" |
  "0" per nascondere i gruppi nella lista nick, "1" per visualizzare
  i gruppi della lista nick

| highlight_words | "-" oppure elenco di parole separato da virgole |
  "-" è un valore speciale per disabilitare qualsiasi evento su questo
  buffer, o un elenco di parole separate da virgole da evidenziare in
  questo buffer, ad esempio: "abc,def,ghi"

| highlight_words_add | elenco di parole separate da virgole |
  Elenco di parole separate da virgole da evidenziare in questo buffer,
  queste parole vengono aggiunte alle parole evidenziate esistenti nel
  buffer

| highlight_words_del | elenco di parole separate da virgole |
  Elenco di parole separate da virgole da rimuovere dalle
  parole evidenziate nel buffer

// TRANSLATION MISSING
| highlight_regex | qualsiasi stringa |
  POSIX extended regular expression for highlight

// TRANSLATION MISSING
| highlight_tags_restrict | elenco separato da virgole di tag |
  Restrict highlights to messages with these tags in this buffer
  (it is possible to combine many tags as a logical "and" with separator "+",
  for example: "nick_toto+irc_action")

// TRANSLATION MISSING
| highlight_tags | elenco separato da virgole di tag |
  Force highlight on messages with these tags in this buffer
  (it is possible to combine many tags as a logical "and" with separator "+",
  for example: "nick_toto+irc_action")

| hotlist_max_level_nicks | elenco separado da virgole di "nick:livello" |
  Elenco separato da virgole di nick con il livello massimo per la hotlist
  su questo buffer (il livello può essere: -1: mai nella hotlist, 0: basso,
  1: messaggio, 2: privato, 3: evento), ad esempio: "joe:2,mike:-1,robert:-1"
  (joe non produce eventi sul buffer, mike e robert non modificano la hotlist)

| hotlist_max_level_nicks_add | elenco separato da virgole di "nick:livello" |
  Elenco separato da virgole di nick con il livello per la hotlist, questi
  nick vengono aggiunti a quelli esistenti nel buffer

| hotlist_max_level_nicks_del | elenco separato da virgole di nick |
  Elenco separato da virgole di nick da rimuovere dai livelli massimi della
  hotlist

| key_bind_xxx | qualsiasi stringa |
  Assegna un nuovo tasto 'xxx', specifico per questo buffer, il valore è il
  comando da eseguire per questo tasto

| key_unbind_xxx | - |
  Rimuove l'assegnazione del tasto 'xxx' per questo buffer

| input | qualsiasi stringa |
  Imposta un nuovo valore per l'input del buffer

| input_pos | posizione |
  Imposta la posizione del cursore per l'input del buffer

| input_get_unknown_commands | "0" oppure "1" |
  "0" per disabilitare i comandi sconosciuti per questo buffer (comportamento
  predefinito), "1" per ricevere i comandi sconosciuti, ad esempio se l'utente
  digita "/unknowncmd", verrà ricevuto dal buffer (nessun errore riguardo il
  comando sconosciuto)

| localvar_set_xxx | qualsiasi stringa |
  Imposta il nuovo valore per la variabile locale 'xxx' (la variabile verrà
  creata se non esiste)

| localvar_del_xxx | - |
  Rimuove la variabile locale 'xxx'
|===

Esempio in C:

[source,C]
----
/* disabilita hotlist (per tutti i buffer) */
weechat_buffer_set (NULL, "hotlist", "-");

/* abilita nuovamente hotlist */
weechat_buffer_set (NULL, "hotlist", "+");

/* cambia il nome buffer */
weechat_buffer_set (my_buffer, "name", "my_new_name");

/* aggiunge una nuova variabile locale "tizio" con il valore "abc" */
weechat_buffer_set (my_buffer, "localvar_set_tizio", "abc");

/* rimuove la variabile locale "tizio" */
weechat_buffer_set (my_buffer, "localvar_del_tizio", NULL);
----

Script (Python):

[source,python]
----
# prototipo
weechat.buffer_set(buffer, property, value)

# esempi

# disabilita hotlist (per tutti i buffer)
weechat.buffer_set("", "hotlist", "-")

# abilita nuovamente hotlist
weechat.buffer_set("", "hotlist", "+")

# cambia il nome buffer
weechat.buffer_set(my_buffer, "name", "my_new_name")

# aggiunge una nuova variabile locale "tizio" con il valore "abc"
weechat.buffer_set(my_buffer, "localvar_set_tizio", "abc")

# rimuove la variabile locale "tizio"
weechat.buffer_set(my_buffer, "localvar_del_tizio", "")
----

==== weechat_buffer_set_pointer

Imposta il valore puntatore per la proprietà di un buffer.

Prototipo:

[source,C]
----
void weechat_buffer_set_pointer (struct t_gui_buffer *buffer, const char *property,
                                 void *pointer);
----

Argomenti:

* 'buffer': puntatore al buffer
* 'property': nome della proprietà:
** 'close_callback': set close callback function
** 'close_callback_data': set close callback data
** 'input_callback': set input callback function
** 'input_callback_data': set input callback data
// TRANSLATION MISSING
** 'nickcmp_callback': set nick comparison callback function (this callback is
   called when searching nick in nicklist) _(WeeChat ≥ 0.3.9)_
// TRANSLATION MISSING
** 'nickcmp_callback_data': set nick comparison callback data
   _(WeeChat ≥ 0.3.9)_
// TRANSLATION MISSING
* 'pointer': new pointer value for property

// TRANSLATION MISSING
Prototypes for callbacks:

[source,C]
----
int close_callback (void *data, struct t_gui_buffer *buffer);

int input_callback (void *data, struct t_gui_buffer *buffer, const char *input_data);

int nickcmp_callback (void *data, struct t_gui_buffer *buffer, const char *nick1, const char *nick2);
----

Esempio in C:

[source,C]
----
int
my_close_cb (void *data, struct t_gui_buffer *buffer)
{
    /* ... */
    return WEECHAT_RC_OK;
}

weechat_buffer_set_pointer (my_buffer, "close_callback", &my_close_cb);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_buffer_string_replace_local_var

Sostituisce le variabili globali in una stringa con i loro valori, utilizzando
le variabili del buffer locale.

Prototipo:

[source,C]
----
char *weechat_buffer_string_replace_local_var (struct t_gui_buffer *buffer,
                                               const char *string);
----

Argomenti:

* 'buffer': puntatore al buffer
* 'string': stringa con testo e variabili locali che utilizzano il formato "$var"

Valore restituito:

* stringa con i valori delle variabili locali

Esempio in C:

[source,C]
----
weechat_buffer_set (my_buffer, "localvar_set_toto", "abc");

char *str = weechat_buffer_string_replace_local_var (my_buffer,
                                                     "test with $toto");
/* str contiene "test with abc" */
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.buffer_string_replace_local_var(buffer, string)

# esempio
weechat.buffer_set(my_buffer, "localvar_set_toto", "abc")
str = weechat.buffer_string_replace_local_var(my_buffer, "test with $toto")
# str contains "test with abc"
----

==== weechat_buffer_match_list

_WeeChat ≥ 0.3.5._

Verifica se il buffer corrisponde ad una lista di buffer.

Prototipo:

[source,C]
----
int weechat_buffer_match_list (struct t_gui_buffer *buffer, const char *string);
----

Argomenti:

* 'buffer': puntatore al buffer
* 'string': elenco separato da virgole di buffer:
** "*" indica tutti i buffer
** il nome preceduto da "!" viene escluso
// TRANSLATION MISSING
** wildcard "*" is allowed in name

Valore restituito:

* 1 se il buffer coincide con la lista, altrimenti 0

Esempio in C:

[source,C]
----
struct t_gui_buffer *buffer = weechat_buffer_search ("irc", "freenode.#weechat");
if (buffer)
{
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "*"));                    /* 1 */
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "*,!*#weechat*"));        /* 0 */
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "irc.freenode.*"));       /* 1 */
    weechat_printf (NULL, "%d", weechat_buffer_match_list (buffer, "irc.oftc.*,python.*"));  /* 0 */
}
----

Script (Python):

[source,python]
----
# prototipo
match = weechat.buffer_match_list(buffer, string)

# esempio
buffer = weechat.buffer_search("irc", "freenode.#weechat")
if buffer:
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "*"))                    # 1
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "*,!*#weechat*"))        # 0
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "irc.freenode.*"))       # 1
    weechat.prnt("", "%d" % weechat.buffer_match_list(buffer, "irc.oftc.*,python.*"))  # 0
----

[[windows]]
=== Finestre

Funzioni per richiedere finestre.

==== weechat_current_window

Restituisce il puntatore alla finestra corrente

Prototipo:

[source,C]
----
struct t_gui_window *weechat_current_window ();
----

Valore restituito:

* puntatore alla finestra corrente

Esempio in C:

[source,C]
----
struct t_gui_window *current_window = weechat_current_window ();
----

Script (Python):

[source,python]
----
# prototipo
window = weechat.current_window()

# esempio
current_window = weechat.current_window()
----

==== weechat_window_search_with_buffer

_WeeChat ≥ 0.3.5._

Restituisce il puntatore alla finestra che mostra il buffer.

Prototipo:

[source,C]
----
struct t_gui_window *weechat_window_search_with_buffer (struct t_gui_buffer *buffer);
----

Argomenti:

* 'buffer': puntatore al buffer

Valore restituito:

* puntatore alla finestra che mostra il buffer (NULL se nessuna finestra sta
  mostrando il buffer)

Esempio in C:

[source,C]
----
weechat_printf (NULL,
                "window displaying core buffer: %lx",
                weechat_window_search_with_buffer (weechat_buffer_search_main ()));
----

Script (Python):

[source,python]
----
# prototipo
window = weechat.window_search_with_buffer(buffer)

# esempio
weechat.prnt("", "window displaying core buffer: %s"
    % weechat.window_search_with_buffer(weechat.buffer_search_main()))
----

==== weechat_window_get_integer

Restituisce il valore intero della proprietà di una finestra.

Prototipo:

[source,C]
----
int weechat_window_get_integer (struct t_gui_window *window,
                                const char *property);
----

Argomenti:

* 'window': puntatore alla finestra
* 'property': nome della proprietà:
** 'number': numero della finestra (inizia da 1)
** 'win_x': posizione X della finestra nel terminale (la prima colonna è 0)
** 'win_y': posizione Y della finestra nel terminale (la prima riga è 0)
** 'win_width': larghezza della finestra, in caratteri
** 'win_height': altezza della finestra, in caratteri
** 'win_width_pct': misura percentuale, paragonata alla finestra genitore
   (ad esempio 50 indica metà grandezza)
** 'win_height_pct': misura percentuale, paragonata alla finestra genitore
   (ad esempio 50 indica metà grandezza)
** 'win_chat_x': posizione X della finestra di chat nel terminale
   (la prima colonna è 0)
** 'win_chat_y': posizione Y della finestra di chat nel terminale
   (la prima riga è 0)
** 'win_chat_width': larghezza della finestra di chat, in caratteri
** 'win_chat_height': altezza della finestra di chat, in caratteri
** 'first_line_displayed': 1 se la prima riga del buffer viene visualizzata
   su schermo, altrimenti 0
** 'scrolling': 1 se lo scorrimento è attivo sulla finestra (ultima riga non
   visualizzata)
** 'lines_after': numero di righe non visualizzate dopo l'ultima visualizzata
   (durante lo scorrimento)

Valore restituito:

* valore intero della proprietà

Esempio in C:

[source,C]
----
weechat_printf (NULL, "current window is at position (x,y): (%d,%d)",
                weechat_window_get_integer (weechat_current_window (), "win_x"),
                weechat_window_get_integer (weechat_current_window (), "win_y"));
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.window_get_integer(window, property)

# esempio
weechat.prnt("", "current window is at position (x,y): (%d,%d)"
    % (weechat.window_get_integer(weechat.current_window(), "win_x"),
    weechat.window_get_integer(weechat.current_window(), "win_y")))
----

==== weechat_window_get_string

Restituisce il valore stringa della proprietà di una finestra.

[NOTE]
La funzione non è utilizzata oggi, è riservata per una versione futura.

Prototipo:

[source,C]
----
int weechat_window_get_string (struct t_gui_window *window,
                               const char *property);
----

Argomenti:

* 'window': puntatore alla finestra
* 'property': nome della proprietà

Valore restituito:

* valore stringa della proprietà

==== weechat_window_get_pointer

Restituisce il valore puntatore della proprietà di una finestra.

Prototipo:

[source,C]
----
void *weechat_window_get_pointer (struct t_gui_window *window,
                                  const char *property);
----

Argomenti:

* 'window': puntatore alla finestra
* 'property': nome della proprietà:
** 'current': puntatore alla finestra corrente
** 'buffer': puntatore al buffer visualizzato dalla finestra

Valore restituito:

* valore puntatore della proprietà

Esempio in C:

[source,C]
----
weechat_printf (NULL,
                "buffer displayed in current window: %lx",
                weechat_window_get_pointer (weechat_current_window (), "buffer"));
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.window_get_pointer(window, property)

# esempio
weechat.prnt("", "buffer displayed in current window: %s"
    % weechat.window_get_pointer(weechat.current_window(), "buffer"))
----

==== weechat_window_set_title

Imposta il titolo per il terminale.

Prototipo:

[source,C]
----
void weechat_window_set_title (const char *title);
----

Argomenti:

* 'title': nuovo titolo per il terminale (NULL per resettarlo)

Esempio in C:

[source,C]
----
weechat_window_set_title ("nuovo titolo qui");
----

Script (Python):

[source,python]
----
# prototipo
weechat.window_set_title(window, title)

# esempio
weechat.window_set_title("nuovo titolo qui")
----

[[nicklist]]
=== Lista nick

Funzioni per il buffer nicklist.

==== weechat_nicklist_add_group

Aggiunge un gruppo in una lista nick.

Prototipo:

[source,C]
----
struct t_gui_nick_group *weechat_nicklist_add_group (struct t_gui_buffer *buffer,
                                                     struct t_gui_nick_group *parent_group,
                                                     const char *name,
                                                     const char *color,
                                                     int visible);
----

Argomenti:

* 'buffer': puntatore al buffer
* 'parent_group': puntatore al genitore del gruppo, NULL se il gruppo non ha genitore
  (lista nick radice)
* 'name': nome del gruppo
* 'color': nome per l'opzione colore:
** nome opzione per WeeChat, ad esempio 'weechat.color.nicklist_group'
** colore con sfondo opzionale, ad esempio 'yellow' o 'yellow,red'
** nome colore per la barra:
*** 'bar_fg': colore di primo piando per la barra
*** 'bar_delim': colore dei delimitatori per la barra
*** 'bar_bg': colore di sfondo per la barra
* 'visible':
** '1': gruppi e sottogruppi/nick sono visibili
** '0': gruppi e sottogruppi/nick sono nascosti

[NOTE]
Il nome del gruppo può iniziare con uno o più numeri, seguiti da una pipe, e
infine dal nome del gruppo. Quando questa stringa si trova all'inizio, viene
utilizzata per ordinare i gruppi nella lista nick. Ad esempio i gruppi "1|test" e
"2|abc" verranno visualizzati in quest'ordine: prima "test" poi "abc".

Valore restituito:

* puntatore al nuovo gruppo, NULL in caso di errore

Esempio in C:

[source,C]
----
struct t_gui_nick_group *my_group =
    weechat_nicklist_add_group (my_buffer,
                                my_parent_group,
                                "test_group",
                                "weechat.color.nicklist_group",
                                1);
----

Script (Python):

[source,python]
----
# prototipo
group = weechat.nicklist_add_group(buffer, parent_group, name, color, visible)

# esempio
group = weechat.nicklist_add_group(my_buffer, my_parent_group, "test_group",
    "weechat.color.nicklist_group", 1)
----

==== weechat_nicklist_search_group

Cerca un gruppo in una lista nick.

Prototipo:

[source,C]
----
struct t_gui_nick_group *weechat_nicklist_search_group (struct t_gui_buffer *buffer,
                                                        struct t_gui_nick_group *from_group,
                                                        const char *name);
----

Argomenti:

* 'buffer': puntatore al buffer
* 'from_group': ricerca solo da questo gruppo, se NULL, allora la cerca in
  tutta la lista nick
* 'name': nome gruppo da cercare

Valore restituito:

* puntatore al gruppo trovato, NULL se non trovato

Esempio in C:

[source,C]
----
struct t_gui_nick_group *ptr_group = weechat_nicklist_search_group (my_buffer,
                                                                    NULL, "test_group");
----

Script (Python):

[source,python]
----
# prototipo
group = weechat.nicklist_search_group(buffer, from_group, name)

# esempio
group = weechat.nicklist_search_group(my_buffer, "", "test_group")
----

==== weechat_nicklist_add_nick

Aggiunge un nick in un gruppo.

Prototipo:

[source,C]
----
struct t_gui_nick_group *weechat_nicklist_add_nick (struct t_gui_buffer *buffer,
                                                    struct t_gui_nick_group *group,
                                                    const char *name,
                                                    const char *color,
                                                    const char *prefix,
                                                    const char *prefix_color,
                                                    int visible);
----

Argomenti:

* 'buffer': puntatore al buffer
* 'group': puntatore al gruppo
* 'name': nome nick
* 'color': nome dell'opzione per il colore:
*** nome opzione per WeeChat (da weechat.color.xxx), ad esempio 'chat_delimiters'
*** colore con sfondo opzionale, ad esempio 'yellow' o 'yellow,red'
*** nome colore per la barra:
**** 'bar_fg': colore di primo piano per la barra
**** 'bar_delim': colore dei delimitatori per la barra
**** 'bar_bg': colore di sfondo per la barra
* 'prefix': prefisso visualizzato prima del nick
* 'prefix_color': nome dell'opzione per il colore:
** nome opzione per WeeChat (da weechat.color.xxx), ad esempio 'chat_delimiters'
** colore con sfondo opzionale, ad esempio 'yellow' o 'yellow,red'
** nome colore per la barra:
*** 'bar_fg': colore di primo piano per la barra
*** 'bar_delim': colore dei delimitatori per la barra
*** 'bar_bg': colore di sfondo per la barra
* 'visible':
** '1': il nick è visibile
** '0': il nick è nascosto

Valore restituito:

* puntatore al nuovo nick, NULL in caso di errore

Esempio in C:

[source,C]
----
struct t_gui_nick *my_nick =
    weechat_nicklist_add_nick (my_buffer, my_group,
                               "test_nick",
                               (nick_away) ? "weechat.color.nicklist_away" : "bar_fg",
                               "@", "lightgreen",
                               1);
----

Script (Python):

[source,python]
----
# prototipo
nick = weechat.nicklist_add_nick(buffer, group, name, color, prefix, prefix_color, visible)

# esempio
if nick_away:
    color = "weechat.color.nicklist_away"
else:
    color = "bar_fg"
nick = weechat.nicklist_add_nick(my_buffer, my_group, "test_nick", color, "@", "lightgreen", 1)
----

==== weechat_nicklist_search_nick

Cerca un nick nella lista nick.

Prototipo:

[source,C]
----
struct t_gui_nick *weechat_nicklist_search_nick (struct t_gui_buffer *buffer,
                                                 struct t_gui_nick_group *from_group,
                                                 const char *name);
----

Argomenti:

* 'buffer': puntatore al buffer
* 'from_group': cerca solo da questo gruppo, se NULL, allora cerca
  nell'intera lista nick
* 'name': nick da cercare

Valore restituito:

* puntatore al nuovo nick, NULL se non trovato

Esempio in C:

[source,C]
----
struct t_gui_nick *ptr_nick = weechat_nicklist_search_nick (my_buffer,
                                                            NULL, "test_nick");
----

Script (Python):

[source,python]
----
# prototipo
nick = weechat.nicklist_search_nick(buffer, from_group, name)

# esempio
nick = weechat.nicklist_search_nick(my_buffer, "", "test_nick")
----

==== weechat_nicklist_remove_group

Rimuove un gruppo da una lista nick.

Prototipo:

[source,C]
----
void weechat_nicklist_remove_group (struct t_gui_buffer *buffer,
                                    struct t_gui_nick_group *group);
----

Argomenti:

* 'buffer': puntatore al buffer
* 'group': puntatore al gruppo da rimuovere (verranno rimossi anhe
  i sottogruppi/nick)

Esempio in C:

[source,C]
----
weechat_nicklist_remove_group (my_buffer, my_group);
----

Script (Python):

[source,python]
----
# prototipo
weechat.nicklist_remove_group(buffer, group)

# esempio
weechat.nicklist_remove_group(my_buffer, my_group)
----

==== weechat_nicklist_remove_nick

Rimuove un nick dalla lista nick.

Prototipo:

[source,C]
----
void weechat_nicklist_remove_nick (struct t_gui_buffer *buffer,
                                   struct t_gui_nick *nick);
----

Argomenti:

* 'buffer': puntatore al buffer
* 'nick': puntatore al nick da rimuovere

Esempio in C:

[source,C]
----
weechat_nicklist_remove_nick (my_buffer, my_nick);
----

Script (Python):

[source,python]
----
# prototipo
weechat.nicklist_remove_nick(buffer, nick)

# esempio
weechat.nicklist_remove_nick(my_buffer, my_nick)
----

==== weechat_nicklist_remove_all

Rimuove tutti i gruppi/nick da una lista nick.

Prototipo:

[source,C]
----
void weechat_nicklist_remove_all (struct t_gui_buffer *buffer);
----

Argomenti:

* 'buffer': puntatore al buffer

Esempio in C:

[source,C]
----
weechat_nicklist_remove_all (my_buffer);
----

Script (Python):

[source,python]
----
# prototipo
weechat.nicklist_remove_all(buffer)

# esempio
weechat.nicklist_remove_all(my_buffer)
----

==== weechat_nicklist_get_next_item

_WeeChat ≥ 0.3.7._

Ottiene il prossimo gruppo oppure il nick dalla lista nick (usato principalmente
per mostrare la lista nick).

Prototipo:

[source,C]
----
void weechat_nicklist_get_next_item (struct t_gui_buffer *buffer,
                                     struct t_gui_nick_group **group,
                                     struct t_gui_nick **nick);
----

Argomenti:

* 'buffer': puntatore al buffer
* 'group': puntatore sul puntatore al gruppo
* 'nick': puntatore sul puntatore al nick

Esempio in C:

[source,C]
----
struct t_gui_nick_group *ptr_group;
struct t_gui_nick *ptr_nick;

ptr_group = NULL;
ptr_nick = NULL;
weechat_nicklist_get_next_item (buffer, &ptr_group, &ptr_nick);
while (ptr_group || ptr_nick)
{
    if (ptr_nick)
    {
        /* nick */
        /* ... */
    }
    else
    {
        /* gruppo */
        /* ... */
    }
    weechat_nicklist_get_next_item (buffer, &ptr_group, &ptr_nick);
}
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_nicklist_group_get_integer

_WeeChat ≥ 0.3.4._

Restituisce un valore intero della proprietà di un gruppo.

Prototipo:

[source,C]
----
int weechat_nicklist_group_get_integer (struct t_gui_buffer *buffer,
                                        struct t_gui_nick_group *group,
                                        const char *property);
----

Argomenti:

* 'buffer': puntatore al buffer
* 'group': puntatore al gruppo
* 'property': nome della proprietà:
** 'visible': 1 se il gruppo è visibile, altrimenti 0
** 'level': livello del gruppo (root è 0)

Valore restituito:

* valore intero della proprietà

Esempio in C:

[source,C]
----
int visible = weechat_nicklist_group_get_integer (buffer, group, "visible");
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.nicklist_group_get_integer(buffer, group, property)

# esempio
visible = weechat.nicklist_group_get_integer(buffer, group, "visible")
----

==== weechat_nicklist_group_get_string

_WeeChat ≥ 0.3.4._

Restituisce il valore stringa della proprietà di un gruppo.

Prototipo:

[source,C]
----
const char *weechat_nicklist_group_get_string (struct t_gui_buffer *buffer,
                                               struct t_gui_nick_group *group,
                                               const char *property);
----

Argomenti:

* 'buffer': puntatore al buffer
* 'group': puntatore al gruppo
* 'property': nome della proprietà:
** 'name': nome del gruppo
** 'color': colore del gruppo nella lista nick

Valore restituito:

* valore stringa della proprietà

Esempio in C:

[source,C]
----
const char *color = weechat_nicklist_group_get_string (buffer, group, "color");
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.nicklist_group_get_string(buffer, group, property)

# esempio
color = weechat.nicklist_group_get_string(buffer, group, "color")
----

==== weechat_nicklist_group_get_pointer

_WeeChat ≥ 0.3.4._

Restituisce il valore puntatore della proprietà di un gruppo.

Prototipo:

[source,C]
----
void *weechat_nicklist_group_get_pointer (struct t_gui_buffer *buffer,
                                          struct t_gui_nick_group *group,
                                          const char *property);
----

Argomenti:

* 'buffer': puntatore al buffer
* 'group': puntatore al gruppo
* 'property': nome della proprietà:
** 'parent': puntatore al gruppo genitore

Valore restituito:

* valore puntatore della proprietà

Esempio in C:

[source,C]
----
struct t_gui_nick_group *parent = weechat_nicklist_group_get_pointer (buffer, group, "parent");
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.nicklist_group_get_pointer(buffer, group, property)

# esempio
parent = weechat.nicklist_group_get_pointer(buffer, group, "parent")
----

==== weechat_nicklist_group_set

_WeeChat ≥ 0.3.4._

Imposta il valore stringa della proprietà di un gruppo.

Prototipo:

[source,C]
----
void weechat_nicklist_group_set (struct t_gui_buffer *buffer,
                                 struct t_gui_nick_group *group,
                                 const char *property,
                                 const char *value);
----

Argomenti:

* 'buffer': puntatore al buffer
* 'group': puntatore al gruppo
// TRANSLATION MISSING
* 'property': nome della proprietà (see table below)
// TRANSLATION MISSING
* 'value': new value for property

// TRANSLATION MISSING
Properties:

[width="100%",cols="^2,4,8",options="header"]
|===
| Nome | Valore | Descrizione

| color | nome per l'opzione del colore per WeeChat |
  Consultare l'argomento "color" della funzione
  <<_weechat_nicklist_add_group,weechat_nicklist_add_group>>

| visible | "0", "1" |
  "0" = gruppo nascosto, "1" = gruppo visibile
|===

Esempio in C:

[source,C]
----
/* cambia colore del gruppo a "bar_fg" */
weechat_nicklist_group_set (buffer, group, "color", "bar_fg");

/* cambia il colore del gruppo a giallo */
weechat_nicklist_group_set (buffer, group, "color", "yellow");

/* nasconde gruppo nella lista nick */
weechat_nicklist_group_set (buffer, group, "visible", "0");
----

Script (Python):

[source,python]
----
# prototipo
weechat.nicklist_group_set(buffer, group, property, value)

# esempi

# cambia colore del gruppo a "bar_fg"
weechat.nicklist_group_set(buffer, group, "color", "bar_fg")

# cambia colore del gruppo a giallo
weechat.nicklist_group_set(buffer, group, "color", "yellow")

# nasconde gruppo nella lista nick
weechat.nicklist_group_set(buffer, group, "visible", "0")
----

==== weechat_nicklist_nick_get_integer

_WeeChat ≥ 0.3.4._

Restituisce il valore intero della proprietà di un nick.

Prototipo:

[source,C]
----
int weechat_nicklist_nick_get_integer (struct t_gui_buffer *buffer,
                                       struct t_gui_nick *nick,
                                       const char *property);
----

Argomenti:

* 'buffer': puntatore al buffer
* 'nick': puntatore al nick
* 'property': nome della proprietà:
** 'visible': 1 se il nick è visibile, altrimenti 0

Valore restituito:

* valore intero della proprietà

Esempio in C:

[source,C]
----
int visible = weechat_nicklist_nick_get_integer (buffer, nick, "visible");
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.nicklist_nick_get_integer(buffer, nick, property)

# esempio
visible = weechat.nicklist_nick_get_integer(buffer, nick, "visible")
----

==== weechat_nicklist_nick_get_string

_WeeChat ≥ 0.3.4._

Restituisce il valore stringa della proprietà di un nick.

Prototipo:

[source,C]
----
const char *weechat_nicklist_nick_get_string (struct t_gui_buffer *buffer,
                                              struct t_gui_nick *nick,
                                              const char *property);
----

Argomenti:

* 'buffer': puntatore al buffer
* 'nick': puntatore al nick
* 'property': nome della proprietà:
** 'name': nome del nick
** 'color': colore del nick nella lista nick
** 'prefix': prefisso del nick
** 'prefix_color': colore del prefisso nella lista nick

Valore restituito:

* valore stringa della proprietà

Esempio in C:

[source,C]
----
const char *color = weechat_nicklist_nick_get_string (buffer, nick, "color");
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.nicklist_nick_get_string(buffer, nick, property)

# esempio
color = weechat.nicklist_nick_get_string(buffer, nick, "color")
----

==== weechat_nicklist_nick_get_pointer

_WeeChat ≥ 0.3.4._

Restituisce il valore puntatore della proprietà di un nick.

Prototipo:

[source,C]
----
void *weechat_nicklist_nick_get_pointer (struct t_gui_buffer *buffer,
                                         struct t_gui_nick *nick,
                                         const char *property);
----

Argomenti:

* 'buffer': puntatore al buffer
* 'nick': puntatore al nick
* 'property': nome proprietà:
** 'group': puntatore al gruppo che contiene questo nick

Valore restituito:

* valore puntatore della proprietà

Esempio in C:

[source,C]
----
struct t_gui_nick_group *group = weechat_nicklist_nick_get_pointer (buffer, nick, "group");
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.nicklist_nick_get_pointer(buffer, nick, property)

# esempio
group = weechat.nicklist_nick_get_pointer(buffer, nick, "group")
----

==== weechat_nicklist_nick_set

_WeeChat ≥ 0.3.4._

Imposta il valore stringa della proprietà di un nick.

Prototipo:

[source,C]
----
void weechat_nicklist_nick_set (struct t_gui_buffer *buffer,
                                struct t_gui_nick *nick,
                                const char *property,
                                const char *value);
----

Argomenti:

* 'buffer': puntatore al buffer
* 'nick': puntatore al nick
// TRANSLATION MISSING
* 'property': nome della proprietà (see table below)
// TRANSLATION MISSING
* 'value': new value for property

// TRANSLATION MISSING
Properties:

[width="100%",cols="^2,4,8",options="header"]
|===
| Nome | Valore | Descrizione

| color | nome per l'opzione del colore di WeeChat |
  Consultare l'argomento "color" della funzione
  <<_weechat_nicklist_add_nick,weechat_nicklist_add_nick>>

| prefix | qualsiasi stringa |
  Prefisso del nick

| prefix_color | nome per l'opzione del colore di WeeChat |
  Consultare l'argomento "prefix_color" della funzione
  <<_weechat_nicklist_add_nick,weechat_nicklist_add_nick>>

| visible | "0", "1" |
  "0" = nick nascosto, "1" = nick visibile
|===

Esempi in C:

[source,C]
----
/* cambia colore del nick in azzurro */
weechat_nicklist_nick_set (buffer, nick, "color", "cyan");

/* cambia prefisso in "+" */
weechat_nicklist_nick_set (buffer, nick, "prefix", "+");

/* cambia colore del prefisso in giallo */
weechat_nicklist_nick_set (buffer, nick, "prefix_color", "yellow");

/* nascondi nick nella lista nick */
weechat_nicklist_nick_set (buffer, nick, "visible", "0");
----

Script (Python):

[source,python]
----
# prototipo
weechat.nicklist_nick_set(buffer, nick, property, value)

# esempi

# cambia colore del nick in azzurro
weechat.nicklist_nick_set(buffer, nick, "color", "cyan")

# cambia prefisso in "+"
weechat.nicklist_nick_set(buffer, nick, "prefix", "+")

# cambia colore del prefisso in giallo
weechat.nicklist_nick_set(buffer, nick, "prefix_color", "yellow")

# nascondi nick nella lista nick
weechat.nicklist_nick_set(buffer, nick, "visible", "0")
----

[[bars]]
=== Barre

Funzioni per le barre.

==== weechat_bar_item_search

Cerca un elemento barra.

Prototipo:

[source,C]
----
struct t_gui_bar_item *weechat_bar_item_search (const char *name);
----

Argomenti:

* 'name': nome dell'elemento barra

Valore restituito:

* puntatore all'elemento barra trovato, NULL se non trovato

Esempio in C:

[source,C]
----
struct t_gui_bar_item *bar_item = weechat_bar_item_search ("myitem");
----

Script (Python):

[source,python]
----
# prototipo
bar_item = weechat.bar_item_search(name)

# esempio
bar_item = weechat.bar_item_search("myitem")
----

==== weechat_bar_item_new

// TRANSLATION MISSING
_Updated in 0.4.2._

Crea un nuovo elemento barra.

Prototipo:

[source,C]
----
struct t_gui_bar_item *weechat_bar_item_new (const char *name,
                                             char *(*build_callback)(void *data,
                                                                     struct t_gui_bar_item *item,
                                                                     struct t_gui_window *window,
                                                                     struct t_gui_buffer *buffer,
                                                                     struct t_hashtable *extra_info),
                                             void *build_callback_data);
----

Argomenti:

* 'name': nome dell'elemento barra
* 'build_callback': funzione chiamata quando l'elemento barra viene
  compilato, argomenti e valore restituito:
** 'void *data': puntatore
** 'struct t_gui_bar_item *item': puntatore all'elemento barra
// TRANSLATION MISSING
** 'struct t_gui_window *window': puntatore alla finestra (NULL when called for
   a root bar)
// TRANSLATION MISSING
** 'struct t_gui_buffer *buffer': buffer displayed in window (if window is NULL,
   then it is current buffer) or buffer given in bar item with syntax:
   "@buffer:item" _(WeeChat ≥ 0.4.2)_
// TRANSLATION MISSING
** 'struct t_hashtable *extra_info': always NULL (argument is reserved for a
   future version) _(WeeChat ≥ 0.4.2)_
** valore restituito: contenuto dell'elemento barra
* 'build_callback_data': puntatore fornito alla callback quando
  chiamata da WeeChat

Valore restituito:

* puntatore al nuovo elemento barra, NULL se non trovato

Esempio in C:

[source,C]
----
char *
my_build_callback (void *data,
                   struct t_gui_bar_item *item,
                   struct t_gui_window *window,
                   struct t_gui_buffer *buffer,
                   struct t_hashtable *extra_info)
{
    return strdup ("my content");
}

struct t_gui_bar_item *my_item = weechat_bar_item_new ("myitem",
                                                       &my_build_callback,
                                                       NULL);
----

Script (Python):

// TRANSLATION MISSING
[IMPORTANT]
For compatibility with versions ≤ 0.4.1, the default callback has only 3
arguments: 'data', 'item' and 'window' (no 'buffer' and 'extra_info'). +
To use a callback with all arguments, you must add "(extra)" before the name,
see example below (supported only in WeeChat ≥ 0.4.2).

// TRANSLATION MISSING
[source,python]
----
# prototipo
bar_item = weechat.bar_item_new(name, build_callback, build_callback_data)

# esempio (callback without "buffer" and "extra_info")
def my_build_callback(data, item, window):
    return "my content"

bar_item = weechat.bar_item_new("myitem", "my_build_callback", "")

# example (callback with all arguments, for WeeChat ≥ 0.4.2)
def my_build_callback2(data, item, window, buffer, extra_info):
    return "my content"

bar_item2 = weechat.bar_item_new("(extra)myitem2", "my_build_callback2", "")  # WeeChat ≥ 0.4.2
----

==== weechat_bar_item_update

Aggiorna il contenuto dell'elemento barra, chiamando la callback
che lo ha compilato.

Prototipo:

[source,C]
----
void weechat_bar_item_update (const char *name);
----

Argomenti:

* 'name': nome dell'elemento barra

Esempio in C:

[source,C]
----
weechat_bar_item_update ("myitem");
----

Script (Python):

[source,python]
----
# prototipo
weechat.bar_item_update(name)

# esempio
weechat.bar_item_update("myitem")
----

==== weechat_bar_item_remove

Rimuove un elemento barra.

Prototipo:

[source,C]
----
void weechat_bar_item_remove (struct t_gui_bar_item *item);
----

Argomenti:

* 'item': puntatore all'elemento barra

Esempio in C:

[source,C]
----
weechat_bar_item_remove (&my_item);
----

Script (Python):

[source,python]
----
# prototipo
weechat.bar_item_remove(item)

# esempio
weechat.bar_item_remove(myitem)
----

==== weechat_bar_search

Cerca una barra.

Prototipo:

[source,C]
----
struct t_gui_bar *weechat_bar_search (const char *name);
----

Argomenti:

* 'name': nome della barra

Valore restituito:

* puntatore alla barra trovata, NULL se non trovata

Esempio in C:

[source,C]
----
struct t_gui_bar *bar = weechat_bar_search ("mybar");
----

Script (Python):

[source,python]
----
# prototipo
bar = weechat.bar_search(name)

# esempio
bar = weechat.bar_search("mybar")
----

==== weechat_bar_new

Crea una nuova barra.

Prototipo:

[source,C]
----
struct t_gui_bar *weechat_bar_new (const char *name,
                                   const char *hidden,
                                   const char *priority,
                                   const char *type,
                                   const char *condition,
                                   const char *position,
                                   const char *filling_top_bottom,
                                   const char *filling_left_right,
                                   const char *size,
                                   const char *size_max,
                                   const char *color_fg,
                                   const char *color_delim,
                                   const char *color_bg,
                                   const char *separator,
                                   const char *items);
----

Argomenti:

* 'name': nome della barra
* 'hidden':
** 'on': la barra è nascosta
** 'off': la barra è visibile
* 'priority': priorità per la barra (intero)
* 'type':
** 'root': barra visualizzata una sola volta, al di fuori delle finestre
** 'window': barra visualizzata in ogni finestra
* 'condition': condizioni per la visualizzazione della barra:
** 'active': la barra viene visualizzata solo nella finestra attiva
** 'inactive': la barra viene visualizzata solo nelle finestre inattive
** 'nicklist': la barra viene visualizzata nelle finestre con liste nick
// TRANSLATION MISSING
** evaluated expression: see chapter about bars in 'WeeChat User's guide'
* 'position': 'top', 'bottom', 'left' o 'right'
* 'filling_top_bottom':
** 'horizontal': gli elementi sono posizionati in orizzontale
   (spazio dopo ogni elemento)
** 'vertical': gli elementi sono posizionati in verticale
   (nuova riga dopo ogni elemento)
** 'columns_horizontal': gli elementi sono posizionati in orizzontale,
   visualizzati su colonne
** 'columns_vertical': gli elementi sono posizionati in verticale,
   visualizzati su colonne
* 'filling_left_right':
** 'horizontal': gli elementi sono posizionati in orizzontale
   (spazio dopo ogni elemento)
** 'vertical': gli elementi sono posizionati in verticale
   (nuova riga dopo ogni elemento)
** 'columns_horizontal': gli elementi sono posizionati in orizzontale,
   visualizzati su colonne
** 'columns_vertical': gli elementi sono posizionati in verticale,
   visualizzati su colonne
* 'size': dimensione della barra in caratteri
  (0 corrisponde a dimensione automatica)
* 'size_max': dimensione massima per la barra
  (0 corrisponde a nessuna dimensione massima)
* 'color_fg': colore per il testo nella barra
* 'color_delim': colore per i delimitatori nella barra
* 'color_bg': colore di sfondo per la barra
* 'separator':
** 'on': la barra ha una riga di separazione con altre finestre/barre
** 'off': nessun separatore
* 'items': elenco di elemento nella barra, separati da virgola (spazio tra
  gli elementi), o "+" (elementi incollati)

Valore restituito:

* puntatore alla nuova barra, NULL in caso di errore

Esempio in C:

[source,C]
----
struct t_gui_bar *my_bar = weechat_bar_new ("mybar",
                                            "off",
                                            "100",
                                            "window",
                                            "",
                                            "top",
                                            "horizontal",
                                            "vertical",
                                            "0",
                                            "5",
                                            "default",
                                            "cyan",
                                            "blue",
                                            "off",
                                            "time,buffer_number+buffer_name");
----

Script (Python):

[source,python]
----
# prototipo
bar = weechat.bar_new(name, hidden, priority, type, condition, position,
    filling_top_bottom, filling_left_right, size, size_max,
    color_fg, color_delim, color_bg, separator, items)

# esempio
bar = weechat.bar_new("mybar", "off", "100", "window", "", "top", "horizontal", "vertical",
    "0", "5", "default", "cyan", "blue", "off", "time,buffer_number+buffer_name")
----

==== weechat_bar_set

Imposta un nuovo valore per la proprietà di una barra.

Prototipo:

[source,C]
----
int weechat_bar_set (struct t_gui_bar *bar, const char *property,
                     const char *value);
----

Argomenti:

* 'bar': puntatore alla barra
* 'property': name, hidden, priority, conditions, position, filling_top_bottom,
  filling_left_right, size, size_max, color_fg, color_delim, color_bg,
  separator, items (consultare <<_weechat_bar_new,weechat_bar_new>>)
* 'value': nuovo valore per la proprietà

Valore restituito:

* 1 se il nuovo valore è stato impostato, 0 in caso di errore

Esempio in C:

[source,C]
----
weechat_bar_set (mybar, "position", "bottom");
----

Script (Python):

[source,python]
----
# prototipo
weechat.bar_set(bar, property, value)

# esempio
weechat.bar_set(my_bar, "position", "bottom")
----

==== weechat_bar_update

Aggiorna il contenuto di una barra su schermo.

Prototipo:

[source,C]
----
void weechat_bar_update (const char *name);
----

Argomenti:

* 'name': nome della barra

Esempio in C:

[source,C]
----
weechat_bar_update ("mybar");
----

Script (Python):

[source,python]
----
# prototipo
weechat.bar_update(name)

# esempio
weechat.bar_update("mybar")
----

==== weechat_bar_remove

Rimuove una barra.

Prototipo:

[source,C]
----
void weechat_bar_remove (struct t_gui_bar *bar);
----

Argomenti:

* 'bar': puntatore alla barra

Esempio in C:

[source,C]
----
weechat_bar_remove (mybar);
----

Script (Python):

[source,python]
----
# prototipo
weechat.bar_remove(bar)

# esempio
weechat.bar_remove(my_bar)
----

[[commands]]
=== Comandi

Funzioni per eseguire comandi di WeeChat.

==== weechat_command

// TRANSLATION MISSING
_Updated in 1.1._

Esegue un comando.

Prototipo:

[source,C]
----
int weechat_command (struct t_gui_buffer *buffer, const char *command);
----

Argomenti:

* 'buffer': puntatore al buffer (il comando viene eseguito su questo buffer,
  utilizzare NULL per il buffer corrente)
* 'command': comando da eseguire (se preceduto da "/"), oppure il testo
  viene inviato sul buffer

Valori restituiti: (_WeeChat ≥ 1.1_)

* 'WEECHAT_RC_OK' se l'operazione ha successo
* 'WEECHAT_RC_ERROR' se c'è un errore

Esempio in C:

[source,C]
----
int rc;
rc = weechat_command (weechat_buffer_search ("irc", "freenode.#weechat"),
                      "/whois FlashCode");
----

Script (Python):

[source,python]
----
# prototipo
weechat.command(buffer, command)

# esempio
rc = weechat.command(weechat.buffer_search("irc", "freenode.#weechat"), "/whois FlashCode")
----

[[network]]
=== Network

Funzioni di rete.

==== weechat_network_pass_proxy

Stabilisce una connessione/autenticazione con un proxy.

[IMPORTANT]
// TRANSLATION MISSING
This function is blocking on call to connect(), so it must be called in a forked
process only, to not block WeeChat.

Prototipo:

[source,C]
----
int weechat_network_pass_proxy (const char *proxy,
                                int sock,
                                const char *address,
                                int port);
----

Argomenti:

* 'proxy': nome del proxy da utilizzare
* 'sock': socket da utilizzare
* 'address': indirizzo (nome host o indirizzo IP)
* 'port': port

Valore restituito:

* 1 se la connessione è andata a buon fine, 0 in caso di
  errore

Esempio in C:

[source,C]
----
if (weechat_network_pass_proxy ("my_proxy", sock, "chat.freenode.net", 6667))
{
    /* OK */
}
else
{
    /* errore */
}
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_network_connect_to

// TRANSLATION MISSING
_Updated in 0.4.3._

Stabilisce una connessione con un host remoto.

[IMPORTANT]
// TRANSLATION MISSING
This function is blocking on call to connect(), so it must be called in a forked
process only, to not block WeeChat.

Prototipo:

[source,C]
----
int weechat_network_connect_to (const char *proxy,
                                struct sockaddr *address,
                                socklen_t address_length);
----

Argomenti:

* 'proxy': nome del proxy da utilizzare
// TRANSLATION MISSING
* 'address': address to connect to (with port)
// TRANSLATION MISSING
* 'address_length': length of argument 'address'

Valore restituito:

// TRANSLATION MISSING
* socket number (>= 0) if connection is OK, -1 if an error occurred

Esempio in C:

// TRANSLATION MISSING
[source,C]
----
struct sockaddr *addr;
socklen_t length;
int sock;

/* allocate/set address and port in 'addr', set 'length' */
/* ... */

sock = weechat_network_connect_to (NULL, addr, length);
if (sock >= 0)
{
    /* OK */
}
else
{
    /* errore */
}
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

[[infos]]
=== Info

Funzioni per ottenere info.

==== weechat_info_get

Restituisce la info, come stringa, da WeeChat o da un plugin.

Prototipo:

[source,C]
----
const char *weechat_info_get (const char *info_name, const char *arguments);
----

Argomenti:

// TRANSLATION MISSING
* 'info_name': nome delle informazioni da leggere (see table below)
* 'arguments': argomenti per l'informazione richiesta (opzionake, NULL se non
  è richiesto alcun argomento)

Valore restituito:

* stringa con l'informazione richiesta, NULL in caso di errore

// TRANSLATION MISSING
Infos:

include::autogen/plugin_api/infos.asciidoc[]

Esempio in C:

[source,C]
----
weechat_printf (NULL, "Current WeeChat version is: %s (compiled on %s)",
                weechat_info_get ("version", NULL),
                weechat_info_get ("date", NULL));
weechat_printf (NULL, "WeeChat home is: %s",
                weechat_info_get ("weechat_dir", NULL));
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.info_get(info_name, arguments)

# esempio
weechat.prnt("", "Current WeeChat version is: %s (compiled on %s)"
    % (weechat.info_get("version", ""), weechat.info_get("date", ""))
weechat.prnt("", "WeeChat home is: %s" % weechat.info_get("weechat_dir"))
----

==== weechat_info_get_hashtable

_WeeChat ≥ 0.3.4._

Restituisce una info, come tabella hash, da WeeChat o da un plugin.

Prototipo:

[source,C]
----
struct t_hashtable *weechat_info_get_hashtable (const char *info_name,
                                                struct t_hashtable *hashtable);
----

Argomenti:

// TRANSLATION MISSING
* 'info_name': nome della info da leggere (see table below)
* 'hashtable': tabella hash con argomenti (dipende dalla info richiesta)
* (opzionale, NULL se l'argomento non viene richiesto)

Valore restituito:

* tabella hash con la info richiesta, NULL in caso di errore

// TRANSLATION MISSING
Infos:

include::autogen/plugin_api/infos_hashtable.asciidoc[]

Esempio in C:

[source,C]
----
struct t_hashtable *hashtable_in, *hashtable_out;

hashtable_in = weechat_hashtable_new (8,
                                      WEECHAT_HASHTABLE_STRING,
                                      WEECHAT_HASHTABLE_STRING,
                                      NULL,
                                      NULL);
if (hashtable_in)
{
    weechat_hashtable_set (hashtable_in, "message",
                           ":nick!user@host PRIVMSG #weechat :message here");
    hashtable_out = weechat_info_get_hashtable ("irc_message_parse",
                                                hashtable_in);
    /*
     * now hashtable_out has following keys/values:
     *   "nick"     : "nick"
     *   "host"     : "nick!user@host"
     *   "command"  : "PRIVMSG"
     *   "channel"  : "#weechat"
     *   "arguments": "#weechat :message here"
     */
    weechat_hashtable_free (hashtable_in);
    weechat_hashtable_free (hashtable_out);
}
----

Script (Python):

[source,python]
----
# prototipo
dict = weechat.info_get_hashtable(info_name, dict_in)

# esempio
dict_in = {"message": ":nick!user@host PRIVMSG #weechat :message here"}
weechat.prnt("", "message parsed: %s"
             % weechat.info_get_hashtable("irc_message_parse", dict_in))
----

[[infolists]]
=== Liste info

Una lista info è una lista di "elementi". Ciascun elemento contiene
delle variabili.

Ad esempio, la lista info "irc_server" ha N elementi (N è il numero di
server IRC definiti). Per ogni elemento, esistono variabili come "name",
"buffer", "is connected",...

Ogni variabile ha un tipo e un valore. I tipi possibili sono:

* 'integer': qualunque valore intero
* 'string': qualunque valore stringa
* 'pointer': qualunque puntatore
* 'buffer': buffer di lunghezza fissa, contenente qualunque dato
* 'time': valore tempo

==== weechat_infolist_new

Crea una nuova lista info.

Prototipo:

[source,C]
----
struct t_infolist *weechat_infolist_new ();
----

Valore restituito:

* puntatore alla nuova lista info

Esempio in C:

[source,C]
----
struct t_infolist *infolist = weechat_infolist_new ();
----

Script (Python):

[source,python]
----
# prototipo
infolist = weechat.infolist_new()

# esempio
infolist = weechat.infolist_new()
----

==== weechat_infolist_new_item

Aggiunge un elemento alla lista info.

Prototipo:

[source,C]
----
struct t_infolist_item *weechat_infolist_new_item (struct t_infolist *infolist);
----

Argomenti:

* 'infolist': puntatore alla lista info

Valore restituito:

* puntatore al nuovo elemento

Esempio in C:

[source,C]
----
struct t_infolist_item *item = weechat_infolist_new_item (infolist);
----

Script (Python):

[source,python]
----
# prototipo
item = weechat.infolist_new_item(infolist)

# esempio
item = weechat.infolist_new_item(infolist)
----

==== weechat_infolist_new_var_integer

Aggiunge una variabile intera ad un elemento della
lista info.

Prototipo:

[source,C]
----
struct t_infolist_var *weechat_infolist_new_var_integer (struct t_infolist_item *item,
                                                         const char *name,
                                                         int value);
----

Argomenti:

* 'item': puntatore all'elemento della lista info
* 'name': nome variabile
* 'value': valore intero

Valore restituito:

* puntatore alla nuova variabile

Esempio in C:

[source,C]
----
struct t_infolist_var *var = weechat_infolist_new_var_integer (item,
                                                               "my_integer",
                                                               123);
----

Script (Python):

[source,python]
----
# prototipo
var = weechat.infolist_new_var_integer(item, name, value)

# esempio
var = weechat.infolist_new_var_integer(item, "my_integer", 123)
----

==== weechat_infolist_new_var_string

Aggiunge una variabile stringa ad un elemento
della lista info.

Prototipo:

[source,C]
----
struct t_infolist_var *weechat_infolist_new_var_string (struct t_infolist_item *item,
                                                        const char *name,
                                                        const char *value);
----

Argomenti:

* 'item': puntatore all'elemento della lista info
* 'name': nome variabile
* 'value': valore stringa

Valore restituito:

* puntatore alla nuova variabile

Esempio in C:

[source,C]
----
struct t_infolist_var *var = weechat_infolist_new_var_string (item,
                                                              "my_string",
                                                              "value");
----

Script (Python):

[source,python]
----
# prototipo
var = weechat.infolist_new_var_string(item, name, value)

# esempio
var = weechat.infolist_new_var_string(item, "my_string", "value")
----

==== weechat_infolist_new_var_pointer

Aggiunge una variabile puntatore ad un elemento
della lista info.

Prototipo:

[source,C]
----
struct t_infolist_var *weechat_infolist_new_var_pointer (struct t_infolist_item *item,
                                                         const char *name,
                                                         void *pointer);
----

Argomenti:

* 'item': puntatore all'elemento della lista info
* 'name': nome variabile
* 'pointer': puntatore

Valore restituito:

* puntatore alla nuova variabile

Esempio in C:

[source,C]
----
struct t_infolist_var *var = weechat_infolist_new_var_pointer (item,
                                                               "my_pointer",
                                                               &pointer);
----

Script (Python):

[source,python]
----
# prototipo
var = weechat.infolist_new_var_pointer(item, name, pointer)

# esempio
var = weechat.infolist_new_var_pointer(item, "my_pointer", pointer)
----

==== weechat_infolist_new_var_buffer

Aggiunge una variabile puntatore ad un elemento della lista info.

Prototipo:

[source,C]
----
struct t_infolist_var *weechat_infolist_new_var_buffer (struct t_infolist_item *item,
                                                        const char *name,
                                                        void *pointer,
                                                        int size);
----

Argomenti:

* 'item': puntatore all'elemento della lista info
* 'name': nome della variabile
* 'pointer': puntatore al buffer
* 'size': dimensione del buffer

Valore restituito:

* puntatore alla nuova variabile

Esempio in C:

[source,C]
----
char buffer[256];
/* ... */
struct t_infolist_var *var = weechat_infolist_new_var_buffer (item,
                                                              "my_buffer",
                                                              &buffer,
                                                              sizeof (buffer));
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_infolist_new_var_time

Aggiunge una variabile tempo ad un elemento della lista info.

Prototipo:

[source,C]
----
struct t_infolist_var *weechat_infolist_new_var_time (struct t_infolist_item *item,
                                                      const char *name,
                                                      time_t time);
----

Argomenti:

* 'item': puntatore all'elemento della lista info
* 'name': nome della variabile
* 'time': valore tempo

Valore restituito:

* puntatore alla nuova variabile

Esempio in C:

[source,C]
----
struct t_infolist_var *var = weechat_infolist_new_var_time (item,
                                                            "my_time",
                                                            time (NULL));
----

Script (Python):

[source,python]
----
# prototipo
var = weechat.infolist_new_var_time(item, name, time)

# esempio
var = weechat.infolist_new_var_time(item, "my_time", int(time.time()))
----

==== weechat_infolist_get

Restituisce una lista info da WeeChat o da un plugin.

[IMPORTANT]
Il contenuto della lista info è un duplicato dei dati attuali. Se si sta
richiedendo una lista info con molti dati (come "buffer_lines"), WeeChat
allocherà memoria per duplicare tutti i dati, e potrebbe essere necessario un
po' di tempo. +
Invece di usare liste info più grandi, è preferibilie usare hdata (ma le liste
info potrebbero avere più info di hdata, che sono dati raw), consultare <<hdata,hdata>>.

Prototipo:

[source,C]
----
struct t_infolist *weechat_infolist_get (const char *infolist_name,
                                         void *pointer,
                                         const char *arguments);
----

Argomenti:

// TRANSLATION MISSING
* 'infolist_name': nome della lista info da leggere (see table below)
* 'pointer': puntatore ad un elemento, per ricevere solo questo
  elemento nella lista info (opzionale, può essere NULL)
* 'arguments': argomenti per la lista info richiesta (opzionale, NULL se
  non è necessario alcun argomento)

Valore restituito:

* puntatore alla lista info, NULL in caso di errore

// TRANSLATION MISSING
Infolists:

include::autogen/plugin_api/infolists.asciidoc[]

Esempio in C:

[source,C]
----
struct t_infolist *infolist = weechat_infolist_get ("irc_server", NULL, NULL);
----

Script (Python):

[source,python]
----
# prototipo
infolist = weechat.infolist_get(infolist_name, pointer, arguments)

# esempio
infolist = weechat.infolist_get("irc_server", "", "")
----

==== weechat_infolist_next

Sposta "cursor" all'elemento successivo nella lista info. La prima chiamata
a questa funzione per una lista info sposta il cursore al primo elemento
nella lista info.

Prototipo:

[source,C]
----
int weechat_infolist_next (struct t_infolist *infolist);
----

Argomenti:

* 'infolist': puntatore alla lista info

Valore restituito:

* 1 se il cursore è stato spostato sull'elemento successivo, 0 se è
  stata raggiunta la fine della lista

Esempio in C:

[source,C]
----
if (weechat_infolist_next (infolist))
{
    /* legge variabili nell'elemento... */
}
else
{
    /* nessun altro elemento disponibile */
}
----

Script (Python):

[source,python]
----
# prototipo
rc = weechat.infolist_next(infolist)

# esempio
rc = weechat.infolist_next(infolist)
if rc:
    # legge variabili nell'elemento...
else:
    # nessun altro elemento disponibile
----

==== weechat_infolist_prev

Sposta "cursor" all'elemento precedente nella lista info. La prima
chiamata a questa funzione per una lista info sposta il cursore
all'ultimo elemento.

Prototipo:

[source,C]
----
int weechat_infolist_prev (struct t_infolist *infolist);
----

Argomenti:

* 'infolist': puntatore alla lista info

Valore restituito:

* 1 se il cursore è stato spostato sull'elemento precedente, 0 se
  è stato raggiunto l'inizio della lista

Esempio in C:

[source,C]
----
if (weechat_infolist_prev (infolist))
{
    /* legge variabili nell'elemento... */
}
else
{
    /* nessun altro elemento disponibile */
}
----

Script (Python):

[source,python]
----
# prototipo
rc = weechat.infolist_prev(infolist)

# esempio
rc = weechat.infolist_prev(infolist)
if rc:
    # read variables in item...
else:
    # no more item available
----

==== weechat_infolist_reset_item_cursor

Ripristina "cursor" per la lista info.

Prototipo:

[source,C]
----
void weechat_infolist_reset_item_cursor (struct t_infolist *infolist);
----

Argomenti:

* 'infolist': puntatore alla lista info

Esempio in C:

[source,C]
----
weechat_infolist_reset_item_cursor (infolist);
----

Script (Python):

[source,python]
----
# prototipo
weechat.infolist_reset_item_cursor(infolist)

# esempio
weechat.infolist_reset_item_cursor(infolist)
----

==== weechat_infolist_search_var

_WeeChat ≥ 0.4.3._

// TRANSLATION MISSING
Search a variable in the current infolist item.

Prototipo:

[source,C]
----
struct t_infolist_var *weechat_infolist_search_var (struct t_infolist *infolist,
                                                    const char *name);
----

Argomenti:

* 'infolist': puntatore alla lista info
* 'name': nome della variabile

Valore restituito:

// TRANSLATION MISSING
* pointer to variable found, NULL if the variable was not found

Esempio in C:

// TRANSLATION MISSING
[source,C]
----
if (weechat_infolist_search_var (infolist, "name"))
{
    /* variable "name" exists */
    /* ... */
}
----

Script (Python):

// TRANSLATION MISSING
[source,python]
----
# prototipo
var = weechat.infolist_search_var(infolist, name)

# esempio
if weechat.infolist_search_var(infolist, "name"):
    # variable "name" exists
    # ...
----

==== weechat_infolist_fields

Restituisce una lista di campi per l'elemento della
lista info corrente.

Prototipo:

[source,C]
----
const char *weechat_infolist_fields (struct t_infolist *infolist);
----

Argomenti:

* 'infolist': puntatore alla lista info

Valore restituito:

* stringa con una lista di campi per l'elemento della lista info corrente.
  La lista è separata da virgole, e contiene lettere per tipo, seguite dal
  nome della variabile. I tipi sono: "i" (intero), "s" (stringa), "p" (puntatore),
  "b" (buffer), "t" (tempo).

Esempio in C:

[source,C]
----
const char *fields = weechat_infolist_fields (infolist);
/* i campi contengono qualcosa come:
   "i:my_integer,s:my_string,p:my_pointer,b:my_buffer,t:my_time" */
----

Script (Python):

[source,python]
----
# prototipo
fields = weechat.infolist_fields(infolist)

# esempio
fields = weechat.infolist_fields(infolist)
# i campi contengono qualcosa come:
# "i:my_integer,s:my_string,p:my_pointer,b:my_buffer,t:my_time"
----

==== weechat_infolist_integer

Restituisce il valore della variabile intera nell'elemento
corrente della lista info.

Prototipo:

[source,C]
----
int weechat_infolist_integer (struct t_infolist *infolist, const char *var);
----

Argomenti:

* 'infolist': puntatore alla lista info
* 'var': nome della variabile (deve essere di tipo "integer")

Valore restituito:

* valore intero della variabile

Esempio in C:

[source,C]
----
weechat_printf (NULL, "integer = %d",
                weechat_infolist_integer (infolist, "my_integer"));
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.infolist_integer(infolist, var)

# esempio
weechat.prnt("", "integer = %d" % weechat.infolist_integer(infolist, "my_integer"))
----

==== weechat_infolist_string

Restituisce il valore della variabile stringa nell'elemento
della lista info corrente.

Prototipo:

[source,C]
----
const char *weechat_infolist_string (struct t_infolist *infolist, const char *var);
----

Argomenti:

* 'infolist': puntatore alla lista info
* 'var': nome della variabile (deve essere di tipo "string")

Valore restituito:

* valore stringa della variabile

Esempio in C:

[source,C]
----
weechat_printf (NULL, "string = %s",
                weechat_infolist_string (infolist, "my_string"));
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.infolist_string(infolist, var)

# esempio
weechat.prnt("", "string = %s" % weechat.infolist_string(infolist, "my_string"))
----

==== weechat_infolist_pointer

Restituisce il valore della variabile puntatore nell'elemento
della lista info corrente.

Prototipo:

[source,C]
----
void *weechat_infolist_pointer (struct t_infolist *infolist, const char *var);
----

Argomenti:

* 'infolist': puntatore alla lista info
* 'var': nome della variabile (deve essere di tipo "pointer")

Valore restituito:

* puntatore al valore della variabile

Esempio in C:

[source,C]
----
weechat_printf (NULL, "pointer = 0x%lx",
                weechat_infolist_pointer (infolist, "my_pointer"));
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.infolist_pointer(infolist, var)

# esempio
weechat.prnt("", "pointer = 0x%s" % weechat.infolist_pointer(infolist, "my_pointer"))
----

==== weechat_infolist_buffer

Restituisce il valore della variabile buffer nell'elemento corrente
della lista info.

Prototipo:

[source,C]
----
void *weechat_infolist_buffer (struct t_infolist *infolist, const char *var,
                               int *size);
----

Argomenti:

* 'infolist': puntatore alla lista info
* 'var': nome della variabile (deve essere di tipo "buffer")
* 'size': puntatore ad una variabile intera, verrà impostata con la
  dimensione del buffer

Valore restituito:

* puntatore al buffer

Esempio in C:

[source,C]
----
int size;
void *pointer = weechat_infolist_buffer (infolist, "my_buffer", &size);
weechat_printf (NULL, "buffer = 0x%lx, size = %d",
                pointer, size);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_infolist_time

Restituisce il valore della variabile data/ora nell'elemento
attivo della lista info.

Prototipo:

[source,C]
----
time_t weechat_infolist_time (struct t_infolist *infolist, const char *var);
----

Argomenti:

* 'infolist': puntatore alla lista info
* 'var': nome della variabile (deve essere di tipo "time")

Valore restituito:

* valore della variabile nel formato data/ora

Esempio in C:

[source,C]
----
weechat_printf (NULL, "time = %ld",
                weechat_infolist_time (infolist, "my_time"));
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.infolist_time(infolist, var)

# esempio
weechat.prnt("", "time = %ld" % weechat.infolist_time(infolist, "my_time"))
----

==== weechat_infolist_free

Libera una lista info.

Prototipo:

[source,C]
----
void weechat_infolist_free (struct t_infolist *infolist);
----

Argomenti:

* 'infolist': puntatore alla lista info

Esempio in C:

[source,C]
----
weechat_infolist_free (infolist);
----

Script (Python):

[source,python]
----
# prototipo
weechat.infolist_free(infolist)

# esempio
weechat.infolist_free(infolist)
----

[[hdata]]
=== Hdata

Funzioni per hdata (accesso raw a WeeChat o ai dati dei plugin).

// TRANSLATION MISSING
[IMPORTANT]
Hdata fornisce un accesso in sola lettura ai dati. È *SEVERAMENTE VIETATO*
scrivere qualcosa in memoria puntato dalle variabili in hdata. +
The only way to update data is to call function
<<_weechat_hdata_update,weechat_hdata_update>>.

==== weechat_hdata_new

// TRANSLATION MISSING
_WeeChat ≥ 0.3.6, updated in 0.3.9 and 0.4.0._

Crea un nuovo hdata.

[NOTE]
.hdata vs infolist
====
Hdata è un metodo veloce per leggere i dati di WeeChat o dei plugin. È simile
alle liste info, ma ci sono alcune differenze:

* è più veloce ed usa meno memoria: lettura diretta dei dati senza duplicazione
* può contenere informazioni differenti rispetto alle liste info: esso contiene
  solo dati raw in strutture (le liste info possono aggiungere alcuni dati extra
  per convenienza)
====

Prototipo:

[source,C]
----
struct t_hdata *weechat_hdata_new (const char *hdata_name, const char *var_prev, const char *var_next,
                                   int create_allowed, int delete_allowed,
                                   int (*callback_update)(void *data,
                                                          struct t_hdata *hdata,
                                                          void *pointer,
                                                          struct t_hashtable *hashtable),
                                   void *callback_update_data);
----

Argomenti:

* 'hdata_name': nome di un hdata
* 'var_prev': nome della variabile nella struttura che è puntatore all'elemento
  precedente nella lista (può essere NULL se non è disponibile tale variabile)
* 'var_next': nome della variabile nella struttura che è puntatore all'elemento
  successivo nella lista (può essere NULL se non è disponibile tale variabile)
// TRANSLATION MISSING
* 'create_allowed': 1 if create of structure is allowed, otherwise 0
  _(WeeChat ≥ 0.4.0)_
// TRANSLATION MISSING
* 'delete_allowed': 1 if delete of structure is allowed, otherwise 0
  _(WeeChat ≥ 0.3.9)_
// TRANSLATION MISSING
* 'callback_update': callback to update data in hdata, can be NULL if no update
  is allowed _(WeeChat ≥ 0.3.9)_, arguments and return value:
** 'void *data': pointer
** 'struct t_hdata *hdata': pointer to hdata
** 'struct t_hashtable *hashtable': hashtable with variables to update
   (see <<_weechat_hdata_update,weechat_hdata_update>>)
** return value: number of variables updated
// TRANSLATION MISSING
* 'callback_update_data': pointer given to update callback when it is called by
  WeeChat _(WeeChat ≥ 0.3.9)_

Valore restituito:

* puntatore al nuovo hdata

Esempio in C:
source,C]
----
struct t_hdata *hdata = weechat_hdata_new ("myplugin_list", "prev", "next", 0, 0, &callback_update, NULL);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_hdata_new_var

// TRANSLATION MISSING
_WeeChat ≥ 0.3.6, updated in 0.3.9_

Crea una nuova variabile in hdata.

Prototipo:

[source,C]
----
void weechat_hdata_new_var (struct t_hdata *hdata, const char *name, int offset, int type,
                            int update_allowed, const char *array_size, const char *hdata_name);
----

Argomenti:

* 'hdata': puntatore ad hdata
* 'name': nome della variabile
* 'offset': offset della variabile nella struttura
* 'type': tipo variabile, una di:
** WEECHAT_HDATA_CHAR
** WEECHAT_HDATA_INTEGER
** WEECHAT_HDATA_LONG
** WEECHAT_HDATA_STRING
** WEECHAT_HDATA_SHARED_STRING
** WEECHAT_HDATA_POINTER
** WEECHAT_HDATA_TIME
** WEECHAT_HDATA_HASHTABLE
** WEECHAT_HDATA_OTHER
// TRANSLATION MISSING
* 'update_allowed': 1 if update of variable is allowed, otherwise 0
  _(WeeChat ≥ 0.3.9)_
// TRANSLATION MISSING
* 'array_size': not NULL only if a variable is an array, and it can be:
  _(WeeChat ≥ 0.3.9)_
** name of variable in hdata: this variable will be used as size of array
   (dynamic size for array)
** integer (as string): fixed size for array
** '*': automatic size: the size of array is computed by looking at values, when
   the first NULL is found (only for type string, pointer or hashtable)
* 'hdata_name': nome di un hdata (se è un puntatore ad una struttura con dati)

Esempio in C:

[source,C]
----
struct t_myplugin_list
{
    char *name;
    struct t_gui_buffer *buffer;
    int tags_count;
    char **tags_array;
    char **string_split;
    struct t_myplugin_list *prev;
    struct t_myplugin_list *next;
};

/* ... */

struct t_hdata *hdata = weechat_hdata_new ("myplugin_list", "prev", "next");
weechat_hdata_new_var (hdata, "name", offsetof (struct t_myplugin_list, name), WEECHAT_HDATA_STRING, 0, NULL, NULL);
weechat_hdata_new_var (hdata, "buffer", offsetof (struct t_myplugin_list, buffer), WEECHAT_HDATA_POINTER, 0, NULL, NULL);
weechat_hdata_new_var (hdata, "tags_count", offsetof (struct t_myplugin_list, tags_count), WEECHAT_HDATA_INTEGER, 0, NULL, NULL);
weechat_hdata_new_var (hdata, "tags_array", offsetof (struct t_myplugin_list, tags_array), WEECHAT_HDATA_STRING, 0, "tags_count", NULL);
weechat_hdata_new_var (hdata, "string_split", offsetof (struct t_myplugin_list, string_split), WEECHAT_HDATA_STRING, 0, "*", NULL);
weechat_hdata_new_var (hdata, "prev", offsetof (struct t_myplugin_list, prev), WEECHAT_HDATA_POINTER, 0, NULL, "myplugin_list");
weechat_hdata_new_var (hdata, "next", offsetof (struct t_myplugin_list, next), WEECHAT_HDATA_POINTER, 0, NULL, "myplugin_list");
----

La macro "WEECHAT_HDATA_VAR" può essere usata per accorciare il codice:

[source,C]
----
WEECHAT_HDATA_VAR(struct t_myplugin_list, name, STRING, 0, NULL, NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, buffer, POINTER, 0, NULL, NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, tags_count, INTEGER, 0, NULL, NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, tags_array, STRING, 0, "tags_count", NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, string_split, STRING, 0, "*", NULL);
WEECHAT_HDATA_VAR(struct t_myplugin_list, prev, POINTER, 0, NULL, "myplugin_list");
WEECHAT_HDATA_VAR(struct t_myplugin_list, next, POINTER, 0, NULL, "myplugin_list");
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_hdata_new_list

// TRANSLATION MISSING
_WeeChat ≥ 0.3.6, updated in 1.0._

Crea una nuovo puntatore alla lista in hdata.

Prototipo:

[source,C]
----
void weechat_hdata_new_list (struct t_hdata *hdata, const char *name, void *pointer, int flags);
----

Argomenti:

* 'hdata': puntatore hdata
* 'name': nome delal variabile
* 'pointer': puntatore alla lista
// TRANSLATION MISSING
* 'flags': combination of following values: _(WeeChat ≥ 1.0)_
** 'WEECHAT_HDATA_LIST_CHECK_POINTERS': list used to check pointers

Esempio in C:

[source,C]
----
struct t_myplugin_list
{
    char *name;
    struct t_gui_buffer *buffer;
    int tags_count;
    char **tags_array;
    char **string_split;
    struct t_myplugin_list *prev;
    struct t_myplugin_list *next;
};

/* ... */

struct t_hdata *hdata = weechat_hdata_new ("myplugin_list", "prev", "next");
weechat_hdata_new_var (hdata, "name", offsetof (struct t_myplugin_list, name), WEECHAT_HDATA_STRING, NULL, NULL);
weechat_hdata_new_var (hdata, "buffer", offsetof (struct t_myplugin_list, buffer), WEECHAT_HDATA_POINTER, NULL, NULL);
weechat_hdata_new_var (hdata, "tags_count", offsetof (struct t_myplugin_list, tags_count), WEECHAT_HDATA_INTEGER, NULL, NULL);
weechat_hdata_new_var (hdata, "tags_array", offsetof (struct t_myplugin_list, tags_array), WEECHAT_HDATA_STRING, "tags_count", NULL);
weechat_hdata_new_var (hdata, "string_split", offsetof (struct t_myplugin_list, string_split), WEECHAT_HDATA_STRING, "*", NULL);
weechat_hdata_new_var (hdata, "prev", offsetof (struct t_myplugin_list, prev), WEECHAT_HDATA_POINTER, NULL, "myplugin_list");
weechat_hdata_new_var (hdata, "next", offsetof (struct t_myplugin_list, next), WEECHAT_HDATA_POINTER, NULL, "myplugin_list");

weechat_hdata_new_list (hdata, "buffers", &buffers, WEECHAT_HDATA_LIST_CHECK_POINTERS);
weechat_hdata_new_list (hdata, "last_buffer", &last_buffer, 0);
----

La macro "WEECHAT_HDATA_LIST" può essere usata per accorciare il codice:

[source,C]
----
WEECHAT_HDATA_LIST(buffers, WEECHAT_HDATA_LIST_CHECK_POINTERS);
WEECHAT_HDATA_LIST(last_buffer, 0);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_hdata_get

_WeeChat ≥ 0.3.6._

Restituisce hdata per una struttura di WeeChat o di un plugin.

[NOTE]
Hdata non contiene dati, è una tabella hash con la posizione delle variabili
nella struttura. Ciò indica che è necessario questo hdata ed un puntatore ad
un oggetto di WeeChat/plugin per leggere dei dati.

Prototipo:

[source,C]
----
struct t_hdata *weechat_hdata_get (const char *hdata_name);
----

Argomenti:

// TRANSLATION MISSING
* 'hdata_name': nome di un hdata (see list below)

Valore restituito:

* puntatore ad un hdata, NULL in caso di errore

// TRANSLATION MISSING
List of hdata:

include::autogen/plugin_api/hdata.asciidoc[]

Esempio in C:

[source,C]
----
struct t_hdata *hdata = weechat_hdata_get ("irc_server");
----

Script (Python):

[source,python]
----
# prototipo
hdata = weechat.hdata_get(hdata_name)

# esempio
hdata = weechat.hdata_get("irc_server")
----

==== weechat_hdata_get_var_offset

_WeeChat ≥ 0.3.6._

Restituisce l'offset della variabile in hdata.

Prototipo:

[source,C]
----
int weechat_hdata_get_var_offset (struct t_hdata *hdata, const char *name);
----

Argomenti:

* 'hdata': puntatore hdata
* 'name': nome della variabile

Valore restituito:

* offset della variabile, 0 in caso di errore

Esempio in C:

[source,C]
----
int offset = weechat_hdata_get_var_offset (hdata, "name");
----

Script (Python):

[source,python]
----
# prototipo
offset = weechat.hdata_get_var_offset(hdata, name)

# esempio
offset = weechat.hdata_get_var_offset(hdata, "name")
----

==== weechat_hdata_get_var_type

_WeeChat ≥ 0.3.6._

Restituisce il tipo di variabile in hdata (come intero).

Prototipo:

[source,C]
----
int weechat_hdata_get_var_type (struct t_hdata *hdata, const char *name);
----

Argomenti:

* 'hdata': puntatore hdata
* 'name': nome della variabile

Valore restituito:

* tipo della variabile, -1 in caso di errore

Esempio in C:

[source,C]
----
int type = weechat_hdata_get_var_type (hdata, "name");
switch (type)
{
    case WEECHAT_HDATA_CHAR:
        /* ... */
        break;
    case WEECHAT_HDATA_INTEGER:
        /* ... */
        break;
    case WEECHAT_HDATA_LONG:
        /* ... */
        break;
    case WEECHAT_HDATA_STRING:
        /* ... */
        break;
    case WEECHAT_HDATA_SHARED_STRING:
        /* ... */
        break;
    case WEECHAT_HDATA_POINTER:
        /* ... */
        break;
    case WEECHAT_HDATA_TIME:
        /* ... */
        break;
    case WEECHAT_HDATA_HASHTABLE:
        /* ... */
        break;
    case WEECHAT_HDATA_OTHER:
        /* ... */
        break;
    default:
        /* variable not found */
        break;
}
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_hdata_get_var_type_string

_WeeChat ≥ 0.3.6._

Restituisce il tipo di variabile in hdata (come stringa).

Prototipo:

[source,C]
----
const char *weechat_hdata_get_var_type_string (struct t_hdata *hdata, const char *name);
----

Argomenti:

* 'hdata': puntatore hdata
* 'name': nome della variabile

Valore restituito:

* tipo della variabile, NULL in caso di errore

Esempio in C:

[source,C]
----
weechat_printf (NULL, "type = %s",
                weechat_hdata_get_var_type_string (hdata, "name"));
----

Script (Python):

[source,python]
----
# prototipo
type = weechat.hdata_get_var_type_string(hdata, name)

# esempio
weechat.prnt("", "type = %s" % weechat.hdata_get_var_type_string(hdata, "name"))
----

==== weechat_hdata_get_var_array_size

_WeeChat ≥ 0.3.9._

// TRANSLATION MISSING
Return array size for variable in hdata.

Prototipo:

[source,C]
----
int weechat_hdata_get_var_array_size (struct t_hdata *hdata, void *pointer, const char *name);
----

Argomenti:

* 'hdata': puntatore hdata
* 'pointer': puntarore all'oggetto di WeeChat/plugin
* 'name': nome della variabile

Valore restituito:

// TRANSLATION MISSING
* array size for variable, -1 if variable is not an array or if an error occurred

Esempio in C:

[source,C]
----
int array_size = weechat_hdata_get_var_array_size (hdata, pointer, "name");
----

Script (Python):

[source,python]
----
# prototipo
array_size = weechat.hdata_get_var_array_size(hdata, pointer, name)

# esempio
array_size = weechat.hdata_get_var_array_size(hdata, pointer, "name")
----

==== weechat_hdata_get_var_array_size_string

_WeeChat ≥ 0.3.9._

// TRANSLATION MISSING
Return array size for variable in hdata (as string).

Prototipo:

[source,C]
----
const char *weechat_hdata_get_var_array_size_string (struct t_hdata *hdata, void *pointer,
                                                     const char *name);
----

Argomenti:

* 'hdata': puntatore hdata
* 'pointer': puntarore all'oggetto di WeeChat/plugin
* 'name': nome della variabile

Valore restituito:

// TRANSLATION MISSING
* array size for variable as string, NULL if variable is not an array or if an
  error occurred

Esempio in C:

[source,C]
----
const char *array_size = weechat_hdata_get_var_array_size_string (hdata, pointer, "name");
----

Script (Python):

[source,python]
----
# prototipo
array_size = weechat.hdata_get_var_array_size_string(hdata, pointer, name)

# esempio
array_size = weechat.hdata_get_var_array_size_string(hdata, pointer, "name")
----

==== weechat_hdata_get_var_hdata

_WeeChat ≥ 0.3.6._

Restituisce hdata per la variabile in hdata.

Prototipo:

[source,C]
----
const char *weechat_hdata_get_var_hdata (struct t_hdata *hdata, const char *name);
----

Argomenti:

* 'hdata': puntatore hdata
* 'name': nome della variabile

Valore restituito:

* hdata per la variabile, NULL in caso di nessun hdata presente o di errore

Esempio in C:

[source,C]
----
weechat_printf (NULL, "hdata = %s", weechat_hdata_get_var_hdata (hdata, "name"));
----

Script (Python):

[source,python]
----
# prototipo
hdata_name = weechat.hdata_get_var_hdata(hdata, name)

# esempio
weechat.prnt("", "hdata = %s" % weechat.hdata_get_var_hdata(hdata, "name"))
----

==== weechat_hdata_get_var

_WeeChat ≥ 0.3.6._

Restituisce il puntatore al contenuto della variabile in hdata.

Prototipo:

[source,C]
----
void *weechat_hdata_get_var (struct t_hdata *hdata, void *pointer, const char *name);
----

Argomenti:

* 'hdata': puntatore hdata
* 'pointer': puntarore all'oggetto di WeeChat/plugin
* 'name': nome della variabile

Valore restituito:

* puntatore al contenuto della variabile, NULL in caso di errore

Esempio in C:

[source,C]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
void *pointer = weechat_hdata_get_var (hdata, buffer, "name");
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_hdata_get_var_at_offset

_WeeChat ≥ 0.3.6._

Restituisce il puntatore al contenuto della variabile in hdata, usando un offset.

Prototipo:

[source,C]
----
void *weechat_hdata_get_var_at_offset (struct t_hdata *hdata, void *pointer, int offset);
----

Argomenti:

* 'hdata': puntatore hdata
* 'pointer': puntatore ad un oggetto di WeeChat/plugin
* 'offset': offset della variabile

Valore restituito:

* puntatore al contenuto della variabile, NULL in caso di errore

Esempio in C:

[source,C]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
int offset = weechat_hdata_get_var_offset (hdata, "name");
void *pointer = weechat_hdata_get_var_at_offset (hdata, buffer, offset);
----

[NOTE]
Questa funzione non è disponibile nelle API per lo scripting.

==== weechat_hdata_get_list

_WeeChat ≥ 0.3.6._

Restituisce il puntatore alla lista da hdata.

Prototipo:

[source,C]
----
void *weechat_hdata_get_list (struct t_hdata *hdata, const char *name);
----

Argomenti:

* 'hdata': puntatore hdata
* 'name': nome della lista

Valore restituito:

* puntatore alla lista, NULL in caso di errore

Esempio in C:

[source,C]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffers = weechat_hdata_get_list (hdata, "gui_buffers");
----

Script (Python):

[source,python]
----
# prototipo
list = weechat.hdata_get_list(hdata, name)

# esempio
hdata = weechat.hdata_get("buffer")
buffers = weechat.hdata_get_list(hdata, "gui_buffers")
----

==== weechat_hdata_check_pointer

// TRANSLATION MISSING
_WeeChat ≥ 0.3.7, updated in 1.0._

Verifica se un puntatore è valido per un hdata e un puntatore della lista.

Prototipo:

[source,C]
----
int weechat_hdata_check_pointer (struct t_hdata *hdata, void *list, void *pointer);
----

Argomenti:

* 'hdata': puntatore hdata
// TRANSLATION MISSING
* 'list': puntatore alla lista; if NULL _(WeeChat ≥ 1.0)_, the pointer is
  checked with the lists in hdata that have flag "check pointers" (see
  <<_weechat_hdata_new_list,weechat_hdata_new_list>>), and if no such list
  exists, the pointer is considered as valid
* 'pointer': puntatore da verificare

Valore restituito:

* 1 se il puntatore è in lista, 0 in caso contrario

Esempio in C:

[source,C]
----
/* check if a buffer pointer is valid */
struct t_hdata *hdata = weechat_hdata_get ("buffer");
if (weechat_hdata_check_pointer (hdata,
                                 weechat_hdata_get_list (hdata, "gui_buffers"),
                                 ptr_buffer))
{
    /* valid pointer */
}
else
{
    /* invalid pointer */
}
----

Script (Python):

[source,python]
----
# prototipo
rc = weechat.hdata_check_pointer(hdata, list, pointer)

# esempio
hdata = weechat.hdata_get("buffer")
if weechat.hdata_check_pointer(hdata, weechat.hdata_get_list(hdata, "gui_buffers"), ptr_buffer):
    # valid pointer
    # ...
else:
    # invalid pointer
    # ...
----

==== weechat_hdata_move

_WeeChat ≥ 0.3.6._

Sposta il puntatore ad un altro elemento nella lista.

Prototipo:

[source,C]
----
void *weechat_hdata_move (struct t_hdata *hdata, void *pointer, int count);
----

Argomenti:

* 'hdata': puntatore hdata
* 'pointer': puntatore ad un oggetto di WeeChat/plugin
* 'count': numero di salto(i) da eseguire (intero positivo o negativo, diverso
  da 0)

Valore restituito:

* puntatore all'elemento raggiunto, NULL in caso di errore

Esempio in C:

[source,C]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();

/* passa al buffer successivo, 2 volte */
buffer = weechat_hdata_move (hdata, buffer, 2);

/* passa al buffer precedente */
if (buffer)
    buffer = weechat_hdata_move (hdata, buffer, -1);
----

Script (Python):

[source,python]
----
# prototipo
pointer = weechat.hdata_move(hdata, pointer, count)

# esempio
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()

# passa al buffer successivo, 2 volte
buffer = weechat.hdata_move(hdata, buffer, 2)

# passa al buffer precedente
if buffer:
    buffer = weechat.hdata_move(hdata, buffer, -1)
----

==== weechat_hdata_search

_WeeChat ≥ 0.4.1._

// TRANSLATION MISSING
Search element in a list: the expression 'search' is evaluated for each element
in list, until element is found (or end of list).

Prototipo:

[source,C]
----
void *weechat_hdata_search (struct t_hdata *hdata, void *pointer, const char *search, int move);
----

Argomenti:

* 'hdata': puntatore hdata
* 'pointer': puntatore ad un oggetto di WeeChat/plugin
// TRANSLATION MISSING
* 'search': expression to evaluate, default pointer in expression is the name of
  hdata (and this pointer changes for each element in list); for help on
  expression, see command `/eval` in 'WeeChat User's guide'
// TRANSLATION MISSING
* 'move': number of jump(s) to execute after unsuccessful search (negative or
  positive integer, different from 0)

Valore restituito:

// TRANSLATION MISSING
* pointer to element found, NULL if not found

Esempio in C:

[source,C]
----
struct t_hdata *hdata = weechat_hdata_get ("irc_server");
void *servers = weechat_hdata_get (hdata, "irc_servers");

/* search irc server with name "freenode" */
void *server = weechat_hdata_search (hdata, servers, "${irc_server.name} == freenode", 1);
if (server)
{
    /* ... */
}
----

Script (Python):

// TRANSLATION MISSING
[source,python]
----
# prototipo
pointer = weechat.hdata_search(hdata, pointer, search, count)

# esempio
hdata = weechat.hdata_get("irc_server")
servers = weechat.hdata_get_list(hdata, "irc_servers")

# search irc server with name "freenode"
server = weechat.hdata_search(hdata, servers, "${irc_server.name} == freenode", 1)
if server:
    # ...
----

==== weechat_hdata_char

_WeeChat ≥ 0.3.7._

Restituisce il valore di una variabile char in una struttura dati usando hdata.

Prototipo:

[source,C]
----
char weechat_hdata_char (struct t_hdata *hdata, void *pointer, const char *name);
----

Argomenti:

* 'hdata': puntatore hdata
* 'pointer': puntatore all'oggetto di WeeChat/plugin
// TRANSLATION MISSING
* 'name': nome della variabile (deve essere di tipo "char"); for arrays,
  the name can be "N|name" where N is the index in array (starting at 0),
  for example: "2|name"

Valore restituito:

* valore char della variabile

Esempio in C:

[source,C]
----
weechat_printf (NULL, "letter = %c", weechat_hdata_char (hdata, pointer, "letter"));
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.hdata_char(hdata, pointer, name)

# esempio
weechat.prnt("", "letter = %c" % weechat.hdata_char(hdata, pointer, "letter"))
----

==== weechat_hdata_integer

_WeeChat ≥ 0.3.6._

Restituisce il valore di una variabile integer in una struttura dati usando hdata.

Prototipo:

[source,C]
----
int weechat_hdata_integer (struct t_hdata *hdata, void *pointer, const char *name);
----

Argomenti:

* 'hdata': puntatore hdata
* 'pointer': puntatore all'oggetto di WeeChat/plugin
// TRANSLATION MISSING
* 'name': nome della variabile (deve essere di tipo "integer"); for arrays,
  the name can be "N|name" where N is the index in array (starting at 0),
  for example: "2|name"

Valore restituito:

* valore intero della variabile

Esempio in C:

[source,C]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
weechat_printf (NULL, "number = %d", weechat_hdata_integer (hdata, buffer, "number"));
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.hdata_integer(hdata, pointer, name)

# esempio
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
weechat.prnt("", "number = %d" % weechat.hdata_integer(hdata, buffer, "number"))
----

==== weechat_hdata_long

_WeeChat ≥ 0.3.6._

Restituisce il valore della variabile long della struttura usando hdata.

Prototipo:

[source,C]
----
long weechat_hdata_long (struct t_hdata *hdata, void *pointer, const char *name);
----

Argomenti:

* 'hdata': puntatore hdata
* 'pointer': puntatore all'oggetto di WeeChat/plugin
// TRANSLATION MISSING
* 'name': nome della variabile (deve essere di tipo "long"); for arrays,
  the name can be "N|name" where N is the index in array (starting at 0),
  for example: "2|name"

Valore restituito:

* valore long della variabile

Esempio in C:

[source,C]
----
weechat_printf (NULL, "longvar = %ld", weechat_hdata_long (hdata, pointer, "longvar"));
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.hdata_long(hdata, pointer, name)

# esempio
weechat.prnt("", "longvar = %ld" % weechat.hdata_long(hdata, pointer, "longvar"))
----

==== weechat_hdata_string

_WeeChat ≥ 0.3.6._

Restituisce il valore della variabile string nella struttura usando hdata.

Prototipo:

[source,C]
----
const char *weechat_hdata_string (struct t_hdata *hdata, void *pointer, const char *name);
----

Argomenti:

* 'hdata': puntatore hdata
* 'pointer': puntatore all'oggetto di WeeChat/plugin
// TRANSLATION MISSING
* 'name': nome della variabile (deve essere di tipo "string"); for arrays,
  the name can be "N|name" where N is the index in array (starting at 0),
  for example: "2|name"

Valore restituito:

* valore stringa della variabile

Esempio in C:

[source,C]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
weechat_printf (NULL, "name = %s", weechat_hdata_string (hdata, buffer, "name"));
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.hdata_string(hdata, pointer, name)

# esempio
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
weechat.prnt("", "name = %s" % weechat.hdata_string(hdata, buffer, "name"))
----

==== weechat_hdata_pointer

_WeeChat ≥ 0.3.6._

Restituisce il valore della variabile puntatore nella struttura usando hdata.

Prototipo:

[source,C]
----
void *weechat_hdata_pointer (struct t_hdata *hdata, void *pointer, const char *name);
----

Argomenti:

* 'hdata': hdata hdata
* 'pointer': pointer all'oggetto di WeeChat/plugin
// TRANSLATION MISSING
* 'name': nome della variabile (deve essere di tipo "pointer"); for arrays,
  the name can be "N|name" where N is the index in array (starting at 0),
  for example: "2|name"

Valore restituito:

* valore puntatore della variabile

Esempio in C:

[source,C]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
weechat_printf (NULL, "lines = %lx", weechat_hdata_pointer (hdata, buffer, "lines"));
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.hdata_pointer(hdata, pointer, name)

# esempio
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
weechat.prnt("", "lines = %lx" % weechat.hdata_pointer(hdata, buffer, "lines"))
----

==== weechat_hdata_time

_WeeChat ≥ 0.3.6._

Restituisce il valore della variabile time nella struttura usando hdata.

Prototipo:

[source,C]
----
time_t weechat_hdata_time (struct t_hdata *hdata, void *pointer, const char *name);
----

Argomenti:

* 'hdata': puntatore hdata
* 'pointer': puntatore all'oggetto di WeeChat/plugin
// TRANSLATION MISSING
* 'name': nome della variabile (deve essere di tipo "time"); for arrays,
  the name can be "N|name" where N is the index in array (starting at 0),
  for example: "2|name"

Valore restituito:

* valore time della variabile

Esempio in C:

[source,C]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *ptr = weechat_buffer_search_main ();
ptr = weechat_hdata_pointer (hdata, ptr, "lines");
if (ptr)
{
    hdata = weechat_hdata_get ("lines");
    ptr = weechat_hdata_pointer (hdata, ptr, "first_line");
    if (ptr)
    {
        hdata = weechat_hdata_get ("line");
        ptr = weechat_hdata_pointer (hdata, ptr, "data");
        if (ptr)
        {
            hdata = weechat_hdata_get ("line_data");
            time_t date = weechat_hdata_time (hdata, hdata, "date");
            weechat_printf (NULL, "time of last line displayed = %s", ctime (&date));
        }
    }
}
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.hdata_time(hdata, pointer, name)

# esempio
buf = weechat.buffer_search_main()
ptr = weechat.hdata_pointer(weechat.hdata_get("buffer"), buf, "lines")
if ptr:
    ptr = weechat.hdata_pointer(weechat.hdata_get("lines"), ptr, "first_line")
    if ptr:
        ptr = weechat.hdata_pointer(weechat.hdata_get("line"), ptr, "data")
        if ptr:
            date = weechat.hdata_time(weechat.hdata_get("line_data"), ptr, "date")
            weechat.prnt("", "time of first line displayed = %s" % time.strftime("%F %T", time.localtime(int(date))))
----

==== weechat_hdata_hashtable

_WeeChat ≥ 0.3.7._

Restituisce il valore di una variabile nella tabella hash nella struttura usando
hdata.

Prototipo:

[source,C]
----
struct t_hashtable *weechat_hdata_hashtable (struct t_hdata *hdata, void *pointer, const char *name);
----

Argomenti:

* 'hdata': puntatore hdata
* 'pointer': puntatore all'oggetto di WeeChat/plugin
// TRANSLATION MISSING
* 'name': nome della variabile (deve essere di tipo "hashtable"); for arrays,
  the name can be "N|name" where N is the index in array (starting at 0),
  for example: "2|name"

Valore restituito:

* valore della tabella hash della variabile (puntatore alla tabella hash)

Esempio in C:

[source,C]
----
struct t_hdata *hdata = weechat_hdata_get ("buffer");
struct t_gui_buffer *buffer = weechat_buffer_search_main ();
struct t_hashtable *hashtable = weechat_hdata_hashtable (hdata, buffer, "local_variables");
weechat_printf (NULL, "%d local variables in core buffer",
                weechat_hashtable_get_integer (hashtable, "items_count"));
----

Script (Python):

[source,python]
----
# prototipo
hashtable = weechat.hdata_hashtable(hdata, pointer, name)

# esempio
hdata = weechat.hdata_get("buffer")
buffer = weechat.buffer_search_main()
hash = weechat.hdata_hashtable(hdata, buffer, "local_variables")
weechat.prnt("", "local variables in core buffer:")
for key in hash:
    weechat.prnt("", "  %s == %s" % (key, hash[key]))
----

// TRANSLATION MISSING
==== weechat_hdata_set

_WeeChat ≥ 0.3.9._

Set new value for variable in a hdata.

[NOTE]
This function can be called only in an update callback
(see <<_weechat_hdata_new,weechat_hdata_new>> and
<<_weechat_hdata_update,weechat_hdata_update>>), if the variable can be updated.

Prototipo:

[source,C]
----
int weechat_hdata_set (struct t_hdata *hdata, void *pointer, const char *name, const char *value);
----

Argomenti:

* 'hdata': hdata pointer
* 'pointer': pointer to WeeChat/plugin object
* 'name': variable name (types allowed: char, integer, long, string, pointer,
  time)
* 'value': new value for variable

Valore restituito:

* 1 if ok, 0 if error

Esempio in C:

[source,C]
----
weechat_hdata_set (hdata, pointer, "message", "test");
----

[NOTE]
This function is not available in scripting API.

// TRANSLATION MISSING
==== weechat_hdata_update

_WeeChat ≥ 0.3.9._

Update data in a hdata.

Prototipo:

[source,C]
----
int weechat_hdata_update (struct t_hdata *hdata, void *pointer, struct t_hashtable *hashtable);
----

Argomenti:

* 'hdata': hdata pointer
* 'pointer': pointer to WeeChat/plugin object
* 'hashtable': variables to update: keys are name of variables, values are new
  values for variables (keys and values are string), some special keys are
  allowed:
// TRANSLATION MISSING
** key `__create_allowed` (with any value): return 1 if create is allowed for
   structure, otherwise 0 _(WeeChat ≥ 0.4.0)_
** key `__delete_allowed` (with any value): return 1 if delete is allowed for
   structure, otherwise 0
** key `__update_allowed`, value is name of a variable: return 1 if update is
   allowed for this variable, otherwise 0
** key `__delete` (with any value): delete structure (if allowed)

Valore restituito:

* number of variables updated

Esempio in C:

[source,C]
----
/* subtract one hour on last message displayed in current buffer */

struct t_gui_lines *own_lines;
struct t_gui_line *line;
struct t_gui_line_data  *line_data;
struct t_hdata *hdata;
struct t_hashtable *hashtable;
char str_date[64];

own_lines = weechat_hdata_pointer (weechat_hdata_get ("buffer"), weechat_current_buffer (), "own_lines");
if (own_lines)
{
    line = weechat_hdata_pointer (weechat_hdata_get ("lines"), own_lines, "last_line");
    if (line)
    {
        line_data = weechat_hdata_pointer (weechat_hdata_get ("line"), line, "data");
        hdata = weechat_hdata_get ("line_data");
        hashtable = weechat_hashtable_new (8,
                                           WEECHAT_HASHTABLE_STRING,
                                           WEECHAT_HASHTABLE_STRING,
                                           NULL,
                                           NULL);
        if (hashtable)
        {
            snprintf (str_date, sizeof (str_date), "%ld", ((long int)weechat_hdata_time (hdata, line_data, "date")) - 3600);
            weechat_hashtable_set (hashtable, "date", str_date);
            weechat_hdata_update (hdata, line_data, hashtable);
            weechat_hashtable_free (hashtable);
        }
    }
}
----

Script (Python):

[source,python]
----
# prototipo
count = weechat.hdata_update(hdata, pointer, hashtable)

# example: subtract one hour on last message displayed in current buffer
own_lines = weechat.hdata_pointer(weechat.hdata_get("buffer"), weechat.current_buffer(), "own_lines")
if own_lines:
    line = weechat.hdata_pointer(weechat.hdata_get("lines"), own_lines, "last_line")
    if line:
        line_data = weechat.hdata_pointer(weechat.hdata_get("line"), line, "data")
        hdata = weechat.hdata_get("line_data")
        weechat.hdata_update(hdata, line_data, {"date": str(weechat.hdata_time(hdata, line_data, "date") - 3600)})
----

==== weechat_hdata_get_string

_WeeChat ≥ 0.3.6._

Restituisce il valore stringa di una proprietà di hdata.

Prototipo:

[source,C]
----
const char *weechat_hdata_get_string (struct t_hdata *hdata, const char *property);
----

Argomenti:

* 'hdata': puntatore hdata
* 'property': nome della proprietà:
** 'var_keys': stringa con la lista di chiavi per le variabili in hdata
   (formato: "key1,key2,key3")
** 'var_values': stringa con la lista di valori per le variabili in hdata
   (formato: "value1,value2,value3")
** 'var_keys_values': stringa cona la lista di chiavi e valori per le variabili in hdata
   (formato: "key1:value1,key2:value2,key3:value3")
** 'var_prev': nome della variabile nella struttura che fa da puntatore al
   precedente elemento nella lista
** 'var_next': nome della variabile nella struttura che fa da puntatore al
   successivo elemento nella lista
** 'list_keys': stringa con la lista di chiavi per le liste in hdata
   (formato: "key1,key2,key3")
** 'list_values': stringa con la lista di valori per le liste in hdata
   (formato: "value1,value2,value3")
** 'list_keys_values': stringa con la lista di chiavi e valori per le liste in hdata
   (formato: "key1:value1,key2:value2,key3:value3")

Valore restituito:

* valore stringa della proprietà

Esempio in C:

[source,C]
----
weechat_printf (NULL, "variables in hdata: %s", weechat_hdata_get_string (hdata, "var_keys"));
weechat_printf (NULL, "lists in hdata: %s", weechat_hdata_get_string (hdata, "list_keys"));
----

Script (Python):

[source,python]
----
# prototipo
value = weechat.hdata_get_string(hdata, property)

# esempio
weechat.prnt("", "variables in hdata: %s" % weechat.hdata_get_string(hdata, "var_keys"))
weechat.prnt("", "lists in hdata: %s" % weechat.hdata_get_string(hdata, "list_keys"))
----

[[upgrade]]
=== Aggiornamento

Funzioni per l'aggiornamento di WeeChat (comando "/upgrade").

==== weechat_upgrade_new

Crea o legge un file per l'aggiornamento.

Prototipo:

[source,C]
----
struct t_upgrade_file *weechat_upgrade_new (const char *filename, int write);
----

Argomenti:

* 'filename': nome del file (l'estensione ".upgrade" verrà aggiunta a questo nome
  da WeeChat)
* 'write':
** '1': crea il file (in modalità scrittura, prima dell'aggiornamento)
** '0': legge il file (dopo l'aggiornamento)

Valore restituito:

* puntatore al file di aggiornamento

Esempio in C:

[source,C]
----
struct t_upgrade_file *upgrade_file = weechat_upgrade_new ("my_file", 1);
----

Script (Python):

[source,python]
----
# prototipo
upgrade_file = weechat.upgrade_new(filename, write)

# esempio
upgrade_file = weechat.upgrade_new("my_file", 1)
----

==== weechat_upgrade_write_object

Scrive un oggetto nel file di aggiornamento.

Prototipo:

[source,C]
----
int weechat_upgrade_write_object (struct t_upgrade_file *upgrade_file,
                                  int object_id,
                                  struct t_infolist *infolist);
----

Argomenti:

* 'upgrade_file': puntatore al file di aggiornamento
* 'object_id': id per l'oggetto
* 'infolist': lista info da scrivere nel file

Valore restituito:

* 1 se ok, 0 se errore

Esempio in C:

[source,C]
----
if (weechat_upgrade_write_object (upgrade_file, 1, &infolist))
{
    /* ok */
}
else
{
    /* errore */
}
----

Script (Python):

[source,python]
----
# prototipo
rc = weechat.upgrade_write_object(upgrade_file, object_id, infolist)

# esempio
weechat.upgrade_write_object(upgrade_file, 1, infolist)
----

==== weechat_upgrade_read

Legge un file di aggiornamento.

Prototipo:

[source,C]
----
int weechat_upgrade_read (struct t_upgrade_file *upgrade_file,
                          int (*callback_read)(void *data,
                                               struct t_upgrade_file *upgrade_file,
                                               int object_id,
                                               struct t_infolist *infolist),
                          void *callback_read_data);
----

Argomenti:

* 'upgrade_file': puntatore al file di aggiornamento
* 'callback_read': funzione chiamata per ogni oggetto letto nel file
  di aggiornamento, argomenti e valore restituito:
** 'void *data': puntatore
** 'struct t_upgrade_file *upgrade_file': puntatore al file di aggiornamento
** 'int object_id': id dell'oggetto
** 'struct t_infolist *infolist': lista info con il contenuto dell'oggetto
** valore restituito:
*** 'WEECHAT_RC_OK'
*** 'WEECHAT_RC_ERROR'
* 'callback_read_data': puntatore assegnato per la lettura della chiamata
  quando chiamata da WeeChat

Valore restituito:

* 1 se ok, 0 se errore

Esempio in C:

[source,C]
----
int
my_upgrade_read_cb (struct t_upgrade_file *upgrade_file,
                    int object_id,
                    struct t_infolist *infolist)
{
    /* lettura variabili... */
    return WEECHAT_RC_OK;
}

weechat_upgrade_read (upgrade_file, &my_upgrade_read_cb, NULL);
----

Script (Python):

[source,python]
----
# prototipo
rc = weechat.upgrade_read(upgrade_file, callback_read, callback_read_data)

# esempio
def my_upgrade_read_cb(upgrade_file, object_id, infolist):
    # lettura variabili...
    return weechat.WEECHAT_RC_OK

weechat.upgrade_read(upgrade_file, "my_upgrade_read_cb", ""))
----

==== weechat_upgrade_close

Chiude un file di aggiornamento.

Prototipo:

[source,C]
----
void weechat_upgrade_close (struct t_upgrade_file *upgrade_file);
----

Argomenti:

* 'upgrade_file': puntatore al file di aggiornamento

Esempio in C:

[source,C]
----
weechat_upgrade_close (upgrade_file);
----

Script (Python):

[source,python]
----
# prototipo
weechat.upgrade_close(upgrade_file)

# esempio
weechat.upgrade_close(upgrade_file)
----
