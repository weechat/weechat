= WeeChat Benutzerhandbuch
:author: Sébastien Helleu
:email: flashcode@flashtux.org
:lang: de
:toc: left
:toclevels: 4
:toc-title: Inhaltsverzeichnis
:sectnums:
:sectnumlevels: 3
:docinfo1:


Übersetzer:

* Nils Görs <weechatter@arcor.de>, 2010-2016


Diese Anleitung beschreibt den WeeChat Chat Client und ist Teil von WeeChat.

Die aktuelle Version dieser Anleitung finden Sie auf:
https://weechat.org/doc


[[introduction]]
== Einleitung

WeeChat (Wee Enhanced Environment for Chat) ist ein freier, schneller und
schlanker Chat-Client der für unterschiedliche Betriebssysteme entwickelt wird.

[[features]]
=== Funktionen

wesentliche Merkmale:

* Unterstützung verschiedener Protokolle (in der Hauptsache das IRC-Protokoll)
* mehrere Server Verbindungen sind möglich (mittels SSL, IPv6, proxy)
* klein, schnell und schlank
* den eigenen persönlichen Bedürfnissen anpassbar und durch Erweiterungen und Skripten in der Funktionalität erweiterbar
* IRC RFCs konform
  http://tools.ietf.org/html/rfc1459[1459],
  http://tools.ietf.org/html/rfc2810[2810],
  http://tools.ietf.org/html/rfc2811[2811],
  http://tools.ietf.org/html/rfc2812[2812] und
  http://tools.ietf.org/html/rfc2813[2813]
* IRC proxy und relay für remote Schnittstellen
* Betriebssystemunabhängig (GNU/Linux, *BSD, MacOS X, Windows und weitere)
* 100% GPL, freie Software

Die WeeChat Homepage findet man unter: https://weechat.org/

[[prerequisites]]
=== Vorbereitung

Um WeeChat zu installieren wird folgendes benötigt:

* ein lauffähiges GNU/Linux System (mit Kompilierungswerkzeugen für Quellpakete),
  oder ein kompatibles OS
* _root_ Privilegien (um WeeChat in das Systemverzeichnis zu installieren)
* einige Bibliotheken (siehe <<dependencies,Abhängigkeiten>>).

[[install]]
== Installation

[[binary_packages]]
=== Binärpaket

Binärpakete sind für folgende Distributionen erhältlich:

* Arch Linux: `pacman -S weechat`
* Cygwin (Windows): wähle das WeeChat Paket in setup.exe aus
* Debian/Ubuntu (oder Debian kompatible Distribution):
  `apt-get install weechat-curses weechat-plugins`
* Fedora Core: `dnf install weechat`
* Gentoo: `emerge weechat`
* Mandriva/RedHat (oder eine RPM kompatible Distribution):
  `rpm -i /path/to/weechat-x.y.z-1.i386.rpm`
* openSUSE: `zypper in weechat`
* Sourcemage: `cast weechat`

zusätzliche Pakete können bzw. sollten installiert werden. Zum Beispiel: weechat-plugins.

Für andere Distributionen schauen Sie bitte in die jeweilige Anleitung,
wie man Pakete installiert.

[[source_package]]
=== Quellpakete

WeeChat kann mittels cmake oder autotools kompiliert werden (cmake sollte dabei die bevorzugte Methode sein).

[NOTE]
Unter OS X kann http://brew.sh/[Homebrew] verwendet werden:
`brew install weechat --with-python --with-perl`
(für Hilfe: `brew info weechat`).

[[dependencies]]
==== Abhängigkeiten

folgende Tabelle beschreibt, welche Pakete zwingend notwendig sind um WeeChat
zu kompilieren und welche Pakete optional genutzt werden können.

[width="100%",cols="5,^3,^3,.^13",options="header"]
|===
| Paket ^(1)^            | Version       | benötigt | Funktion
| C compiler
  (gcc, clang, ...)      |               | *ja*     | zum Erstellen der Binärdatei.
| C++ compiler           |               |          | zum Erstellen der Binärdatei und um Test auszuführen, javascript Erweiterung.
| cmake                  |               | *ja*     | zum kompilieren (autotools ist möglich. cmake wird aber empfohlen).
| pkg-config             |               | *ja*     | entdeckt installierte Bibliotheken.
| libncursesw5-dev ^(2)^ |               | *ja*     | Ncurses Oberfläche.
| libcurl4-gnutls-dev    |               | *ja*     | URL Transfer.
| zlib1g-dev             |               | *ja*     | Kompression für Pakete, die mittels Relay- (WeeChat Protokoll), Script-Erweiterung übertragen werden.
| libgcrypt20-dev        |               | *ja*     | Geschützte Daten, IRC SASL Authentifikation (DH-BLOWFISH/DH-AES), Skript-Erweiterung.
| libgnutls28-dev        | ≥ 2.2.0 ^(3)^ |          | SSL Verbindung zu einem IRC Server, Unterstützung von SSL in der Relay-Erweiterung, IRC SASL Authentifikation (ECDSA-NIST256P-CHALLENGE).
| gettext                |               |          | Internationalisierung (Übersetzung der Mitteilungen; Hauptsprache ist englisch).
| ca-certificates        |               |          | Zertifikate für SSL Verbindungen.
| libaspell-dev
  ∥ libenchant-dev       |               |          | Aspell Erweiterung.
| python-dev             | ≥ 2.5 ^(4)^   |          | Python Erweiterung.
| libperl-dev            |               |          | Perl Erweiterung.
| ruby-2.3, ruby2.3-dev  | ≥ 1.8         |          | Ruby Erweiterung.
| liblua5.3-dev          |               |          | Lua Erweiterung.
| tcl-dev                | ≥ 8.5         |          | Tcl Erweiterung.
| guile-2.0-dev          | ≥ 2.0         |          | Guile (scheme) Erweiterung.
| libv8-dev              | ≤ 3.24.3      |          | Javascript Erweiterung.
| asciidoctor            | ≥ 1.5.4       |          | zum Erstellen der man page und der Dokumentation.
| libcpputest-dev        | ≥ 3.4         |          | zum Erstellen und um Test auszuführen.
|===

[NOTE]
^(1)^ Paketnamen wurden von der Debian GNU/Linux Distribution übernommen.
Versionen und Paketnamen können für andere Distributionen abweichend sein. +
^(2)^ WeeChat kann auch mit libncurses5-dev kompiliert werden. Dies wird aber
*NICHT* empfohlen (es treten dabei Darstellungsfehler mit breiten Zeichen
auf). +
^(3)^ Gnutls ≥ 3.0.21 wird benötigt um eine IRC SASL Authentifizierung mittels
ECDSA-NIST256P-CHALLENGE durchzuführen. +
^(4)^ Die empfohlene Version ist 2.7 (alle Skripten laufen mit der Version 2.7,
aber nicht mit Version ≤ 2.6 oder ≥ 3.0).

Falls eine Debian/Ubuntu basierte Distribution genutzt wird und man einen
"deb-src" Quelleintrag in _/etc/apt/sources.list_ eingetragen hat, dann ist
es mit folgendem Befehl möglich alle notwendigen Abhängigkeiten zu
installieren:

----
# apt-get build-dep weechat
----

[[compile_with_cmake]]
==== Kompilieren mit cmake

* Installation in das Systemverzeichnis (benötigt _root_ Privilegien):

----
$ mkdir build
$ cd build
$ cmake ..
$ make
% make install    (als root)
----

* Installation in ein benutzerdefiniertes Verzeichnis:

----
$ mkdir build
$ cd build
$ cmake .. -DCMAKE_INSTALL_PREFIX=/Pfad/zum/Verzeichnis
$ make
$ make install
----

Optionen für cmake können mit dem Format, "-DOPTION=VALUE", genutzt werden.

Liste von häufig verwendeten Optionen:

[width="100%",cols="2m,2,5m,12",options="header"]
|===
| Option | Wert | Standardwert | Beschreibung

| CMAKE_BUILD_TYPE | `Debug`, `Release`, `RelWithDebInfo`, `MinSizeRel` | |
  Art des builds: `Debug` (oder `RelWithDebInfo`) sollte verwendet werden, wenn meine eine Entwicklerversion
  von WeeChat nutzt.

| CMAKE_INSTALL_PREFIX | Verzeichnis | /usr/local |
  Verzeichnis in welchem WeeChat installiert wird.

| WEECHAT_HOME | Verzeichnis | ~/.weechat |
  Standard-Verzeichnis in welchem die Daten liegen.

| CA_FILE | Datei | /etc/ssl/certs/ca-certificates.crt |
  Datei enthält die Zertifizierungen.
  This is the default value of option
  <<option_weechat.network.gnutls_ca_file,weechat.network.gnutls_ca_file>>.

| ENABLE_ALIAS | `ON`, `OFF` | ON |
  kompiliert <<alias_plugin,Alias Erweiterung>>.

| ENABLE_ASPELL | `ON`, `OFF` | ON |
  kompiliert <<aspell_plugin,Aspell Erweiterung>>.

| ENABLE_CHARSET | `ON`, `OFF` | ON |
  kompiliert <<charset_plugin,Charset Erweiterung>>.

| ENABLE_MAN | `ON`, `OFF` | OFF |
  kompiliert man page.

| ENABLE_DOC | `ON`, `OFF` | OFF |
  kompiliert Dokumentation (dies ist sehr zeitintensiv und wird nur empfohlen falls
  Binärpakete erstellt werden, die die Dokumentation beinhalten sollen, oder man die
  Dokumentation nicht auf der Homepage abrufen kann).

| ENABLE_ENCHANT | `ON`, `OFF` | OFF |
  kompiliert <<aspell_plugin,Aspell plugin>> mittels Enchant.

| ENABLE_EXEC | `ON`, `OFF` | ON |
  kompiliert <<exec_plugin,Exec Erweiterung>>.

| ENABLE_FIFO | `ON`, `OFF` | ON |
  kompiliert <<fifo_plugin,Fifo Erweiterung>>.

| ENABLE_GNUTLS | `ON`, `OFF` | ON |
  kompiliert Gnutls (für SSL).

| ENABLE_GUILE | `ON`, `OFF` | ON |
  kompiliert <<scripts_plugins,Guile Erweiterung>> (Scheme).

| ENABLE_IRC | `ON`, `OFF` | ON |
  kompiliert <<irc_plugin,IRC Erweiterung>>.

| ENABLE_JAVASCRIPT | `ON`, `OFF` | ON |
  kompiliert <<scripts_plugins,Javascript Erweiterung>>.

| ENABLE_LARGEFILE | `ON`, `OFF` | ON |
  Unterstützung großer Dateien.

| ENABLE_LOGGER | `ON`, `OFF` | ON |
  kompiliert <<logger_plugin,Logger Erweiterung>>.

| ENABLE_LUA | `ON`, `OFF` | ON |
  kompiliert <<scripts_plugins,Lua Erweiterung>>.

| ENABLE_NCURSES | `ON`, `OFF` | ON |
  kompiliert Ncurses Oberfläche.

| ENABLE_NLS | `ON`, `OFF` | ON |
  aktiviert NLS (Übersetzungen).

| ENABLE_PERL | `ON`, `OFF` | ON |
  kompiliert <<scripts_plugins,Perl Erweiterung>>.

| ENABLE_PYTHON | `ON`, `OFF` | ON |
  kompiliert <<scripts_plugins,Python Erweiterung>>.

| ENABLE_PYTHON3 | `ON`, `OFF` | OFF |
  kompiliert <<scripts_plugins,Python Erweiterung>> mittels Python 3 (dies wird *NICHT* empfohlen,
  da viele Skripten nicht kompatible mit Python 3 sind).

| ENABLE_RELAY | `ON`, `OFF` | ON |
  kompiliert <<relay_plugin,Relay Erweiterung>>.

| ENABLE_RUBY | `ON`, `OFF` | ON |
  kompiliert <<scripts_plugins,Ruby Erweiterung>>.

| ENABLE_SCRIPT | `ON`, `OFF` | ON |
  kompiliert <<scripts_plugins,Script Erweiterung>>.

| ENABLE_SCRIPTS | `ON`, `OFF` | ON |
  kompiliert <<scripts_plugins,Skripten-Erweiterungen>> (Python, Perl, Ruby,
  Lua, Tcl, Guile, Javascript).

| ENABLE_TCL | `ON`, `OFF` | ON |
  kompiliert <<scripts_plugins,Tcl Erweiterung>>.

| ENABLE_TRIGGER | `ON`, `OFF` | ON |
  kompiliert <<trigger_plugin,Trigger Erweiterung>>.

| ENABLE_XFER | `ON`, `OFF` | ON |
  kompiliert <<xfer_plugin,Xfer Erweiterung>>.

| ENABLE_TESTS | `ON`, `OFF` | OFF |
  kompiliert Testumgebung.
|===

Weitere Optionen können mit folgendem Befehl angezeigt werden:

----
$ cmake -LA
----

oder mittels der Curses-Oberfläche:

----
$ ccmake ..
----

[[compile_with_autotools]]
==== Kompilieren mit autotools

[WARNING]
Ausschließlich das Kompilieren mittels cmake wird offiziell unterstützt. Autotools
sollte nur verwendet werden falls man keine Möglichkeit hat cmake zu nutzen. +
Für die Erstellung mittels autotools werden zusätzliche Pakete benötigt und es ist
zeitintensiver als cmake.

* Installation in das Systemverzeichnis (benötigt _root_ Privilegien):

----
$ ./autogen.sh
$ mkdir build
$ cd build
$ ../configure
$ make
% make install    (als root)
----

* Installation in ein benutzerdefiniertes Verzeichnis:

----
$ ./autogen.sh
$ mkdir build
$ cd build
$ ../configure --prefix=/Pfad/zum/Verzeichnis
$ make
$ make install
----

Die Optionen können auch für das _configure_ Skript verwendet und mittels
folgendem Befehl angezeigt werden:

----
$ ./configure --help
----

[[git_sources]]
=== Git Quellen

Warnung: Git Quellen sollten nur von erfahrenen Nutzern verwendet werden. Eventuell lassen
sich die Quellen nicht kompilieren oder der Code ist nicht stabil. Sie sind hiermit gewarnt!

Um die Git Quellen zu beziehen nutzen Sie folgende Befehle:

----
$ git clone https://github.com/weechat/weechat.git
----

Folgen Sie bitte der Anleitung zur Erstellung aus Quellpaketen (siehe <<source_package,Quellpakete>>).

[[report_crashes]]
=== Abstürze melden

Falls WeeChat abgestürzt sein sollte und Sie diesen Fehler melden möchten:

* kompilieren Sie WeeChat mit Debug-Information (oder installieren Sie das Binärpaket mit Debug-Information)
* aktivieren Sie _core_ Dateien auf Ihrem System
* installieren Sie gdb

[[debug_info]]
==== Debug info

Bei der Kompilierung mit cmake muss folgende Option gesetzt werden:

----
$ cmake .. -DCMAKE_BUILD_TYPE=Debug
----

Bei der Kompilierung mit autotools ist debug standardmäßig aktiviert (`--with-debug=1`).

Wird ein Binärpaket genutzt dann muss zusätzlich das Paket _weechat-dbg_ installiert werden.

[[core_files]]
==== Core Dateien

Um _core_ Dateien zu aktivieren kann folgende Option genutzt werden:
<<option_weechat.startup.sys_rlimit,weechat.startup.sys_rlimit>>:

----
/set weechat.startup.sys_rlimit "core:-1"
----

Wird eine WeeChat Version ≤ 0.3.8 verwendet oder man möchte die _core_ Dateien
aktivieren, bevor WeeChat gestaret wird, wird der Befehl `ulimit` benötigt.

Zum Beispiel muss unter Linux in einer _bash_ Shell folgender Befehl in die `~/.bashrc`
Datei eingetragen werden:

----
ulimit -c unlimited
----

optional kann noch die maximale Dateigröße bestimmt werden:

----
ulimit -c 200000
----

[[gdb_backtrace]]
==== Rückverfolgung mit gdb

Falls WeeChat abstürzen sollte, dann wird auf Ihrem System eine _core_ bzw. _core.12345_ Datei
(_12345_ ist die Prozess-Id) erzeugt.
Diese Datei wird in dem Verzeichnis erzeugt aus welchem Sie WeeChat gestartet haben (dies
ist *nicht* das Verzeichnis in welchem sich WeeChat befindet!).

Beispiel: _weechat_ ist installiert in _/usr/bin/_ und die _core_ Datei befindet sich
in _/home/xxx/_. Nun wird gdb mit folgendem Befehl aufgerufen:

----
gdb /usr/bin/weechat /home/xxx/core
----

Nun startet man _gdb_ und führt den Befehl `bt full` innerhalb der gdb Umgebung aus, um die
Fehlermeldung auszugeben. Eine Fehlermeldung von gdb sieht z.B. wie folgt aus:

----
(gdb) set logging file /tmp/crash.txt
(gdb) set logging on
Copying output to /tmp/crash.txt.
(gdb) bt full
#0  0x00007f9dfb04a465 in raise () from /lib/libc.so.6
#1  0x00007f9dfb04b8e6 in abort () from /lib/libc.so.6
#2  0x0000000000437f66 in weechat_shutdown (return_code=1, crash=1)
    at /some_path/src/core/weechat.c:351
#3  <signal handler called>
#4  0x000000000044cb24 in hook_process_timer_cb (arg_hook_process=0x254eb90,
    remaining_calls=<value optimized out>) at /some_path/src/core/wee-hook.c:1364
        hook_process = 0x254eb90
        status = <value optimized out>
#5  0x000000000044cc7d in hook_timer_exec ()
    at /some_path/src/core/wee-hook.c:1025
        tv_time = {tv_sec = 1272693881, tv_usec = 212665}
        ptr_hook = 0x2811f40
        next_hook = 0x0
#6  0x000000000041b5b0 in gui_main_loop ()
    at /some_path/src/gui/curses/gui-curses-main.c:319
        hook_fd_keyboard = 0x173b600
        tv_timeout = {tv_sec = 0, tv_usec = 0}
        read_fds = {fds_bits = {0 <repeats 16 times>}}
        write_fds = {fds_bits = {0 <repeats 16 times>}}
        except_fds = {fds_bits = {0 <repeats 16 times>}}
        max_fd = <value optimized out>
----

Diese Fehlermeldung senden Sie bitte an den Entwickler und beschreiben was den Fehler ausgelöst hat.

Danke für Ihre Mithilfe!

[[debug_running_weechat]]
==== Eine laufende Session von WeeChat debuggen

Um eine laufende Session von WeeChat zu debuggen (zum Beispiel wenn WeeChat nicht
mehr reagieren sollte) sollte man gdb mit der Prozess-ID starten (_12345_ muss durch
die PID des laufenden weechat Prozesses ersetzt werden):

----
gdb /usr/bin/weechat 12345
----

Sollte WeeChat abgestürzt sein, muss der Befehl `bt full` genutzt werden:

----
(gdb) bt full
----

[[usage]]
== Nutzung

[[running_weechat]]
=== WeeChat starten

Befehlszeile:

include::cmdline_options.de.adoc[]

Um WeeChat zu starten muss folgender Befehl ausgeführt werden:

----
$ weechat
----

Wird WeeChat zum ersten mal gestartet wird eine Konfigurationsdatei
mit Standardparametern erstellt. Die Konfigurationsdatei heißt:
_~/.weechat/weechat.conf_.

Die Einstellungen für WeeChat können an die eigenen Bedürfnisse angepasst werden. Dazu sollten
Veränderungen an der Konfigurationsdatei mit dem internen Befehl `/set` durchführt werden. (siehe
<<weechat_commands,WeeChat Befehle>>).

[[files_and_directories]]
=== Dateien und Verzeichnisse

WeeChat schreibt standardmäßig seine Konfiguration und andere
Daten in folgendes Verzeichnis:  `~/.weechat`

Verzeichnisse:

[width="100%",cols="1m,3",options="header"]
|===
| Pfad/Datei        | Beschreibung
| ~/.weechat/       | WeeChat Heimatverzeichnis (kann angepasst werden, siehe <<running_weechat,Running WeeChat>>).
|    logs/          | Logdateien (eine Datei pro Buffer).
|    python/        | Python-Skripten.
|       autoload/   | Python-Skripten die beim Start automatisch ausgeführt werden ^(1)^.
|    perl/          | Perl-Skripten.
|       autoload/   | Perl-Skripten die beim Start automatisch ausgeführt werden ^(1)^.
|    ruby/          | Ruby-Skripten.
|       autoload/   | Ruby-Skripten die beim Start automatisch ausgeführt werden ^(1)^.
|    lua/           | Lua-Skripten.
|       autoload/   | Lua-Skripten die beim Start automatisch ausgeführt werden ^(1)^.
|    tcl/           | Tcl-Skripten.
|       autoload/   | Tcl-Skripten die beim Start automatisch ausgeführt werden ^(1)^.
|    guile/         | Guile-Skripten.
|       autoload/   | Guile-Skripten die beim Start automatisch ausgeführt werden ^(1)^.
|    javascript/    | Javascript-Skripten.
|       autoload/   | Javascript-Skripten die beim Start automatisch ausgeführt werden ^(1)^.
|===

[NOTE]
^(1)^ Das Verzeichnis besteht meistens aus symbolischen Links welche auf das eigentliche Skript zeigen.

Folgende Dateien findet man im Heimatverzeichnis:

[width="100%",cols="1m,3,6",options="header"]
|===
| Datei        | Beschreibung                            | sensible Daten
| weechat.conf | Hauptkonfiguration von WeeChat          | möglich (Beispiel: Auflistung der Channels im Buffers-Layout).
| sec.conf     | Konfigurationsdatei mit sensiblen Daten | *Ja, hoch sensibel*: diese Datei sollte niemals weitergegeben werden.
| plugins.conf | Konfigurationsdatei für Erweiterungen   | möglich, hängt von der Erweiterung/Skript ab.
| alias.conf   | Konfigurationsdatei: Alias-Erweiterung  | möglich, hängt von den Aliases ab.
| aspell.conf  | Konfiguration für _aspell_-Erweiterung  | Nein.
| charset.conf | Konfiguration für _charset_-Erweiterung | Nein.
| exec.conf    | Konfiguration für _exec_-Erweiterung    | Nein.
| irc.conf     | Konfiguration für _irc_-Erweiterung     | *Ja*: Datei kann Passwörter für Server, Nickserv oder Channels enthalten (sofern diese nicht in `sec.conf` gesichert sind).
| logger.conf  | Konfiguration für _logger_-Erweiterung  | Nein.
| relay.conf   | Konfiguration für _relay_-Erweiterung   | Nein.
| script.conf  | Konfiguration für _script_-Erweiterung  | Nein.
| trigger.conf | Konfiguration für _trigger_-Erweiterung | möglich, hängt von den Triggern ab.
| xfer.conf    | Konfiguration für _xfer_-Erweiterung    | Nein.
| weechat.log  | WeeChat Logdateien                      | Nein.
|===

[IMPORTANT]
Es wird *nicht empfohlen* die Konfigurationsdateien manuell zu editieren, da WeeChat
diese Dateien zu jeder Zeit überschreiben kann (zum Beispiel:  <<command_weechat_quit,/quit>>)
und man eine veränderte Datei mit dem Befehl <<command_weechat_reload,/reload>> neu
laden muss (mit dem Risiko von Datenverlust da Daten kommentarlos überschrieben werden,
bevor man diese ggf. gesichert hat <<command_weechat_save,/save>>). +
Man sollte immer den <<command_weechat_set,/set>> Befehl nutzen, da der Befehl die
Eingabe prüft und Änderungen sofort wirksam werden.

[[screen_layout]]
=== Screen layout

Beispiel des WeeChat-Terminals:

....
 ▼ Bar "title"
┌───────────────────────────────────────────────────────────────────────────┐
│Welcome to #test, this is a test channel                                   │
│12:52:27   --> | Flashy (flashcode@weechat.org) has joined #test   │@Flashy│
│12:52:27    -- | Nicks #test: [@Flashy @joe +weebot peter]         │@joe   │
│12:52:27    -- | Channel #test: 4 nicks (2 ops, 1 voice, 1 normal) │+weebot│
│12:52:27    -- | Channel created on Tue Jan 27 06:30:17 2009       │peter  │
│12:54:15 peter | hey!                                              │       │
│12:55:01  @joe | hello                                             │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│[12:55] [6] [irc/freenode] 3:#test(+n){4}* [H: 4:#abc(2,5), 6]             │
│[@Flashy(i)] hi peter!█                                                    │
└───────────────────────────────────────────────────────────────────────────┘
 ▲ Bars "status" und "input"                               Bar "nicklist" ▲
....

Der Bildschirm setzt sich aus folgenden Bereichen zusammen:

* Chat-Bereich (in der Mitte des Bildschirms). Dieser enthält den Text und zusätzlich für jede Zeile:
** die Uhrzeit
** Prefix (links von dem "|")
** Nachricht (rechts von dem "|")
* Die Bars können um den Chat-Bereich angeordnet werden. Standard-Bars sind:
** _title_ Bar, über dem Chat-Bereich
** _status_ Bar, unter dem Chat-Bereich
** _input_ Bar, unter der Status-Bar
** _nicklist_ Bar, auf der rechten Seite

Die _status_-Bar besitzt als Standardeinträge:

[width="100%",cols="^3,^4,10",options="header"]
|===
| Item                  | Beispiel              | Beschreibung
| time                  | `[12:55]`             | Uhrzeit.
| buffer_last_number    | `[6]`                 | Nummer des letzten Buffers.
| buffer_plugin         | `[irc/freenode]`      | Erweiterung des aktuellen Buffers (IRC Erweiterung setzt den IRC Servername für den Buffer).
| buffer_number         | `3`                   | Aktuelle Nummer des Buffers.
| buffer_name           | `#test`               | Name des aktuellen Buffers.
| buffer_modes          | `+n`                  | IRC Channel-Modi.
| buffer_nicklist_count | `{4}`                 | Anzahl der Nicks in Benutzerliste.
| buffer_zoom           | !                     | `!` bedeutet, dass ein zusammengefügter Buffer gezoomed (nur dieser Buffer wird angezeigt) wird.
| buffer_filter         | `+*+`                 | Filteranzeige: `+*+` bedeutet das Zeilen gefiltert (unterdrückt) wurden. Ein leerer Eintrag zeigt an dass alle Zeilen dargestellt werden.
| scroll                | `-MORE(50)-`          | Scroll Indikator, zeigt an wie viele Zeilen unterhalb der zur Zeit dargestellten Zeile vorhanden sind.
| lag                   | `[Lag: 2.5]`          | Verzögerungsanzeige, in Sekunden (keine Anzeige falls Verzögerung gering).
| hotlist               | `[H: 4:#abc(2,5), 6]` | Liste der Buffer mit Aktivität (ungelesene Nachrichten) (für das Beispiel: 2 Highlights und 5 ungelesene Nachrichten im Channel _#abc_, eine ungelesene Nachricht in Buffer #6).
| completion            | `abc(2) def(5)`       | Liste von Wörtern für Vervollständigung, die Zahl zeigt an wie viele Varianten möglich sind.
|===

In der _input_ Bar lautet die Standardeinstellung:

[width="100%",cols="^3,^4,10",options="header"]
|===
| Item         | Beispiel                                      | Beschreibung
| input_prompt | `[@Flashy(i)]`                                | Input prompt, für irc: Nick und Modi (Modus "+i" bedeutet auf freenode, unsichtbar).
| away         | `(away)`                                      | Abwesenheitsanzeige.
| input_search | `[Search (~ str,msg)]`                        | Suchindikatoren ("`~`": Groß-und Kleinschreibung ignorieren, "`==`": Groß-und Kleinschreibung berücksichtigen, "`str`": einfache Textsuche, "`regex`": suche mit regulären Ausdrücken, "`msg`": Suche in Nachrichten, "`pre`": Suche in Präfix, "`pre\|msg`": Suche in Präfix und Nachrichten).
| input_paste  | `[Paste 7 lines ? [ctrl-Y] Ja [ctrl-N] Nein]` | Nachfrage ob sieben Zeilen eingefügt werden sollen.
| input_text   | `hi peter!`                                   | Text der eingegeben wird.
|===

andere Items die man nutzen kann (die aber nicht standardmäßig in einer Bar aktiviert sind):

[width="100%",cols="^3,^4,10",options="header"]
|===
| Item              | Beispiel            | Beschreibung
| aspell_dict       | `de,en`             | zeigt an welche Wörterbücher für die Rechtschreibung im aktuellen Buffer genutzt werden.
| aspell_suggest    | `Glück,Glocke,Block`| Vorschläge für ein falsch geschriebenes Wort.
| buffer_count      | `10`                | absolute Anzahl an geöffneten Buffern.
| buffer_short_name | `#test`             | Kurzname des aktuellen Buffers.
| irc_channel       | `#test`             | aktueller IRC Channelname.
| irc_nick_modes    | `@`                 | IRC Modi für den eigenen Nick.
| mouse_status      | `M`                 | Status der Maus (keine Anzeige, falls Maus deaktiviert).
| window_number     | `2`                 | Nummer des aktuellen Fensters.
|===

[[command_line]]
=== Befehlszeile

In der WeeChat Befehlszeile (am unteren Rand des Fensters) können Befehle ausgeführt oder
ein Text in den Buffer geschrieben werden.

[[command_line_syntax]]
==== Syntax

Ein Befehl wird durch das Zeichen "/" eingeleitet, gefolgt von dem Namen des Befehls. In folgendem
Beispiel werden alle Konfigurationsoptionen angezeigt:

----
/set
----

Jeder Text der nicht mit dem Zeichen "/" beginnt wird in den Buffer geschrieben.
In folgendem Beispiel wird der Text _Hallo_ in den aktuellen Buffer geschrieben:

----
Hallo
----

Dennoch ist es möglich einen Text in den Buffer zu schreiben der mit dem Zeichen "/" beginnt.
Dazu muss dem ersten "/" ein zweites "/" vorangestellt werden. Um den Befehl `/set` als Text zu senden:

----
//set
----

[[command_line_colors]]
==== Farbkodierung

Für einige Erweiterungen wie z.B. der IRC Erweiterung können Farbkodierungen und Attribute für den
Text gesetzt werden. Dazu muss die Tastenkombination kbd:[Ctrl+c], gefolgt von einem der folgenden
Zeichen, genutzt werden:

[width="60%",cols="3,5",options="header"]
|===
| Taste                  | Beschreibung
| kbd:[Ctrl+c], kbd:[b]  | Text wird fett dargestellt.
| kbd:[Ctrl+c], kbd:[c],
  kbd:[xx]               | Textfarbe `xx` (siehe Farbtabelle).
| kbd:[Ctrl+c], kbd:[c],
  kbd:[xx], kbd:[,],
  kbd:[yy]               | Textfarbe `xx` und Hintergrundfarbe `yy` (siehe Farbtabelle).
| kbd:[Ctrl+c], kbd:[i]  | Text wird kursiv dargestellt.
| kbd:[Ctrl+c], kbd:[o]  | deaktiviert Farben und Attribute.
| kbd:[Ctrl+c], kbd:[v]  | Farben umkehren (kehrt Textfarbe und Hintergrundfarbe um).
| kbd:[Ctrl+c], kbd:[_]  | Text wird mit Unterstrich dargestellt.
|===

[NOTE]
Der selbe Befehl (ohne den Wert für kbd:[Ctrl+c], kbd:[c]) sollte genutzt werden
um die Farbkodierungen bzw. Attribute zu deaktivieren.

Farbtabelle für kbd:[Ctrl+c], kbd:[c]:

include::autogen/user/irc_colors.adoc[]

[NOTE]
Um sich alle verfügbaren Farben anzeigen zu lassen, die der Terminal
unterstützt, kann man in WeeChat die Tastenkombination kbd:[Alt+c]
im `/color` Buffer nutzen oder im Terminal den Befehl `weechat --colors` ausführen.

Beispiel: Im Buffer wird "Hallo an alle!" ausgegeben. Dabei wird "Hallo" in Fettschrift
und hellblau und "an alle" rot und unterstrichen dargestellt.

----
^Cc12^CbHallo ^Cb^Cc04^C_an alle^C_^Cc!
----

[NOTE]
Die Farben können in der IRC Erweiterung neu belegt werden,
mittels der Option <<option_irc.color.mirc_remap,irc.color.mirc_remap>>.

[[colors]]
=== Farben

WeeChat kann bis zu 256 Farbpaarungen nutzen um einen Text in Bars oder im
Chatbereich darzustellen (der Terminal muss natürlich 256 Farben unterstützten).

Gemäß der Einstellung in der _TERM_-Umgebungsvariable bestehen folgende Einschränkungen
was die Farbdarstellung in WeeChat betrifft:

[width="50%",cols="8,>2,>2",options="header"]
|===
| $TERM                                  | Farben | Paare
| "rxvt-unicode", "xterm", ...           |     88 |   256
| "rxvt-256color", "xterm-256color", ... |    256 |   256
| "screen"                               |      8 |    64
| "screen-256color"                      |    256 |   256
| "tmux"                                 |      8 |    64
| "tmux-256color"                        |    256 |   256
|===

Mittels `weechat --colors` oder dem internen WeeChat-Befehl `/color` kann man sich
die Einschränkungen für die jeweilige Umgebungsvariable anzeigen lassen.

Folgende Werte sind für die _TERM_-Umgebungsvariable zu empfehlen, sofern man 256 Farben
nutzen möchte:

* falls screen genutzt wird: _screen-256color_
* für tmux: _screen-256color_ oder _tmux-256color_
* ausserhalb screen/tmux: _xterm-256color_, _rxvt-256color_, _putty-256color_, ...

[NOTE]
Es sollte das Paket "ncurses-term" installiert werden um die Werte der _TERM_
Variable nutzen zu können.

Sollte screen genutzt werden, fügt man folgende Zeile an das Ende der Datei
_~/.screenrc_:

----
term screen-256color
----

Sollte die Umgebungsvariable _TERM_ falsch gesetzt worden sein und WeeChat
wird derweil schon ausgeführt, kann die Variable mit folgenden zwei Befehlen
geändert werden:

----
/set env TERM screen-256color
/upgrade
----

[[colors_basic]]
==== Basisfarben

Basisfarben in WeeChat sind:

[width="50%",cols="^3m,8",options="header"]
|===
| Name         | Farbe
| default      | Standard Terminalfarbe (transparent für Hintergrund)
| black        | Schwarz
| darkgray     | Dunkelgrau
| red          | Dunkelrot
| lightred     | Hellrot
| green        | Dunkelgrün
| lightgreen   | Hellgrün
| brown        | Braun
| yellow       | Gelb
| blue         | Dunkelblau
| lightblue    | Hellblau
| magenta      | Dunkel magenta
| lightmagenta | Hell magenta
| cyan         | Dunkel türkis
| lightcyan    | Hell türkis
| gray         | Grau
| white        | Weiß
|===

[[colors_extended]]
==== erweiterte Farbpalette

WeeChat belegt die Farbpaare dynamisch, sobald die Farbe genutzt werden sollte. Zum Beispiel
um mit einer Farbe Buffer oder Bars zu nutzen.

Zu den Basisfarben können zusätzlich Farben zwischen eins und der maximalen Anzahl an Farben
genutzt werden die vom jeweiligen Terminal zur Verfügung gestellt werden.

Mit dem `/color` Befehl kann man sich sowohl die aktuelle Farbpalette anzeigen lassen als
auch die Anzahl der zu nutzenden Farben. Mit kbd:[Alt+c] kann man vorübergehend zu den
Terminalfarben wechseln um eine Farbe auszuwählen.

Um zum Beispiel die Uhrzeit in einem Buffer in einem schönen Orange darzustellen:

----
/set weechat.color.chat_time 214
----

oder falls man den Hintergrund der Statusbar in einm sehr dunklen Grün haben möchte:

----
/set weechat.bar.status.color_bg 22
----

[[colors_aliases]]
==== Alias

Man kann einer Farbe einen Alias zuordnen um diesen Alias anstelle einer Zahl in
die Optionen einzutragen. Um einen Alias zu definieren nutzt man den Befehl
`/color alias`.

Beispiel:

----
/color alias 214 orange
/set weechat.color.chat_delimiters orange
----

[[colors_attributes]]
==== Attribute

Er ist möglich einer Farbe ein Attribut hinzuzufügen. Dazu wird dem
Farbnamen oder der Farbnummer ein- oder mehrere Attribute vorangestellt.

* `+*+` : fett
* `+!+` : invertierte Darstellung
* `+/+` : kursiven
* `+_+` : unterstrichen
* `+|+` : behält Attribut bei: fett, invertierte Darstellung, Unterstrichen wird beim Farbwechsel nicht zurückgesetzt

Um zum Beispiel dem eigenen Nick die Farbe weiß und unterstrichen
zuzuordnen:

----
/set weechat.color.chat_nick_self _white
----

oder um die Zeitanzeige in der Statusbar orange, fett und unterstrichen
darzustellen:

----
/set weechat.color.status_time *_214
----

Um einer Standard-Terminalfarbe (-1) ein Attribut hinzuzufügen muss eine Zahl
gewählt werden die größer ist als die letzte genutzte Farbe des Terminals.
Zum Beispiel; maximale Farbwahl in WeeChat: 99999.

Um der Vordergrundfarbe des Terminals das Attribut "fett" zuzuordnen:

----
/set weechat.color.status_time *99999
----

[[buffers_and_windows]]
=== Buffer und Fenster

Ein _Buffer_ setzt sich zusammen aus einer Nummer, besitzt einem Namen, hat Zeilen die angezeigt
werden (und noch anderen Daten).

Beispiele von Buffern:

* Core Buffer (wird durch WeeChat beim Programmstart erstellt und kann nicht geschlossen werden!)
* IRC Server  (hier werden die Nachrichten ausgegeben die der Server verschickt)
* IRC Channel
* IRC Privat  (wird auch Query-Buffer genannt)

Ein _Fenster_ ist ein Bildschirmbereich der Buffer darstellt. Es ist möglich
den Bildschirm in mehrere Fenster aufzuteilen.

Jedes Fenster stellt einen Buffer dar. Ein Buffer kann unsichtbar sein (er wird
in einem Fenster nicht angezeigt) oder ein Buffer wird durch ein oder mehrere Fenster
angezeigt.

Beispiele für eine horizontal Fensteraufteilung (`/window splith`):

....
                          ▼ Fenster #2 (Buffer #4)
┌───────────────────────────────────────────────────────────────────────────┐
│Welcome to #abc                                                            │
│12:55:12     Max | hi                                              │@Flashy│
│12:55:20 @Flashy | hi Max!                                         │Max    │
│12:55:32     Max | how are you?                                    │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│[12:55] [6] [irc/freenode] 4:#abc(+n){2}                                   │
│[@Flashy]                                                                  │
│───────────────────────────────────────────────────────────────────────────│
│Welcome to #test                                                           │
│12:54:15 peter | hey!                                              │@Flashy│
│12:55:01  @joe | hello                                             │@joe   │
│                                                                   │+weebot│
│                                                                   │peter  │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│[12:55] [6] [irc/freenode] 3:#test(+n){4}                                  │
│[@Flashy] hi peter!█                                                       │
└───────────────────────────────────────────────────────────────────────────┘
                          ▲ Fenster #1 (Buffer #3)
....

Beispiele für eine vertikale Fensteraufteilung (`/window splitv`):

....
┌───────────────────────────────────────────────────────────────────────────┐
│Welcome to #test                     │Welcome to #abc                      │
│12:54:15 peter | hey!        │@Flashy│12:55:12     Max | hi        │@Flashy│
│12:55:01  @joe | hello       │@joe   │12:55:20 @Flashy | hi Max!   │Max    │
│                             │+weebot│                             │       │
│                             │peter  │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│[12:55] [irc/oftc] 3:#test(+n){4}    │[12:55] [irc/oftc] 4:#abc(+n){2}     │
│[@Flashy] hi peter!█                 │[@Flashy]                            │
└───────────────────────────────────────────────────────────────────────────┘
      ▲ Fenster #1 (Buffer #3)              ▲ Fenster #2 (Buffer #4)
....

Beispiele für eine vertikale und horizontale Fensteraufteilung:

....
                                            ▼ Fenster #3 (Buffer #5)
┌───────────────────────────────────────────────────────────────────────────┐
│Welcome to #test                     │Welcome to #def                      │
│12:54:15 peter | hey!        │@Flashy│12:55:42 @Flashy | hi        │@Flashy│
│12:55:01  @joe | hello       │@joe   │12:55:56    alex | hi Flashy │alex   │
│                             │+weebot│                             │       │
│                             │peter  │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │[12:55] [irc/oftc] 5:#def(+n){2}     │
│                             │       │[@Flashy]                            │
│                             │       │─────────────────────────────────────│
│                             │       │Welcome to #abc                      │
│                             │       │12:55:12     Max | hi        │@Flashy│
│                             │       │12:55:20 @Flashy | hi Max!   │Max    │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│[12:55] [irc/oftc] 3:#test(+n){4}    │[12:55] [irc/oftc] 4:#abc(+n){2}     │
│[@Flashy] hi peter!█                 │[@Flashy]                            │
└───────────────────────────────────────────────────────────────────────────┘
      ▲ Fenster #1 (Buffer #3)              ▲ Fenster #2 (Buffer #4)
....

[[buffers_lines]]
=== Zeilen in Buffern

[[lines_format]]
==== Format von Zeilen

Zeilen die in einem formatierten Buffer dargestellt werden haben folgende Felder:

[width="100%",cols="2,2,10",options="header"]
|===
| Feld                 | Ansicht               | Beschreibung
| Datum/Zeit(Nachricht)| Ja                    | Datum/Zeit einer Nachricht (möglicherweise die Vergangenheit).
| Datum/Zeit(Ausgabe)  | Nein                  | Datum/Zeit wenn WeeChat eine Nachricht ausgibt.
| Präfix               | Ja                    | Präfix einer Nachricht, gewöhnlich der Nick.
| Nachricht            | Ja                    | Die eigentliche Nachricht.
| Ansicht              | Nein                  | Boolean: wahr, falls Zeile angezeigt wird, unwahr, falls die Zeile if line gefiltert wird. Siehe Befehl <<command_weechat_filter,/filter>>.
| Highlight            | Nein                  | Boolean: wahr, falls die Zeile ein Highlight enthält, unwahr, falls nicht.
| Tags                 | mittels `/debug tags` | Tags die im Zusammenhang mit der Zeile stehen (siehe <<lines_tags,lines tags>>).
|===

Die Darstellung von Zeilen kann mittels Optionen individualisiert werden. Zum einen mittels der "look"-Optionen
(_pass:[weechat.look.*]_) und der Color-Optionen (_pass:[weechat.color.chat_*]_).

[[lines_tags]]
==== Tags in Zeilen

WeeChat nutzt Tags für unterschiedliche Aufgaben:

* highlight
* Benachrichtigungsstufe
* logging
* für Befehle <<command_weechat_filter,/filter>>

Tags kann man sich mit dem Befehl `/debug tags` anzeigen lassen (den Befehl ein zweites mal ausführen um die Tags wieder unsichtbar zu machen).

Tags die häufig verwendet werden (keine vollständige Auflistung):

[width="70%",cols="1m,4",options="header"]
|===
| Tag              | Beschreibung
| no_filter        | Zeile kann nicht gefiltert werden.
| no_highlight     | die Zeile kann nicht gehiglighted werden.
| no_log           | Zeile wird nicht in die Log-Datei geschrieben.
| log0 ... log9    | Grad der Protokollierung (siehe `/help logger`).
| notify_none      | Buffer welche die Zeile enthält wird nicht zur Hotlist hinzufügt.
| notify_message   | Buffer welche die Zeile enthält wird mit der Stufe "message" zur Hotlist hinzugefügt.
| notify_private   | Buffer welche die Zeile enthält wird mit der Stufe "private" zur Hotlist hinzugefügt.
| notify_highlight | Buffer welche die Zeile enthält wird mit der Stufe "highlight" zur Hotlist hinzugefügt.
| self_msg         | eigene Nachricht.
| nick_xxx         | Nachricht ist vom Nick "xxx".
| prefix_nick_ccc  | Präfix für den Nick mit der Farbe "ccc".
| host_xxx         | Username und Host in der Nachricht.
| irc_xxx          | IRC Nachricht "xxx" (kann ein Befehl oder eine dreistellige Zahl sein).
| irc_numeric      | IRC nummerische Nachricht.
| irc_error        | Fehler vom IRC Server.
| irc_action       | Action von einem Nick (Befehl `/me`).
| irc_ctcp         | CTCP Nachricht.
| irc_ctcp_reply   | Antwort auf eine CTCP Nachricht.
| irc_smart_filter | IRC Nachricht die mittels "smart filter" unterdrückt werden kann.
| away_info        | Nachricht mit "away" Information.
|===

[[bars]]
=== Bars

Eine _Bar_ ist ein Bereich der parallel, zum Chatfenster, jedwede Art von Text enthalten kann.

Eine Bar kann mittels `weechat.bar.name.option` konfiguriert werden. Dabei steht `name`,
für den Namen der Bar und `option` für die Option für diese Bar.

Aufzählung von Bar-Optionen:

[width="100%",cols="2m,2,10",options="header"]
|===
| Option | Wert   | Beschreibung

| type | `root`, `window` |
  Eine Bar, vom Typ `root`, kann nur einmal, außerhalb von Fenstern, auf dem Bildschirm
  dargestellt werden. Standardmäßig existiert keine `root` Bar. Eine solche Bar, mit Namen
  _buffers_, wird zum Beispiel durch das Skript _buffers.pl_ eingerichtet in welcher alle
  geöffneten Buffer aufgeführt werden. +
  Eine Bar, vom Typ `window`, wird in jedem einzelnen Fenster dargestellt, beispielsweise
  wenn man das Fenster teilt (mit `/window splith` oder `/window splitv`). Die vier
  standardmäßigen Bars (_title_, _status_, _input_, _nicklist_), sind vom Typ `window`.

| position | `top`, `bottom`, `left`, `right` |
  Position der Bar: ober- oder unterhalb des Chatfensters, oder links/rechts davon.

| priority | integer ≥ 0 |
  Priorität für die Bar: legt die Reihenfolge fest in der die Bars angeordnet werden sollen,
  wenn mehrere Bars den selben Typ und Position besitzen. +
  Die Bars werden vom Rand zur Mitte des Bildschirms gezeichnet. Eine höhere Priorität
  bewirkt, dass die Bar näher am Rand gezeichnet wird. +
  Beispiel: Die _input_ Bar hat eine Priorität von 1000 und wird somit vor der _status_ Bars
  gezeichnet, da diese lediglich eine Priorität von 500 besitzt.

| size | integer ≥ 0 |
  Die Größe der Bar: Anzahl der Spalten, falls die Bar links/rechts bzw. Anzahl an Zeilen falls
  die Bar oben/unten dargestellt wird. Wird eine Größe `0` gewählt, dann wird die Größe der Bar
  automatisch bestimmt.

| size_max | integer ≥ 0 |
  Die maximale Größe der Bar, `0` = keine Limitierung (diese Option wird nur genutzt, falls die
  Option `size` = `0` ist).

| color_bg | color |
  Hintergrundfarbe, für die Bar.

| color_fg | color |
  Textfarbe, für die Bar.

| color_delim | color |
  Farbe der Trennzeichen, in der Bar.

| hidden | `on`, `off` |
  Ist diese Option `on`, wird die Bar versteckt. +
  Hinweis: anstelle dieser Option sollte vorzugsweise der `/bar` Befehl genutzt werden.
  Beispiel: `/bar toggle nicklist` (siehe Befehl <<command_weechat_bar,/bar>>).

| separator | `on`, `off` |
  Ist diese Option `on`, wird ein Separator (Linie) gezeichnet die eine Bar von anderen
  Bars oder dem Chatbereich trennt.

| items | string |
  Eine Aufzählung von _items_ (siehe <<bar_items,items>> für weitere Informationen).

| filling_left_right | `horizontal`, `vertical`, `columns_horizontal`, `columns_vertical` |
  Art, wie der Inhalt der Bar die `links` oder `rechts` gezeichnet wird, dargestellt wird (siehe
  <<bar_filling,filling>> für weitere Informationen).

| filling_top_bottom | `horizontal`, `vertical`, `columns_horizontal`, `columns_vertical` |
  Art, wie der Inhalt der Bar die `oben` oder `unten` gezeichnet wird, dargestellt wird (siehe
  <<bar_filling,filling>> für weitere Informationen).

| conditions | string |
  Bedingungen, wann die Bar angezeigt wird (siehe <<bar_conditions,conditions>> für weitere
  Informationen).
|===

[[bar_items]]
==== Items

Die Option _items_ ist ein String, mit einer Anzahl von Bar-Items. Diese werden
durch Kommata voneinander getrennt (auf dem Bildschirm wird das Komma durch ein
Leerzeichen ersetzt). Möchte man die Items ohne Leerzeichen darstellen, nutzt
man ein "+" um die Items zu trennen.

Eine Liste von Bar-Items kann man sich mit dem Befehl `/bar listitems` anzeigen lassen.

Vor oder nach dem Item können Zeichen eingefügt werden. Diese dürfen nicht alphanumerisch,
"-" oder "_" sein. Die Zeichen werden mit der entsprechenden Farbe, für Trennzeichen,
dargestellt (Option _color_delim_).

Beispiel einer Bar mit den Items, "[time],buffer_number+:+buffer_plugin+.+buffer_name":

....
┌───────────────────────────────────────────────────────────────────────────┐
│[12:55] 3:irc/freenode.#weechat                                            │
└───────────────────────────────────────────────────────────────────────────┘
....

Eine Besonderheit stellt die Möglichkeit dar, ein Item eines bestimmten Buffers
anzuzeigen. Syntax: "@buffer:item" ("buffer" ist der vollständige Name des Buffers
und "item" der Name der Bar-Item)

Dies ist für root-Bars sinnvoll, um gezielt ein Item eines bestimmten Buffers
anzuzeigen, welcher nicht im aktuellen Fenster oder überhaupt nicht sichtbar
ist.

Beispiel: Benutzerliste von bitlbee permanent in einer root-Bar darstellen (die Bar
heißt hierbei _bitlist_ und der Name des bitlbee Servers _bitlbee_):

----
/set weechat.bar.bitlist.items "@irc.bitlbee.&bitlbee:buffer_nicklist"
----

[[bar_filling]]
==== Darstellung innerhalb einer Bar

Es gibt folgende vier Möglichkeiten um Text innerhalb einer Bar darzustellen:

* `horizontal`: die Items werden horizontal, von links nach rechts, dargestellt.
   Sollten neue Zeilen dargestellt werden, dann werden diese durch ein Leerzeichen
   von der vorherigen getrennt.
* `vertical`: die Items werden von oben nach unten dargestellt. Neue Zeilen werden
  neben der vorherigen dargestellt.
* `columns_horizontal`: Item werden in Spalten dargestellt, wobei der Text linksbündig
  ausgerichtet ist. Das erste Item wird in der linken oberen Ecke angezeigt und das
  zweite Item ist in der selben Zeile, auf der rechten Seite.
* `columns_vertical`: Item werden in Spalten dargestellt, wobei der Text linksbündig
  ausgerichtet ist. Das erste Item wird in der linken oben Ecke angezeigt und das
  zweite Item wird eine Zeile darunter angezeigt.

Die Standard-Bars _title_, _status_ und _input_ nutzen eine _horizontal_
Darstellung und die Standard-Bar _nicklist_ nutzt eine _vertical_ Darstellung.

Einige Beispiele, wie die Bar _nicklist_ dargestellt werden kann:

....
┌───────────────────────────────────────────────────────────────────────┐
│Welcome to #test, this is a test channel                               │
│12:54:15 peter | hey!                                         │@carl   │
│12:55:01  +Max | hello                                        │@jessika│
│                                                              │@maddy  │
│                                                              │%Diego  │
│                                                              │%Melody │
│                                                              │+Max    │
│                                                              │ celia  │
│                                                              │ Eva    │
│                                                              │ freddy │
│                                                              │ Harold^│
│                                                              │ henry4 │
│                                                              │ jimmy17│
│                                                              │ jodie ▼│
│[12:55] [6] [irc/freenode] 3:#test(+n){24}                             │
│[@carl] █                                                              │
└───────────────────────────────────────────────────────────────────────┘
                                     filling_left_right = vertical ▲

┌───────────────────────────────────────────────────────────────────────┐
│Welcome to #test, this is a test channel                               │
│12:54:15 peter | hey!                                │@carl     lee    │
│12:55:01  +Max | hello                               │@jessika  louise │
│                                                     │@maddy    mario  │
│                                                     │%Diego    mark   │
│                                                     │%Melody   peter  │
│                                                     │+Max      Rachel │
│                                                     │ celia    richard│
│                                                     │ Eva      sheryl │
│                                                     │ freddy   Vince  │
│                                                     │ Harold^  warren │
│                                                     │ henry4   zack   │
│                                                     │ jimmy17         │
│                                                     │ jodie           │
│[12:55] [6] [irc/freenode] 3:#test(+n){24}                             │
│[@carl] █                                                              │
└───────────────────────────────────────────────────────────────────────┘
                             filling_left_right = columns_vertical ▲

┌───────────────────────────────────────────────────────────────────────┐
│@carl    %Diego    celia    Harold^  jodie    mario    Rachel   Vince  │
│@jessika %Melody   Eva      henry4   lee      mark     richard  warren │
│@maddy   +Max      freddy   jimmy17  louise   peter    sheryl   zack   │
│───────────────────────────────────────────────────────────────────────│
│                                                                       │
        filling_top_bottom = columns_vertical ▲

┌───────────────────────────────────────────────────────────────────────┐
│@carl    @jessika @maddy   %Diego   %Melody  +Max      celia    Eva    │
│ freddy   Harold^  henry4   jimmy17  jodie    lee      louise   mario  │
│ mark     peter    Rachel   richard  sheryl   Vince    warren   zack   │
│───────────────────────────────────────────────────────────────────────│
│                                                                       │
      filling_top_bottom = columns_horizontal ▲
....

[[bar_conditions]]
==== Bedingungen

Der Inhalt der Option _conditions_ ist evaluiert um festzulegen ob die entsprechende
Bar angezeigt werden soll oder nicht.

Folgende Zeichenketten sind möglich:

* _active_  : das Fenster muss das aktive Fenster sein
* _inactive_: das Fenster muss das inaktive Fenster sein
* _nicklist_: der Buffer der in einem Fenster dargestellt wird, muss eine
              Benutzerliste anzeigen.
* ein Ausdruck: wird als boolescher Wert ausgewertet (siehe Befehl
  <<command_weechat_eval,/eval>>)

Für den Ausdruck sind folgende Variablen verfügbar:

* `+${active}+`  : wahr, wenn Fenster aktiv ist
* `+${inactive}+`: wahr, wenn Fenster inaktiv ist
* `+${nicklist}+`: wahr, wenn der Buffer im Fenster eine Nicklist anzeigt.

Folgende Zeiger sind verfügbar:

* `+${window}+`: das Fenster in dem der Zustand ausgewertet wird
* `+${buffer}+`: der Buffer eines Fensters in dem der Zustand ausgewertet wird

Beispiel wie man die Bar-Nicklist in allen Buffer, die eine Nicklist besitzen,
darstellt, aber nur wenn das Fenster eine Mindestbreite von > 100 Pixeln aufweist:

----
/set weechat.bar.nicklist.conditions "${nicklist} && ${window.win_width} > 100"
----

Gleiche Bedingungen, aber die Benutzerliste wird im Buffer _&bitlbee_ immer angezeigt
(auch wenn das Fenster kleiner als 100 Pixel ist):

----
/set weechat.bar.nicklist.conditions "${nicklist} && (${window.win_width} > 100 || ${buffer.full_name} == irc.bitlbee.&bitlbee)"
----

[[bare_display]]
=== einfacher Anzeigemodus

Ein vereinfachter Anzeigemodus, mit Namen "bare", kann aktiviert werden um
überlange URLs ganz einfach mit der Maus anzuklicken oder um Text mit der
Maus zu markieren.

Der vereinfachte Anzeigemodus hat folgende Funktionen:

* es wird lediglich der Inhalt des aktuellen Buffers angezeigt, es findet keine
  Aufteilung des Fensters statt, es werden keine Bars angezeigt (Title, Nicklist,
  Status, Input, ...)
* die Mausunterstützung ist deaktiviert (sofern sie aktiviert war): die Maus kann
  wie in einem Terminal genutzt werden um URLs anzuklicken oder Text zu markieren
* ncurses wird nicht genutzt, deshalb werden URLs am Ende der Zeile nicht abgeschnitten.

Der Standardtastenbefehl um den vereinfachten Textmodus zu aktivieren ist kbd:[Alt+l],
mit dem selben Tastenbefehl wird dieser Modus wieder beendet (dieser Modus kann auch
mit jeder beliegen Tasteneingabe beendet werden, siehe Option
<<option_weechat.look.bare_display_exit_on_input,weechat.look.bare_display_exit_on_input>>).

Das Format für die Zeitanzeige kann mit folgender Option angepasst werden
<<option_weechat.look.bare_display_time_format,weechat.look.bare_display_time_format>>.

Der vereinfachte Anzeigemodus kann mit einer vorgegebenen Zeit gestartet werden
<<command_weechat_window,/window>>.

Im normalen Modus sieht WeeChat wie folgt aus:

....
┌───────────────────────────────────────────────────────────────────────────┐
│Welcome to #test, this is a test channel                                   │
│12:52:27   --> | Flashy (flashcode@weechat.org) has joined #test   │@Flashy│
│12:52:27    -- | Nicks #test: [@Flashy @joe +weebot peter]         │@joe   │
│12:52:27    -- | Channel #test: 4 nicks (2 ops, 1 voice, 1 normal) │+weebot│
│12:52:27    -- | Channel created on Tue Jan 27 06:30:17 2009       │peter  │
│12:54:15 peter | hey!                                              │       │
│12:55:01  @joe | peter: hook_process: https://weechat.org/files/do │       │
│               | c/devel/weechat_plugin_api.en.html#_weechat_hook_ │       │
│               | process                                           │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│[12:55] [6] [irc/freenode] 3:#test(+n){4}* [H: 4:#abc(2,5), 6]             │
│[@Flashy(i)] hi peter!█                                                    │
└───────────────────────────────────────────────────────────────────────────┘
....

Der selbe Bildschirm sieht im vereinfachten Anzeigemodus wie folgt aus:

....
┌───────────────────────────────────────────────────────────────────────────┐
│                                                                           │
│                                                                           │
│                                                                           │
│                                                                           │
│                                                                           │
│                                                                           │
│                                                                           │
│                                                                           │
│                                                                           │
│                                                                           │
│                                                                           │
│                                                                           │
│                                                                           │
│12:52 --> Flashy (flashcode@weechat.org) has joined #test                  │
│12:52 -- Nicks #test: [@Flashy @joe +weebot peter]                         │
│12:52 -- Channel #test: 4 nicks (2 ops, 1 voice, 1 normal)                 │
│12:52 -- Channel created on Tue Jan 27 06:30:17 2009                       │
│12:54 <peter> hey!                                                         │
│12:55 <@joe> peter: hook_process: https://weechat.org/files/doc/devel/weech│
│at_plugin_api.en.html#_weechat_hook_process                                │
└───────────────────────────────────────────────────────────────────────────┘
....

Es kann nun die URL von _joe_ ohne Probleme angeklickt werden (dies setzt
natürlich voraus, dass der Terminal das Anwählen von URLs unterstützt).

[[notify_levels]]
=== Benachrichtigungsstufen

[[setup_notify_levels]]
==== Benachrichtigungsstufen einstellen

Es gibt vier Benachrichtigungsstufen für Nachrichten, welche in Buffern dargestellt
werden. Nachfolgend eine Liste, sortiert von niedrig nach hoch:

*       _low_: Nachricht mit einer geringen Wertigkeit (zum Beispiel: IRC join/part/quit)
*   _message_: Nachricht von einem User
*   _private_: Nachricht in einem privaten Buffer
* _highlight_: wenn es sich um eine _highlight_ Nachricht handelt

Jeder Buffer besitzt eine Benachrichtigungsstufe, um festzulegen, bei welchen Nachrichten
der entsprechende Buffer in der Hotlist angezeigt werden soll.

Der Wert für die Benachrichtigungsstufe kann mittels folgender Option festgelegt
werden:
<<option_weechat.look.buffer_notify_default,weechat.look.buffer_notify_default>>,
Der Standardwert ist _all_.

[width="50%",cols="3m,10",options="header"]
|===
| Benachrichtigungsstufe | Welche Nachrichten Berücksichtigung in der Hotlist finden
| none                   | (keine)
| highlight              | _highlight_ + _private Nachrichten_
| message                | _highlight_ + _private Nachrichten_ + _normale Nachrichten_
| all                    | _highlight_ + _private Nachrichten_ + _normal Nachrichten_ + _Nachrichten mit einer niedrigen Priorität_
|===

Benachrichtigungsstufen können für mehrere Buffer definiert werden. Zum Beispiel
für alle Buffer des IRC Servers "freenode":

----
/set weechat.notify.irc.freenode message
----

Setzt die Benachrichtigungsstufe ausschließlich für den Channel "#weechat",
auf die Stufe _highlight_:

----
/set weechat.notify.irc.freenode.#weechat highlight
----

Die Benachrichtigungsstufe für einen Buffer kann mittels dem `/buffer`
Befehl festgelegt werden:

----
/buffer notify highlight
----

[[max_hotlist_level_nicks]]
==== Maximaler Hotlist-Level für Nicks

Es ist möglich den sogeannten maximalen Hotlist-Level für einzele Nicks einzustellen,
per Buffer oder für mehrere Gruppen (wie IRC Server).

Die Buffer-Eigenschaft "hotlist_max_level_nicks" kann mit einer Anzahl von Nicks genutzt werden
und für jeden einzelen Nick kann ein maximler Hotlist-Level eingestellt wertden. Mögliche Stufen sind:

* -1: keine Änderungen an der Hotlist für den entsprechenden Nick
* 0: niedrige Priorität (zum Beispiel join/part Nachrichten)
* 1: Nachricht
* 2: private Nachricht
* 3: Highlight (eigentlich unnötigt, da es standardmäßig die höchste Stufe für alle Nachrichten ist)

Um zum Bespiel Highlights von "joe" und "mike" im aktuellen Buffer zu deaktivieren:

----
/buffer set hotlist_max_level_nicks_add joe:2,mike:2
----

[NOTE]
Die Buffer-Eigenschaft "hotlist_max_level_nicks" ist keine permanente Einstellung und wird nicht
in der Konfigurationsdatei gesichert. + Um diese Einstellung persistent zu machen benötigt man
das Skript _buffer_autoset.py_: Um das Skript zu installieren `/script install buffer_autoset.py`
und um eine Hilfe zu erhalten wie man es nutzt: `/help autosetbuffer`.

[[highlights]]
=== Highlights

[[highlights_words]]
==== Worte als Highlights hinzufügen

Standardmäßig werden in WeeChat alle Nachrichten von anderen Personen als highlight
deklariert wenn diese den eigenen Nick beinhalten, deshalb ist ein highlight abhängig
vom jeweiligen Buffer (ein Nick kann in je nach Buffer unterschiedlich sein)

Es können weitere Wörter zu den highlights hinzugefügt werden, mit der Option
<<option_weechat.look.highlight,weechat.look.highlight>>,  zum Beispiel um
neben dem eigenen Nick auch die Wörter "Wort1","Wort2" und alle Wörter die mit
"Test" beginnen zu highlighten:

----
/set weechat.look.highlight Wort1,Wort2,Test*
----

Wird eine spezielle Regel benötigt, dann können reguläre Ausdrücke
verwendet werden. Dazu sollte man folgende Option nutzen:
<<option_weechat.look.highlight_regex,weechat.look.highlight_regex>>,
um zum Beispiel die Wörter "flashcode", "flashcöde" und "flashy"
zu highlighten:

----
/set weechat.look.highlight_regex flashc[oö]de|flashy
----

Die Trennzeichen die Wörter umschließen können angepasst werden, mit der
Option:  <<option_weechat.look.word_chars_highlight,weechat.look.word_chars_highlight>>.

[[highlights_tags]]
==== Tags zu highlight hinzufügen

Zeilen die in einem Buffer dargestellt werden enthalten "tags" welche zusätzliche
Informationen über die Herkunft der Nachricht oder über die Nachricht selbst
beinhalten. + Diese "tags" können mit dem Befehl `/debug tags` dargestellt werden
(um die Anzeige wieder zu entfernen, nochmals den Befehl ausführen).

Um Tags als Highlights zu nutzen wird folgende Option verwendet:
<<option_weechat.look.highlight_tags,weechat.look.highlight_tags>>.
Tags werden durch Kommata getrennt und mehrere Tags können mit 
"+" genutzt werden um ein logischen "und" zu erstellen.

Zum Beispiel um alle Nachrichten vom Nick "FlashCode" und alle notice-Nachrichten
von Nicks die mit "toto" beginnen zu highlighten:

----
/set weechat.look.highlight_tags "nick_flashcode,irc_notice+nick_toto*"
----

[[highlights_regex_buffer]]
==== Highlights mit regulärem Ausdruck für einen Buffer nutzen

Man kann reguläre Ausdrücke für Highlights in einem Buffer nutzen indem man
die Eigenschaft des Buffers mittels "highlight_regex" anpasst.

Um zum Beispiel jede Nachricht im aktuellen Buffer als Highlight-Nachricht einzustufen:

----
/buffer set highlight_regex .*
----

[NOTE]
Die Buffer-Eigenschaft "highlight_regex" ist keine permanente Einstellung und wird nicht
in der Konfigurationsdatei gesichert. + Um diese Einstellung persistent zu machen benötigt man
das Skript _buffer_autoset.py_: Um das Skript zu installieren `/script install buffer_autoset.py`
und um eine Hilfe zu erhalten wie man es nutzt: `/help autosetbuffer`.

[[key_bindings]]
=== Standard Tastenbelegung

[[key_bindings_command_line]]
==== Tastenbefehle für die Befehlszeile

[width="100%",cols="^.^3,.^8,.^5",options="header"]
|===
| Taste           | Beschreibung | Befehl
| kbd:[←] +
  kbd:[Ctrl+b]    | setzt den Cursor eine Position nach links. | `/input move_previous_char`
| kbd:[→] +
  kbd:[Ctrl+f]    | setzt den Cursor eine Position nach rechts. | `/input move_next_char`
| kbd:[Ctrl+←] +
  kbd:[Alt+b]     | springt in der Befehlszeile zum Anfang des vorherigen Wortes. | `/input move_previous_word`
| kbd:[Ctrl+→] +
  kbd:[Alt+f]     | springt in der Befehlszeile zum Anfang des nächsten Wortes. | `/input move_next_word`
| kbd:[Home] +
  kbd:[Ctrl+a]    | springt zum Anfang der Befehlszeile. | `/input move_beginning_of_line`
| kbd:[End] +
  kbd:[Ctrl+e]    | springt ans Ende der Befehlszeile. | `/input move_end_of_line`
| kbd:[Ctrl+c],
  kbd:[b]         | fügt Steuerzeichen für fett geschrieben Text ein. | `/input insert \x02`
| kbd:[Ctrl+c],
  kbd:[c]         | fügt Steuerzeichen für Textfarbe ein. | `/input insert \x03`
| kbd:[Ctrl+c],
  kbd:[i]         | fügt Steuerzeichen für kursiven Text ein. | `/input insert \x1D`
| kbd:[Ctrl+c],
  kbd:[o]         | fügt Steuerzeichen für Standardfarbe ein. | `/input insert \x0F`
| kbd:[Ctrl+c],
  kbd:[v]         | fügt Steuerzeichen für Hintergrundfarbe ein. | `/input insert \x16`
| kbd:[Ctrl+c],
  kbd:[_]         | fügt Steuerzeichen für unterstrichenen Text ein. | `/input insert \x1F`
| kbd:[Del] +
  kbd:[Ctrl+d]    | entfernt in der Befehlszeile das nächste Zeichen. | `/input delete_next_char`
| kbd:[Backsp.] +
  kbd:[Ctrl+h]    | entfernt in der Befehlszeile das vorherige Zeichen. | `/input delete_previous_char`
| kbd:[Ctrl+k]    | entfernt alle Zeichen vom Cursor bis zum Ende der Zeile (die Zeichenkette wird dabei in die interne Zwischenablage kopiert). | `/input delete_end_of_line`
| kbd:[Ctrl+r]    | Textsuche im Verlaufsspeicher des Buffers (siehe <<key_bindings_search_context,Tasten für Such-Kontext>>). | `/input search_text_here`
| kbd:[Ctrl+t]    | Zeichen austauschen. | `/input transpose_chars`
| kbd:[Ctrl+u]    | entfernt alle Zeichen vom Cursor bis zum Anfang der Zeile (die Zeichenkette wird dabei in die interne Zwischenablage kopiert). | `/input delete_beginning_of_line`
| kbd:[Ctrl+w]    | entfernt das Wort links vom Cursor (die Zeichenkette wird dabei in die interne Zwischenablage kopiert). | `/input delete_previous_word`
| kbd:[Ctrl+y]    | fügt den Inhalt der internen Zwischenablage ein. | `/input clipboard_paste`
| kbd:[Ctrl+_]    | Rückgängig machen der letzten Aktion, in der Befehlszeile. | `/input undo`
| kbd:[Alt+_]     | Wiederherstellen der letzten Aktion, in der Befehlszeile. | `/input redo`
| kbd:[Tab]       | Vervollständigung von Befehlen oder Nicks (nochmaliges kbd:[Tab]: findet nächste Vervollständigung). | `/input complete_next`
| kbd:[Shift+Tab] | ohne Vervollständigung: führt eine teilweise Vervollständigung durch. Bei unerledigter Vervollständigung : wird die vorherige Vervollständigung genutzt. | `/input complete_previous`
| kbd:[Enter] +
  kbd:[Ctrl+j] +
  kbd:[Ctrl+m]    | führt einen Befehl aus oder sendet den Text  (im Such-Modus: stoppt Suche). | `/input return`
| kbd:[↑]         | ruft vorherigen Befehl oder Nachricht aus dem Verlaufsspeicher auf (im Such-Modus: rückwärts suchen). | `/input history_previous`
| kbd:[↓]         | ruft nächsten Befehl oder Nachricht aus dem Verlaufsspeicher auf (im Such-Modus: vorwärts suchen). | `/input history_next`
| kbd:[Ctrl+↑]    | ruft vorherigen Befehl/Nachricht aus dem globalen Verlaufsspeicher auf (für alle Buffer). | `/input history_global_previous`
| kbd:[Ctrl+↓]    | ruft nächsten Befehl/Nachricht aus dem globalen Verlaufsspeicher auf (für alle Buffer). | `/input history_global_next`
| kbd:[Alt+d]     | löscht das Wort rechts vom Cursor (die Zeichenkette wird dabei in die interne Zwischenablage kopiert). | `/input delete_next_word`
| kbd:[Alt+k]     | zeigt den Tastencode, einschließlich des eingebundenen Befehls, einer Tastenkombination an und fügt diesen in die Befehlszeile ein. | `/input grab_key_command`
| kbd:[Alt+r]     | komplette Eingabezeile lösche.n| `/input delete_line`
| kbd:[Alt+s]     | schaltet die Aspell Funktion an/aus. | `/mute aspell toggle`
|===

[[key_bindings_buffers_windows]]
==== Tastenbefehle für Buffer / Fenster

[width="100%",cols="^.^3,.^8,.^5",options="header"]
|===
| Taste           | Beschreibung | Befehl
| kbd:[Ctrl+l]    | Fenster wird neu gezeichnet. | `/window refresh`
| kbd:[Ctrl+s],
  kbd:[Ctrl+u]    | setzt für alle Buffer die Markierung für ungelesene Nachrichten. | `/input set_unread`
| kbd:[Ctrl+x]    | sind mehrere Buffer zu einem Buffer zusammen gefügt wechselt man diese durch. | `/input switch_active_buffer`
| kbd:[Alt+x]     | Zoom eines zusammengefügten Buffers (kbd:[Alt+x] ein zweites mal: alle zusammengefügten Buffer werden angezeigt). | `/input zoom_merged_buffer`
| kbd:[PgUp]      | eine Seite im Verlaufsspeicher des Buffers nach oben blättern. | `/window page_up`
| kbd:[PgDn]      | eine Seite im Verlaufsspeicher des Buffer nach unten blättern. | `/window page_down`
| kbd:[Alt+PgUp]  | einige Zeilen im Verlaufsspeicher des Buffer nach oben blättern. | `/window scroll_up`
| kbd:[Alt+PgDn]  | einige Zeilen im Verlaufsspeicher des Buffer nach unten blättern. | `/window scroll_down`
| kbd:[Alt+Home]  | springt zur ersten Zeile des Verlaufsspeichers des aktuellen Buffer.s| `/window scroll_top`
| kbd:[Alt+End]   | springt zur letzten Zeile des Verlaufsspeichers des aktuellen Buffers. | `/window scroll_bottom`
| kbd:[Alt+←] +
  kbd:[Alt+↑] +
  kbd:[Ctrl+p] +
  kbd:[F5]        | zum vorherigen Buffer springen. | `/buffer -1`
| kbd:[Alt+→] +
  kbd:[Alt+↓] +
  kbd:[Ctrl+n] +
  kbd:[F6]        | zum nächsten Buffer springen. | `/buffer +1`
| kbd:[F7]        | zum vorherigen Fenster wechseln. | `/window -1`
| kbd:[F8]        | zum nächsten Fenster wechseln. | `/window +1`
| kbd:[F9]        | Titel des Buffers nach links verschieben. | `+/bar scroll title * -30%+`
| kbd:[F10]       | Titel des Buffers nach rechts verschieben. | `+/bar scroll title * +30%+`
| kbd:[F11]       | Benutzerliste um eine Seite nach oben blättern. | `/bar scroll nicklist * -100%`
| kbd:[F12]       | Benutzerliste um eine Seite nach unten blättern. | `/bar scroll nicklist * +100%`
| kbd:[Alt+F11]   | springt zum Anfang der Benutzerliste. | `/bar scroll nicklist * b`
| kbd:[Alt+F12]   | springt zum Ende der Benutzerliste. | `/bar scroll nicklist * e`
| kbd:[Alt+a]     | wechselt zum nächsten Buffer mit Aktivität (nach Priorität: highlight, Nachricht, ...). | `/input jump_smart`
| kbd:[Alt+h]     | löscht Hotliste (Aktivitätsanzeige für die Buffer). | `/input hotlist_clear`
| kbd:[Alt+j],
  kbd:[Alt+f]     | wechselt zum ersten Buffer. | `/buffer -`
| kbd:[Alt+j],
  kbd:[Alt+l]     | wechselt zum letzten Buffer. | `/buffer +`
| kbd:[Alt+j],
  kbd:[Alt+r]     | wechselt zum IRC RAW Buffer. | `/server raw`
| kbd:[Alt+j],
  kbd:[Alt+s]     | wechselt zum IRC Server Buffer. | `/server jump`
| kbd:[Alt+0...9] | wechselt zum Buffer mit der Nummer (0 = 10). | `/buffer *N`
| kbd:[Alt+j],
  kbd:[01...99]   | wechselt zum Buffer mit der angegeben Nummer. | `/buffer *NN`
| kbd:[Alt+l]     | schaltet einfachen Anzeigemodus an/aus. | `/window bare`
| kbd:[Alt+m]     | schaltet Mausfunktion ein/aus. | `/mouse toggle`
| kbd:[Alt+n]     | springt zur nächsten Highlight Nachricht. | `/window scroll_next_highlight`
| kbd:[Alt+p]     | springt zur vorherigen Highlight Nachricht. | `/window scroll_previous_highlight`
| kbd:[Alt+u]     | springt zur ersten ungelesenen Zeile im Buffer. | `/window scroll_unread`
| kbd:[Alt+w],
  kbd:[Alt+↑]     | wechselt zum oberen Fenster. | `/window up`
| kbd:[Alt+w],
  kbd:[Alt+↓]     | wechselt zum unteren Fenster. | `/window down`
| kbd:[Alt+w],
  kbd:[Alt+←]     | wechselt zum linken Fenster. | `/window left`
| kbd:[Alt+w],
  kbd:[Alt+→]     | wechselt zum rechten Fenster. | `/window right`
| kbd:[Alt+w],
  kbd:[Alt+b]     | passt die Größe aller Fenster an. | `/window balance`
| kbd:[Alt+w],
  kbd:[Alt+s]     | Wechselt Buffer von zwei Fenstern. | `/window swap`
| kbd:[Alt+z]     | Zoom für aktuelles Fenster (nochmals kbd:[Alt+z]: stellt die vorherigen Einstellungen wieder her). | `/window zoom`
| kbd:[Alt+<]     | springt zum letzten besuchten Buffer. | `/input jump_previously_visited_buffer`
| kbd:[Alt+>]     | springt zum nächsten besuchten Buffer. | `/input jump_next_visited_buffer`
| kbd:[Alt+/]     | wechselt zum jeweils zuletzt angezeigten Buffern. | `/input jump_last_buffer_displayed`
| kbd:[Alt+=]     | schaltet Filterfunktion an/aus. | `/filter toggle`
| kbd:[Alt+-]     | schaltet, für den aktuellen Buffer, Filterfunktion an/aus. | `/filter toggle @`
|===

[[key_bindings_search_context]]
==== Tasten für "Suchen"-Kontext

Diese Tasten werden im Kontext "search" verwendet (wenn kbd:[Ctrl+r] genutzt wird um
in einem Buffer nach einem Text zu suchen).

[width="100%",cols="^.^3,.^8,.^5",options="header"]
|===
| Taste          | Beschreibung | Befehl
| kbd:[Ctrl+r]   | Wechsel des Suchmodus: einfache Textsuche (Standard), reguläre Ausdrücke. | `/input search_switch_regex`
| kbd:[Alt+c]    | auf Groß-/Kleinschreibung umschalten. | `/input search_switch_case`
| kbd:[Tab]      | wechselt Suche in: Nachricht (Standard), im Präfix, Präfix + Nachricht. | `/input search_switch_where`
| kbd:[↑]        | sucht vorheriger Zeile. | `/input search_previous`
| kbd:[↓]        | sucht nächste Zeile . | `/input search_next`
| kbd:[Enter] +
  kbd:[Ctrl+j] +
  kbd:[Ctrl+m]   | beendet Suche ab aktueller Position. | `/input search_stop_here`
| kbd:[Ctrl+q]   | beendet Suche und blättert zum Ende des Buffers. | `/input search_stop`
|===

[[key_bindings_cursor_context]]
==== Tasten für "Cursor"-Kontext

Diese Tasten werden im Kontext "cursor" verwendet (Cursor kann frei auf dem Bildschirm bewegt werden)

[width="100%",cols="^.^3,^.^2,.^7,.^7",options="header"]
|===
| Taste          | Bereich       | Beschreibung | Befehl
| kbd:[↑]        | -             | bewegt Cursor eine Zeile nach oben. | `/cursor move up`
| kbd:[↓]        | -             | bewegt Cursor eine Zeile nach unten. | `/cursor move down`
| kbd:[←]        | -             | bewegt Cursor eine Spalte nach links. | `/cursor move left`
| kbd:[→]        | -             | bewegt Cursor eine Spalte nach rechts. | `/cursor move right`
| kbd:[Alt+↑]    | -             | bewegt Cursor einen Bereich nach oben. | `/cursor move area_up`
| kbd:[Alt+↓]    | -             | bewegt Cursor einen Bereich nach unten. | `/cursor move area_down`
| kbd:[Alt+←]    | -             | bewegt Cursor einen Bereich nach links. | `/cursor move area_left`
| kbd:[Alt+→]    | -             | bewegt Cursor einen Bereich nach rechts. | `/cursor move area_right`
| kbd:[m]        | Chat          | quotet Nachricht. | `hsignal:chat_quote_message;/cursor stop`
| kbd:[q]        | Chat          | quotet prefix + Nachricht. | `hsignal:chat_quote_prefix_message;/cursor stop`
| kbd:[Q]        | Chat          | quotet Uhrzeit + prefix + Nachricht. | `hsignal:chat_quote_time_prefix_message;/cursor stop`
| kbd:[b]        | Benutzerliste | verbannt nick (Ban). | `/window ${_window_number};/ban ${nick}`
| kbd:[k]        | Benutzerliste | kickt nick. | `/window ${_window_number};/kick ${nick}`
| kbd:[K]        | Benutzerliste | kickt und verbannt nick. | `/window ${_window_number};/kickban ${nick}`
| kbd:[q]        | Benutzerliste | öffnet privaten Chat mit Nick. | `/window ${_window_number};/query ${nick};/cursor stop`
| kbd:[w]        | Benutzerliste | führt einen whois für Nick aus. | `/window ${_window_number};/whois ${nick}`
| kbd:[Enter] +
  kbd:[Ctrl+j] +
  kbd:[Ctrl+m]   | -             | beendet den Cursor-Modus. | `/cursor stop`
|===

[[key_bindings_mouse_context]]
==== Tasten für "mouse"-Kontext

Diese Tasten werden im Kontext "mouse" verwendet, wenn eine Mausfunktion genutzt worden ist.

[width="100%",cols="^.^3,^.^3,^.^3,.^8,.^8",options="header"]
|===
| Maustaste ^(1)^ | Mausgeste    | Bereich              | Beschreibung | Befehl
| ◾◽◽             | -            | Chat                 | wechselt zum Fenster. | `/window ${_window_number}`
| ◾◽◽             | links        | Chat                 | zum vorherigen Buffer springen. | `/window ${_window_number};/buffer +1`
| ◾◽◽             | rechts       | Chat                 | zum nächsten Buffer springen. | `/window ${_window_number};/buffer +1`
| ◾◽◽             | links(lang)  | Chat                 | wechselt zum ersten Buffer. | `/window ${_window_number};/buffer 1`
| ◾◽◽             | rechts(lang) | Chat                 | wechselt zum letzten Buffer. | `/window ${_window_number};/input jump_last_buffer`
| ◾◽◽             | -            | chat (script buffer) | wählt einen Eintrag im Script-Buffer aus. | `/script go ${_chat_line_y}`
| ◽◽◾             | -            | chat (script buffer) | installiert/entfernt ein Skript. | `/script go ${_chat_line_y};/script installremove -q ${script_name_with_extension}`
| ⇑               | -            | Chat                 | mehrere Zeilen im Verlaufsspeicher des Buffer nach oben blättern. | `/window scroll_up -window ${_window_number}`
| ⇓               | -            | Chat                 | mehrere Zeilen im Verlaufsspeicher des Buffer nach unten blättern. | `/window scroll_down -window ${_window_number}`
| ⇑               | -            | chat (script buffer) | fünf Zeilen nach oben blättern, im Script-Buffer. | `/script up 5`
| ⇓               | -            | chat (script buffer) | fünf Zeilen nach unten blättern, im Script-Buffer. | `/script down 5`
| kbd:[Ctrl+⇑]    | -            | chat                 | horizontal, nach links scrollen. | `/window scroll_horiz -window ${_window_number} -10%`
| kbd:[Ctrl+⇓]    | -            | chat                 | horizontal, nach rechts scrollen. | `/window scroll_horiz -window ${_window_number} +10%`
| ◾◽◽             | hoch         | Benutzerliste        | Benutzerliste um eine Seite nach oben blättern. | `/bar scroll nicklist ${_window_number} -100%`
| ◾◽◽             | runter       | Benutzerliste        | Benutzerliste um eine Seite nach unten blättern. | `/bar scroll nicklist ${_window_number} +100%`
| ◾◽◽             | hoch(lang)   | Benutzerliste        | springt zum Anfang der Benutzerliste. | `/bar scroll nicklist ${_window_number} b`
| ◾◽◽             | runter(lang) | Benutzerliste        | springt zum Ende der Benutzerliste. | `/bar scroll nicklist ${_window_number} e`
| ◾◽◽             | -            | Benutzerliste        | öffnet privaten Chat mit Nick. | `/window ${_window_number};/query ${nick}`
| ◽◽◾             | -            | Benutzerliste        | führt einen whois für Nick aus. | `/window ${_window_number};/whois ${nick}`
| ◾◽◽             | links        | Benutzerliste        | kickt Nick. | `/window ${_window_number};/kick ${nick}`
| ◾◽◽             | links(lang)  | Benutzerliste        | kickt und verbannt Nick. | `/window ${_window_number};/kickban ${nick}`
| ◽◽◾             | links        | Benutzerliste        | verbannt Nick. | `/window ${_window_number};/ban ${nick}`
| ◽◽◾             | -            | Input                | fängt ein Mausereignis und fügt dieses in die Befehlszeile ein. | `/input grab_mouse_area`
| ⇑               | -            | jede Bar             | blättert Bar um 20% nach oben. | `/bar scroll ${_bar_name} ${_window_number} -20%`
| ⇓               | -            | jede Bar             | blättert Bar um 20% nach unten. | `/bar scroll ${_bar_name} ${_window_number} +20%`
| ◽◾◽             | -            | überall              | aktiviert den Cursor-Modus an dieser Position. | `/cursor go ${_x},${_y}`
|===

[NOTE]
^(1)^ "⇑" und "⇓" sind Symbole für Mausrad hoch/runter.

[[mouse]]
=== Mausunterstützung

WeeChat unterstützt Maustasten als auch Mausgesten. Dies funktioniert sowohl im
lokalen Terminal wie auch über eine Remote Verbindung via SSH.

[[mouse_enable]]
==== Mausunterstützung aktivieren

Um die Mausunterstützung beim Programmstart zu aktivieren:

----
/set weechat.look.mouse on
----

Um die Mausunterstützung direkt zu aktivieren, kann man den Tastenkurzbefehl
kbd:[Alt+m] nutzen oder folgenden Befehl ausführen:

----
/mouse enable
----

Es ist möglich die Mausunterstützung kurzzeitig zu deaktivieren und dies auf
einen Tastenkurzbefehl zu legen. Zum Beispiel soll über den Tastenkurzbefehl
kbd:[Alt+%] die Mausunterstützung für 10 Sekunden deaktiviert werden:

----
/key bind meta-% /mouse toggle 10
----

[IMPORTANT]
Ist die Maus in Weechat aktiviert werden alle Mausereignisse duch WeeChat gefangen.
Dadurch werden Aktionen wie Kopieren+Einfügen oder Klicks auf URLs nicht an das
Terminal weitergereicht. + Mittels der kbd:[Shift] Taste kann aber das Mausereignis
an das Terminal weitergeleitet werden, als ob die Maus deaktiviert wäre (bei
einigen  Terminals, wie z.B. iTerm, muß die Taste kbd:[Alt] anstelle von
kbd:[Shift] verwendet werden).

[NOTE]
Sollten Probleme bei der Mausunterstützung auftreten, dann sollte Bitte die _WeeChat FAQ_ gelesen werden.

[[mouse_bind_events]]
==== Befehle einem Maus-Ereignis zuweisen

Es gibt eine Anzahl von Maus-Ereignissen, die standardmäßig durch WeeChat definiert
sind (siehe <<key_bindings_mouse_context,Tasten für "mouse"-Kontext>>).

Man kann mit dem Befehl `/key` im Kontext "mouse" aber auch eigene Befehle zuweisen
und löschen (für die Syntax, siehe Befehl <<command_weechat_key,/key>>).

Der Name eines Ereignisses besteht aus einem Modifier (optional), einer Maustaste/Mausrad
und der Mausgeste (optional). Die unterschiedlichen Elemente werden durch ein "-" getrennt.

Liste der Modifiers:

[width="50%",cols="3m,4",options="header"]
|===
| Modifier | Beschreibung
| ctrl     | Taste kbd:[Ctrl]
| alt      | Taste kbd:[Alt]
| ctrl-alt | Taste kbd:[Ctrl] + kbd:[Alt]
|===

Liste der Maustasten/Mausrad:

[width="50%",cols="3m,4",options="header"]
|===
| Maustaste/-rad      | Beschreibung
| button1             | Linker Mausknopf wird gedrückt
| button2             | Rechter Mausknopf wird gedrückt
| button3             | Mittlerer Mausknopf wird gedrückt (häufig der Druck auf das Mausrad)
| button4 ... button9 | Ein zusätzlicher Mausknopf wird gedrückt
| wheelup             | Mausrad wird nach oben gescrollt
| wheeldown           | Mausrad wird nach unten gescrollt
|===

Liste der Mausgesten (nur für Maustasten, nicht für das Mausrad, anwendbar):

[width="50%",cols="3m,4",options="header"]
|===
| Mausgeste          | Distanz
| gesture-up         | 3 ... 19
| gesture-up-long    | ≥ 20
| gesture-down       | 3 ... 19
| gesture-down-long  | ≥ 20
| gesture-left       | 3 ... 39
| gesture-left-long  | ≥ 40
| gesture-right      | 3 ... 39
| gesture-right-long | ≥ 40
|===

Liste von unvollständigen Ereignissen (nur für Mausknopf, nützlich für Erweiterungen/Skripten):

[width="50%",cols="3m,4",options="header"]
|===
| Ereignis   | Beschreibung
| event-down | Mausknopf ist gedrückt
| event-drag | Maus wurde mit gedrücktem Mausknopf bewegt
|===

Bespiele von Ereignissen:

* `button1`
* `ctrl-button1`
* `button1-gesture-right`
* `button1-event-down`
* `button1-event-drag`
* `alt-button2-gesture-down-long`
* `wheelup`
* `ctrl-alt-wheeldown`

[TIP]
Wird eine Funktion im "mouse"-Kontext hinzufügt ist es möglich, mehrere
Mausereignisse mittels `+*+` abzufangen. Zum Beispiel fängt
`+button1-gesture-*+` alle Mausgesten ab, die mit der linken Maustaste
eingeleitet werden.

[TIP]
Den Namen eines Mausereignisses kann man mittels des Befehls `/input grab_mouse` erfragen.
Man führt den Befehl in der Eingabezeile aus und startet das Ereignis. Als Ergebnis erhält
man in der Eingabezeile den Namen des ausgeführten Mausereignisses.

[[secured_data]]
=== sensible Daten

[[secured_data_storage]]
==== Archivierung

WeeChat kann Passwörter oder sensible Daten verschlüsseln und in der
Datei _sec.conf_ speichern.

Diese Konfigurationsdatei wird vor allen anderen Dateien geladen und die
gespeicherten Daten können in verschiedenen WeeChat Optionen bzw.
Erweiterungen und Skripten genutzt werden.

Es kann eine Passphrase genutzt werden um die Daten in _sec.conf_ zu
verschlüsseln. Dies ist nicht obligatorisch wird aber dringend empfohlen,
da ansonsten die Daten in Klartext gesichert werden.

----
/secure passphrase Dies ist meine Passphrase
----

Wenn eine Passphrase genutzt wird fragt WeeChat diese beim Programmstart
ab (bei einem `/upgrade` ist dies nicht der Fall).

Die Passphrase kann auch in einer Datei gesichert werden (siehe Option
<<option_sec.crypt.passphrase_file,sec.crypt.passphrase_file>>).

[[secured_data_encryption]]
===== Verschlüsselung

Die Daten werden in drei Schritten verschlüsselt:

. erstellt einen Schlüssel anhand der Passphrase (optional mit Salt).
. errechnet einen Hash über die Daten die verschlüsselt werden soll.
. verschlüsselt den Hash + Daten (Ausgabe ist: Salt + Hash/Daten verschlüsselt)

[NOTE]
Der Cipher Block Modus ist _CFB_.

Das Ergebnis wird als hexadezimale Zeichenkette in _sec.conf_ gesichert.
Zum Beispiel:

----
[data]
__passphrase__ = on
freenode = "53B1C86FCDA28FC122A95B0456ABD79B5AB74654F21C3D099A6CCA8173239EEA59533A1D83011251F96778AC3F5166A394"
----

[[secured_data_decryption]]
===== Entschlüsselung

Die Entschlüsselung findet in drei Schritten statt:

. erstellt einen Schlüssel mittels Salt und Passphrase.
. entschlüsselt Hash + Daten.
. überprüft ob der entschlüsselte Hash mit dem Hash der entschlüsselten Daten übereinstimmt.

[[secured_data_manage]]
==== Umgang mit sensiblen Daten

Um sensible Daten zu schützen wird der Befehl `/secure set` verwendet. Es folgt
ein Beispiel wie man das Passwort für den IRC Server _freenode_ schützt:

----
/secure set freenode meinPasswort
----

Um einen Überblick über seine schutzwürdigen Daten zu erhalten kann ein
gesonderter Buffer geöffnet werden. In diesem Buffer kann man sich mittels
kbd:[Alt+v] seine Passwörter anzeigen lassen. Um den Buffer zu öffnen nutzt
man:

----
/secure
----

Verschlüsselte Daten können in einigen Optionen verwendet werden, die z.B.
Passwörter beinhalten. Dies dient dazu Passwörter nicht im Klartext als
Wert einer Option zu sichern. Dazu wird folgendes Format, anstelle des
Passwortes, verwendet: "${sec.data.xxx}". "xxx" ist hierbei der Name den man
dem Passwort zugeordnet hat (siehe oben, mittels `/secure set xxx ...`). +
Für eine vollständige Liste aller unterstützten Optionen, siehe  `/help secure`.

Um z.B. das oben eingestellte _freenode_ Passwort für eine
<<irc_sasl_authentication,SASL Authentifizierung>> zu nutzen:

----
/set irc.server.freenode.sasl_password "${sec.data.freenode}"
----

[[options_and_commands]]
=== Optionen und Befehle

[[sec_options]]
==== Optionen für schutzwürdige Daten (sec.conf)

Sektionen:

[width="100%",cols="3m,6m,16",options="header"]
|===
| Sektion | Steuerbefehl                       | Beschreibung
| crypt   | /set sec.crypt.*                   | Optionen für Verschlüsselung.
| data    | <<command_weechat_secure,/secure>> | geschützte Daten.
|===

Optionen:

include::autogen/user/sec_options.adoc[]

[[weechat_options]]
==== WeeChat Optionen (weechat.conf)

Sektionen:

[width="100%",cols="3m,6m,16",options="header"]
|===
| Sektion    | Steuerbefehl                              | Beschreibung
| debug      | <<command_weechat_debug,/debug set>>      +
               /set weechat.debug.*                      | Debug level, for core and plugins (Optionen können in Sektion hinzugefügt/entfernt werden).
| startup    | /set weechat.startup.*                    | Startup options.
| look       | /set weechat.look.*                       | Look and feel.
| palette    | <<command_weechat_color,/color alias>>    +
               /set weechat.palette.*                    | Alternativnamen für Farben (Optionen können in Sektion hinzugefügt/entfernt werden).
| color      | /set weechat.color.*                      | Farben.
| completion | /set weechat.completion.*                 | Optionen für Vervollständigung.
| history    | /set weechat.history.*                    | Optionen für Befehlsverlauf (Befehle und Buffer).
| proxy      | <<command_weechat_proxy,/proxy>>          +
               /set weechat.proxy.*                      | Proxy Optionen.
| network    | /set weechat.network.*                    | Netzwerk/SSL Optionen.
| bar        | <<command_weechat_bar,/bar>>              +
               /set weechat.bar.*                        | Optionen für die Bars.
| layout     | <<command_weechat_layout,/layout>>        | Layouts.
| notify     | <<command_weechat_buffer,/buffer notify>> | Benachrichtigungsstufe für Buffer (Optionen können in Sektion hinzugefügt/entfernt werden).
| filter     | <<command_weechat_filter,/filter>>        | Filter.
| key        | <<command_weechat_key,/key>>              | Tastenbefehle in default context.
| key_search | <<command_weechat_key,/key>>              | Tastenbefehle in search context.
| key_cursor | <<command_weechat_key,/key>>              | Tastenbefehle in cursor context.
| key_mouse  | <<command_weechat_key,/key>>              | Tastenbefehle in mouse context.
|===

Optionen:

include::autogen/user/weechat_options.adoc[]

[[weechat_commands]]
==== WeeChat Befehle

include::autogen/user/weechat_commands.adoc[]

[[plugins]]
== Erweiterungen

Eine WeeChat Erweiterung ist eine dynamische Bibliothek (library), die in C geschrieben
und kompiliert ist. Unter GNU/Linux besitzt eine Erweiterung als Dateiendung ".so", unter
Windows ".dll".

Erweiterungen die gefunden werden, werden beim Start von WeeChat automatisch geladen.
Natürlich ist es möglich während einer laufenden Session von WeeChat Erweiterungen
nachträglich zu laden oder zu entfernen.

Es ist wichtig zwischen _Erweiterung_ und _Skript_ zu unterscheiden. Eine Erweiterung
ist eine Binärdatei die kompiliert wurde und mit dem Befehl `/plugin` geladen wird.
Dem gegenüber ist ein _Skript_ eine Textdatei die durch eine Erweiterung z.B. _python_
mittels dem Befehl `/python` geladen wird.

Mit dem Befehl `/plugin` kann eine Erweiterung geladen bzw. entfernt werden. Auch können
mit dem Befehl alle installierten Erweiterungen aufgelistet werden. Wird eine Erweiterung
entfernt hat dies Einfluss auf die von dieser Erweiterung geöffneten Buffer.
Diese Buffer werden dann geschlossen.

Beispiele wie man Erweiterungen lädt, entfernt und auflistet:

----
/plugin load irc
/plugin unload irc
/plugin list
----

Standarderweiterungen:

[width="100%",cols="^1,5",options="header"]
|===
| Erweiterung | Beschreibung
| alias       | definiert Alias für Befehle.
| aspell      | Rechtschreibprüfung für Befehlszeile.
| charset     | Zeichensatz (de)-kodierung in Buffern.
| exec        | ausführen von externen Befehlen aus WeeChat heraus.
| fifo        | FIFO Pipe die zur Fernsteuerung von WeeChat genutzt werden kann.
| irc         | IRC Chat-Protokoll.
| logger      | erstellt Protokolldateien von Buffern.
| relay       | Daten via Netzwerk übermitteln.
| script      | Skripten-Manager.
| python      | Python-Skript API.
| perl        | Perl-Skript API.
| ruby        | Ruby-Skript API.
| lua         | Lua-Skript API.
| tcl         | Tcl-Skript API.
| guile       | Guile(scheme)-Skript API.
| javascript  | Javascript-Skript API.
| trigger     | Veränderung von Text und Ausführen von Befehlen bei einem Ereignis, welche durch WeeChat oder eine Erweiterung ausgelöst werden.
| xfer        | Datentransfer und Direktchat.
|===

Um mehr über Erweiterungen- und Skriptenprogrammierung (mittels API) zu erfahren,
sollten Sie die _WeeChat Plugin API Reference_ oder _WeeChat Scripting Guide_ lesen.

[[alias_plugin]]
=== Alias Erweiterung

Die Alias-Erweiterung erlaubt es, für Befehle, sogenannte Kurzbefehle (einen Alias) zu erstellen.

[[alias_commands]]
==== Befehle

include::autogen/user/alias_commands.adoc[]

[[aspell_plugin]]
=== Aspell Erweiterung

Mit der ASpell Erweiterung findet eine Rechtschreibprüfung Einzug in WeeChat.
Dabei ist es möglich mehrere Wörterbücher für einen Buffer zu nutzen.

[[aspell_options]]
==== Optionen (aspell.conf)

Sektionen:

[width="100%",cols="3m,6m,16",options="header"]
|===
| Sektion    | Steuerbefehl                              | Beschreibung
| color      | /set aspell.color.*                       | Farben.
| check      | /set aspell.check.*                       | Optionen um Einstellungen an der Rechtschreibprüfung vorzunehmen.
| dict       | <<command_aspell_aspell,/aspell setdict>> +
               /set aspell.dict.*                        | Wörterbücher für Buffer (Optionen können in Sektion hinzugefügt/entfernt werden).
| option     | /set aspell.option.*                      | <<aspell_speller_options,Optionen für Rechtschreibprüfung>> (Optionen können in Sektion hinzugefügt/entfernt werden).
|===

Optionen:

include::autogen/user/aspell_options.adoc[]

[[aspell_commands]]
==== Befehle

include::autogen/user/aspell_commands.adoc[]

[[aspell_speller_options]]
==== Optionen für Rechtschreibprüfung

Optionen für die Rechtschreibprüfung können definiert werden indem man die entsprechende
Option in die Sektion "option" der Aspell-Konfiguration hinzufügt.

Den Name der Option findet man in der ASpell-Konfigurationsdatei. Eine Auflistung aller
möglichen Optionen erhält man durch:

----
$ aspell config
----

Um zum Beispiel die Option "ignore-case" einzuschalten:

----
/set aspell.option.ignore-case "true"
----

[[aspell_suggestions]]
==== Rechtschreibkorrektur

Eine Rechtschreibkorrektur wird in der Bar-Item "aspell_suggest" angezeigt.
Die Anzahl an Vorschlägen, für die Rechtschreibkorrektur, kann mit der Option
_aspell.check.suggestions_ bestimmt werden.

Um die Rechtschreibkorrektur zu aktivieren, muss für die Option _aspell.check.suggestions_
ein Wert ≥ 0 eingestellt werden und das Bar-Item "aspell_suggest" zu einer Bar, zum
Beispiel _status_, hinzufügt werden.

Beispiel der Rechtschreibkorrektur, mit einem deutschen Wörterbuch (`de`):

....
│[12:55] [6] [irc/freenode] 3:#test(+n){4} [dies,Diebs,Viehs]                     │
│[@Flashy] diehs █                                                                │
└─────────────────────────────────────────────────────────────────────────────────┘
....

Beispiel der Rechtschreibkorrektur, mit zwei Wörterbüchern (`en,de`):

....
│[12:55] [6] [irc/freenode] 3:#test(+n){4} [print,prone,prune/Prinz]              │
│[@Flashy] prinr █                                                                │
└─────────────────────────────────────────────────────────────────────────────────┘
....

[[charset_plugin]]
=== Charset Erweiterung

Die Charset Erweiterung übernimmt das de-/kodieren der Zeichensätze.

Es existiert ein Standardzeichensatz zum de-/kodieren und spezielle Zeichensätze
für Buffer (oder Gruppen von Buffern).

Diese Erweiterung ist optional, sie wird aber empfohlen. Wenn diese Erweiterung
nicht genutzt wird steht WeeChat lediglich UTF-8 zur Verfügung.

Die Charset Erweiterung wird automatisch von WeeChat geladen. Um sicher zu gehen
dass diese Erweiterung geladen wurde führen Sie folgenden Befehl aus:

----
/charset
----

Wird der Befehl nicht gefunden dann kann die Erweiterung mit dem nachfolgenden
Befehl nachgeladen werden:

----
/plugin load charset
----

Wird die Erweiterung nicht geladen dann sollten Sie WeeChat nochmals mit allen
Erweiterungen und der Charset Unterstützung kompilieren.

Wird die Charset Erweiterung gestartet dann wird der Terminal und der interne
Zeichensatz genutzt. Welcher Terminal Zeichensatz genutzt wird hängt davon ab
welchen Zeichensatz Sie lokal nutzen. Intern wird UTF-8 genutzt.

Beispiel:

....
charset: terminal: ISO-8859-15, internal: UTF-8
....

[[charset_options]]
==== Optionen (charset.conf)

Sektionen:

[width="100%",cols="3m,6m,16",options="header"]
|===
| Sektion | Steuerbefehl                                | Beschreibung
| default | /set charset.default.*                      | Vorgegebener Zeichensatz zum De-/kodieren.
| decode  | <<command_charset_charset,/charset decode>> +
            /set charset.decode.*                       | Zeichensatz zum dekodieren (Optionen können in Sektion hinzugefügt/entfernt werden).
| encode  | <<command_charset_charset,/charset encode>> +
            /set charset.encode.*                       | Zeichensatz zum kodieren (Optionen können in Sektion hinzugefügt/entfernt werden).
|===

Optionen:

include::autogen/user/charset_options.adoc[]

[[charset_commands]]
==== Befehle

include::autogen/user/charset_commands.adoc[]

[[charset_set]]
==== Zeichensatz auswählen

Um einen Zeichensatz zum de-/kodieren zu bestimmen wird der Befehl `/set` genutzt.

Beispiel:

----
/set charset.default.decode ISO-8859-15
/set charset.default.encode ISO-8859-15
----

Wenn der globale Zeichensatz zum dekodieren nicht gesetzt ist (dies tritt beim
ersten Aufruf des Charset Erweiterung auf) dann wird automatisch der Zeichensatz
genutzt der vom Terminal verwendet wird (sofern dieser nicht UTF-8 ist) oder
der Standardzeichensatz _ISO-8859-1_.

Der Standardwert zum kodieren ist nicht gesetzt. Deshalb wird der interne Zeichensatz
(UTF-8) genutzt.

Um einen Zeichensatz für IRC Server einzustellen wird der Befehl `/charset` im Server
Buffer ausgeführt. Wird nur der Zeichensatz als Argument übergeben wird dieser sowohl
zum kodieren als auch dekodieren genutzt.

Beispiel:

----
/charset ISO-8859-15
----

ist identisch mit den Befehlen:

----
/charset decode ISO-8859-15
/charset encode ISO-8859-15
----

Um den Zeichensatz in einem IRC-Channel (oder in einem privaten Buffer) zu ändern
wird der selbe Befehl im entsprechenden Buffer genutzt.

Um die Zeichenkodierung für alle Channels und privaten Buffer eines IRC Server zu ändern:

----
/set charset.encode.irc.freenode ISO-8859-15
----

Um sich alle genutzten Zeichensätze anzeigen zu lassen wird folgender Befehl genutzt:

----
/set charset.*
----

[[charset_troubleshooting]]
==== Fehlersuche

sollten Probleme bei der Zeichensatzdarstellung auftreten dann werfen Sie bitte
einen Blick in die _WeeChat FAQ_.

[[exec_plugin]]
=== Exec Erweiterung

Der `/exec` Befehl erlaubt es aus WeeChat heraus einen oder mehrere externe
Befehle auszuführen und eine Ausgabe im lokalen Buffer darzustellen oder in
einem Buffer auszugeben.

[[exec_options]]
==== Optionen (exec.conf)

Sections:

[width="100%",cols="3m,6m,16",options="header"]
|===
| Sektion | Steuerbefehl        | Beschreibung
| command | /set exec.command.* | Optionen für Befehle.
| color   | /set exec.color.*   | Farben.
|===

Options:

include::autogen/user/exec_options.adoc[]

[[exec_commands]]
==== Commands

include::autogen/user/exec_commands.adoc[]

[[fifo_plugin]]
=== Fifo Erweiterung

Sie können WeeChat fern steuern indem Sie Befehle oder einen Text an die FIFO Pipe
schicken (dazu muss die Option "fifo.file.enabled" aktiviert sein (standardmäßig
ist diese Option aktiviert).

Die FIFO-Pipe befindet sich standardmäßig im Pfad _~/.weechat/_ und heißt _weechat_fifo_.

Die Syntax der FIFO Pipe Befehle/Text sieht wie folgt aus:

....
  plugin.buffer *hier Text oder Befehl
  *hier Text oder Befehl
....

einige Beispiele:

* Ändert den eigenen Nick auf dem IRC Server freenode in "newnick":

----
$ echo 'irc.server.freenode */nick newnick' >~/.weechat/weechat_fifo
----

* Schickt eine Nachrich in den IRC #weechat Channel:

----
$ echo 'irc.freenode.#weechat *hello!' >~/.weechat/weechat_fifo
----

* Schickt eine Nachricht in den aktuellen Buffer:

----
$ echo '*hello!' >~/.weechat/weechat_fifo
----

* Sendet zwei Befehle um alle Python-Skripten zu entfernen und dann neu zu laden (die beiden Befehle müssen
  mit "\n" getrennt werden):

----
$ printf '%b' '*/python unload\n*/python autoload\n' >~/.weechat/weechat_fifo
----

[[fifo_options]]
==== Optionen (fifo.conf)

Sektionen:

[width="100%",cols="3m,6m,16",options="header"]
|===
| Sektion | Steuerbefehl     | Beschreibung
| file    | /set fifo.file.* | FIFO Pipe Optionen.
|===

Optionen:

include::autogen/user/fifo_options.adoc[]

[[fifo_commands]]
==== Befehle

include::autogen/user/fifo_commands.adoc[]

[[irc_plugin]]
=== IRC Erweiterung

Die IRC Erweiterung ist konzipiert um mittels dem IRC Protokoll mit anderen Menschen zu chatten.

Die Erweiterung ist Multi-Server fähig und verfügt über alle IRC Befehle, einschließlich DCC Chat
und Datenübertragung (via xfer Erweiterung, siehe <<xfer_plugin,Xfer Erweiterung>>).

[[irc_command_line_options]]
==== Kommandozeilen Befehle

Es ist möglich eine oder mehrere URL von IRC Servern zu übergeben:

----
irc[6][s]://[nick[:password]@]irc.example.org[:port][/channel][,channel[...]]
----

Beispiel: Anmelden beim Server _chat.freenode.net_ mit dem Nick _nono_ und betreten
der Channels _#weechat_ und _#toto_ (Standardport (6667) wird genutzt):

----
$ weechat irc://nono@chat.freenode.net/#weechat,#toto
----

[[irc_options]]
==== Optionen (irc.conf)

Sektionen:

[width="100%",cols="3m,6m,16",options="header"]
|===
| Sektion        | Steuerbefehl                   | Beschreibung
| look           | /set irc.look.*                | Erscheinungsbild.
| color          | /set irc.color.*               | Farben.
| network        | /set irc.network.*             | Netzwerkoptionen.
| msgbuffer      | /set irc.msgbuffer.*           | <<irc_target_buffer,Zielbuffer für IRC Nachrichten>> (Optionen können in Sektion hinzugefügt/entfernt werden).
| ctcp           | /set irc.ctcp.*                | <<irc_ctcp_replies,CTCP Antworten>> (Optionen können in Sektion hinzugefügt/entfernt werden).
| ignore         | <<command_irc_ignore,/ignore>> | Ignoriert Menschen.
| server_default | /set irc.server_default.*      | Standardwerte für Server (werden genutzt, falls keine Optionen für einen Server gesetzt sind).
| server         | <<command_irc_server,/server>> +
                   /set irc.server.*              | Server.
|===

Optionen:

include::autogen/user/irc_options.adoc[]

[[irc_commands]]
==== Befehle

include::autogen/user/irc_commands.adoc[]

[[irc_ssl_certificates]]
==== SSL Zertifikate

Wenn eine Verbindung mittels SSL zu einem IRC Server hergestellt wird dann überprüft
WeeChat immer ob dieser Verbindung sicher ist.

Einige Optionen dienen dazu eine SSL Verbindung zu nutzen:

weechat.network.gnutls_ca_file::
    Pfad zu einer Datei mit SSL Zertifikaten (Standardpfad: "%h/ssl/CAs.pem")

irc.server.xxx.ssl_cert::
    Datei mit den SSL Zertifikaten die genutzt werden um automatisch Ihren Nick
    zu identifizieren (zum Beispiel CertFP auf oftc, siehe unten)

irc.server.xxx.ssl_dhkey_size::
    Größe des Schlüssels der genutzt werden soll beim Schlüsseltausch mittels
    der Diffie-Hellman Methode (Standardwert: 2048)

irc.server.xxx.ssl_verify::
    überprüft ob der SSL Verbindung uneingeschränkt vertraut werden kann (Standardwert: AN)

[NOTE]
Die Option "ssl_verify" ist Vorgabe mäßig immer eingeschaltet. Das gewährleistet dass
die Verifizierung sehr streng genommen wird und dadurch vielleicht versagt. Auch wenn
die Verbindung mit einer vorherigen Version (<0.3.1) funktioniert hat.

[[irc_connect_oftc_with_certificate]]
===== erstes Beispiel: Verbindung zu oftc und Überprüfung der Zertifikate

* Importieren Sie die Zertifikate in einer Shell:

----
$ mkdir -p ~/.weechat/ssl
$ wget -O ~/.weechat/ssl/CAs.pem http://www.spi-inc.org/ca/spi-cacert.crt
----

[NOTE]
Es ist möglich mehrere Zertifikate in der Datei CAs.pem zu verwenden.

* In WeeChat, sofern der Server "oftc" schon hinzufügt wurde:

----
/connect oftc
----

[[irc_connect_oftc_with_certfp]]
===== zweites Beispiel: Verbindung zu oftc mittels CertFP

* Erstellen Sie ein Zertifikat in der Shell:

----
$ mkdir -p ~/.weechat/ssl
$ cd ~/.weechat/ssl
$ openssl req -nodes -newkey rsa:2048 -keyout nick.pem -x509 -days 365 -out nick.pem
----

* In WeeChat, sofern der Server "oftc" schon hinzufügt wurde:

----
/set irc.server.oftc.ssl_cert "%h/ssl/nick.pem"
/connect oftc
/msg nickserv cert add
----

Für weiterreichende Informationen lesen Sie bitte: http://www.oftc.net/oftc/NickServ/CertFP

[[irc_sasl_authentication]]
==== SASL Authentifizierung

WeeChat unterstützt eine SASL Authentifikation, mittels verschiedener Mechanismen:

* _plain_: Passwort liegt in Klarschrift vor (Standard)
* _ecdsa-nist256p-challenge_: Abgleich von öffentlichem/privatem Schlüssel
* _external_: SSL Zertifikat welches auf Client Seite vorliegt
* _dh-blowfish_: Passwort wird mittels blowfish verschlüsselt
  (*unsicher*, wird nicht empfohlen)
* _dh-aes_: Passwort wird mittels AES verschlüsselt
  (*unsicher*, wird nicht empfohlen)

[NOTE]
Die "gcrypt" Bibliothek wird beim kompilieren von WeeChat benötigt um
"dh-blowfish"nutzen zu können (siehe <<dependencies,Abhängigkeiten>>).

Optionen für Server sind:

* _sasl_mechanism_: Mechanismus welcher genutzt werden soll (siehe oben)
* _sasl_timeout_: Zeitüberschreitung für Authentifizierung (in Sekunden)
* _sasl_fail_: auszuführende Aktion falls die SASL Authentifizierung fehlschlägt
* _sasl_username_: Username (Nickname)
* _sasl_password_: Passwort
* _sasl_key_: Datei mit privatem ECC Schlüssel (für den
  _ecdsa-nist256p-challenge_ Mechanismus)

[[irc_sasl_ecdsa_nist256p_challenge]]
===== SASL ECDSA-NIST256P-CHALLENGE

Es muss ein privater Schlüssel erstellt werden um sich mittels des
ECDSA-NIST256P-CHALLENGE Mechanismus authentifizieren zu können (es wird
dadurch kein Passwort während des Verbindungsaufbaus benötigt).

Ein Schlüssel kann mit folgendem Befehl erzeugt werden:

----
$ openssl ecparam -genkey -name prime256v1 >~/.weechat/ecdsa.pem
----

Um den öffentlichen Schlüssel zu erhalten (base64 enkodiert) muss
folgender Befehl ausgeführt werden:

----
$ openssl ec -noout -text -conv_form compressed -in ~/.weechat/ecdsa.pem | grep '^pub:' -A 3 | tail -n 3 | tr -d ' \n:' | xxd -r -p | base64
----

Nun Verbindung zum Server herstellen, identifizieren (z.B. mittels "nickserv identify")
und den öffentlichen Schlüssel für den eigenen Zugang festlegen (der base64 Schlüssel
im Beispiel muss durch den eigenen öffentlichen Schlüssel ersetzt werden:

----
/connect freenode
/msg nickserv identify your_password
/msg nickserv set pubkey Av8k1FOGetUDq7sPMBfufSIZ5c2I/QYWgiwHtNXkVe/q
----

Konfiguration der SASL Optionen des Servers:

----
/set irc.server.freenode.sasl_mechanism ecdsa-nist256p-challenge
/set irc.server.freenode.sasl_username "your_nickname"
/set irc.server.freenode.sasl_key "%h/ecdsa.pem"
----

Erneut mit dem Server verbinden:

----
/reconnect freenode
----

[[irc_tor_freenode]]
==== Verbindung zu Freenode mittels TOR/SASL herstellen

Neben der Möglichkeit eine Verbindung zum Freenode Server mittels SSL aufzubauen,
kann man außerdem eine Verbindung via TOR (https://www.torproject.org/) herstellen.
Dies dient dazu die eigene Privatsphäre und Sicherheit im Internet zu erhöhen.

Im ersten Schritt muss TOR installiert werden. Für Debian (und Derivate):

----
$ sudo apt-get install tor
----

In WeeChat muss nun ein socks5 Proxy für den TOR Service erstellt werden (Hostname/IP
und Port müssen dabei an die eigene TOR Konfiguration angepasst werden):

----
/proxy add tor socks5 127.0.0.1 9050
----

Jetzt muss der neue Server hinzufügt werden, zum Beispiel:

----
/server add freenode-tor p4fsi4ockecnea7l.onion
----

Einen Proxy für TOR anlegen:

----
/set irc.server.freenode-tor.proxy "tor"
----

Die SASL Authentifikation einstellen:

----
/set irc.server.freenode-tor.sasl_username "your_nickname"
/set irc.server.freenode-tor.sasl_password "your_password"
----

Zum Abschluss stellt man eine Verbindung zum Server her:

----
/connect freenode-tor
----

Um mehr über Freenode und TOR zu erfahren: http://freenode.net/irc_servers.shtml#tor

[[irc_smart_filter_join_part_quit]]
==== einfacher Filter für join/part/quit Nachrichten

Es existiert ein einfacher Filter für join/part/quit Nachrichten falls ein Nick für
eine vorgegebene Zeit in einem Channel inaktiv gewesen ist.

Diese Funktion ist standardmäßig aktiviert, aber Sie müssen einen Filter erstellen damit
solche Nachrichten im Buffer unterdrückt werden. Ein Beispiel:

----
/filter add irc_smart * irc_smart_filter *
----

Dabei ist es natürlich möglich den Filter in der Form einzurichten dass er nur
für einen Channel Gültigkeit besitzt oder aber für mehrere Channels die mit dem
selben Namen beginnen (siehe `/help filter`):

----
/filter add irc_smart_weechat irc.freenode.#weechat irc_smart_filter *
/filter add irc_smart_weechats irc.freenode.#weechat* irc_smart_filter *
----

Sie können auch nur join oder part/quit Nachrichten unterdrücken:

----
/set irc.look.smart_filter_join on
/set irc.look.smart_filter_quit on
----

Zusätzlich kann auch eine Verzögerung (in Minuten) eingestellt werden:

----
/set irc.look.smart_filter_delay 5
----

Falls ein Nick in den letzten fünf Minuten nicht aktiv gewesen ist werden seine
join und/oder part/quit Nachrichten im Channel unterdrückt.

[[irc_ctcp_replies]]
==== CTCP Antworten

Sie haben die Möglichkeit CTCP Antworten anzupassen oder aber bestimmte CTCP
Anfragen zu sperren (es wird nicht darauf geantwortet).

Beispiel: Um eine Antwort auf die CTCP Anfrage "VERSION" anzupassen nutzen Sie
folgenden Befehl:

----
/set irc.ctcp.version "I'm running WeeChat $version, it rocks!"
----

Wenn Sie die Anfrage CTCP "VERSION" blockieren möchten (es wird nicht darauf
geantwortet) dann löschen Sie einfach den Rückgabe-String:

----
/set irc.ctcp.version ""
----

Selbst bisher unbekannte CTCP Anfragen können beantwortet werden. Nehmen wir
zum Beispiel die Anfrage CTCP "BLABLA":

----
/set irc.ctcp.blabla "Dies ist meine Antwort auf CTCP BLABLA"
----

Auch kann man CTCP Antworten für jeden einzelnen Server anpassen. Dazu muss
man lediglich den internen Servernamen vor die CTCP Anfrage setzen:

----
/set irc.ctcp.freenode.version "WeeChat $version (for freenode)"
----

Sollen die CTCP Antworten wieder auf die Standardeinstellungen zurück gesetzt werden
dann müssen Sie lediglich die Option löschen:

----
/unset irc.ctcp.version
----

Folgende Platzhalter können in den CTCP-Antworten genutzt werden. Diese werden dann
mit dem entsprechenden Wert ersetzt:

[width="100%",cols="^2l,4,8",options="header"]
|===
| Platzhalter  | Beschreibung                        | Wert/Beispiel
| $clientinfo  | Liste der CTCP Antworten            | `ACTION DCC CLIENTINFO FINGER PING SOURCE TIME USERINFO VERSION`
| $version     | WeeChat Version                     | `0.4.0-dev`
| $versiongit  | WeeChat Version + Git version ^(1)^ | `0.4.0-dev (git: v0.3.9-104-g7eb5cc4)`
| $git         | Git Version ^(1)^                   | `v0.3.9-104-g7eb5cc4`
| $compilation | Datum der Kompilierung              | `Dec 16 2012`
| $osinfo      | Info über das genutzte OS           | `Linux 2.6.32-5-amd64 / x86_64`
| $site        | WeeChat Seite                       | `https://weechat.org/`
| $download    | WeeChat, Download Seite             | `https://weechat.org/download`
| $time        | Aktuelle Uhrzeit/Datum              | `Sun, 16 Dec 2012 10:40:48 +0100`
| $username    | Username beim IRC Server            | `Name`
| $realname    | Realname beim IRC Server            | `John Doe`
|===

[NOTE]
^(1)^ Die Git Version wird durch die Ausgabe des Befehls `git describe` ermittelt.
Dies erfordert, dass WeeChat aus dem Git Repository heraus kompiliert wurde
und das Git überhaupt installiert ist.

Falls CTCP Optionen nicht festgelegt sind, lauten die CTCP Antworten:

[width="100%",cols="^2,4,8",options="header"]
|===
| CTCP       | Antwortformat                        | Beispiel
| CLIENTINFO | `$clientinfo`                        | `ACTION DCC CLIENTINFO FINGER PING SOURCE TIME USERINFO VERSION`
| FINGER     | `WeeChat $versiongit`                | `WeeChat 0.4.0-dev (git: v0.3.9-104-g7eb5cc4)`
| SOURCE     | `$download`                          | `https://weechat.org/download`
| TIME       | `$time`                              | `Sun, 16 Dec 2012 10:40:48 +0100`
| USERINFO   | `$username ($realname)`              | `Name (John Doe)`
| VERSION    | `WeeChat $versiongit ($compilation)` | `WeeChat 0.4.0-dev (git: v0.3.9-104-g7eb5cc4) (Dec 16 2012)`
|===

[[irc_target_buffer]]
==== Zielbuffer für IRC Nachrichten

Sie können einen Zielbuffer einstellen in welchem IRC Nachrichten dargestellt werden sollen.
Dazu dienen die Optionen `+irc.msgbuffer.*+`.

Für einige IRC Nachrichten (siehe unten) können zusätzliche Werte angepasst werden:

current::
    aktueller Buffer (falls es ein IRC Buffer ist, ansonsten im entsprechenden Server Buffer)

private::
    privaten Buffer, oder im aktuellen/Server Buffer falls nicht vorhanden (gemäß der Einstellung
    in der Option _irc.look.msgbuffer_fallback_)

server::
    Server Buffer

weechat::
    WeeChat "core" Buffer

Falls die Option nicht gesetzt ist (Standard) wählt WeeChat einen geeigneten Buffer aus,
üblicherweise handelt es sich dabei um einen Server oder Channel-Buffer.

Unvollständige Liste der IRC Nachrichten bzw. Alias die angepasst werden können:

[width="60%",cols="^1m,^3m,8",options="header"]
|===
| Nachricht | Alias         | Beschreibung
| error     |               | Fehler
| invite    |               | Einladung in einen Channel
| join      |               | join
| kick      |               | kick
| kill      |               | kill
| mode      |               | Modus
| notice    |               | Mitteilung
| part      |               | part
| quit      |               | quit
| topic     |               | topic
| wallops   |               | wallops
|           | ctcp          | ctcp (gesendet oder empfangen, in einer privmsg oder notice Nachricht)
| 221       |               | User mode string
| 275       | whois         | whois (sichere Verbindung)
| 301       | whois         | whois (abwesend)
| 303       |               | ison
| 305       | unaway        | nicht abwesend
| 306       | away          | abwesend
| 307       | whois         | whois (registrierter Nick)
| 310       | whois         | whois (Hilfe Modus)
| 311       | whois         | whois (User)
| 312       | whois         | whois (Server)
| 313       | whois         | whois (Operator)
| 314       | whowas        | whowas
| 315       | who           | who (Ende)
| 317       | whois         | whois (inaktiv)
| 318       | whois         | whois (ende)
| 319       | whois         | whois (Channels)
| 320       | whois         | whois (User identifizieren)
| 321       | list          | list (Start)
| 322       | list          | list (Channel)
| 323       | list          | list (Ende)
| 326       | whois         | whois (hat oper privs)
| 327       | whois         | whois (Host)
| 328       |               | Channel URL
| 329       |               | Erstellungsdatum des Channel
| 330       | whois         | whois (eingelogged als)
| 331       |               | kein Topic für Channel
| 332       |               | Channel-Topic
| 333       |               | Infos über Topic
| 335       | whois         | whois (ist ein Bot auf)
| 338       | whois         | whois (Host)
| 341       |               | inviting
| 343       | whois         | whois (ist opered als)
| 344       | reop          | channel reop
| 345       | reop          | channel reop (Ende)
| 346       | invitelist    | Einladung Liste
| 347       | invitelist    | Einladung Liste (Ende)
| 348       | exceptionlist | exception Liste
| 349       | exceptionlist | exception Liste (Ende)
| 351       |               | Server Version
| 352       | who           | who
| 353       | names         | Liste von Usern im Channel
| 366       | names         | Ende der /names Liste
| 367       | banlist       | ban Liste
| 368       | banlist       | Ende der ban Liste
| 369       | whowas        | whowas (Ende)
| 378       | whois         | whois (Verbindung von)
| 379       | whois         | whois (genutzte Modi)
| 401       | whois         | kein solcher Nick/Channel
| 402       | whois         | kein solcher Server
| 432       |               | fehlerhafter Nickname
| 433       |               | Nickname wird schon verwendet
| 438       |               | nicht autorisiert um Nicknamen zu ändern
| 671       | whois         | whois (sichere Verbindung)
| 728       | quietlist     | quiet Liste
| 729       | quietlist     | Ende der quiet Liste
| 732       | monitor       | Liste der Nicks welche überwacht werden
| 733       | monitor       | Liste der Nicks welche überwacht werden (Ende)
| 901       |               | Sie sind nun eingelogged
|===

andere nummerische Befehle können angepasst werden.

Den IRC Nachrichten kann der Servername vorangestellt werden um zu spezifizieren
von welchem IRC Server die Nachricht gekommen ist. Zum Beispiel: `freenode.whois`.

einige Beispiele:

* gibt die Antwort von `/whois` im privaten Buffer aus:

----
/set irc.msgbuffer.whois private
----

* stellt die Ausgabe von whois wieder auf Standardbuffer zurück (Server Buffer):

----
/unset irc.msgbuffer.whois
----

* zeigt Einladungen im aktuellen Buffer an, nur für den "freenode" Server:

----
/set irc.msgbuffer.freenode.invite current
----

* die Nachricht "303" (ison) wird im WeeChat "core" Buffer angezeigt:

----
/set irc.msgbuffer.303 weechat
----

[[logger_plugin]]
=== Logger Erweiterung

Die Logger Erweiterung erlaubt es den Inhalt von Buffern in Dateien zu sichern.
Dabei kann man über Optionen Einfluss darauf nehmen was gesichert und wie etwas
gesichert werden soll.

[[logger_options]]
==== Optionen (logger.conf)

Sektionen:

[width="100%",cols="3m,6m,16",options="header"]
|===
| Sektion | Steuerbefehl        | Beschreibung
| look    | /set logger.look.*  | Erscheinungsbild.
| color   | /set logger.color.* | Farben.
| file    | /set logger.file.*  | Optionen für Protokolldateien.
| level   | /set logger.level.* | Protokollierungslevel pro Buffer (Optionen können in Sektion hinzugefügt/entfernt werden).
| mask    | /set logger.mask.*  | Dateinamenmaske pro buffer (Optionen können in Sektion hinzugefügt/entfernt werden).
|===

Optionen:

include::autogen/user/logger_options.adoc[]

[[logger_commands]]
==== Befehle

include::autogen/user/logger_commands.adoc[]

[[logger_log_levels]]
==== Log Levels

Die Protokollierung wird durch einen sogenannten Level für jeden Buffer sichergestellt.
Der Standardlevel ist dabei 9 (damit werden alle Nachrichten die im Buffer angezeigt
werden protokolliert). Der Grad einer Protokollierung kann separat für jeden einzelnen
Buffer oder aber für eine Anzahl von Buffern festgelegt werden.

Mögliche Level sind hierbei 0 bis 9. Null bedeutet, es findet keine Protokollierung
statt und neun, dass alle Nachrichten protokolliert werden.

Erweiterungen nutzen unterschiedliche Level um Nachrichten anzuzeigen.
Die IRC Erweiterung nutzt folgende Level:

* Level 1: Nachrichten eines Users (im Channel oder privat)
* Level 2: Nick wurde geändert (der eigene oder von einer anderen Person)
* Level 3: jedwede Server Nachricht (ausgenommen join/part/quit)
* Level 4: Server Nachrichten join/part/quit

Setzen Sie also den Grad der Protokollierung für einen IRC Channel auf "3"
wird Weechat alle Nachrichten protokollieren, ausgenommen join/part/quit
Nachrichten.

weitere Beispiele:

* Level 3 für IRC Channel #weechat nutzen:

----
/set logger.level.irc.freenode.#weechat 3
----

* Level 3 für freenode Server Buffer nutzen:

----
/set logger.level.irc.server.freenode 3
----

* Level 3 für alle Channels auf dem Server freenode nutzen:

----
/set logger.level.irc.freenode 3
----

* Level 2 für alle IRC Buffers nutzen:

----
/set logger.level.irc 2
----

[[logger_filenames_masks]]
==== Dateinamenmaske

Es ist möglich eine Dateinamenmaske für jeden Buffer zu erstellen und diese Maske
mit lokalen Buffervariablen zu füllen. Um zu sehen welche lokalen Variabel es gibt:

----
/buffer localvar
----

Zum Beispiel für den Buffer "irc.freenode.#weechat". WeeChat sucht in dieser
Reihenfolge nach einer Maske:

----
logger.mask.irc.freenode.#weechat
logger.mask.irc.freenode
logger.mask.irc
logger.file.mask
----

Dies bedeutet dass man eine Maske speziell für einen IRC Server
("logger.mask.irc.freenode") anlegen kann oder aber global für
die Erweiterung ("logger.mask.irc").

[[logger_files_by_date]]
===== Protokolldatei nach Datum

Um Protokolldateien mit einer Datumsrelevanz zu erstellen müssen
Datumsspezifikationen in der Maske genutzt werden (siehe
`man strftime` für das Format). Zum Beispiel:

----
/set logger.file.mask "%Y/%m/$plugin.$name.weechatlog"
----

Erstellt eine Struktur in folgender Form:

....
~/.weechat/
    |--- logs/
        |--- 2010/
            |--- 11/
            |       irc.server.freenode.weechatlog
            |       irc.freenode.#weechat.weechatlog
        |--- 2010/
            |--- 12/
            |       irc.server.freenode.weechatlog
            |       irc.freenode.#weechat.weechatlog
....

[[logger_irc_files_by_server_channel]]
===== Protokolldateien nach Server und Channel

Soll für jeden IRC Server ein Verzeichnis erstellt werden mit jeweils
einer Protokolldatei für jeden Channel:

----
/set logger.mask.irc "irc/$server/$channel.weechatlog"
----

Erstellt eine Struktur in folgender Form:

....
~/.weechat/
    |--- logs/
        |--- irc/
            |--- freenode/
            |       freenode.weechatlog
            |       #weechat.weechatlog
            |       #mychan.weechatlog
            |--- oftc/
            |       oftc.weechatlog
            |       #chan1.weechatlog
            |       #chan2.weechatlog
....

[[relay_plugin]]
=== Relay Erweiterung

Die Relay-Erweiterung wird genutzt um Daten, mittels unterschiedlicher Protokolle,
über ein Netzwerk zu übermitteln:

* _irc_: IRC Proxy: um mittels einem oder mehreren IRC-Clients eine Verbindung zu
  IRC Servern zu unterhalten.
* _weechat_: Protokoll welches es erlaubt die Daten mit einer externen Oberfläche
  zu teilen (zum Beispiel QWeeChat)

[[relay_options]]
==== Optionen (relay.conf)

Sektionen:

[width="100%",cols="3m,6m,16",options="header"]
|===
| Sektion | Steuerbefehl                       | Beschreibung
| look    | /set relay.look.*                  | Erscheinungsbild.
| color   | /set relay.color.*                 | Farben.
| network | /set relay.network.*               | Netzwerkoptionen.
| irc     | /set relay.irc.*                   | für das IRC Protokoll spezifische Optionen (IRC Proxy).
| port    | <<command_relay_relay,/relay add>> +
            /set relay.port.*                  | Ports zur Nutzung der Relay-Erweiterung (IRC und weechat Protokolle) (Optionen können in Sektion hinzugefügt/entfernt werden).
|===

Optionen:

include::autogen/user/relay_options.adoc[]

[[relay_commands]]
==== Befehle

include::autogen/user/relay_commands.adoc[]

[[relay_password]]
==== Passwort

Es wird nachdrücklich Empfohlen ein Passwort für die Relay-Verbindung zu nutzen:

----
/set relay.network.password "meinPasswort"
----

Dieses Passwort wird sowohl für das _irc_ als auch für das _weechat_ Protokoll
verwendet.

[[relay_ssl]]
==== SSL

Man kann SSL mittels eines selbst erstellten Zertifikates und eines privaten
Schlüssels nutzen. Um SSL für die Verbindung zu aktivieren stellt man dem
Protokollnamen ein "ssl" voran.

Die Standarddatei für Zertifikate/Schlüssel ist _~/.weechat/ssl/relay.pem_
(option <<option_relay.network.ssl_cert_key,relay.network.ssl_cert_key>>).

Ein Zertifikat und einen privaten Schlüssel kann man mit folgenden Befehlen
erstellen:

----
$ mkdir -p ~/.weechat/ssl
$ cd ~/.weechat/ssl
$ openssl req -nodes -newkey rsa:2048 -keyout relay.pem -x509 -days 365 -out relay.pem
----

Sollte WeeChat schon gestartet worden sein, kann man das Zertifikat und der private
Schlüssel mittels folgendem Befehl nachträglich geladen werden:

----
/relay sslcertkey
----

[[relay_irc_proxy]]
==== IRC Proxy

Die Relay Erweiterung kann wie ein IRC Proxy genutzt werden. Dabei simuliert
die Erweiterung einen IRC Server und man kann sich mit jedem IRC Client zu WeeChat
verbinden.

Es kann für jeden IRC Server ein Port definiert werden, oder aber ein Port für
alle Server.

Wird ein Port für alle Server genutzt, dann muss der Client den internen Namen
des zu nutzenden Servers mit dem IRC Befehl "PASS" anfordern:

----
PASS server:meinPasswort
----

Beispiel: IRC Proxy mit SSL für einen beliebigen Server (Client wählt aus):

----
/relay add ssl.irc 8000
----

Beispiel: IRC Proxy ohne SSL und nur für "freenode":

----
/relay add irc.freenode 8000
----

Nun kann man eine Verbindung zum Port 8000 mit jedem beliebigen IRC Client
herstellen, indem man das Server Passwort "meinPasswort" nutzt (oder
"freenode:meinPasswort" sofern kein Server angegeben wurde).

[[relay_weechat_protocol]]
==== WeeChat Protokoll

Die Relay-Erweiterung kann Daten, mittels dem WeeChat Protokoll, an eine
externe Oberfläche senden.

Nun kann man mittels einer remote Oberfläche Kontakt zu WeeChat herstellen.
Eine Liste der remote Oberflächen findet man auf der Homepage:
https://weechat.org/download

[IMPORTANT]
WeeChat selber kann sich NICHT mit einer anderen WeeChat Instanz über
dieses Protokoll verbinden.

Zum Beispiel:

----
/relay add weechat 9000
----

Nun kann man über den Port 9000 mittels einer Oberfläche und dem Passwort
"meinPasswort" eine Verbindung zu WeeChat herstellen.

[[relay_websocket]]
==== WebSocket

Das WebSocket Protokoll (http://tools.ietf.org/html/rfc6455[RFC 6455]) wird nun
in der Relay Erweiterung unterstützt.

Der WebSocket Handshake wird automatisch erkannt und der Socket ist sofort
funktionsfähig, sofern die benötigten Header gefunden werden und die Herkunft
bestätigt wurde (siehe Option <<option_relay.network.websocket_allowed_origins,relay.network.websocket_allowed_origins>>).

Ein WebSocket kann in HTML5, mit einer JavaScript Zeile, geöffnet werden:

[source,js]
----
websocket = new WebSocket("ws://server.com:9000/weechat");
----

Der Port (im Beispiel: 9000) ist der Port der in der Relay Erweiterung angegeben wurde.
Die URI muss immer auf "/weechat" enden (_irc_ und _weechat_ Protokoll).

[[scripts_plugins]]
=== Erweiterungen für Skripten

WeeChat unterstützt sechs Skript-Erweiterungen: Python, Perl, Ruby, Lua, Tcl,
Guile (scheme) und Javascript.
Mit diesen Erweiterungen kann für die jeweilige Skript-Sprache, Skripten geladen, ausgeführt
und entfernt werden.

Eine weitere Erweiterung ist "script". Dies ist ein Skripten-Manager mit dem es möglich ist,
unabhängig von der Skript-Sprache, Skripten zu laden und zu entfernen. Des weiteren können
Skripten, aus dem Skript-Repository, installiert und deinstalliert werden. Das Skript-Repository
kann unter folgender URL eingesehen werden: https://weechat.org/scripts

Sollten wir Ihr Interesse geweckt haben, selber Skripten für WeeChat zu programmieren, dann lesen Sie
bitte die _WeeChat Scripting Guide_.

[[script_options]]
==== Script Optionen (script.conf)

Sektionen:

[width="100%",cols="3m,6m,16",options="header"]
|===
| Sektion | Steuerbefehl          | Beschreibung
| look    | /set script.look.*    | Erscheinungsbild.
| color   | /set script.color.*   | Farben.
| scripts | /set script.scripts.* | Optionen für den Download von Skripten.
|===

Optionen:

include::autogen/user/script_options.adoc[]

[[script_commands]]
==== Skript Befehle

include::autogen/user/script_commands.adoc[]

[[python_commands]]
==== Python Befehle

include::autogen/user/python_commands.adoc[]

[[perl_commands]]
==== Perl Befehle

include::autogen/user/perl_commands.adoc[]

[[ruby_commands]]
==== Ruby Befehle

include::autogen/user/ruby_commands.adoc[]

[[lua_commands]]
==== Lua Befehle

include::autogen/user/lua_commands.adoc[]

[[tcl_commands]]
==== Tcl Befehle

include::autogen/user/tcl_commands.adoc[]

[[guile_commands]]
==== Guile Befehle

include::autogen/user/guile_commands.adoc[]

[[javascript_commands]]
==== Javascript Befehle

include::autogen/user/javascript_commands.adoc[]

[[trigger_plugin]]
=== Trigger Erweiterung

Trigger ist das Schweizer Armeemesser für WeeChat. Es können verschiedene
Hooks überwacht werden (signal. modifier, print, ...), der Inhalt von
Daten kann verändert werden, es können ein- oder mehrere Befehle ausgeführt
werden. Eine Bedingung kann genutzt werden um damit zu verhindern, dass der
Trigger unter bestimmten Umständen ausgeführt wird.

Um Trigger nutzen zu können ist es erforderlich zu wissen wie signals,
modifiers, ... in WeeChat funktionieren. Dazu sollte man das Kapitel
_Hooks_ in der _Anleitung für API Erweiterung_ lesen.

[[trigger_options]]
==== Optionen (trigger.conf)

Sektionen:

[width="100%",cols="3m,6m,16",options="header"]
|===
| Sektion | Steuerbefehl                             | Beschreibung
| look    | /set trigger.look.*                      | Erscheinungsbild.
| color   | /set trigger.color.*                     | Farben.
| trigger | <<command_trigger_trigger,/trigger add>> +
            <<command_trigger_trigger,/trigger set>> +
            /set trigger.trigger.*                   | Trigger Optionen.
|===

Optionen:

include::autogen/user/trigger_options.adoc[]

[[trigger_commands]]
==== Befehle

include::autogen/user/trigger_commands.adoc[]

[[trigger_anatomy]]
==== Aufbau eines Triggers

Ein Trigger hat folgende Optionen (Benennung ist
`trigger.trigger.<name>.<option>`):

[width="100%",cols="2m,2,10",options="header"]
|===
| Option | Wert   | Beschreibung

| enabled | `on`, `off` |
  Wenn die Option auf `off` gesetzt ist, dann ist der Trigger deaktiviert und die Ausführung ist gestoppt.

| hook | `signal`, `hsignal`, `modifier`, `print`, `command`, `command_run`,
  `timer`, `config`, `focus` |
  Der hook welcher durch Trigger genutzt werden soll. Für weitere Informationen siehe
  _Anleitung für API Erweiterung_, Kapitel _Hooks_.

| arguments | string |
  Argumente welche der Hook nutzen soll. Dies ist davon abhängig welcher Hook-Typ genutzt wird.

| conditions | string |
  Bedingung wann der Trigger ausgeführt werden soll; Inhalt ist evaluiert
  (siehe Befehl <<command_weechat_eval,/eval>>).

| regex | string |
  Einer oder mehrere erweiterte reguläre POSIX Ausdrücke, um die empfangenen Daten
  im Hook-Callback zu ändern (oder Daten die durch die Trigger-Erweiterung hinzugefügt
  worden sind), siehe <<trigger_regex,reguläre Ausdrücke>>.

| command | string |
  Befehl der ausgeführt werden soll (mehrere Befehle können durch Kommata
  voneinander getrennt werden); Inhalt ist evaluiert (siehe Befehl <<command_weechat_eval,/eval>>).

| return_code | `ok`, `ok_eat`, `error` |
  Rückgabewert des Callback (Standardwert: `ok`, sollte für fast jeden Trigger
  genutzt werden. Die anderen Werte werden höchst selten verwendet).

| post_action | `none`, `disable`, `delete` |
  Aktion welche nach der Abarbeitung des Triggers ausgeführt werden soll
  (Standardwert ist `none` und sollte in den meisten Fällen zur Anwendung
  kommen.)
|===

Ein Beispiel ist der standardmäßig genutzte Trigger _beep_, der
folgende Optionen besitzt:

----
trigger.trigger.beep.enabled = on
trigger.trigger.beep.hook = print
trigger.trigger.beep.arguments = ""
trigger.trigger.beep.conditions = "${tg_highlight} || ${tg_msg_pv}"
trigger.trigger.beep.regex = ""
trigger.trigger.beep.command = "/print -beep"
trigger.trigger.beep.return_code = ok
trigger.trigger.beep.post_action = none
----

[[trigger_execution]]
==== Ausführung

Wenn ein Trigger-Callback aufgerufen wird, dann wird folgende Befehlskette
abgearbeitet:

. Überprüfung von Bedingungen; falls unwahr, beenden
. ersetze Text mittels erweitertem regulärer POSIX Ausdruck (sofern im Trigger definiert)
. ein oder mehrere Befehle werden ausgeführt (sofern im Trigger definiert)
. Beendigung mit einem Rückgabewert (ausgenommen sind die Hooks _modifier_ und _focus_)
. Aktion welche nach der Abarbeitung des Triggers ausgeführt werden soll (falls der Wert abweichend von `none` sein sollte).

[[trigger_hook_arguments]]
==== Hook Argumente

Die Argumente sind abhängig von dem genutzten Hook und werden durch
ein Semikolon getrennt.

[width="100%",cols="2,6,7",options="header"]
|===
| Hook | Argumente | Beispiele

| signal |
  1. Signalname (Priorität erlaubt) (erforderlich) +
  2. Signalname (Priorität erlaubt) +
  3. ... |
  `+*,irc_in_privmsg+` +
  `+*,irc_in_privmsg;*,irc_in_notice+` +
  `+signal_sigwinch+`

| hsignal |
  1. Signalname (Priorität erlaubt) (erforderlich) +
  2. Signalname (Priorität erlaubt) +
  3. ... |
  `+nicklist_nick_added+`

| modifier |
  1. modifier-Name (Priorität erlaubt) (erforderlich) +
  2. modifier-Name (Priorität erlaubt) +
  3. ... |
  `+weechat_print+` +
  `+5000\|input_text_display;5000\|history_add+`

| print |
  1. Buffername +
  2. Tags +
  3. Nachricht +
  4. entferne Farben (0/1) |
  `+irc.freenode.*+` +
  `+irc.freenode.#weechat+` +
  `+irc.freenode.#weechat;irc_notice+` +
  `+*;;;1+`

| command |
  1. Befehlsname (Priorität erlaubt) (erforderlich) +
  2. Beschreibung +
  3. Argumente +
  4. Beschreibung der Argumente +
  5. Vervollständigung |
  `+test+` +
  `+5000\|test+`

| command_run |
  1. Befehl (Priorität erlaubt) (erforderlich) +
  2. Befehl (Priorität erlaubt) +
  3. ... |
  `+/cmd arguments+`

| timer |
  1. Intervall in Millisekunden (erforderlich) +
  2. Abgleich der Sekunden (Standardwert: 0) +
  3. max. Anzahl an Aufrufen (Standardwert: 0, was "unendlich" bedeutet) |
  `+3600000+` +
  `+60000;0;5+`

| config |
  1. Name der Option (Priorität erlaubt) (erforderlich) +
  2. Name der Option (Priorität erlaubt) +
  3. ... |
  `+weechat.look.*+`

| focus |
  1. area Name (Priorität erlaubt) (erforderlich) +
  2. area Name (Priorität erlaubt) +
  3. ... |
  `+buffer_nicklist+`
|===

[[trigger_conditions]]
==== Bedingungen

Bedingungen werden benötigt um einen Vorgang am Laufen zu halten oder um
diesen zu stoppen.

Diese sind evaluiert und die Daten im Callback können verwendet werden
(siehe <<trigger_callback_data,Daten in Callbacks>> und Befehl
<<command_weechat_eval,/eval>>).

Beispiel: der standardmäßig genutzte Trigger _beep_ nutzt folgende Bedingungen,
um ausschließlich bei einer privaten Nachricht oder einem Highlight ausgeführt
zu werden:

----
${tg_highlight} || ${tg_msg_pv}
----

[[trigger_regex]]
==== reguläre Ausdrücke

Reguläre Ausdrücke werden verwendet um Variablen in einem Callback Hashtable zu ändern.

Das Format ist: "/regex/replace" oder "/regex/replace/var" (wobei _var_ eine
Variable eines Hashtable darstellt). +
Sollte _var_ nicht näher spezifiziert sein, wird die Standard-Variable genutzt,
welche abhängig von dem genutzten Hook ist:

[width="50%",cols="4,5m",options="header"]
|===
| Hook        | Standard-Variable
| signal      | tg_signal_data
| hsignal     |
| modifier    | tg_string
| print       | tg_message
| command     | tg_argv_eol1
| command_run | tg_command
| timer       | tg_remaining_calls
| config      | tg_value
| focus       |
|===

Mehrere reguläre Ausdrücke können durch ein Leerzeichen voneinander
getrennt werden, zum Beispiel:
"/regex1/replace1/var1 /regex2/replace2/var2".

Das Zeichen "/" kann durch jedes andere Zeichen ersetzt werden (ein
oder mehrere identische Zeichen).

Matching groups können in "replace" genutzt werden:

* `+${re:0}+` bis `+${re:99}+`: `+${re:0}+` um alles zu matchen, `+${re:1}+` bis
  `+${re:99}+` um Gruppen zu fangen
* `+${re:+}+`: der letzte match (mit der höchsten Nummer)
* `+${hide:c,${re:N}}+`: match "N" mit allen Zeichen die durch "c" ersetzt wurden
  (Beispiel: `+${hide:*,${re:2}}+` ist die group #2 mit allen Zeichen die durch
  `+*+` ersetzt wurden).

Beispiel: nutzte Fettschrift zwischen dem Zeichen "*":

----
/\*(\S+)\*/*${color:bold}${re:1}${color:-bold}*/
----

Beispiel: der Standard-Trigger _server_pass_ nutzt folgenden regulären Ausdruck
um ein Passwort in den Befehlen `/server` und `/connect` zu verbergen (die
einzelnen Zeichen des Passwortes werden durch `+*+` ersetzt):

----
==^(/(server|connect) .*-(sasl_)?password=)(\S+)(.*)==${re:1}${hide:*,${re:4}}${re:5}
----

[NOTE]
In diesem Beispiel wird "==" als Trennzeichen verwendet, da ein "/" in
dem regulären Ausdruck genutzt wird.

[[trigger_command]]
==== Befehl

Der Befehl wird erst ausgeführt nach dem mittels eines regulären Ausdruckes
der Text verändert wurde. Mehrere Befehle können durch Semikolon voneinander
getrennt werden.

Der Inhalt ist evaluiert (siehe Befehl <<command_weechat_eval,/eval>>) und der
durch einen regulären Ausdruck veränderte Text kann in dem Befehl verwendet
werden.

Beispiel: der standardmäßig genutzte Trigger _beep_ nutzt folgenden
Befehl um einen Ton (BEL) zu erzeugen.

----
/print -beep
----

[[trigger_callback_data]]
==== Daten in Callbacks

Daten, die dem Callback übergeben werden, werden in einer Hashtable (Pointer
und Strings) gesichert und können durch folgende Optionen genutzt werden:

* _conditions_
* _regex_
* _command_

Der Inhalt eines Hashtable ist abhängig von dem Hook-Typ.

Ein komfortabler Weg um die Daten eines Triggers zu sehen ist es den
Monitor-Buffer zu öffnen:

----
/trigger monitor
----

[[trigger_data_signal]]
===== Signale

Der Callback von "signal" legt folgende Variablen in der Hashtable an:

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable       | Typ    | Beschreibung
| tg_signal      | string | Name des Signals.
| tg_signal_data | string | Daten die vom Signal gesendet wurde.
|===

Sollte das Signal eine IRC Nachricht beinhalten, wird die Nachricht analysiert
und die Daten in einer Hashtable gesichert:

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable             | Typ    | Beschreibung
| server               | string | Name des Server (Beispiel: "freenode").
| tags                 | string | Tags in Nachricht (findet selten Verwendung).
| message_without_tags | string | Nachricht ohne Tags.
| nick                 | string | Nick.
| host                 | string | Hostname.
| command              | string | IRC Befehl (Beispiel: "PRIVMSG", "NOTICE", ...).
| channel              | string | IRC Channel.
| arguments            | string | Argumente des Befehls (Beinhaltet Wert von _channel_).
| text                 | string | Text (zum Beipiel eine Nachricht eines Users).
| pos_command          | string | Index von _command_ innerhalb einer Nachricht ("-1" falls _command_ nicht gefunden wird).
| pos_arguments        | string | Index von_arguments_ innerhalb einer Nachricht ("-1" falls _arguments_ nicht gefunden wird).
| pos_channel          | string | Index von _channel_ innerhalb einer Nachricht ("-1" falls _channel_ nicht gefunden wird).
| pos_text             | string | Index von _text_ innerhalb einer Nachricht ("-1" falls _text_ nicht gefunden wird).
|===

Sofern es sich bei den Daten um einen Pointer handelt, kann die Variable `tg_signal_data`
wie im folgenden Beispiel genutzt werden um den Inhalt von hdata zu lesen (im Beispiel
wird der Pointer eines Buffer verwendet):

----
${buffer[${tg_signal_data}].full_name}
----

[[trigger_data_hsignal]]
===== Hsignal

Der Callback von "hsignal" legt folgende Variablen in der Hashtable an:

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable  | Typ    | Beschreibung
| tg_signal | string | Name des Signals.
|===

Das Hashtable enthält alle Schlüssel/Werte (Typ: string/string).

[[trigger_data_modifier]]
===== Modifier

Der Callback von "modifier" legt folgende Variablen in der Hashtable an:

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable          | Typ    | Beschreibung
| tg_modifier       | string | Name des modifier.
| tg_modifier_data  | string | Daten die der modifier übermittelt.
| tg_string         | string | Zeichenkette die verändert werden kann.
| tg_string_nocolor | string | Zeichenkette ohne Farbcodes.
|===

Für den modifier _weechat_print_ gilt, Tags werden hinzugefügt, sofern sie
vorhanden sind (siehe <<trigger_data_print,hook print>> weiter unten), und nachfolgende Variablen:

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable           | Typ     | Beschreibung
| buffer             | pointer | Buffer in welchem die Nachricht geschrieben werden soll.
| tg_plugin          | string  | Erweiterung des entsprechenden Buffers.
| tg_buffer          | string  | vollständiger Name des Buffers.
| tg_prefix          | string  | Präfix der Nachricht.
| tg_prefix_nocolor  | string  | Präfix ohne Farbcodes.
| tg_message         | string  | Nachricht die ausgegeben werden soll.
| tg_message_nocolor | string  | Nachricht die ausgegeben werden soll, ohne Farbcodes.
|===

Sollte das Signal eine IRC Nachricht beinhalten, wird die Nachricht analysiert
und die Daten in einer Hashtable gesichert (siehe <<trigger_data_signal,hook signal>>).

[[trigger_data_print]]
===== Print

Der Callback von "print" legt folgende Variablen in der Hashtable an:

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable           | Typ     | Beschreibung
| buffer             | pointer | Buffer.
| tg_date            | string  | Datum/Uhrzeit der Nachricht (Format: `YYYY-MM-DD hh:mm:ss`).
| tg_displayed       | string  | "1" wenn Nachricht dargestellt wird, "0" falls Nachricht gefiltert wird.
| tg_highlight       | string  | "1" falls es sich um eine Highlight-Nachricht handelt, andernfalls "0".
| tg_prefix          | string  | Präfix.
| tg_prefix_nocolor  | string  | Präfix ohne Farbcodes.
| tg_message         | string  | Nachricht.
| tg_message_nocolor | string  | Nachricht ohne Farbcodes.
|===

Variablen welche gesetzt werden, aufgrund der Nutzung von Tags in einer Nachricht
(_weechat_print_ nutzt ebenso diese Tag-Variablen):

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable           | Typ    | Beschreibung
| tg_tags            | string | Tags einer Nachricht (Komma wird automatisch zu Beginn und Ende den Tags hinzugefügt).
| tg_tags_count      | string | Anzahl an Tags der Nachricht.
| tg_tag_nick        | string | Nick (extrahiert aus Tag "nick_xxx").
| tg_tag_prefix_nick | string | Nickfarbe für Präfix (extrahier aus Tag "prefix_nick_ccc").
| tg_tag_host        | string | Username und Host, Format: username@host (extrahiert aus Tag "host_xxx").
| tg_tag_notify      | string | Benachrichtigungsstufe (_none_, _message_, _private_, _highlight_).
| tg_notify          | string | Benachrichtigungsstufe, falls von _none_ abweichend.
| tg_msg_pv          | string | "1" für eine private Nachricht, andernfalls "0".
|===

[[trigger_data_command]]
===== Command

Der Callback von "command" legt folgende Variablen in der Hashtable an:

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable     | Typ     | Beschreibung
| buffer       | pointer | Buffer.
| tg_argvN     | string  | Argument #N.
| tg_argv_eolN | string  | von Argument #N bis zum Ende der Argumente.
|===

[[trigger_data_command_run]]
===== Command_run

Der Callback von "command_run" legt folgende Variablen in der Hashtable an:

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable   | Typ     | Beschreibung
| buffer     | pointer | Buffer.
| tg_command | string  | auszuführender Befehl.
|===

[[trigger_data_timer]]
===== Timer

Der Callback von "timer" legt folgende Variablen in der Hashtable an:

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable           | Typ    | Beschreibung
| tg_remaining_calls | string | Anzahl der noch ausstehenden Aufrufe.
| tg_date            | string | aktuelles Datum und Uhrzeit (Format: `YYYY-MM-DD hh:mm:ss`).
|===

[[trigger_data_config]]
===== Config

Der Callback von "config" legt folgende Variablen in der Hashtable an:

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable  | Typ    | Beschreibung
| tg_option | string | Option.
| tg_value  | string | Wert.
|===

[[trigger_data_focus]]
===== Focus

Der Callback von "focus" legt folgende Variablen in der Hashtable an:

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable | Typ     | Beschreibung
| window   | pointer | Fenster.
| buffer   | pointer | Buffer.
|===

Das Hashtable enthält alle Schlüssel/Werte (Typ: string/string).

[[trigger_examples]]
==== Beispiele

[[trigger_example_url_color]]
===== URLs werden eingefärbt

Zeigt URLs in grün an:

----
/trigger add url_color modifier weechat_print "${tg_notify}" "==\S+://\S+==${color:green}${re:0}${color:reset}=="
----

[NOTE]
Dies ist ein einfacher regulärer Ausdruck der möglicherweise nicht alle URLs
erkennt, dafür ist er aber wesentlich schneller als ein komplexer regulärer Ausdruck.

[[trigger_example_auto_pong]]
===== automatisierte "pong" Antwort, bei einer "ping" Anfrage

Wenn jemand eine "ping" Nachricht in einen privaten Buffer sendet, verschickt dieser Trigger
automatisch eine `pong` Antwort:

----
/trigger add pong print "" "${type} == private && ${tg_message} == ping" "" "pong"
----

[[trigger_example_responsive_layout]]
===== reaktives layout

Der nachfolgende Trigger kann verwendet werden um Anpassungen vorzunehmen, falls
sich die Größe des Terminalfensters verändert:

----
/trigger add resize_small signal signal_sigwinch "${info:term_width} < 100" "" "/bar hide nicklist"
/trigger add resize_big signal signal_sigwinch "${info:term_width} >= 100" "" "/bar show nicklist"
----

Der Trigger nutzt das Signal "signal_sigwinch", welches durch WeeChat verschickt wird
sobald das Signal SIGWINCH vom Terminal empfangen wird.

Die Bedingung `+${info:term_width}+` überprüft die Breite des Terminal (zusätzlich kann
auch `+${info:term_height}+` genutzt werden).

In obigem Beispiel wird die Nicklist versteckt, sobald das Terminal verkleinert wird.
Die Benutzerliste wird wieder angezeigt, sobald die Breite des Terminals größer oder
gleich 100 Zeichen ist.

[[trigger_example_config_save]]
===== automatisches speichern der Konfiguration

Die Konfigurationsdateien (`+*.conf+`), können automatisch jede Stunde
gespeichert werden:

----
/trigger add cfgsave timer 3600000;0;0 "" "" "/mute /save"
----

Argumente für den Hook-Timer sind:

* _3600000_: 3600 * 1000 Millisekunden, der Callback wird jede Stunde ausgeführt
* _0_: Abgleich der Sekunden (es findet keine Justierung statt)
* _0_: maximale Anzahl an aufrufen (0 = unbegrenzt)

Der Befehl `/mute /save` sorgt dafür, dass die Konfiguration ohne kommentarlos
gespeichert wird (es findet keine Ausgabe im Core-Buffer statt).

[[xfer_plugin]]
=== Xfer Erweiterung

Mit der xfer Erweiterung kann man:

* einen direkten Chat nutzen (zwischen zwei Hosts, ohne Server): zum Beispiel "DCC Chat"
  mittels IRC Erweiterung
* Datentransfer, zum Beispiel "DCC" mittels IRC Erweiterung

[[xfer_options]]
==== Optionen (xfer.conf)

Sektionen:

[width="100%",cols="3m,6m,16",options="header"]
|===
| Sektion | Steuerbefehl        | Beschreibung
| look    | /set xfer.look.*    | Erscheinungsbild.
| color   | /set xfer.color.*   | Farben.
| network | /set xfer.network.* | Netzwerkoptionen.
| file    | /set xfer.file.*    | Optionen zum Versenden und Empfangen von Dateien.
|===

Optionen:

include::autogen/user/xfer_options.adoc[]

[[xfer_commands]]
==== Befehle

include::autogen/user/xfer_commands.adoc[]

[[support]]
== Unterstützung

Bevor man nach Unterstützung fragt sollte man sicherstellen, dass man sowohl die
Dokumentation als auch die FAQ gelesen hat, welche mit WeeChat bereitgestellt wird.

Unterstützung im IRC findet man auf dem Server _chat.freenode.net_:

* offizielle Channel (Entwickler vertreten):
** _#weechat_ (englisch)
** _#weechat-fr_ (französisch)
* kein offizieller Channel:
** _#weechat-de_ (deutsch)

Weitere Möglichkeiten, um mit den Entwicklern in Kontakt zu treten, siehe: https://weechat.org/dev/support
