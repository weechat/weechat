//
// This file is auto-generated by script docgen.py.
// DO NOT EDIT BY HAND!
//

// tag::irc_commands[]
[[command_irc_admin]]
* `+admin+`: Information über den Server-Administrator abfragen

----
/admin  [<target>]

target: Servername
----

[[command_irc_allchan]]
* `+allchan+`: führt einen Befehl aus der an alle Kanäle gesendet wird, die mit einem Server verbunden sind

----
/allchan  [-current] [-parted] [-exclude=<channel>[,<channel>...]] <command>
          [-current] [-parted] -include=<channel>[,<channel>...] <command>

 -current: führt einen Befehl aus der an alle Kanäle des aktuellen Servers gesendet wird
  -parted: wird nur bei vom Server getrennten Kanälen ausgeführt
 -exclude: dient zum Ausschluss ausgewählter Kanäle (Platzhalter "*" kann verwendet werden)
 -include: findet Anwendung für ausgewählte Kanäle (Platzhalter "*" kann verwendet werden)\n
  command: Befehl der ausgeführt werden soll

Argumente und Befehl werden evaluiert (siehe /help eval), folgende Variablen können genutzt werden:
  $server             Name des Servers
  $channel            Name des Kanals
  $nick               Nickname der auf dem Server genutzt wird
  ${irc_server.xxx}   Variable xxx von Server
  ${irc_channel.xxx}  Variable xxx von Kanal

Beispiele:
  führe den Befehl '/me Ich teste gerade etwas...' für alle Kanäle aus:
    /allchan /me Ich teste gerade etwas...
  schicke 'Hallo Welt' an jeden Kanal, ausgenommen an den #weechat Kanal:
    /allchan -exclude=#weechat Hallo Welt
  schicke 'Hallo Welt' an jeden Kanal, ausgenommen an den #weechat Kanal und Kanäle die mit #linux beginnen:
    /allchan -exclude=#weechat,#linux* Hallo Welt
  schickt den Text 'Hallo' an alle Kanäle die mit #linux beginnen:
    /allchan -include=#linux* Hallo
  schließt alle, vom Server getrennte, Kanäle.:
    /allchan -parted /close
----

[[command_irc_allpv]]
* `+allpv+`: führt einen Befehl aus der an alle privaten Buffer gesendet wird, die mit einem Server verbunden sind

----
/allpv  [-current] [-exclude=<nick>[,<nick>...]] <command>
        [-current] -include=<nick>[,<nick>...] <command>

 -current: führt einen Befehl aus der für alle privaten Buffer, des aktuellen Servers, Anwendung findet
 -exclude: dient zum Ausschluss ausgewählter Nicks (Platzhalter "*" kann verwendet werden)
 -include: findet Anwendung für ausgewählte Nicks (Platzhalter "*" kann verwendet werden)
  command: Befehl der ausgeführt werden soll

Argumente und Befehl werden evaluiert (siehe /help eval), folgende Variablen können genutzt werden:
  $server             Name des Servers
  $channel            Name des Kanals
  $nick               Nickname der auf dem Server genutzt wird
  ${irc_server.xxx}   Variable xxx von Server
  ${irc_channel.xxx}  Variable xxx von Kanal

Beispiele:
  führe den Befehl '/me Ich teste gerade etwas...' für alle privaten Buffer aus:
    /allpv /me Ich teste gerade etwas...
  schicke 'Hallo' an alle, ausgenommen an Nick foo:
    /allpv -exclude=foo Hallo
  schicke den Text 'Hallo' an alle, ausgenommen für Nick foo und Nicks die mit bar beginnen:
    /allpv -exclude=foo,bar* Hallo
  schicke den Text 'Hallo' an alle Nicks die mit bar beginnen:
    /allpv -include=bar* Hallo
  schließe alle privaten Buffer:
    /allpv /close
----

[[command_irc_allserv]]
* `+allserv+`: führt einen Befehl aus, der zu allen verbundenen Server gesendet wird

----
/allserv  [-exclude=<server>[,<server>...]] <command>
          -include=<server>[,<server>...] <command>

 -exclude: dient zum Ausschluss ausgewählter Server (Platzhalter "*" kann verwendet werden)
 -include: findet Anwendung für ausgewählte Server (Platzhalter "*" kann verwendet werden)
  command: Befehl der ausgeführt werden soll

Argumente und Befehl werden evaluiert (siehe /help eval), folgende Variablen können genutzt werden:
  $server             Name des Servers
  $nick               Nickname der auf dem Server genutzt wird
  ${irc_server.xxx}   Variable xxx von Server

Beispiele:
  ändere den Nick auf allen Servern:
    /allserv /nick newnick
  setzt den Status, auf allen Servern, auf abwesend:
    /allserv /away I'm away
  führt ein whois mit meinem nick auf allen Servern aus:
    /allserv /whois $nick
----

[[command_irc_auth]]
* `+auth+`: authentifizieren mit SASL

----
/auth  [<username> <password>]

username: SASL Username (Inhalt ist evaluiert, siehe /help eval; Serveroptionen werden mit ${irc_server.xxx} evaluiert und ${server} wird durch den Servernamen ersetzt)
password: SASL-Passwort oder Pfad zur Datei mit privatem Schlüssel (Inhalt ist evaluiert, siehe /help eval; Serveroptionen werden mit ${irc_server.xxx} evaluiert und ${server} wird durch den Servernamen ersetzt)

Wenn Benutzername und Kennwort nicht angegeben wurden, werden die Werte aus den Serveroptionen "sasl_username" und "sasl_password" (oder "sasl_key") verwendet.

Beispiele:
  authentifizieren Sie sich mit dem im Server definierten Benutzernamen/Passwort:
    /auth
  authentifizieren Sie sich mit einem anderen Benutzer:
    /auth user2 password2
  authentifizieren als anderer Benutzer mit Mechanismus ecdsa-nist256p-challenge:
    /auth user2 ${weechat_config_dir}/ecdsa2.pem
----

[[command_irc_autojoin]]
* `+autojoin+`: Konfigurieren der Serveroption "autojoin"

----
/autojoin  add [<channel1> [<channel2>...]]
           addraw <channel1>[,<channel2>...] [<key1>[,<key2>...]]
           del [<channel1> [<channel2>...]]
           apply
           sort

    add: Hinzufügen des aktuellen Kanals oder einer Liste von Kanälen (mit optionalen Schlüsseln) zur autojoin-Option; Wenn Sie sich in dem Kanal befinden und der Schlüssel nicht übergeben wird, wird der Schlüssel im Kanal gelesen
 addraw: das IRC Roh-Format wird genutzt (wie beim /join Befehl): alle Kanäle werden durch Kommata voneinander getrennt und optional werden die Schlüssel durch Kommata separiert
    del: Löschen des aktuellen Kanals oder eine Liste von Kanälen aus der autoJoin-Option
channel: Kanalname
    key: Schlüssel für den Kanal
  apply: fügt die aktuell besuchten Kanäle in der autojoin-Option hinzu
   sort: sortiert die Kanäle alphabetisch in der autojoin Option

Beispiele:
  /autojoin add
  /autojoin add #test
  /autojoin add #chan1 #chan2
  /allchan /autojoin add
  /autojoin addraw #chan1,#chan2,#chan3 key1,key2
  /autojoin del
  /autojoin del #chan1
  /autojoin apply
  /autojoin sort
----

[[command_irc_ban]]
* `+ban+`: Nicknamen oder Hosts sperren/verbannen

----
/ban  [<channel>] [<nick> [<nick>...]]

channel: Name des Kanals
   nick: Nick oder Host

Ohne Angabe von Argumenten wird die Ban-Liste für den aktuellen Kanal angezeigt.
----

[[command_irc_cap]]
* `+cap+`: Aushandlung der Clientfähigkeit

----
/cap  ls
      list
      req|ack [<capability> [<capability>...]]
      end

   ls: führt alle Fähigkeiten auf die vom Server unterstützt werden
 list: führt alle Fähigkeiten auf die aktuell genutzt werden
  req: fordert eine Fähigkeit an
  ack: bestätigt eine Fähigkeit die von Serverseite eine Bestätigung erfordert
  end: beendet die Übertragung von Fähigkeiten

Ohne Angaben von Argumenten werden "ls" und "list" gesendet.

Fähigkeiten die von WeeChat unterstützt werden: account-notify, away-notify, cap-notify, chghost, extended-join, invite-notify, message-tags, multi-prefix, server-time, setname, userhost-in-names..

Fähigkeiten die standardmäßig genutzt werden sollen, können mit der Option irc.server_default.capabilities gesetzt werden (oder individuell für jeden Server mit der Option irc.server.xxx.capabilities).

Beispiele:
  zeigt unterstützte und aktivierte Funktionen an:
    /cap
  Fähigkeiten multi-prefix und away-notify anfordern:
    /cap req multi-prefix away-notify
  Fähigkeit extended-join anfordern, Fähigkeit multi-prefix entfernen:
    /cap req extended-join -multi-prefix
  Fähigkeit away-notify entfernen
    /cap req -away-notify
----

[[command_irc_connect]]
* `+connect+`: Mit IRC-Server(n) verbinden

----
/connect  [<server> [<server>...]] [-<option>[=<value>]] [-no<option>] [-nojoin] [-switch]
          -all|-auto|-open [-nojoin] [-switch]

    server: Name des Servers, folgende Möglichkeiten bestehen:
            - intern genutzter Servername, zu dem eine Verbindung aufgebaut werden soll (Server muss zuerst mittels "/server add" angelegt werden (wird empfohlen!))
            - Hostname/Port oder IP/Port, Port 6667 wird standardmäßig verwendet
            - URL mit folgendem Format: irc[6][s]://[nickname[:password]@]irc.example.org[:port][/#channel1][,#channel2[...]]
            Hinweis: bei einer Adresse/IP/URL, wird ein temporärer Server erstellt (DIESER WIRD NICHT GESPEICHERT), siehe /help irc.look.temporary_servers
    option: legt Einstellung für den Server fest (die Boolean-Einstellungen können weggelassen werden)
  nooption: deaktiviert eine Boolean Einstellung (Beispiel: -nossl)
      -all: Verbindung wird zu den Servern hergestellt, für die eine Konfiguration vorhanden ist
     -auto: Verbindung zu den Servern herstellen, für die die Einstellung "autoconnect" aktiviert ist
     -open: stellt eine Verbindung zu allen geöffneten Servern her, zu denen aktuell keine Verbindung besteht
   -nojoin: Channel(s) werden nicht betreten (auch falls die Funktion "autojoin" aktiviert sein sollte)
   -switch: wechselt zur nächsten Server-Adresse

Um eine Verbindung zum Server, oder Verbindungsversuche, zu beenden wird der Befehl /disconnect verwendet.

Beispiele:
  /connect libera
  /connect irc.oftc.net/6667
  /connect irc6.oftc.net/6667 -ipv6
  /connect irc6.oftc.net/6697 -ipv6 -ssl
  /connect my.server.org/6697 -ssl -password=test
  /connect irc://nick@irc.oftc.net/#channel
  /connect -switch
----

[[command_irc_ctcp]]
* `+ctcp+`: CTCP-Nachricht verschicken

----
/ctcp  [-server <server>] <target>[,<target>...] <type> [<arguments>]

   server: an diesen Server senden (interner Servername)
   target: Nick- oder Kanalname an welchen eine CTCP-Nachricht geschickt werden soll ('*' = aktueller Kanal)
     type: CTCP-Nachricht (Beispiele: "version", "ping", usw.)
arguments: Argumente für CTCP

Beispiele:
  /ctcp toto time
  /ctcp toto version
  /ctcp * version
----

[[command_irc_cycle]]
* `+cycle+`: Einen Kanal verlassen und wieder betreten

----
/cycle  [<channel>[,<channel>...]] [<message>]

channel: Name des Kanals
message: Abschiedsnachricht (wird anderen Usern angezeigt)
----

[[command_irc_dcc]]
* `+dcc+`: Startet DCC Verbindung (Datentransfer oder einen Direktchat)

----
/dcc  chat <nick>
      send <nick> <file>

nick: Nickname
file: zu versendende Datei (welche lokal vorliegt)

Beispiel:
  sendet eine Chat-Anfrage an den User "toto"
    /dcc chat toto
  sendet die Datei "/home/foo/bar.txt" an den User "toto"
    /dcc send toto /home/foo/bar.txt
----

[[command_irc_dehalfop]]
* `+dehalfop+`: halb-Operator-Privilegien einem oder mehreren Nick(s) entziehen

----
/dehalfop  <nick> [<nick>...]
           * -yes

nick: Nick oder Maske (Platzhalter "*" kann verwendet werden)
   *: entzieht allen Nicks im Kanal den half-operator-Status, ausgenommen sich selber
----

[[command_irc_deop]]
* `+deop+`: Operator-Privilegien einem oder mehreren Nicknamen entziehen

----
/deop  <nick> [<nick>...]
       * -yes

nick: Nick oder Maske (Platzhalter "*" kann verwendet werden)
   *: entzieht allen Nicks im Kanal den Operator-Status, ausgenommen sich selber
----

[[command_irc_devoice]]
* `+devoice+`: Voice-Privilegien einem oder mehreren Nicknamen entziehen

----
/devoice  <nick> [<nick>...]
          * -yes

nick: Nick oder Maske (Platzhalter "*" kann verwendet werden)
   *: entzieht allen Nicks im Kanal den voice-Status
----

[[command_irc_die]]
* `+die+`: Server herunterfahren

----
/die  [<target>]

target: Servername
----

[[command_irc_disconnect]]
* `+disconnect+`: Verbindung zu einem oder mehreren IRC-Server(n) trennen

----
/disconnect  [<server>|-all|-pending [<reason>]]

  server: interner Name des Servers
    -all: Verbindung zu allen Servern trennen
-pending: bricht eine automatische Wiederverbindung zu Servern ab, zu denen gerade eine erneute Verbindung aufgebaut werden soll
  reason: Begründung für die Trennung
----

[[command_irc_halfop]]
* `+halfop+`: halb-Operator Status an Nick(s) vergeben

----
/halfop  <nick> [<nick>...]
         * -yes

nick: Nick oder Maske (Platzhalter "*" kann verwendet werden)
   *: vergibt an alle Nicks im Kanal den half-operator-Status
----

[[command_irc_ignore]]
* `+ignore+`: Ignoriert Nicks/Hosts von Kanälen oder Servern

----
/ignore  list
         add [re:]<nick> [<server> [<channel>]]
         del <number>|-all

     list: zeigt alle Ignorierungen an
      add: fügt eine Ignorierung hinzu
     nick: Nick oder Hostname (dies kann ein erweiterter regulärer POSIX Ausdruck sein, sofern "re:" angegeben wird oder eine Maske mittels "*" genutzt wird um ein oder mehrere Zeichen zu ersetzen)
      del: entfernt eine Ignorierung
   number: Nummer der Ignorierung die entfernt werden soll (nutze "list" um den entsprechenden Eintrag zu finden)
     -all: entfernt alle Einträge
   server: interner Name des Server auf welchem die Ignorierung statt finden soll
  channel: Name des Kanals, in dem die Ignorierung statt finden soll

Hinweis: Um zwischen Groß-und Kleinschreibung zu unterscheiden muss am Wortanfang "(?-i)" genutzt werden.

Beispiele:
  ignoriert den Nick "toto" global:
    /ignore add toto
  ignoriert den Host "toto@domain.com" auf dem libera Server:
    /ignore add toto@domain.com libera
  ignoriert den Host "toto*@*.domain.com" im Chat libera/#weechat:
    /ignore add toto*@*.domain.com libera #weechat
----

[[command_irc_info]]
* `+info+`: Information über den Server abfragen

----
/info  [<target>]

target: Servername
----

[[command_irc_invite]]
* `+invite+`: Eine Person in einen Kanal einladen

----
/invite  <nick> [<nick>...] [<channel>]

   nick: Nickname
channel: Name des Kanals
----

[[command_irc_ison]]
* `+ison+`: Überprüft ob ein Nick gegenwärtig auf IRC angemeldet ist

----
/ison  <nick> [<nick>...]

nick: Nickname
----

[[command_irc_join]]
* `+join+`: einen Kanal betreten

----
/join  [-noswitch] [-server <server>] [<channel1>[,<channel2>...]] [<key1>[,<key2>...]]

-noswitch: es wird nicht zu dem angegebenen Kanal gewechselt
   server: an angegebenen Server (interner Name) senden
  channel: Name des Kanals, der betreten werden soll
      key: Zugriffsschlüssel für einen Kanal (Kanäle, die einen Zugriffsschlüssel benötigen, müssen zuerst aufgeführt werden)

Beispiele:
  /join #weechat
  /join #geschützter_Kanal,#weechat Zugriffsschlüssel
  /join -server libera #weechat
  /join -noswitch #weechat
----

[[command_irc_kick]]
* `+kick+`: wirft einen User aus einem Kanal

----
/kick  [<channel>] <nick> [<reason>]

channel: Kanalname
   nick: Nick der rausgeworfen werden soll
 reason: Begründung für den Rauswurf (evaluiert, siehe /help eval; besondere Variablen ${nick} (eigener Nick), ${target} (betroffener Nick), ${channel} und ${server}, werden durch den entsprechenden Wert ersetzt)
----

[[command_irc_kickban]]
* `+kickban+`: wirft einen User aus einem Kanal und sein Host kommt auf die Bannliste

----
/kickban  [<channel>] <nick> [<reason>]

channel: Kanalname
   nick: Nickname der rausgeworfen und gebannt werden soll
 reason: Begründung für den Rauswurf (evaluiert, siehe /help eval; besondere Variablen ${nick} (eigener Nick), ${target} (betroffener Nick), ${channel} und ${server}, werden durch den entsprechenden Wert ersetzt)

Es ist möglich kick/ban mittels einer Maske auszuführen. Der Nick wird aus der Maske heraus gefiltert und durch "*" ersetzt.

Beispiel:
  sperre "*!*@host.com" und kicke dann "toto":
    /kickban toto!*@host.com
----

[[command_irc_kill]]
* `+kill+`: Beende Client-Server Verbindung

----
/kill  <nick> [<reason>]

  nick: Nickname
reason: Grund der Abmeldung
----

[[command_irc_links]]
* `+links+`: alle Servernamen auflisten, die dem antwortenden Server bekannt sind

----
/links  [[<target>] <server_mask>]

     target: dieser Remote-Server soll die Anfrage beantworten
server_mask: die aufzulistenden Server sollen diesem Muster entsprechen
----

[[command_irc_list]]
* `+list+`: Kanäle und deren Themen auflisten

----
/list  [-server <server>] [-re <regex>] [<channel>[,<channel>...]] [<target>]

 server: an diesen Server senden (interner Name)
 regexp: erweiterter regulärer POSIX Ausdruck, der auf die Ausgabe angewendet werden soll (zwischen Groß- und Kleinschreibung wird nicht unterschieden. Um zwischen Groß- und Kleinschreibung zu unterscheiden muss zu Beginn "(?-i)" genutzt werden)
channel: aufzulistender Kanal
 target: Servername

Beispiele:
  listet alle Kanäle des Servers auf (dies kann bei großen Netzwerken sehr lange dauern):
    /list
  listet den Kanal #weechat auf:
    /list #weechat
  listet alle Kanäle auf die mit "#weechat" beginnen (dies kann bei großen Netzwerken sehr lange dauern):
    /list -re #weechat.*
----

[[command_irc_lusers]]
* `+lusers+`: Statistik über die Größe des IRC-Netzwerks abfragen

----
/lusers  [<mask> [<target>]]

  mask: ausschließlich Server, die diesem Muster entsprechen
target: Server, der die Anfrage weiterleiten soll
----

[[command_irc_map]]
* `+map+`: Zeigt das IRC Netzwerk, in Form einer Baumstruktur, an

----
----

[[command_irc_me]]
* `+me+`: eine CTCP ACTION an den aktuellen Kanal senden

----
/me  <message>

message: zu sendende Nachricht
----

[[command_irc_mode]]
* `+mode+`: Eigenschaften eines Kanals oder von einem User ändern

----
/mode  [<channel>] [+|-]o|p|s|i|t|n|m|l|b|e|v|k [<arguments>]
       <nick> [+|-]i|s|w|o

Kanal-Eigenschaften:
  channel: zu ändernder Kanal (standardmäßig der erste Kanal)
  o: vergibt/entzieht Operator Privilegien
  p: privater Kanal
  s: geheimer Kanal
  i: geschlossener Kanal (Zutritt nur mit Einladung)
  t: nur Operatoren dürfen das Thema setzen
  n: keine Nachrichten von außerhalb des Kanals zulassen
  m: moderierter Kanal (schreiben nur mit Voice)
  l: maximale Anzahl an Usern im Kanal festlegen
  b: Bannmaske für zu sperrende User (in nick!ident@host-Form)
  e: legt Ausnahmemaske fest
  v: vergibt/entzieht Schreibrechte (voice) in moderierten Kanälen
  k: legt ein Passwort für den Kanal fest
User-Eigenschaften:
  nick: zu ändernder Nickname
  i: User als unsichtbar kennzeichnen
  s: User empfängt Server-Nachrichten
  w: User empfängt WALLOPS
  o: User ist Channel-Operator

Die Liste der hier dargestellten Eigenschaften ist nicht vollständig. Es sollte die Dokumentation des jeweiligen Servers zu Rate gezogen werden, um alle verfügbaren Modi zu erfahren.

Beispiele:
  schützt das Thema des Channels #weechat:
    /mode #weechat +t
  um sich auf dem Server unsichtbar machen:
    /mode nick +i
----

[[command_irc_motd]]
* `+motd+`: Die "Mitteilung des Tages" abfragen

----
/motd  [<target>]

target: Servername
----

[[command_irc_msg]]
* `+msg+`: Nachricht an Nick/Kanal verschicken

----
/msg  [-server <server>] <target>[,<target>...] <text>

server: schicke an diesen Server (interner Servername)
target: Nick oder Kanal (darf eine Maske sein, '*' = aktueller c)
  text: zu sendender Text
----

[[command_irc_names]]
* `+names+`: Nicknamen des Kanals auflisten

----
/names  [<channel>[,<channel>...]]

channel: Name des Kanals
----

[[command_irc_nick]]
* `+nick+`: derzeitigen Nicknamen ändern

----
/nick  [-all] <nick>

-all: Nickname auf allen verbundenen Servern ändern
nick: neuer Nickname
----

[[command_irc_notice]]
* `+notice+`: Mitteilung (notice) an einen User verschicken

----
/notice  [-server <server>] <target> <text>

server: an diesen Server senden (interner Name)
target: Nick- oder Kanalname
  text: zu sendender Text
----

[[command_irc_notify]]
* `+notify+`: fügt eine Benachrichtigung für An- oder Abwesenheit von Nicks auf Servern hinzu

----
/notify  add <nick> [<server> [-away]]
         del <nick>|-all [<server>]

   add: fügt eine Benachrichtigung hinzu
  nick: Nickname
server: interner Name des Servers (Standard: aktueller Server)
 -away: gibt eine Benachrichtigung aus, falls sich die Abwesenheitsnachricht ändert (der Nick wird mittels whois abgefragt)
   del: entfernt eine Benachrichtigung
  -all: entfernt alle Benachrichtigungen

Ohne Angabe von Argumenten werden alle Benachrichtigungen für den aktuellen Server angezeigt (um alle Server abzufragen muss der Befehl im Core Buffer ausgeführt werden).

Beispiele:
  Benachrichtigung falls sich "toto" am aktuellen Server an- oder abmeldet:
    /notify add toto
  Benachrichtigung falls sich "toto" am libera Server an- oder abmeldet:
    /notify add toto libera
  Benachrichtigung falls "toto" den Befehl away am libera Server nutzt:
    /notify add toto libera -away
----

[[command_irc_op]]
* `+op+`: Status des Kanal-Operator an Nicknamen vergeben

----
/op  <nick> [<nick>...]
     * -yes

nick: Nick oder Maske (Platzhalter "*" kann verwendet werden)
   *: vergibt an alle Nicks im Kanal den Operator-Status
----

[[command_irc_oper]]
* `+oper+`: Operator Privilegien anfordern

----
/oper  <user> <password>

    user: Username
password: Passwort
----

[[command_irc_part]]
* `+part+`: Einen Kanal verlassen

----
/part  [<channel>[,<channel>...]] [<message>]

channel: Name des Kanals welcher verlassen werden soll
message: Abschiedsnachricht (wird anderen Usern angezeigt)
----

[[command_irc_ping]]
* `+ping+`: sendet einen Ping an den Server

----
/ping  <target1> [<target2>]

target1: Server
target2: Ping an diesen Server weiterleiten
----

[[command_irc_pong]]
* `+pong+`: Auf Ping antworten

----
/pong  <daemon> [<daemon2>]

 Daemon: Daemon welcher auf die Ping-Nachricht geantwortet hat
Daemon2: Nachricht an diesen Daemon weiterleiten
----

[[command_irc_query]]
* `+query+`: Eine private Nachricht an einen Nick schicken

----
/query  [-noswitch] [-server <server>] <nick>[,<nick>...] [<text>]

-noswitch: es wird nicht zum neuen Buffer gewechselt
server: an diesen Server senden (interner Name)
target: Nickname
  text: zu sendender Text
----

[[command_irc_quiet]]
* `+quiet+`: Nicks oder Hosts das Wort entziehen (User können im Kanal erst schreiben, wenn sie "+v" oder höher besitzen)

----
/quiet  [<channel>] [<nick> [<nick>...]]

channel: Name des Kanals
   nick: Nick oder Host

Ohne Angabe von Argumenten wird die Quiet-Liste für den aktuellen Kanal angezeigt.
----

[[command_irc_quote]]
* `+quote+`: Daten direkt an Server senden (siehe RFC 2812)

----
/quote  [-server <server>] <data>

server: an diesen Server senden (interner Name wird genutzt)
data: unbearbeitete (RAW) Daten die gesendet werden sollen
----

[[command_irc_reconnect]]
* `+reconnect+`: Mit einem oder mehreren Server(n) erneut verbinden

----
/reconnect  <server> [<server>...] [-nojoin] [-switch]
            -all [-nojoin] [-switch]

 server: Servername zu welchem neu verbunden werden soll (interner Name)
   -all: mit allen Servern neu verbinden
-nojoin: Kanäle werden nicht betreten (auch falls autojoin für diesen Server aktiviert ist)
-switch: wechselt zur nächsten Server-Adresse
----

[[command_irc_rehash]]
* `+rehash+`: Den Server auffordern seine Konfigurationsdatei neu zu laden

----
/rehash  [<option>]

option: zusätzliche Einstellung, die von manchen Servern berücksichtigt wird
----

[[command_irc_remove]]
* `+remove+`: zwingt einen User einen Kanal zu verlassen

----
/remove  [<channel>] <nick> [<reason>]

channel: Kanalname
   nick: Nick der rausgeworfen werden soll
 reason: Begründung für den Rauswurf (Variablen die genutzt werden können: $nick, $channel und $server)
----

[[command_irc_restart]]
* `+restart+`: Server dazu bringen sich selbst neu zu starten

----
/restart  [<target>]

target: Servername
----

[[command_irc_sajoin]]
* `+sajoin+`: fordert einen User auf einen oder mehrere Kanäle zu betreten

----
/sajoin  <nick> <channel>[,<channel>...]

   nick: Nickname
channel: Name des Kanals
----

[[command_irc_samode]]
* `+samode+`: ändert den Modus des Kanals ohne das Operator-Privilegien vorliegen

----
/samode  [<channel>] <mode>

Channel: Name des Kanals
   Mode: neuer Modus für Kanal
----

[[command_irc_sanick]]
* `+sanick+`: zwingt einen User den Nick zu ändern

----
/sanick  <nick> <new_nick>

    nick: Nickname
new_nick: neuer Nickname
----

[[command_irc_sapart]]
* `+sapart+`: zwingt einen User den oder die Kanäle zu verlassen

----
/sapart  <nick> <channel>[,<channel>...]

   nick: Nickname
channel: Name des Kanals
----

[[command_irc_saquit]]
* `+saquit+`: Zwingt einen User den Server mit Begründung zu verlassen

----
/saquit  <nick> <reason>

  nick: Nickname
reason: Grund der Abmeldung
----

[[command_irc_server]]
* `+server+`: auflisten, hinzufügen oder entfernen von IRC-Servern

----
/server  list|listfull [<name>]
         add <name> <hostname>[/<port>] [-temp] [-<option>[=<value>]] [-no<option>]
         copy|rename <name> <new_name>
         reorder <name> [<name>...]
         open <name>|-all [<name>...]
         del|keep <name>
         deloutq|jump
         raw [<filter>]

    list: listet Server auf (ohne Angabe von Argumente wird diese Liste standardmäßig ausgegeben)
listfull: listet alle Server auf, mit detaillierten Informationen zu jedem einzelnen Server
     add: erstellt einen neuen Server
    name: Servername, dient der internen Nutzung und zur Darstellung; dieser Name wird genutzt um sich mit dem Server zu verbinden (/connect name) und um die entsprechenden Optionen anzupassen: irc.server.name.xxx
hostname: Name oder IP-Adresse des Servers. Optional kann zusätzlich der Port festgelegt werden (Standard-Port: 6667). Mehrere Adressen können durch Kommata getrennt werden
   -temp: erstellt temporären Server (wird nicht gespeichert)
  option: legt die Optionen für den Server fest (die Boolean-Optionen können weggelassen werden)
nooption: stellt die Boolean Einstellung auf 'off' (Beispiel: -nossl)
    copy: erstellt eine Kopie des Servers
  rename: benennt den Server um
 reorder: Anordnung der Server ändern
    open: öffnet den Serverbuffer, ohne eine Verbindung herzustellen
    keep: übernimmt den Server in die Konfigurationsdatei (nur sinnvoll bei temporär angelegten Servern)
     del: entfernt einen Server
 deloutq: löscht bei allen Servern alle ausgehende Nachrichten, die in der Warteschlange stehen (dies betrifft alle Nachrichten die WeeChat gerade sendet)
    jump: springt zum Server-Buffer
     raw: öffnet Buffer mit Roh-IRC-Daten
  filter: setzt einen neuen Filter um übereinstimmende Nachrichten anzuzeigen (ein Filter kann auch in der Eingabezeile im IRC Datenbuffer angelegt werden); erlaubte Formattierungen:
            *       zeigt alle Nachrichten an (keine Filterung von Nachrichten)
            xxx     zeigt nur Nachrichten mit "xxx" an
            s:xxx   zeigt nur Nachrichten von Server "xxx" an
            f:xxx   zeigt nur Nachrichten mit dem entsprechenden Flag an: recv (erhaltene Nachricht), sent (gesendete Nachricht), modified (Nachricht welche modifiziert wurde), redirected (umgeleitete Nachricht)
            m:xxx   zeigt nur IRC Befehl "xxx" an
            c:xxx   zeigt nur Nachrichten an auf die die evaluierte Bedingung "xxx" zutrifft, folgende Variable können verwendet werden: Ausgabe der Funktion irc_message_parse (wie nick, command, channel, text, etc., siehe Funktion info_get_hashtable in der Anleitung für API Erweiterung für eine Liste aller möglichen Variablen), date (Format: "yyyy-mm-dd hh:mm:ss"), server, recv, sent, modified, redirected

Beispiele:
  /server listfull
  /server add libera irc.libera.chat
  /server add libera irc.libera.chat/6697 -ssl -autoconnect
  /server add chatspike irc.chatspike.net/6667,irc.duckspike.net/6667
  /server copy libera libera-test
  /server rename libera-test libera2
  /server reorder libera2 libera
  /server del libera
  /server deloutq
  /server raw
  /server raw s:libera
  /server raw c:${recv} && ${command}==PRIVMSG && ${nick}==foo
----

[[command_irc_service]]
* `+service+`: einen neuen Service eintragen

----
/service  <nick> <reserved> <distribution> <type> <reserved> <info>

distribution: Sichtbarkeit des Services
       type: für spätere Verwendung reserviert
----

[[command_irc_servlist]]
* `+servlist+`: Auflistung von Services die momentan mit dem Netzwerk verbunden sind

----
/servlist  [<mask> [<type>]]

mask: nur zutreffende Services auflisten
type: nur Services von diesem Typ auflisten
----

[[command_irc_setname]]
* `+setname+`: setze Realnamen

----
/setname  <Realname>

realname: neuer Realname
----

[[command_irc_squery]]
* `+squery+`: Nachricht an einen Service senden

----
/squery  <service> <text>

service: Name des Service
   text: zu sendender Text
----

[[command_irc_squit]]
* `+squit+`: Verbindung zum Server trennen

----
/squit  <target> <comment>

 target: Name des Servers
comment: Kommentar
----

[[command_irc_stats]]
* `+stats+`: Serverstatistik abfragen

----
/stats  [<query> [<target>]]

 query: c/h/i/k/l/m/o/y/u (siehe RFC1459)
target: Name des Servers
----

[[command_irc_summon]]
* `+summon+`: Nutzer die auf dem IRC-Server arbeiten darum bitten auf den IRC-Server zu kommen

----
/summon  <user> [<target> [<channel>]]

   user: Benutzername
 target: Servername
channel: Kanalname
----

[[command_irc_time]]
* `+time+`: Ortszeit des Servers abfragen

----
/time  [<target>]

target: Zeit des angegebenen Servers abfragen
----

[[command_irc_topic]]
* `+topic+`: Thema des Kanals abfragen/setzen

----
/topic  [<channel>] [<topic>|-delete]

channel: Name des Kanals
  topic: neues Thema für den Kanal
-delete: entfernt das Thema des Kanals
----

[[command_irc_trace]]
* `+trace+`: Route zum angegebenen Server ermitteln

----
/trace  [<target>]

target: Servername
----

[[command_irc_unban]]
* `+unban+`: Bann von Nicks oder Hosts aufheben

----
/unban  [<channel>] <nick>|<number> [<nick>|<number>...]

channel: Name des Kanals
   nick: Nick oder Host
 number: ban Nummer (wird beim Befehl /ban angezeigt)
----

[[command_irc_unquiet]]
* `+unquiet+`: Nicks oder Hosts das Wort erteilen

----
/unquiet  [<channel>] <nick>|<number> [<nick>|<number>...]

channel: Name des Kanals
   nick: Nick oder Host
 number: Quiet-Nummer (wird beim Befehl /quiet angezeigt)
----

[[command_irc_userhost]]
* `+userhost+`: zeigt Informationen zu Nicknamen an

----
/userhost  <nick> [<nick>...]

nick: Nickname
----

[[command_irc_users]]
* `+users+`: Auflistung der User die bei dem Server angemeldet sind

----
/users  [<target>]

target: Servername
----

[[command_irc_version]]
* `+version+`: Versionsinformation des Nicknamen oder Servers ermitteln (des aktuellen oder angegebenen Nick/Server)

----
/version  [<target>|<nick>]

target: Servername
  nick: Nickname
----

[[command_irc_voice]]
* `+voice+`: Voice an Nick(s) vergeben

----
/voice  <nick> [<nick>...]
        * -yes

nick: Nick oder Maske (Platzhalter "*" kann verwendet werden)
   *: vergibt an alle Nicks im Kanal den voice-Status
----

[[command_irc_wallchops]]
* `+wallchops+`: Nachricht an Kanal-Operator verschicken

----
/wallchops  [<channel>] <text>

channel: Name des Kanals
   text: Text der versendet werden soll
----

[[command_irc_wallops]]
* `+wallops+`: Nachricht an alle User schicken die den 'w'-Mode gesetzt haben

----
/wallops  <text>

text: Text der gesendet werden soll
----

[[command_irc_who]]
* `+who+`: sendet eine Anfrage die eine Anzahl von Informationen zurück gibt

----
/who  [<mask> [o]]

mask: nur Information über betreffende Nicknamen abfragen
   o: nur Operatoren ausgeben, die dem Filter entsprechen
----

[[command_irc_whois]]
* `+whois+`: Information über User abfragen

----
/whois  [<target>] [<nick>[,<nick>...]]

target: Name des Servers (interner Servername)
  nick: Nick, welcher abgefragt werden soll (es kann auch eine Maske genutzt werden)

Ohne Angabe von Argumenten, nutzt /whois folgende Regel:
- den eigenen Nick, falls es sich um einen Server/Kanal-Buffer handelt
- den Nick des Gesprächspartners, falls es sich um einen privaten Buffer handelt.

Sollte die Einstellung irc.network.whois_double_nick aktiviert sein dann wird ein Nick zweimal verwendet (sofern der Nick nur einmal angegeben wurde), um die Idle-Zeit zu erhalten.
----

[[command_irc_whowas]]
* `+whowas+`: Informationen über einen nicht mehr angemeldeten Nicknamen abfragen

----
/whowas  <nick>[,<nick>...] [<count> [<target>]]

  nick: Nickname
 count: maximale Anzahl an Antworten (negative Zahl für eine vollständige Suche)
target: Antwort soll auf diese Suchmaske zutreffen
----
// end::irc_commands[]

// tag::alias_commands[]
[[command_alias_alias]]
* `+alias+`: auflisten, hinzufügen oder entfernen von Alternativnamen

----
/alias  list [<alias>]
        add <alias> [<command>[;<command>...]]
        addcompletion <completion> <alias> [<command>[;<command>...]]
        del <alias> [<alias>...]

         list: listet Alternativbefehle auf (ohne Angabe von Argumenten wird diese Liste dargestellt)
          add: fügt einen Alternativbefehl hinzu
addcompletion: fügt einen Alternativbefehl, mit einer benutzerdefinierten Vervollständigung, hinzu
          del: entfernt einen Alternativbefehl
   completion: Vervollständigung für Alternativbefehl: standardmäßig wird die Vervollständigung auf den Zielbefehl angewendet
               Hinweis: Mit der Variablen "%%command" kann eine Vervollständigung eines vorhandenen Befehls durchgeführt werden
        alias: Name des Alternativbefehls
      command: Name des zuzuordnenden Befehls, inklusive Argumenten (mehrere Befehle können durch Semikolon getrennt werden)

Anmerkung: Im Befehl können Variablen genutzt werden, die dann durch den entsprechenden Wert ersetzt werden:
        $n: Argument 'n' (zwischen 1 und 9)
       $-m: Argumente von 1 bis 'm'
       $n-: Argumente von 'n' bis zum letzten Argument
      $n-m: Argumente von 'n' bis 'm'
        $*: alle Argumente
        $~: letztes Argument
      $var: "var" ist eine lokale Variable für den jeweiligen Buffer (siehe /buffer listvar)
            Beispiel: $nick, $channel, $server, $plugin, $name

Beispiele:
  Alternativbefehl "/split" wird anlegt um ein Fenster horizontal zu teilen:
    /alias add split /window splith
  Alternativbefehl "/hallo" wird angelegt um in allen Channels, außer im #weechat Channel, den Text "Hallo" auszugeben:
    /alias add hallo /allchan -exclude=#weechat hallo
  Alternativbefehl "/forcejoin" wird angelegt um den IRC Befehl "forcejoin" mit einer Vervollständigung von /sajoin auszuführen:
    /alias addcompletion %%sajoin forcejoin /quote forcejoin
----
// end::alias_commands[]

// tag::weechat_commands[]
[[command_weechat_allbuf]]
* `+allbuf+`: führt einen Befehl in allen Buffern aus

----
/allbuf  <Befehl>

command: Befehl der ausgeführt werden soll (oderText welcher in den Buffer gesendet werden soll, sofern dem Befehl kein '/' vorangestellt ist)

Beispiele:
  setze den ungelesen Marker für alle Buffer:
    /allbuf /buffer set unread
----

[[command_weechat_away]]
* `+away+`: Abwesenheitsstatus setzen oder entfernen

----
/away  [-all] [<message>]

   -all: Abwesenheitsstatus auf allen verbundenen Server setzen oder entfernen
message: Abwesenheitsnachricht (ohne Angabe einer Nachricht wird der Abwesenheitszustand entfernt)
----

[[command_weechat_bar]]
* `+bar+`: Infobars verwalten

----
/bar  list|listfull|listitems
      add <name> <type>[,<conditions>] <position> <size> <separator> <item1>[,<item2>...]
      default [input|title|status|nicklist]
      del <name>|-all
      set <name> <option> <value>
      hide|show|toggle <name>
      scroll <name> <window> <scroll_value>

         list: zeigt alle Infobars an
     listfull: zeigt eine detaillierte Liste aller Infobars an (ausführlich)
    listitems: zeigt alle Items an, die in den Infobars genutzt werden
          add: füge eine neue Infobar hinzu
         name: Name der Infobar (muss einmalig sein)
         type:   root: außerhalb eines Fensters,
               window: innerhalb eines Fensters, mit optionalen Bedingungen (siehe unten)
   conditions: Bedingungen für eine Infobar:
                 active: in einem aktiven Fenster
               inactive: in einem inaktiven Fenster
               nicklist: in Fenstern mit einer Benutzerliste
               weitere mögliche Bedingungen: siehe /help weechat.bar.xxx.conditions und /help eval
               ohne Angabe von Bedingungen wird die Infobar immer angezeigt
     position: bottom (unten), top (oben), left (links) oder right (rechts)
         size: Größe der Infobar (in Zeichen)
    separator: 1 um eine Trennlinien zu zeichnen, bei 0 oder ohne eine Angabe, wird keine Trennlinien gezeichnet
    item1,...: Items die in der Infobar genutzt werden sollen (Items können durch Kommata oder Leerzeichen getrennt werden ("+" (verbindet Items))
      default: erstellt standardisierte Infobars
          del: entfernt eine Infobar (alle Infobars können mit dem Argument "-all" entfernt werden).
          set: setzt einen Wert für Infobar
       option: Option, die verändert werden soll (für eine Liste aller möglichen Optionen bitte folgenden Befehl nutzen: /set weechat.bar.<barname>.*)
        value: neuer Wert für Option
         hide: Infobar wird ausgeblendet
         show: zeigt eine ausgeblendete Infobar an
       toggle: zeigt/versteckt eine Infobar
       scroll: scrollt Infobar hoch/runter
       window: Nummer des Fensters (nutze '*' für aktuelles Fenster oder für die Root-Bars)
 scroll_value: Werte für Scroll-Funktion: 'x' oder 'y' (optional), gefolgt von '+', '-', 'b' (Beginn) oder 'e' (Ende), Wert (für +/-), und optional % (zum scrollen der Breite/Höhe in %, ansonsten wird dieser Wert als Anzahl der Zeichen interpretiert um die gescrollt werden soll)

Beispiele:
  erstellt eine Infobar mit den Items: time, buffer number + name, und Vervollständigung:
    /bar add mybar root bottom 1 0 [time],buffer_number+:+buffer_name,completion
  versteckt die Infobar (meinebar):
    /bar hide meinebar
  scrollt die Benutzerliste im aktuellen Buffer um 10 Zeilen nach unten:
    /bar scroll nicklist * y+10
  scrollt zum Ende der Nicklist im aktuellen Buffer:
    /bar scroll nicklist * ye
----

[[command_weechat_buffer]]
* `+buffer+`: Buffer verwalten

----
/buffer  list
         add [-free] [-switch] <name>
         clear [<number>|<name>|-merged|-all [<number>|<name>...]]
         move <number>|-|+
         swap <number1>|<name1> [<number2>|<name2>]
         cycle <number>|<name> [<number>|<name>...]
         merge <number>|<name>
         unmerge [<number>|-all]
         hide [<number>|<name>|-all [<number>|<name>...]]
         unhide [<number>|<name>|-all [<number>|<name>...]]
         switch [-previous]
         zoom
         renumber [<number1> [<number2> [<start>]]]
         close [<n1>[-<n2>]|<name>...]
         notify [<level>]
         listvar [<number>|<name>]
         setvar <name> [<value>]
         delvar <name>
         set <property> [<value>]
         get <property>
         jump smart|last_displayed|prev_visited|next_visited
         <number>|-|+|<name>

    list: alle geöffneten Buffer werden aufgelistet (ohne Angabe von Argumente wird diese Liste standardmäßig ausgegeben)
     add: öffnet einen neuen Buffer (dieser kann mit "/buffer close" oder "q" in der Eingabezeile, beendet werden)
   clear: leert den Inhalt des Buffers (entweder durch Angabe der entsprechenden Nummer des Buffers oder "-merged " für zusammengefügte Buffer oder "-all" für alle Buffer. Ohne Angabe eines Arguments wird der aktuelle Buffer gelöscht)
    move: Buffer in der Liste verschieben (kann auch relativ sein, z.B. -1); "-" = auf erste Position verschieben, "+" = auf letzte Position + 1 verschieben
    swap: tauscht zwei Buffer miteinander aus (bei Angabe von nur einem Buffer (Buffernummer/-name), wird der aktuelle Buffer mit dem angegebenen Buffer getauscht)
   cycle: springt in einer Schleife von einem Buffer zum nächsten, die in einer Liste angegeben werden
   merge: fügt den aktuellen Buffer mit einem anderen Buffer zusammen (bei einem Chat-Buffer werden zwei Buffer zusammengefügt
         (Bei der Standardtastenbelegung wird mittels "CTRL-x" zwischen zusammengefügten Buffern umgeschaltet)
 unmerge: trennt Buffer wieder voneinander, falls zwei Buffer die selbe Nummer teilen
    hide: versteckt einen Buffer
  unhide: macht Buffer wieder sichtbar
  switch: wechselt zum nächsten zusammengeführten Buffer (oder zum vorherigen Buffer mit "-previous")
    zoom: zoomen eines zusammengeführten Buffers
renumber: Buffer werden umnummeriert (Einstellung weechat.look.buffer_auto_renumber muss deaktiviert sein)
   close: Buffer schließen (Nummer oder Bereich ist optional)
  notify: Benachrichtigungsstufe für den aktuellen Buffer anzeigen oder einstellen. Folgende Möglichkeiten bestimmen den Grad der Benachrichtigung und ob der Buffer in der Hotlist angezeigt wird:
            none: keine Benachrichtigung
       highlight: Benachrichtigung bei hervorgehobenen Nachrichten (Highlights)
         message: Benachrichtigung bei Nachrichten von Usern + Highlights
             all: Benachrichtigung bei allen Nachrichten
           reset: Benachrichtigung auf Standardwert zurück setzen (all)
 listvar: zeigt die lokalen Variablen für den aktuellen Buffer an
  setvar: legt eine lokale Variable für den aktuellen Buffer an
  delvar: löscht eine lokale Variable des aktuellen Buffers
     set: setzt eine Eigenschaft für den aktuellen Buffer
     get: zeigt eine Eigenschaft für den aktuellen Buffer an
    jump: springt zu einem anderen Buffer:
          smart: nächster Buffer mit Aktivität
          last_displayed: letzter angezeigter Buffer (vor dem letzten Sprung zu einem Buffer)
          prev_visited: zuvor besuchter Buffer
          next_visited: zum nächsten besuchten Buffer springen
  number: wechselt von einem Buffer zu einem anderen, mögliche Optionen:
          '+': relativer Sprung um 'n'-Buffer
          '-': relativer Sprung, um 'n'-Buffer
          '*': wechselt zum Buffer mit der Nummer 'n'; nutzt die interne Einstellung "weechat.look.jump_current_to_previous_buffer"
       -: springt zum ersten Buffer
       +: springt zum letzten Buffer
    name: wechselt zum Buffer mit dem angegebenen Namen (Name muss nicht vollständig sein!)

Beispiele:
  leert den aktuellen Buffer:
    /buffer clear
  verschiebt Buffer auf Position 5:
    /buffer move 5
  tauscht Buffer 1 und 3:
    /buffer swap 1 3
  tauscht Buffer #weechat und den aktuellen Buffer:
    /buffer swap #weechat
  springt in einer Schleife zu den Buffern #chan1, #chan2, #chan3:
    /buffer cycle #chan1 #chan2 #chan3
  verbindet Buffer mit dem Core-Buffer:
    /buffer merge 1
  verbindet Buffer mit #weechat buffer:
    /buffer merge #weechat
  trennt Buffer voneinander:
    /buffer unmerge
  schließt aktuellen Buffer:
    /buffer close
  schließt Buffer 5 bis 7:
    /buffer close 5-7
  springt zum Buffer: #weechat:
    /buffer #weechat
  springt zum nächsten Buffer:
    /buffer +1
  springt zum letzten Buffer:
    /buffer +
----

[[command_weechat_color]]
* `+color+`: definiert Farbaliase und stellt eine Palette der möglichen Farben dar

----
/color  alias <color> <name>
        unalias <color>
        reset
        term2rgb <color>
        rgb2term <rgb> [<limit>]
        -o

  alias: weist einer Farbzahl einen Namen zu
unalias: entfernt einen Namen
  color: Farbnummer (>= 0, maximale Anzahl ist abhängig vom Terminal, üblicherweise 63 oder 255 Farben)
   name: Alternativname für eine Farbe (zum Beispiel: "orange")
  reset: setzt alle Farbpaarungen zurück (nützlich falls keine Farbpaarung mehr verfügbar sein sollte und die automatische Reset-Option deaktiviert ist, siehe Einstellung: "weechat.look.color_pairs_auto_reset")
term2rgb: konvertiert eine Terminalfarbe (0-255) in eine RGB Farbe
rgb2term: konvertiert eine RGB Farbe in eine Terminalfarbe (0-255)
   limit: Anzahl an Farben die aus der Terminalpalette genutzt werden sollen (beginnend von 0); Standardwert: 256
     -o: sendet Terminal-/Farbinformationen in den aktuellen Buffer

Ohne Angabe von Argumenten wird in einem separaten Buffer die darstellbare Farbpalette angezeigt.

Beispiele:
  der Farbe 214 wird das Alias "orange" zugeordnet:
    /color alias 214 orange
  löscht die Farbe 214:
    /color unalias 214
----

[[command_weechat_command]]
* `+command+`: führe explizit einen WeeChat Befehl oder eine Erweiterung aus

----
/command  [-buffer <name>] <plugin> <command>

-buffer: Befehl wird in diesem Buffer ausgeführt
 plugin: Befehl der angegeben Erweiterung wird ausgeführt; 'core' für einen internen WeeChat Befehl, '*' automatisierte Auswahl (entscheidend ist der Buffer in welchem der Befehl ausgeführt wird)
command: auszuführender Befehl (es wird automatisch ein '/' vorangestellt, falls dieser nicht angegeben wurde)
----

[[command_weechat_cursor]]
* `+cursor+`: Cursor kann frei auf dem Bildschirm bewegt werden, um Aktionen in bestimmten Bildschirmbereichen auszuführen

----
/cursor  go chat|<bar>|<x>,<y>
         move up|down|left|right|area_up|area_down|area_left|area_right
         stop

  go: setzt den Cursor in den Chat Bereich, in eine Bar (Name der Bar muss angegeben werden) oder auf die Koordinaten "x,y"
move: Cursor wird in die entsprechende Richtung bewegt
stop: beendet den Cursor-Modus

Ohne Angabe von Argumenten wird der Cursor-Modus umgeschaltet.

Ist die Mausfunktion aktiviert (siehe /help mouse), startet man den Cursor-Modus mit der mittleren Maustaste und positioniert den Cursor auf diesen Punkt.

Standardtastenbefehle im Chatbereich:
  m  zitiere Nachricht
  q  zitiere Präfix + Nachricht
  Q  zitiere Zeit + Präfix + Nachricht

Standardtastenbefehle in Nickliste:
  b  banne Nick (/ban)
  k  kicke Nick (/kick)
  K  kicke und banne Nick (/kickban)
  q  öffne private Unterhaltung mit Nick (/query)
  w  hole Informationen über Anwender (/whois)

weitere Standardtasten im Cursor-Modus:
  Pfeiltasten      bewege Cursor
  alt+Pfeiltasten  bewege Cursor zum nächsten Bereich
  enter            beendet den Cursor-Modus

Beispiele:
  gehe zur Benutzerliste:
    /cursor go nicklist
  gehe zu den Koordinaten x=10, y=5:
    /cursor go 10,5
----

[[command_weechat_debug]]
* `+debug+`: Debug-Funktionen

----
/debug  list
        set <plugin> <level>
        dump|hooks [<plugin>]
        buffer|certs|color|dirs|infolists|libs|memory|tags|term|windows
        mouse|cursor [verbose]
        hdata [free]
        time <command>
        unicode <string>

     list: zeigt alle Erweiterungen mit Debuglevel an
      set: setzt den Level der Protokollierung für eine Erweiterung
   plugin: Name der Erweiterung ("core" für den WeeChat Kern)
    level: Debuglevel der Erweiterung (0 = deaktiviert Debug)
     dump: Speicherabbild in die WeeChat Protokolldatei schreiben (wie bei einem Programmabsturz)
    hooks: zeigt die aktiven Hooks an (bei einer Erweiterung: detaillierte Informationen über Hooks werden angezeigt, die von der Erweiterung erstellt wurden)
   buffer: speichert den Bufferinhalt als hexadezimale Ausgabe in die Protokolldatei
    certs: gibt die Anzahl geladener vertrauenswürdiger Zertifizierungsstellen aus
    color: zeigt Informationen über die aktuellen Farbpaarungen an
   cursor: schaltet den debug-Modus für den Cursor-Modus ein/aus
     dirs: Verzeichnisse werden angezeigt
    hdata: zeigt Informationen zu hdata an (mittels free werden alle hdata Informationen aus dem Speicher entfernt)
infolists: zeigt Information über die Infolists an
     libs: zeigt an welche externen Bibliotheken verwendet werden
   memory: gibt Informationen über den genutzten Speicher aus
    mouse: schaltet den debug-Modus für den Maus-Modus ein/aus
     tags: zeigt für jede einzelne Zeile die dazugehörigen Schlagwörter an
     term: zeigt Informationen über das Terminal an
  windows: zeigt die Fensterstruktur an
     time: misst die Zeit um einen Befehl auszuführen oder um einen Text in den aktuellen Buffer zu senden
  unicode: Zeigt Informationen über Unicode-Zeichen in Zeichenkette an (evaluiert, siehe /help eval)

Beispiele:
  /debug set irc 1
  /debug mouse verbose
  /debug time /filter toggle
  /debug unicode ${chars:${\u26C0}-${\u26CF}}
----

[[command_weechat_eval]]
* `+eval+`: evaluierter Ausdruck

----
/eval  [-n|-s] [-d] <expression>
       [-n] [-d [-d]] -c <expression1> <operator> <expression2>

        -n: gibt das Ergebnis aus, ohne dass dieses in den Buffer gesendet wird (debug Modus)
        -s: teilt Ausdrücke, bevor sie evaluiert werden (mehrere Befehle können durch Semikolon getrennt werden)
        -d: eine Debug-Ausgabe nach Auswertung anzeigen (Nutzung von zwei -d: ausführliche Debug-Ausgabe)
        -c: Auswertung als Bedingung: nutzt Operatoren und runde Klammern, Rückgabewert als Boolean-Wert ("0" oder "1")
expression: Ausdruck welcher verarbeitet werden soll. Variablen im Format ${variable} werden ersetzt (siehe unten); mehrere Befehle werden durch ein Semikolon voneinander getrennt
  operator: ein logischer oder vergleichender Operand:
            - logische Operanden:
                &&  boolean "und"
                ||  boolean "oder"
            - vergleichende Operanden:
                ==  gleich
                !=  ungleich
                <=  kleiner oder gleich
                <   kleiner
                >=  größer oder gleich
                >   größer
                =~  stimmt mit regulärem POSIX Ausdruck überein
                !~  stimmt NICHT mit regulärem POSIX Ausdruck überein
                ==*  stimmt mit Maske überein (Platzhalter "*" ist erlaubt)
                !!*  stimmt mit Maske NICHT überein (Platzhalter "*" ist erlaubt)
                =*   stimmt mit Maske überein, Groß- und Kleinschreibung wird nicht beachtet (Platzhalter "*" ist erlaubt)
                !*   stimmt mit Maske NICHT überein, Groß- und Kleinschreibung wird nicht beachtet (Platzhalter "*" ist erlaubt)
                ==-  ist enthalten, Groß- und Kleinschreibung wird beachtet
                !!-  ist NICHT enthalten, Groß- und Kleinschreibung wird beachtet
                =-   ist enthalten, Groß- und Kleinschreibung wird nicht beachtet
                !-   ist NICHT enthalten, Groß- und Kleinschreibung wird nicht beachtet

Ein Ausdruck gilt als "wahr" sofern das Ergebnis weder NULL, nicht leer und von "0" abweichend ist.
Für einen Vergleich werden Fließkommazahlen genutzt, insofern es sich bei beiden Ausdrücken um gültige Zahlen handelt, folgende Formate werden unterstützt:
  - Integer (Beispiele: 5, -7)
  - Fließkommazahl (Beispiele: 5.2, -7.5, 2.83e-2)
  - hexadezimale Zahl (Beispiele: 0xA3, -0xA3)
Um einen Vergleich zwischen zwei Zeichenketten zu erzwingen, müssen die Ausdrücke in Anführungszeichen gesetzt werden, zum Beispiel:
  50 > 100      ==> 0
  "50" > "100"  ==> 1

Einige Variablen werden im Ausdruck mittels der Formatierung ${variable} ersetzt. Mögliche Variablen sind, nach Reihenfolge ihrer Priorität:
  - die Zeichenfolge selbst ohne Auswertung (Format: "raw:xxx")
  - eine benutzerdefinierte Variable (Format: "name")
  - eine evaluierte Teilzeichenkette (Format: "eval:xxx")
  - eine evaluierte Bedingung (Format: "eval_cond:xxx")
  - eine Zeichenkette mit Escapesequenzen (Format: "esc:xxx" oder "\xxx")
  - eine Zeichenfolge mit einer Reihe von Zeichen (Format: "chars:xxx" oder "chars:c1-c2" wobei "xxx" von folgenden Typ sein muss: "digit", "xdigit", "lower", "upper", "alpha", "alnum")
  - eine Zeichenfolge, die in Kleinbuchstaben umgewandelt wird (Format: "lower:xxx")
  - eine Zeichenfolge, die in Großbuchstaben umgewandelt wird (Format: "upper:xxx")
  - Zeichen, die in einer Zeichenkette nicht dargestellt werden sollen (Format: "hide:Zeichen,Zeichenkette")
  - eine Zeichenkette mit einer maximalen Anzahl an Zeichen (Format: "cut:max,suffix,string" oder "cut:+max,suffix,string")
     oder maximale Anzahl an Zeichen die auf dem Bildschirm angezeigt werden sollen (Format: "cutscr:Max,Suffix,Zeichenkette oder "cutscr:+Max,Suffix,Zeichenkette")
  - eine Zeichenkette umkehren (Format: "rev:xxx" oder "revscr:xxx")
  - eine Zeichenkette wiederholen (Format: "repeat:Anzahl,Zeichenkette")
  - Länge einer Zeichenkette (Format: "length:xxx" oder "lengthscr:xxx")
  - Aufteilen einer Zeichenkette (Format: "split:Anzahl,Trennzeichen,Flags,xxx")
  - Aufteilen von Shell-Argumenten (Format: "split_shell:Anzahl,xxx")
  - eine Farbe (Format: "color:xxx", siehe "Anleitung für API Erweiterung", Funktion "color")
  - zum modifizieren (Format: "modifier:name,data,string")
  - eine Info (Format: "Info:Name,Argumente", Argumente sind optional)
  - eine Basis 16/32/64 kodierte / dekodierte Zeichenfolge (Format: "base_encode:base,xxx" oder "base_decode:base,xxx")
  - aktuelles Datum/Uhrzeit (Format: "date" oder "date:format")
  - eine Umgebungsvariable (Format: "env:XXX")
  - ein Dreifachoperand (Format: "if:Bedingung?Wert_falls_wahr:Wert_falls_unwahr")
  - Ergebnis eines Ausdrucks mit Klammern und Operatoren + - * / // % ** (Format: "calc:xxx")
  - eine zufällige ganze Zahl (Format: "random:min,max")
  - eine übersetzte Zeichenkette (Format: "translate:xxx")
  - eine Benutzervariable definieren (Format: "define:Name,Wert")
  - eine Option (Format: "file.section.option")
  - eine lokale Variable eines Buffers
  - ein(e) hdata - Name/Variable (der Wert wird automatisch in eine Zeichenkette konvertiert), standardmäßig wird für "window" und "buffer" das aktuelle Fenster/Buffer verwendet.
Das Format für hdata kann wie folgt aufgebaut sein:
  hdata.var1.var2...: startet mit hdata (der Pointer muss bekannt sein) und fragt eine Variable nach der anderen ab (weitere hdata können folgen)
  hdata[list].var1.var2...: startet hdata mittels einer Liste, zum Beispiel:
    ${buffer[gui_buffers].full_name}: der vollständige Name des ersten Buffers, in der verknüpften Liste aller Buffer
    ${plugin[weechat_plugins].name}: Name der ersten Erweiterung, in der verknüpften Liste aller Erweiterungen
  hdata[pointer].var1.var2...: startet hdata mittels einem Pointer, zum Beispiel:
    ${buffer[0x1234abcd].full_name}: vollständiger Name eines Buffers und des dazugehörigen Pointers (kann in triggern benutzt werden)
    ${buffer[my_pointer].full_name}: vollständiger Name des Buffers mit dem entsprechenden Pointernamen (kann in Triggern verwendet werden)
Die vorhandenen Namen für hdata und Variablen sind in der "Anleitung für API Erweiterung", Bereich "weechat_hdata_get". beschrieben

Beispiele (einfache Zeichenketten):
  /eval -n ${raw:${info:version}}                ==> ${info:version}
  /eval -n ${eval_cond:${window.win_width}>100}  ==> 1
  /eval -n ${info:version}                       ==> 0.4.3
  /eval -n ${env:HOME}                           ==> /home/user
  /eval -n ${weechat.look.scroll_amount}         ==> 3
  /eval -n ${sec.data.password}                  ==> geheim
  /eval -n ${window}                             ==> 0x2549aa0
  /eval -n ${window.buffer}                      ==> 0x2549320
  /eval -n ${window.buffer.full_name}            ==> core.weechat
  /eval -n ${window.buffer.number}               ==> 1
  /eval -n ${\t}                                 ==> <tab>
  /eval -n ${chars:digit}                         ==> 0123456789
  /eval -n ${chars:J-T}                           ==> JKLMNOPQRST
  /eval -n ${lower:TEST}                          ==> test
  /eval -n ${upper:test}                          ==> TEST
  /eval -n ${hide:-,${relay.network.password}}   ==> --------
  /eval -n ${cut:3,+,test}                       ==> tes+
  /eval -n ${cut:+3,+,test}                      ==> te+
  /eval -n ${date:%H:%M:%S}                      ==> 07:46:40
  /eval -n ${if:${info:term_width}>80?big:small} ==> big
  /eval -n ${rev:Hello}                          ==> olleH
  /eval -n ${repeat:5,-}                         ==> -----
  /eval -n ${length:test}                        ==> 4
  /eval -n ${split:1,,,abc,def,ghi}              ==> abc
  /eval -n ${split:-1,,,abc,def,ghi}             ==> ghi
  /eval -n ${split:count,,,abc,def,ghi}          ==> 3
  /eval -n ${split:random,,,abc,def,ghi}         ==> def
  /eval -n ${split_shell:1,"arg 1" arg2}         ==> arg 1
  /eval -n ${split_shell:-1,"arg 1" arg2}        ==> arg2
  /eval -n ${split_shell:count,"arg 1" arg2}     ==> 2
  /eval -n ${split_shell:random,"arg 1" arg2}    ==> arg2
  /eval -n ${calc:(5+2)*3}                       ==> 21
  /eval -n ${random:0,10}                        ==> 3
  /eval -n ${base_encode:64,test}                ==> dGVzdA==
  /eval -n ${base_decode:64,dGVzdA==}            ==> test
  /eval -n ${translate:Plugin}                   ==> Erweiterung
  /eval -n ${define:len,${calc:5+3}}${len}x${len} ==> 8x8

Beispiele (Bedingungen):
  /eval -n -c ${window.buffer.number} > 2  ==> 0
  /eval -n -c ${window.win_width} > 100    ==> 1
  /eval -n -c (8 > 12) || (5 > 2)          ==> 1
  /eval -n -c (8 > 12) && (5 > 2)          ==> 0
  /eval -n -c abcd =~ ^ABC                 ==> 1
  /eval -n -c abcd =~ (?-i)^ABC            ==> 0
  /eval -n -c abcd =~ (?-i)^abc            ==> 1
  /eval -n -c abcd !~ abc                  ==> 0
  /eval -n -c abcd =* a*d                  ==> 1
  /eval -n -c abcd =- bc                   ==> 1
----

[[command_weechat_filter]]
* `+filter+`: Filterfunktion um Nachrichten in Buffern aus- oder einzublenden, dazu können Schlagwörter oder reguläre Ausdrücke verwendet werden

----
/filter  list
         enable|disable|toggle [<name>|@]
         add|addreplace <name> <buffer>[,<buffer>...] <tags> <regex>
         rename <name> <new_name>
         recreate <name>
         del <name>|-all [<name>...]

      list: alle Filter auflisten
    enable: Filter wird aktiviert (Filter werden standardmäßig aktiviert)
   disable: Filter deaktivieren
    toggle: Filter umschalten
      name: Name des Filters ("@" = aktiviert/deaktiviert alle Filter im aktuellen Buffer)
       add: Filter hinzufügen
addreplace: erzeugt neuen Filter oder ersetzt einen schon existierenden Filter
    rename: benennt einen Filter um
  recreate: in die Eingabezeile wird die entsprechende Filtereinstellung übernommen, um diese dann editieren zu können
       del: Filter entfernen
      -all: entfernt alle Filter
    buffer: durch Kommata getrennte Liste von Buffer in denen der Filter aktiv sein soll:
            - ist der vollständige Name eines Buffer inklusive seiner Erweiterung (Beispiel: "irc.libera.#weechat" oder "irc.server.libera")
            - "*" bedeutet, alle Buffer
            - beginnt ein Name mit '!' wird für diesen Buffer kein Filter genutzt
            - Platzhalter "*" kann verwendet werden
      tags: durch Kommata getrennte Liste von Schlagwörtern. Zum Beispiel: "irc_join,irc_part,irc_quit"
            - logisch "und": mittels "+" zwischen den Tags (zum Beispiel: "nick_toto+irc_action")
            - Platzhalter "*" kann verwendet werden
            - wird ein Tag mit '!' eingeleitet, dann muss dieser Tag NICHT in der Nachricht enthalten sein
     regex: erweiterter regulärer POSIX Ausdruck, um in einer Zeile zu suchen
            - das Präfix (z.B. Nick) wird mittels '\t' von der Nachricht getrennt. Sonderzeichen wie '|' müssen mit einer Escapesequenz : '\|' eingebunden werden)
            - wird ein regulärer Ausdruck mit '!' eingeleitet dann wird das übereinstimmende Ergebnis umgekehrt (nutze '\!' um mit '!' zu beginnen)
            - es werden zwei reguläre Ausdrücke erstellt: Der erste für den Präfix und der zweite für die eigentliche Nachricht
            - reguläre Ausdrücke unterscheiden nicht zwischen Groß- und Kleinschreibung. Um zwischen Groß- und Kleinschreibung zu unterscheiden müssen diese mit "(?-i)" eingeleitet werden.

Mit der Tastenvoreinstellung alt+'=' kann die globale Filterfunktion (de-)aktiviert werden und alt+'-' (de-)aktiviert die Filterfunktion für den aktuellen Buffer.

Die am häufigsten gebrauchten Schlagwörter lauten:
  no_filter, no_highlight, no_log, log0..log9 (log Level),
  notify_none, notify_message, notify_private, notify_highlight,
  self_msg, nick_xxx (xxx ist der Nickname), prefix_nick_ccc (ccc ist die Farbe mit der der Nick dargestellt wird),
  host_xxx (xxx ist der Username + Host in Nachricht),
  irc_xxx (xxx ist durch einen IRC-Befehl/-Nummer zu ersetzen, siehe /server raw oder /debug tags)
  irc_numeric, irc_error, irc_action, irc_ctcp, irc_ctcp_reply, irc_smart_filter, away_info.
Mittels "/debug tags" kann man sich die Schlagwörter jeder einzelnen Zeile darstellen lassen.

Beispiele:
  aktiviert den intelligenten IRC Filter für alle Buffer:
    /filter add irc_smart * irc_smart_filter *
  aktiviert den intelligenten IRC Filter für alle Buffer, außer Buffer die "#weechat" im Namen tragen:
    /filter add irc_smart *,!*#weechat* irc_smart_filter *
  filtert alle IRC join/part/quit Nachrichten:
    /filter add joinquit * irc_join,irc_part,irc_quit *
  filtert Nicks wenn diese den Channel betreten oder durch den Befehl "/names" angezeigt werden:
    /filter add nicks * irc_366 *
  filtert Nick "toto" im IRC Channel #weechat:
    /filter add toto irc.libera.#weechat nick_toto *
  filtert IRC join/action Nachrichten von Nick "toto":
    /filter add toto * nick_toto+irc_join,nick_toto+irc_action *
  filtert Zeilen die "weechat sucks" im IRC Channel #weechat enthalten:
    /filter add sucks irc.libera.#weechat * weechat sucks
  filter Zeilen die exakt "WeeChat sucks" lauten und das in allen Buffern:
    /filter add sucks2 * * (?-i)^WeeChat sucks$
----

[[command_weechat_help]]
* `+help+`: Zeigt einen Hilfstext für Befehle und Einstellungen an

----
/help  -list|-listfull [<plugin> [<plugin>...]]
       <command>
       <option>

    -list: zeigt alle Befehle, nach Erweiterungen sortiert (ohne Angabe von Argumente wird diese Liste standardmäßig ausgegeben)
-listfull: zeigt alle Befehle mit Beschreibung, nach Erweiterung
   plugin: zeigt Befehle explizit für diese Erweiterung an
  command: Name eines Befehls
   option: Name einer Einstellung (nutze /set um Einstellungen anzeigen zu lassen)
----

[[command_weechat_history]]
* `+history+`: Zeigt den Befehlsverlauf des Buffers

----
/history  clear
          <value>

clear: löscht den Befehlsverlauf
value: Anzahl der gewünschten Einträgen im Befehlsverlauf anzeigen
----

[[command_weechat_hotlist]]
* `+hotlist+`: Hotlist verwalten

----
/hotlist  add [low|message|private|highlight]
          clear [<level>]
          remove
          restore [-all]

    add: füge den aktuellen Buffer zur Hotlist (Standardlevel: "low", Bedingungen die in Option weechat.look.hotlist_add_conditions definiert sind, werden NICHT überprüft)
  clear: lösche Hotlist
  level: "lowest" um die niedrigste Benachrichtigungsstufe in der Hotlist zu löschen, "highest" um die höchste Benachrichtigungsstufe in der Hotlist zu löschen, oder mit einer Levelmaske: Integer aus einer Kombination von 1=join/part, 2=message, 4=private, 8=highlight)
 remove: entferne aktuellen Buffer von Hotlist
restore: stellt die letzte Hotlist wieder her, die im aktuellen Buffer entfernt wurde (oder alle Buffer mit -all)
----

[[command_weechat_input]]
* `+input+`: Funktionen für die Befehlszeile

----
/input  <action> [<arguments>]

Auflistung der möglichen Aktionen:
  return: simuliert die "enter" Taste
  complete_next: vervollständigt Wort mit nächster Komplettierung
  complete_previous: vervollständigt Word mit vorheriger Komplettierung
  search_text_here: Textsuche ab aktueller Position
  search_text: Textsuche im Buffer
  search_switch_case: schaltet Groß-/Kleinschreibung ein und aus
  search_switch_regex: Wechsel des Suchmodus: einfache Textsuche/reguläre Ausdrücke
  search_switch_where: wechselt Suche in Nachricht/Präfix
  search_previous: sucht vorheriger Zeile
  search_next: sucht nächste Zeile
  search_stop_here: beendet Suche ab aktueller Position
  search_stop: suche beenden
  delete_previous_char: entfernt vorheriges Zeichen
  delete_next_char: entfernt nächstes Zeichen
  delete_previous_word: entfernt vorheriges Wort
  delete_previous_word_whitespace: vorheriges Wort löschen (bis zum Leerzeichen)
  delete_next_word: entfernt nächstes Wort
  delete_beginning_of_line: entfernt alle Zeichen ab Zeilenanfang bis zum Cursor
  delete_end_of_line: entfernt alle Zeichen ab Cursor bis zum Ende der Zeile
  delete_line: löscht die komplette Eingabezeile
  clipboard_paste: fügt Zeichenkette aus der internen Zwischenablage ein
  transpose_chars: Zeichen austauschen
  undo: letzten Befehl in der Eingabezeile rückgängig machen
  redo: letzten Befehl in der Eingabezeile wiederherstellen
  move_beginning_of_line: springt an den Anfang der Eingabezeile
  move_end_of_line: springt ans Ende der Eingabezeile
  move_previous_char: setzt den Cursor eine Position nach links
  move_next_char: setzt den Cursor eine Position nach rechts
  move_previous_word: springt zum Anfang des vorherigen Wortes, in der Eingabezeile
  move_next_word: springt zum Anfang des nächsten Wortes, in der Eingabezeile
  history_previous: ruft vorherigen Befehl oder Nachricht aus dem Befehlsspeicher auf (im Such-Modus: rückwärts suchen)
  history_next: ruft nächsten Befehl oder Nachricht aus dem Befehlsspeicher auf (im Such-Modus: vorwärts suchen)
  history_global_previous: ruft vorherigen Befehl/Nachricht aus dem globalen Befehlsspeicher auf (für alle Buffer)
  history_global_next: ruft nächsten Befehl/Nachricht aus dem globalen Befehlsspeicher auf (für alle Buffer)
  grab_key: fängt eine Taste (optionales Argument: Verzögerung um eine Taste einzufangen. Standard sind 500 Millisekunden)
  grab_key_command: zeigt den Tastencode (inklusive des eingebundenen Befehls) einer Tastenkombination an und fügt ihn in die Befehlszeile ein (optionales Argument: Verzögerung um eine Taste einzufangen. Standard sind 500 Millisekunden)
  grab_mouse: fängt den Code einer Maus Aktivität
  grab_mouse_area: fängt den Code einer Maus Aktivität mit entsprechendem Bereich
  insert: fügt einen Text in die Eingabezeile ein (Escapesequenzen sind möglich, siehe /help print)
  send: schickt Text an einen Buffer
  paste_start: Einfügen wird gestartet (bracketed paste mode)
  paste_stop: Einfügen wird beendet (bracketed paste mode)

Dieser Befehl wird sinnvollerweise mittels Tastenbelegungen oder Erweiterungen genutzt.
----

[[command_weechat_item]]
* `+item+`: Verwalten von benutzerdefinierten Bar-Items

----
/item  list
       add|addreplace <name> "<conditions>" "<content>"
       rename <name> <new_name>
       refresh <name> [<name>...]
       recreate <name>
       del <name>|-all

      list: zeigt eine Liste aller benutzerdefinierten Bar-Items
       add: fügt ein benutzerdefiniertes Bar-Item hinzu
addreplace: erzeugt neues Bar-Item oder ersetzt ein schon existierendes Bar-Item
      name: benutzerdefinierter Name des Bar-Items
conditions: evaluierte Bedingungen um ein Bar-Item anzuzeigen (zum Beispiel um ein Bar-Item nur in einem bestimmten Buffer anzuzeigen)
   content: Inhalt (evaluiert, siehe /help eval)
    rename: Umbenennen eines benutzerdefinierten Bar-Items
   refresh: aktualisiert den Inhalt des Items in allen Bars, in denen das Item angezeigt wird; jedes Item kann aktualisiert werden: standard/Erweiterung/benutzerdefiniertes Bar-Item
  recreate: kopiert den Befehl in die Eingabezeile um das benutzerdefinierte Bar-Item zu editieren
       del: entfernt ein benutzerdefiniertes Bar-Item
      -all: entfernt alle benutzerdefinierten Bar-Items

Beispiele:
  Item welches die Terminalgröße anzeigt wird hinzugefügt, aber nur in Buffern mit Nummer angezeigt = 1:
    /item add terminfo "${buffer.number} == 1" "term:${info:term_width}x${info:term_height}"
  fügt ein Item hinzu, welches Informationen über den Buffer anzeigt:
    /item add bufinfo "" "${buffer.number}:${buffer.name}${if:${buffer.zoomed}?(Z)}"
  fügt ein Item mit Datum/Uhrzeit hinzu, dabei wird das Format "Dec 25, 12:34 +0100" verwendet, aktualisiert, jede Minute:
    /item add datetime "" "${date:%b %d, %H:%M %z}"
    /trigger add datetime_refresh timer "60000;60" "" "" "/item refresh datetime"
  fügt ein Item mit der Anzahl der Zeilen in dem Buffer hinzu (sichtbar/total), jeweils aktualisiertwenn eine neue Zeile dargestellt wird oder wenn sich der Status der gefilterten Zeilen geändert hat:
    /item add lines_count "" "${calc:${buffer.lines.lines_count}-${buffer.lines.lines_hidden}}/${buffer.lines.lines_count} lines"
    /trigger add lines_count_refresh_print print "" "" "" "/item refresh lines_count"
    /trigger add lines_count_refresh_signal signal "window_switch;buffer_switch;buffer_lines_hidden;filters_*" "" "" "/item refresh lines_count"
  erzwingt die Aktualisierung des Items "lines_count":
    /item refresh lines_count
  erstellt das Item "lines_count", mit anderen Bedingungen oder Inhalten, neu:
    /item recreate lines_count
  entfernt das Item "lines_count":
    /item del lines_count
----

[[command_weechat_key]]
* `+key+`: Einer Taste einen Befehl zuordnen oder entfernen

----
/key  list|listdefault|listdiff [<context>]
      bind <key> [<command> [<args>]]
      bindctxt <context> <key> [<command> [<args>]]
      unbind <key>
      unbindctxt <context> <key>
      reset <key>
      resetctxt <context> <key>
      resetall -yes [<context>]
      missing [<context>]

       list: zeigt die aktuelle Tastenbelegungen an (ohne Angabe von Argumente wird diese Liste standardmäßig ausgegeben)
listdefault: zeigt die Standardeinstellung der Tastenbelegung an
   listdiff: zeigt die Unterschiede zwischen der aktuell genutzten Tastaturbelegung und der Standardbelegung an (hinzugefügte/verändert/gelöschte Tastenbelegungen)
    context: Name des Kontextes ("default" oder "search")
       bind: belegt eine Taste mit einem Befehl oder zeigt an welcher Befehl auf eine Taste gelegt wurde (für Kontext "default")
   bindctxt: belegt eine Taste mit einem Befehl oder zeigt an welcher Befehl auf eine Taste gelegt wurde, dies trifft für Kontext definierte Tasten zu
    command: Befehl (mehrere Befehle werden durch ein Semikolon getrennt)
     unbind: hebt eine Tastenbelegung auf (für Kontext "default")
 unbindctxt: hebt eine Tastenbelegung für den angegebenen Kontext auf
      reset: die Tastenbelegung wird für die ausgewählte Taste auf die Standardeinstellung zurück gesetzt (für Kontext "default")
  resetctxt: die Tastenbelegung wird für die ausgewählte Taste auf die Standardeinstellung zurück gesetzt, dies trifft für den ausgewählten Kontext zu
   resetall: die Tastenbelegung wird auf die Standardeinstellungen zurück gesetzt. Dies löscht ALLE persönlichen Tastenbelegungen (Vorsicht!)
    missing: fügt fehlende Tastenbelegungen hinzu (dazu wird die Standardbelegung genutzt). Dies kann sinnvoll sein wenn man auf eine neue WeeChat Version umgestiegen ist

Falls ein Befehl einer Taste zugeordnet werden soll ist es ratsam zuerst mit der Tastenkombination alt+k (oder Esc + k) einen Fangmodus zu aktivieren um damit die zu belegende Taste zu ermitteln. Durch diesen Schritt wird der benötigte Tasten-Code in die Befehlszeile übernommen.

Für Kontext "mouse" (Kontext "cursor" ist auch möglich), hat der zu verwendende Schlüssel folgendes Format: "@area:Schlüssel" oder "@area1>area2:Schlüssel". "area" kann folgende Werte habe:
          *: jedweder Bereich des Bildschirms
       chat: Chatbereich (für jeden Buffer)
  chat(xxx): Chatbereich für einen Buffer mit dem Namen "xxx" (vollständiger Name mit Erweiterung. Beispiel: chat(perl.iset):)
     bar(*): beliebige Bar
   bar(xxx): Bar mit dem Namen "xxx"
    item(*): beliebiges Bar-Item
  item(xxx): Bar-Item mit Namen "xxx"
Der Platzhalter "*" kann verwendet werden um mehrere unterschiedliche Mausereignisse auszuwählen.
Für den Kontext "mouse" kann ein besonderer Übergabewert für den zu nutzenden Befehl verwendet werden, "hsignal:name". Dieses sendet das hsignal "name" und als Inhalt ein Hashtable als Argument.
Ein weiterer Übergabewert ist "-" und kann genutzt werden um einen Schlüssel zu deaktivieren (der Schlüssel wird bei der Durchführung übersprungen).

Beispiele:
  Mit der Tastenkombination "alt-t" wird die Nicklist-Bar an-und aus geschaltet:
    /key bind meta-t /bar toggle nicklist
  Mit der Tastenkombination "alt-r" wird direkt zum IRC #weechat Buffer gewechselt:
    /key bind meta-r /buffer #weechat
  Die Tastenkombination "alt-r" wird auf die Standardfunktion zurückgesetzt:
    /key reset meta-r
  "Tab"-Taste nutzen um im Kontext "search" die Suche innerhalb eines Buffers zu beenden:
    /key bindctxt search ctrl-I /input search_stop
  Auswahl eines Nicknamens mittels mittlerer Maustaste zeigt zusätzliche Informationen zu dem Nick an:
    /key bindctxt mouse @item(buffer_nicklist):button3 /msg nickserv info ${nick}
----

[[command_weechat_layout]]
* `+layout+`: Verwaltet Buffer/Fenster Layouts

----
/layout  store [<name>] [buffers|windows]
         apply [<name>] [buffers|windows]
         leave
         del [<name>] [buffers|windows]
         rename <name> <new_name>

  store: erstellt ein Layout der zur Zeit verwendeten Buffer/Fenster
  apply: erstelltes Layout verwenden
  leave: belässt das aktuelle Layout (es wird kein Layout aktualisiert)
    del: entfernt Buffer und/oder Fenster eines erstellten Layouts
         (falls weder "buffers" noch "windows" angegeben wird, dann wird das Layout entfernt)
 rename: ein Layout umbenennen
   name: Name unter welchem das Layout erstellt werden soll (Standardlayout heisst "default")
buffers: erstellt bzw. verwendet nur Buffer (Reihenfolge der Buffer)
windows: erstellt bzw. verwendet nur Fenster (Buffer welche im jeweiligen Fenster dargestellt werden)

Wird der Befehl ohne Argumente aufgerufen, werden die erstellten Layout dargestellt.

Das aktuelle Layout kann beim Ausführen des /quit Befehls mit der Option "weechat.look.save_layout_on_exit" gesichert werden.

Hinweis: Das Layout merkt sich nur Fenstereinteilungen und die Positionsnummern von Buffern. Layout öffnet keine Buffer. Das bedeutet zum Beispiel, dass Sie IRC-Kanäle immer noch automatisch betreten müssen, um die Buffer zu öffnen. Das gespeicherte Layout wird erst verwendet, wenn die Buffer geöffnet sind.
----

[[command_weechat_mouse]]
* `+mouse+`: Maussteuerung

----
/mouse  enable|disable|toggle [<delay>]

 enable: aktiviert Maus
disable: deaktiviert Maus
 toggle: umschalten der Mausunterstützung
  delay: Verzögerung (in Sekunden) nach welcher der ursprüngliche Status wiederhergestellt wird (sinnvoll um die Mausunterstützung zeitabhängig zu deaktivieren)

Die Mausunterstützung wird in der Einstellung "weechat.look.mouse" gesichert.

Beispiele:
  Mausunterstützung aktivieren:
    /mouse enable
  Mausunterstützung für 5 Sekunden umschalten:
    /mouse toggle 5
----

[[command_weechat_mute]]
* `+mute+`: führt einen Befehl ohne Textausgabe aus

----
/mute  [-core | -current | -buffer <name>] <command>

   -core: keine Ausgabe im WeeChat Core Buffer
-current: Ausgabe im aktuellen Buffer wird unterdrückt
 -buffer: Ausgabe im ausgewählten Buffer wird unterdrückt
    name: vollständiger Buffername (Beispiel: "irc.server.libera", "irc.libera.#weechat")
 command: Befehl der ohne Textausgabe ausgeführt werden soll (das Präfix, '/', wird automatisch hinzugefügt, falls es dem Befehl nicht vorangestellt wurde)

Wird kein Buffer ausgewählt (-core, -current oder -buffer), dann wird die Textausgabe generell unterdrückt.

Beispiele:
  Speichern der Konfiguration:
  /mute save
  Nachricht in den aktuellen Kanal senden:
  /mute -current msg * hi!
  Nachricht an den #weechat Kanal senden:
  /mute -buffer irc.libera.#weechat msg #weechat hi!
----

[[command_weechat_plugin]]
* `+plugin+`: Erweiterungen verwalten (auflisten/installieren/beenden)

----
/plugin  list [-o|-ol|-i|-il|<name>]
         listfull [<name>]
         load <filename> [<arguments>]
         autoload [<arguments>]
         reload [<name>|* [<arguments>]]
         unload [<name>]

     list: installierte Erweiterungen werden aufgelistet
       -o: sende Liste der geladenen Erweiterungen an den Buffer (Ausgabe in Englisch)
      -ol: sende Liste der geladenen Erweiterungen an den Buffer (Übersetzte Ausgabe)
       -i: Liste der geladenen Erweiterungen in die Befehlszeile kopieren (zum Senden an den Buffer) (Ausgabe in Englisch)
      -il: Liste der geladenen Erweiterungen in die Befehlszeile kopieren (zum Senden an den Buffer) (Übersetzte Ausgabe)
     name: Name einer Erweiterung
 listfull: geladene Erweiterungen auflisten (ausführlich)
     load: Laden einer Erweiterung
 filename: Erweiterung (Dateiname) welche installiert werden soll
arguments: Argumente die der Erweiterung beim Installieren übergeben werden sollen
 autoload: installiert automatisch alle Erweiterungen aus dem System- oder Benutzerverzeichnis
   reload: startet eine Erweiterung erneut (falls kein Name angegeben wird, werden alle Erweiterungen beendet und neu gestartet)
   unload: beendet eine oder alle Erweiterungen (wird kein Name angegeben dann werden alle Erweiterung beendet)

Ohne Angabe eines Arguments werden alle installierten Erweiterungen angezeigt.
----

[[command_weechat_print]]
* `+print+`: gibt einen Text in einem Buffer aus

----
/print  [-buffer <number>|<name>] [-newbuffer <name>] [-free] [-switch] [-core|-current] [-y <line>] [-escape] [-date <date>] [-tags <tags>] [-action|-error|-join|-network|-quit] [<text>]
        -stdout|-stderr [<text>]
        -beep

   -buffer: Buffer in welchem der Text ausgegeben werden soll (standardmäßig: aktueller Buffer)
-newbuffer: erstellt einen neuen Buffer und stellt Text in diesem Buffer dar
     -free: erstellt einen Buffer mit freiem Inhalt (nur mit -newbuffer möglich)
   -switch: wechselt zum Buffer
     -core: Alternativname für "-buffer core.weechat"
  -current: Text wird im aktuell genutzten Buffer ausgegeben
        -y: schreibt den Text in die angegebene Zeile (nur bei Buffern mit freiem Inhalt)
      line: Zeilennummer bei einem Buffer mit freiem Inhalt (erste Zeile ist 0, bei einer negative Zahl wird der Text nach der letzten Zeile eingefügt: -1 = nach der letzten Zeile, -2 = zwei Zeilen, nach der letzten Zeile, usw.)
   -escape: Escapesequenzen werden umgewandelt (zum Beispiel \a, \07, \x07)
     -date: Datum der Nachricht, mögliche Formatierung:
              -n: 'n' vor dem jetzigen Zeipunkt, in Sekunden
             +n: 'n' in Zukunft, in Sekunden
               n: 'n' Sekunden seit der Epoche (siehe man time)
               date/time (ISO 8601): yyyy-mm-ddThh:mm:ss, Beispiel: 2014-01-19T04:32:55
               time: hh:mm:ss (Beispiel: 04:32:55)
     -tags: durch Kommata getrennte Liste von Tags (siehe /help filter für eine Liste von Tags die häufig genutzt werden)
      text: Text der ausgegeben werden soll (Präfix und Nachricht muss durch \t getrennt werden, sollte der Text mit "-" beginnen, muss ein "\" vorangestellt werden)
   -stdout: Text wird an stdout geschickt (Escapesequenzen werden umgewandelt)
   -stderr: Text wird an stderr geschickt (Escapesequenzen werden umgewandelt)
     -beep: Alias für "-stderr \a"

Das Argument -action ... -quit nutzt den Präfix der in der Einstellung "weechat.look.prefix_*" definiert ist.

Folgende Escapesequenzen werden unterstützt:
  \" \\ \a \b \e \f \n \r \t \v \0ooo \xhh \uhhhh \Uhhhhhhhh

Beispiele:
  zeigt eine Erinnerung, mit Highlight, im Core-Buffer dar:
    /print -core -tags notify_highlight Reminder: Milch kaufen
  zeigt eine Fehlernachricht im Core-Buffer an:
    /print -core -error irgend ein Fehler
  zeigt eine Nachricht im Core-Buffer mit dem Präfix "abc" an:
    /print -core abc\tmeine Nachricht
  es wird eine Nachricht im Channel #weechat ausgegeben:
    /print -buffer irc.libera.#weechat Nachricht an #weechat
  gibt einen Schneemann aus (U+2603):
    /print -escape \u2603
  verschickt Alarm (BEL):
    /print -beep
----

[[command_weechat_proxy]]
* `+proxy+`: Proxys verwalten

----
/proxy  list
        add <name> <type> <address> <port> [<username> [<password>]]
        del <name>|-all
        set <name> <option> <value>

    list: listet alle Proxys auf
     add: fügt neuen Proxy hinzu
    name: Name des neuen Proxy (der Name darf nur einmal genutzt werden)
    type: http, socks4 oder socks5
 address: IP oder Hostname
    port: Port
username: Username (optional)
password: Passwort (optional)
     del: entfernt einen Proxy (-all um alle Proxys zu entfernen)
     set: setzt einen Wert für Proxy
  option: Optionen die geändert werden (für eine Liste der möglichen Optionen, bitte folgenden Befehl nutzen: /set weechat.proxy.<proxyname>.*)
   value: neuer Wert für Option

Beispiele:
  erstellt einen HTTP-Proxy, der auf einem lokalen Host läuft und den Port 8888 nutzt:
    /proxy add local http 127.0.0.1 8888
  erstellt einen HTTP-Proxy der das IPv6 Protokoll nutzt:
    /proxy add local http ::1 8888
    /proxy set local ipv6 on
  erstellt einen socks5-Proxy, mit Username und Passwort:
    /proxy add myproxy socks5 sample.host.org 3128 myuser mypass
  entferne einen Proxy:
    /proxy del myproxy
----

[[command_weechat_quit]]
* `+quit+`: WeeChat beenden

----
/quit  [-yes] [<arguments>]

     -yes: Argument muss genutzt werden falls weechat.look.confirm_quit aktiviert sein sollte
arguments: Text der beim Signal "quit" verschickt wird
           (zum Beispiel sendet die IRC Erweiterung diesen Text als Quit-Nachricht an den Server)

Standardmäßig werden alle Konfigurationsdateien beim Beenden gespeichert (siehe Option "weechat.look.save_config_on_exit") und das aktuelle Layout kann gesichert werden (siehe Option "weechat.look.save_layout_on_exit").
----

[[command_weechat_reload]]
* `+reload+`: Konfiguration neu laden

----
/reload  [<file> [<file>...]]

file: Konfigurationsdatei die erneut geladen werden soll (ohne Dateinamenserweiterung ".conf")

Ohne Angabe von Argumenten werden alle Konfigurationen (WeeChat und Erweiterungen) neu geladen.
----

[[command_weechat_repeat]]
* `+repeat+`: führt einen Befehl mehrfach aus

----
/repeat  [-interval <delay>[<unit>]] <count> <command>

  delay: Verzögerung zwischen dem Ausführen der Befehle
   unit: mögliche Werte (optional):
           ms: Millisekunden
            s: Sekunden (Vorgabewert)
            m: Minuten
            h: Stunden
  count: Anzahl, wie oft der Befehl ausgeführt werden soll
command: Befehl welcher ausgeführt werden soll (oder ein Text der an einen Buffer gesendet werden soll, sofern der Befehl nicht mit '/' beginnt)

Hinweis: Der Befehl wird in dem Buffer ausgeführt, in welchem der /repeat Befehl ausgeführt wurde (sollte der Buffer nicht mehr existieren, wird der Befehl nicht ausgeführt).

Beispiel:
  scrolle zwei Seiten hoch:
    /repeat 2 /window page_up
----

[[command_weechat_save]]
* `+save+`: Konfiguration abspeichern

----
/save  [<file> [<file>...]]

file: Konfigurationsdatei die gesichert werden soll (ohne Dateinamenserweiterung ".conf")

Wird keine Datei angegeben dann werden alle Konfigurationen (WeeChat und Erweiterungen) gesichert.

Standardmäßig werden alle Konfigurationsdateien beim Ausführen des /quit Befehls gespeichert (siehe Option "weechat.look.save_config_on_exit").
----

[[command_weechat_secure]]
* `+secure+`: verwaltet zu schützende Daten (Passwörter oder private Daten werden in der Datei sec.conf verschlüsselt)

----
/secure  passphrase <passphrase>|-delete
         decrypt <passphrase>|-discard
         set <name> <value>
         del <name>

passphrase: ändern der Passphrase (ohne Passphrase, werden die Daten in der Datei sec.conf in Klartext gesichert)
   -delete: löscht Passphrase
   decrypt: entschlüsselt Daten nachträglich (dies passiert nur falls die Passphrase beim Start nicht angegeben wurde)
  -discard: verwirft alle verschlüsselten Daten
       set: fügt eine schutzwürdige Information hinzu oder ändert eine bestehende
       del: entfernt eine schutzwürdige Information

Ohne Angabe von Argumenten wird ein neuer Buffer geöffnet und die schutzwürdigen Informationen können dort eingesehen werden.

Tastenbefehle für den secure-Buffer:
  alt+v Werte werden in Klartext angezeigt bzw. verborgen

Wird eine Passphrase verwendet (Daten liegen verschlüsselt vor), fragt WeeChat beim Start die Passphrase ab.
Setzt man die Umgebungsvariable "WEECHAT_PASSPHRASE", kann die Eingabeaufforderung der Passphrase beim Programmstart vermieden werden (diese Variable wird von WeeChat auch beim /upgrade verwendet). Es ist auch möglich mittels der Option sec.crypt.passphrase_command die Passphrase aus der Ausgabe eines externen Befehls, wie eines Passwort-Managers zu lesen (siehe /help sec.crypt.passphrase_command )

schutzwürdige Daten mit dem Format ${sec.data.xxx} können wie folgt genutzt werden:
  - Befehl /eval.
  - Argument in der Befehlszeile für "--run-command"
  - Einstellung weechat.startup.command_{before|after}_plugins
  - weitere Optionen die Passwörter oder sensible Daten beinhalten (zum Beispiel: proxy, irc server und relay); nutze /help mit der entsprechenden Option um zu überprüfen ob die Daten evaluiert werden.

Beispiele:
  festlegen eine Passphrase:
    /secure passphrase Dies ist meine Passphrase
  nutze Programm "pass" um die Passphrase beim Start auszulesen:
    /set sec.crypt.passphrase_command "/usr/bin/pass show weechat/passphrase"
  verschlüsselt libera SASL Passwort:
    /secure set libera meinPasswort
    /set irc.server.libera.sasl_password "${sec.data.libera}"
  verschlüsselt oftc Passwort für nickserv:
    /secure set oftc meinPasswort
    /set irc.server.oftc.command "/msg nickserv identify ${sec.data.oftc}"
  Alternativbefehl um den eigenen Nick zu ghosten:
    /alias add ghost /eval /msg -server libera nickserv ghost meinNick ${sec.data.libera}
----

[[command_weechat_set]]
* `+set+`: um Konfigurationsoptionen und Umgebungsvariablen zu setzen

----
/set  [<option> [<value>]]
      diff [<option> [<option>...]]
      env [<variable> [<value>]]

option: Name der zu ändernden Einstellung (der Platzhalter "*" kann verwendet werden, um sich mehrere Einstellungen anzeigen zu lassen)
 value: neuer Wert den die Einstellung erhalten soll. Abhängig von der ausgewählten Einstellung, kann die Variable folgenden Inhalt haben:
          boolean: on, off oder toggle
          integer: Nummer, ++Nummer oder --Nummer
           string: beliebige Zeichenkette ("" für eine leere Zeichenkette)
            color: Farbwert, ++Nummer oder --Nummer
        Hinweis: für alle Typen von Variablen kann die Zeichenkette "null" (ohne "")  genutzt werden, um den Wert der Einstellung zu löschen (undefinierter Wert). Dies kann nur auf einige besondere Variablen (Erweiterungen) angewendet werden.
  diff: es werden nur Einstellungen angezeigt, die geändert wurden
   env: setzt oder zeigt eine Umgebungsvariable an (um eine Variable zu entfernen muss der Wert "" genutzt werden)

Beispiele:
  Zeigt alle Einstellungen an, die etwas mit highlight zu tun haben:
    /set *highlight*
  Fügt ein highlight-Wort hinzu:
    /set weechat.look.highlight "word"
  zeigt Einstellungen an, die verändert wurden:
    /set diff
  zeigt Einstellungen der IRC Erweiterung an, die verändert wurden:
    /set diff irc.*
  zeigt den Wert der Umgebungsvariable LANG an:
    /set env LANG
  setzt die Umgebungsvariable LANG und nutzt diese:
    /set env LANG fr_FR.UTF-8
    /upgrade
  entfernt die Umgebungsvariable ABC:
    /set env ABC ""
----

[[command_weechat_toggle]]
* `+toggle+`: den Wert einer Konfigurationsoption umschalten

----
/toggle  <option> [<value> [<value>...]]

option: Name einer Option
 value: mögliche Werte für die Option (Werte werden wie bei Shell-Befehlsargumente aufgeteilt: Anführungszeichen können verwendet werden, um Leerzeichen am Anfang/Ende von Werten zu nutzen)

Verhalten:
  - nur eine Option vom Typ Boolean oder String kann ohne Wert umgeschaltet werden:
      - boolean: zwischen Ein/Aus Status umschalten, entsprechend dem aktuellen Wert
      - string: Umschalten zwischen leerem String und Standardwert (funktioniert nur, wenn für die Option ein leerer String erlaubt ist)
  - mit einem vorgegeben einzelnen Wert, zwischen diesem Wert und dem Standardwert der Option umschalten
  - sind mehrere Werte angegeben, schalten Sie zwischen diesen Werten um: Der verwendete Wert ist der, der dem aktuellen Wert der Option folgt; wenn der aktuelle Wert der Option nicht in der Liste enthalten ist, wird der erste Wert aus der Liste verwendet
  - der Sonderwert "null" kann genutzt werden, jedoch nur als erster Wert in der Liste und ohne Anführungszeichen.

Beispiele:
  die Uhrzeit im Chat-Bereich umschalten (die Ausgabe des neuen Wertes wird unterdrückt):
    /mute /toggle weechat.look.buffer_time_format
  Zeitformat im Chat-Bereich ändern (mit Sekunden, ohne Sekunden, deaktiviert):
    /toggle weechat.look.buffer_time_format "%H:%M:%S" "%H:%M" ""
  den automatischen Beitritt des #weechat-Kanals auf dem libera-Server umschalten:
    /toggle irc.server.libera.autojoin null #weechat
----

[[command_weechat_unset]]
* `+unset+`: Konfigurationsparameter freigeben/zurücksetzen

----
/unset  <option>
        -mask <option>

option: Name einer Option
 -mask: nutzt eine Maske um Optionen auszuwählen (Platzhalter "*" kann verwendet werden um viele Optionen in einem Arbeitsschritt zurückzusetzen. Nutzen Sie diese Funktion mit äußerster Sorgfalt!)

Gemäß der jeweiligen Einstellung wird diese zurückgesetzt (bei Standardeinstellungen) oder komplett entfernt (bei optionalen Einstellungen, zum Beispiel die Server-Einstellungen).

Beispiele:
  Eine Einstellung zurücksetzen:
    /unset weechat.look.item_time_format
  Alle Farbeinstellungen zurücksetzen:
    /unset -mask weechat.color.*
----

[[command_weechat_upgrade]]
* `+upgrade+`: Speichern der WeeChat-Sitzung und laden der WeeChat-Binärdatei, ohne die Verbindung zu Servern zu trennen

----
/upgrade  [-yes] [<path_to_binary>|-save|-quit]

          -yes: wird benötigt, sobald Option "weechat.look.confirm_upgrade" aktiviert ist
path_to_binary: Pfad zu einer ausführbaren WeeChat Binärdatei (Standardeinstellung ist die aktuell ausführbare Datei)
        -dummy: ohne Funktion (dient lediglich dazu, um nicht versehentlich die "-quit" Funktion auszuführen)
         -save: speichert nur die aktuelle Sitzung, WeeChat wird nicht beendet oder neu gestartet. DieKonfigurationsdateien werden hierbei nicht gespeichert (falls dies gewünscht wird, nutze vorher /save)
         -quit: trennt *ALLE* Verbindungen, speichert die aktuelle Sitzung und beendet WeeChat, um den aktuellen Zustand später wiederherstellen (siehe unten)

Dieser Befehl führt ein Upgrade von WeeChat durch und startet die laufende Sitzung neu. Bevor dieser Befehl ausgeführt wird, sollte eine neue Version von WeeChat entweder vorab kompiliert, oder mit einem Paketmanager installiert worden sein.

Hinweis: SSL Verbindungen werden während eines Upgrades unterbrochen, da diese Verbindungen zur Zeit nicht mit GnuTLS gehalten werden können. Nach einem erfolgten Upgrade findet eine automatische Verbindung zu diesen Servern statt.

Wichtig: Die Verwendung der Option -save kann gefährlich sein. Für ein Standard-Upgrade oder einen Neustart wird empfohlen, nur den /upgrade (oder mit -quit) Befehl zu nutzen.Mit der Option -save kann eine Sitzung regelmäßig gespeichert und dann wiederhergestellt werden,falls Weechat abnormal beendet wird (Stromausfall, Absturz etc.)

Der Upgrade Vorgang besteht aus vier Schritten:
  1. Sicherung der Sitzung, in Dateien für Core und Erweiterungen (buffers, history, ..)
  2. alle Erweiterungen werden ausgeschaltet (Konfigurationen *.conf werden gesichert)
  3. Sicherung der WeeChat Konfiguration (weechat.conf)
  4. ausführen der neuen Version von WeeChat und wiederherstellen der Sitzung.

Nutzt man die "-quit" Funktion ist die Abfolge geringfügig anders:
  1. es werden *ALLE* Verbindungen getrennt (irc,xfer,relay, ...)
  2. die Sitzung wird in Dateien gesichert (*.upgrade)
  3. alle Erweiterungen werden ausgeschaltet
  4. die WeeChat Konfiguration wird gesichert
  5. WeeChat wird beendet

Mit der Option "-save" ist der Ablauf:
  1. Die Sitzung wird in Dateien (*.upgrade) gesichert, allerdings mit dem Status das IRC und Client Verbindungen unterbrochen sind (es findet aber keine Trennung der Verbindung statt!)

Durch nutzen von -quit oder -save kann eine Sitzung zu einem späteren Zeitpunkt wiederhergestellt werden:weechat --upgrade
WICHTIG: Die Sitzung muss mit exakt den selben Konfigurationsdateien wiederhergestellt werden (*.conf) und wenn möglich mit der selben Version von WeeChat (oder einer neueren Version).
Es ist möglich, die WeeChat-Sitzung auf einem anderen Computer wiederherzustellen, wenn Sie den Inhalt der WeeChat Verzeichnisse kopieren (siehe /debug dirs).
----

[[command_weechat_uptime]]
* `+uptime+`: Zeigt die Uptime von WeeChat an

----
/uptime  [-o|-ol]

 -o: die Laufzeit von WeeChat wird in den aktuellen Buffer geschrieben (in englischer Sprache)
-ol: die Laufzeit von WeeChat wird in den aktuellen Buffer geschrieben (in der voreingestellten Landessprache)
----

[[command_weechat_version]]
* `+version+`: Zeigt die WeeChat-Version und das Datum der Kompilierung an

----
/version  [-o|-ol]

 -o: die Version von WeeChat wird in den aktuellen Buffer ausgegeben (in englischer Sprache)
-ol: die Version von WeeChat wird in den aktuellen Buffer ausgegeben (in der voreingestellten Landessprache)

Um diesen Befehl in jedem Buffer ausführen zu können, kann der Standardkurzbefehl /v genutzt werden (andernfalls wird der IRC Befehl /version in einem IRC Buffer ausgeführt).
----

[[command_weechat_wait]]
* `+wait+`: Terminiere einen Befehl der ausgeführt werden soll

----
/wait  <number>[<unit>] <command>

 number: die Zeit, die gewartet werden soll (dies muss eine natürlich Zahl sein)
   unit: mögliche Werte (optional):
           ms: Millisekunden
            s: Sekunden (Vorgabewert)
            m: Minuten
            h: Stunden
command: Befehl welcher ausgeführt werden soll (oder ein Text der an einen Buffer gesendet werden soll, sofern der Befehl nicht mit '/' beginnt)\n

Hinweis: Der Befehl wird in dem Buffer ausgeführt, in welchem der /wait Befehl ausgeführt wurde (sollte der Buffer nicht mehr existieren, wird der Befehl nicht ausgeführt).

Beispiele:
  Betritt nach 10 Sekunden den Kanal #test:
  /wait 10 /join #test
  Setzt nach 15 Minuten eine globale Abwesenheit:
  /wait 15m /away -all Bin dann mal eben weg
  Versendet nach zwei Minuten den Text 'Hallo':
  /wait 2m Hallo
----

[[command_weechat_window]]
* `+window+`: Fenster verwalten

----
/window  list
         -1|+1|b#|up|down|left|right [-window <number>]
         <number>
         splith|splitv [-window <number>] [<pct>]
         resize [-window <number>] [h|v][+|-]<pct>
         balance
         merge [-window <number>] [all]
         close [-window <number>]
         page_up|page_down [-window <number>]
         refresh
         scroll [-window <number>] [+|-]<value>[s|m|h|d|M|y]
         scroll_horiz [-window <number>] [+|-]<value>[%]
         scroll_up|scroll_down|scroll_top|scroll_bottom|scroll_beyond_end|scroll_previous_highlight|scroll_next_highlight|scroll_unread [-window <number>]
         swap [-window <number>] [up|down|left|right]
         zoom [-window <number>]
         bare [<delay>]

         list: listet die geöffneten Fenster (ohne Angabe von Argumente wird diese Liste standardmäßig ausgegeben)
           -1: springt zum vorherigen Fenster
           +1: springt zum nächsten Fenster
           b#: springt zum nächsten Fenster, welches die Buffer Nummer # besitzt
           up: wechselt zum Fenster über dem aktuellen
         down: wechselt zum Fenster unter dem aktuellen
         left: wechselt zum linken Fenster
        right: wechselt zum rechten Fenster
       number: Nummer des Fensters (siehe /window list)
       splith: teilt das aktuelle Fenster horizontal (um den Vorgang rückgängig zu machen: /window merge)
       splitv: teilt das aktuelle Fenster vertikal (um den Vorgang rückgängig zu machen: /window merge)
       resize: verändert die Größe des aktuellen Fensters. Die neue Größe des Fensters ist prozentual <pct> zum Stammfensters groß
               wird "h" oder "v" angegeben, findet eine Größenanpassung des Stammfenster statt, sofern es vom selben Typ ist (horizontal/vertikal)
      balance: passt die Größe aller Fenster an
        merge: vereinigt Fenster miteinander (all = alle Fenster vereinigen)
        close: Fenster wird geschlossen
      page_up: scrollt eine Seite nach oben
    page_down: scrollt eine Seite nach unten
      refresh: Seite wird neu aufgebaut
       scroll: scrollt eine Anzahl an Zeilen (+/-N) oder zu einer angegebenen Zeit: s=Sekunden, m=Minuten, h=Stunden, d=Tage, M=Monate, y=Jahre
 scroll_horiz: scrollt horizontal eine Anzahl an Spalten (+/-N) oder prozentual von der Fenstergröße ausgehend (dieses scrolling ist nur in Buffern möglich die über einen freien Inhalt verfügen)
    scroll_up: scrollt ein paar Zeilen nach oben
  scroll_down: scrollt ein paar Zeilen nach unten
   scroll_top: scrollt zum Anfang des Buffers
scroll_bottom: scrollt zum Ende des Buffers
scroll_beyond_end: scrollt über das Ende des Buffers hinaus
scroll_previous_highlight: scrollt zum vorherigen Hightlight
scroll_next_highlight: scrollt zum nächsten Highlight
scroll_unread: scrollt zur ersten ungelesenen Zeile in einem Buffer
         swap: tauscht die Buffer von zwei Fenstern (mit optionaler Angabe für das Zielfenster)
         zoom: vergrößert ein Fenster auf 100%
         bare: wechselt zum einfachen Anzeigemodus (optional kann eine Wartezeit in Sekunden angegeben werden, wann wieder zum Standardmodus zurück gewechselt werden soll)

Für splith und splitv gibt "pct" die Größe des neuen Fensters im Verhältnis zur aktuellen Größe an. Zum Beispiel würde ein Wert von 25 bedeuten, dass das neue Fenster nur noch ein Viertel der Größe des alten Fensters besitzt.

Beispiele:
  springt zum Fenster mit dem Buffer #1:
    /window b1
   scrollt zwei Zeilen hoch:
    /window scroll -2
  scrollt zwei Tage hoch:
    /window scroll -2d
  scrollt zum Beginn des aktuellen Tages:
    /window scroll -d
  Fenster #2 wird vergrößert:
    /window zoom -window 2
  teilt das Fenster horizontal, wobei das obere Fenster 30% an Platz zugeteilt bekommt:
    /window splith 30
  ändert die Größe auf 75% des Stammfensters:
    /window resize 75
  die vertikale Aufteilung um 10% vergrößern:
    /window resize v+10
  eine Teilung wird rückgängig gemacht:
    /window merge
  das aktuelle Fenster wird geschlossen:
    /window close
  aktiviert den einfachen Anzeigemodus für zwei Sekunden:
    /window bare 2
----
// end::weechat_commands[]

// tag::buflist_commands[]
[[command_buflist_buflist]]
* `+buflist+`: Bar-Item mit der Liste von Buffern

----
/buflist  enable|disable|toggle
          bar
          refresh

 enable: buflist aktivieren
disable: buflist deaktivieren
 toggle: buflist umschalten
    bar: fügt eine "buflist" Bar hinzu
refresh: erzwingt eine Aktualisierung der Bar-Item (buflist, buflist2 und buflist3)

Jede Zeile die einen Buffer anzeigt wird mittels Zeichenketten-Evaluation dargestellt (siehe /help eval für das Format), dazu werden folgende Optionen genutzt:
  - buflist.look.display_conditions: Bedingungen um einen Buffer in der Liste darzustellen
  - buflist.format.buffer: Format für den Buffer, der nicht der aktuell dargestellte Buffer ist
  - buflist.format.buffer_current: Format für den aktuell dargestellten Buffer

Die folgenden Variablen können in den obigen Optionen genutzt werden:
  - bar item data (siehe hdata "bar_item" in API Dokumentation für eine vollständige Liste), zum Beispiel:
    - ${bar_item.name}
  - window data, wo das Bar-Item dargestellt werden soll (in "root" Bars existieren keine Fenster, siehe hdata "window" in API Dokumentation für eine vollständige Liste), zum Beispiel:
    - ${window.number}
    - ${window.buffer.full_name}
  - buffer data (siehe hdata "buffer" in API Dokumentation für eine vollständige Liste), zum Beispiel:
    - ${buffer.number}
    - ${buffer.name}
    - ${buffer.full_name}
    - ${buffer.short_name}
    - ${buffer.nicklist_nicks_count}
  - irc_server: IRC Serverdaten, ausschließlich genutzt bei einem IRC Buffer (siehe hdata "irc_server" in API Dokumentation)
  - irc_channel: IRC Kanaldaten, ausschließlich genutzt bei einem IRC Kanal-Buffer (siehe hdata "irc_channel" in API Dokumentation)
  - zusätzliche Variablen die durch buflist bereitgestellt werden:
    - ${format_buffer}: der evaluierte Wert der Option buflist.format.buffer; dies kann in der Option buflist.format.buffer_current genutzt werden um zum Beispiel die Hintergrundfarbe zu verändern
    - ${current_buffer}: ein Boolean ("0" oder "1"), "1" falls es sich um den aktuellen Buffer handelt; dies kann in einer Bedingung verwendet werden: ${if:${current_buffer}?...:...}
    - ${merged}: ein Boolean ("0" oder "1"), "1" wenn der Buffer mit einem anderen zusammengefügt ist; kann innerhalb einer Bedingung genutzt werden: ${if:${merged}?...:...}
    - ${format_number}: eingerückte Nummer mit Trennzeichen (evaluiert aus Option buflist.format.number)
    - ${number}: eingerückte Nummer, zum Beispiel " 1", falls die Anzahl der Buffer zwischen 10 und 99 liegt; bei zusammengefügten Buffern enthält die Variable für den ersten Buffer die entsprechende Nummer, die weiteren Buffer enthalten ein Leerzeichen anstelle der Nummer
    - ${number2}: eingerückte Nummer, zum Beispiel " 1", falls die Anzahl der Buffer zwischen 10 und 99 liegt
    - ${number_displayed}: "1" falls Nummer angezeigt wird, ansonsten "0"
    - ${indent}: Einrückung für Name (Channel und private Buffer werden eingerückt) (evaluiert aus Option buflist.format.indent)
    - ${format_nick_prefix}: Nick-Präfix mit entsprechender Farbe für einen Channel (evaluiert aus Option buflist.format.nick_prefix)
    - ${color_nick_prefix}: Farbe für den Nick-Präfix von einem Channel (wird nur genutzt wenn die Option buflist.look.nick_prefix aktiviert ist)
    - ${nick_prefix}: der Nick-Präfix für einen Channel (wird nur genutzt falls die Option buflist.look.nick_prefix aktiviert ist)
    - ${format_name}: der formatierte Name (evaluiert aus Option buflist.format.name)
    - ${name}: der Kurzname (falls einer gesetzt ist), ersatzweise wird auf den Originalnamen zurückgegriffen
    - ${color_hotlist}: die Farbe mit der höchsten Priorität für den entsprechenden Buffer (evaluiert aus Option buflist.format.hotlist_xxx wobei xxx der entsprechende Level ist)
    - ${format_hotlist}: die formatierte Hotlist (evaluiert aus Option buflist.format.hotlist)
    - ${hotlist}: die Hotlist in der Rohform
    - ${hotlist_priority}: "none", "low", "message", "private" oder "highlight"
    - ${hotlist_priority_number}: -1 = keine, 0 = niedrig, 1 = Nachricht, 2 = private, 3 = Hervorhebungen
    - ${format_lag}: die Verzögerung für einen IRC Server-Buffer, ist leer falls es keine Verzögerung gibt (evaluiert aus Option buflist.format.lag)
    - ${format_tls_version}: Indikator der TLS Version für den Serverbuffer, Channels bleiben unberührt (evaluiert aus Option buflist.format.tls_version)
----
// end::buflist_commands[]

// tag::charset_commands[]
[[command_charset_charset]]
* `+charset+`: Ändert den Zeichensatz für aktuellen Buffer

----
/charset  decode|encode <charset>
          reset

 decode: ändere Zeichensatz zum dekodieren
 encode: ändere Zeichensatz zum kodieren
charset: wähle neuen Zeichensatz für aktuellen Buffer
  reset: setze im aktuellen Buffer den Zeichensatz zurück
----
// end::charset_commands[]

// tag::exec_commands[]
[[command_exec_exec]]
* `+exec+`: führe externe Befehle aus

----
/exec  -list
       [-sh|-nosh] [-bg|-nobg] [-stdin|-nostdin] [-buffer <name>] [-l|-o|-oc|-n|-nf] [-oerr] [-cl|-nocl] [-sw|-nosw] [-ln|-noln] [-flush|-noflush] [-color ansi|auto|irc|weechat|strip] [-rc|-norc] [-timeout <timeout>] [-name <name>] [-pipe <command>] [-hsignal <name>] <command>
       -in <id> <text>
       -inclose <id> [<text>]
       -signal <id> <signal>
       -kill <id>
       -killall
       -set <id> <property> <value>
       -del <id>|-all [<id>...]

   -list: zeigt laufende Befehle an
     -sh: es wird die shell verwendet um Befehle auszuführen, mehrere Befehle können dabei gepiped werden (WARNUNG: Dieses Argument sollte nur verwendet werden, falls alle Argumente unbedenklich sind, siehe Argument -nosh)
   -nosh: die shell wird nicht verwendet um Befehle auszuführen (wird benötigt, falls der Befehl mit sensiblen Daten hantiert. Zum Beispiel der Inhalt einer Nachricht eines anderen Users)(Standardverhalten)
     -bg: führt Prozess im Hintergrund aus: es wird weder eine Prozessausgabe noch ein Rückgabewert ausgegeben (nicht kompatibel mit Argumenten -o/-oc/-n/-nf/-pipe/-hsignal)
   -nobg: gibt Prozessausgabe und Rückgabewert aus (Standardverhalten)
  -stdin: erstellt eine PIPE um Daten zu dem Prozess zu senden (mittels /exec -in/-inclose)
-nostdin: es wird keine PIPE für stdin erstellt (Standardverhalten)
 -buffer: zeigt/sendet Ausgabe des Befehls an diesen Buffer (wird der angegebene Buffer nicht gefunden wird ein neuer Buffer mit dem Namen "exec.exec.xxx" erstellt)
      -l: gibt die Ausgabe des Befehls lokal im Buffer aus (Standardverhalten)
      -o: gibt die Ausgabe des Befehls im Buffer aus (nicht kompatibel mit Argumenten -bg/-pipe/-hsignal)
     -oc: gibt die Ausgabe des Befehls im Buffer aus und führt diesen dann aus (betrifft Zeilen die mit "/" beginnen bzw. das benutzerdefinierte Befehlszeichen verwenden) (nicht kompatibel mit Argumenten -bg/-pipe/-hsignal)
      -n: gibt die Ausgabe des Befehls in einem neuen Buffer aus (nicht kompatibel mit Argumenten -bg/-pipe/-hsignal)
     -nf: gibt die Ausgabe des Befehls in einem neuen Buffer, mit einem freien Inhalt, aus (kein Zeilenumbruch, keine Limitierung in der Anzahl der Zeilen), aus (nicht kompatibel mit Argument -bg/-pipe/-hsignal)
   -oerr: sendet stderr (Fehlerausgabe) an den Buffer (kann nur mit den Optionen -o und -oc verwendet werden)
     -cl: der neue Buffer wird vor einer Ausgabe gelöscht
   -nocl: Ausgabe wird an neuen Buffer angehangen, ohne diesen vorher zu löschen (Standardverhalten)
     -sw: es wird zum Ausgabebuffer gewechselt (Standardverhalten)
   -nosw: es wird nicht zum Ausgabebuffer gewechselt
     -ln: legt eine Zeilennummerierung an (Standardverhalten, nur für neue Buffer)
   -noln: es wird keine Zeilennummerierung angezeigt
  -flush: die Ausgabe des Befehls findet in Echtzeit statt (Standardwert)
-noflush: die Ausgabe des Befehls wird am Ende der Ausführung ausgegeben
  -color: es wird eine der folgenden Aktionen bei ANSI Zeichenkodierungen in der Ausgabe durchgeführt:
             ansi: ANSI-Kodierung wird beibehalten
             auto: konvertiert ANSI-Farben nach WeeChat/IRC (Standardverhalten)
              irc: konvertiert ANSI-Farben nach IRC Farben
          weechat: konvertiert ANSI-Farben nach WeeChat-Farben
            strip: ANSI-Farben werden entfernt
     -rc: der Rückgabewert wird ausgegeben (Standardverhalten)
   -norc: der Rückgabewert wird unterdrückt
-timeout: gibt eine Zeitbeschränkung für den auszuführenden Befehl an (in Sekunden)
   -name: dem Befehl wird ein Name zugewiesen (um den Befehl später mittels /exec zu nutzen)
   -pipe: sendet die Ausgabe an einen Befehl von WeeChat/Erweiterung (Zeile für Zeile); sollen Leerzeichen im Befehl/Argument verwendet werden, müssen diese mit Anführungszeichen eingeschlossen werden; Variable $line wird durch die entsprechende Zeile ersetzt (standardmäßig wird die Zeile, getrennt durch ein Leerzeichen, dem Befehl nachgestellt (nicht kompatibel mit den Argumenten -bg/-o/-oc/-n/-nf)
 -hsignal: sendet die Ausgabe als hsignal (um es z.B. mittels /trigger zu verwenden) (nicht kompatibel mit den Argumenten -bg/-o/-oc/-n/-nf)
 command: Befehl der ausgeführt werden soll; beginnt der Befehl mit "url:", wird die shell deaktiviert und der Inhalt der URL wird heruntergeladen und im Buffer ausgegeben
      id: identifiziert eindeutig einen Befehl: entweder durch eine Nummer oder einen Namen (sofern ein Name mittels "-name xxx" zugewiesen wurde)
     -in: sendet Text an die Standardeingabe des Prozesses
-inclose: wie -in aber stdin wird danach geschlossen (und der Text ist optional: ohne Text wird stdin umgehend geschlossen
 -signal: schickt ein Signal an den Prozess; das Signal kann entweder ein Integerwert oder eines der folgenden Schlüsselworte sein: hup, int, quit, kill, term, usr1, usr2
   -kill: Alias für "-signal <id> kill"
-killall: beendet alle laufenden Prozesse
    -set: nutzt eine Hook-Fähigkeit (siehe Funktion hook_set in Anleitung für API Erweiterung)
property: Hook-Fähigkeit
   value: neuer Wert für Hook-Fähigkeit
    -del: entfernt einen beendeten Befehl
    -all: entfernt alle beendeten Befehle

Standardoptionen können in der Einstellung exec.command.default_options bestimmt werden.

Beispiele:
  /exec -n ls -l /tmp
  /exec -sh -n ps xu | grep weechat
  /exec -n -norc url:https://pastebin.com/raw.php?i=xxxxxxxx
  /exec -nf -noln links -dump https://weechat.org/files/doc/devel/weechat_user.en.html
  /exec -o uptime
  /exec -pipe "/print Machine uptime:" uptime
  /exec -n tail -f /var/log/messages
  /exec -kill 0
----
// end::exec_commands[]

// tag::fifo_commands[]
[[command_fifo_fifo]]
* `+fifo+`: Konfiguration für "fifo" Erweiterung

----
/fifo  enable|disable|toggle

 enable: aktivieren der FIFO pipe
disable: deaktivieren der FIFO pipe
 toggle: Status der FIFO pipe umschalten

Die FIFO-Pipe wird als Fernbedienung genutzt, es können Befehle oder Text von der Shell an die FIFO-Pipe geschickt werden
Standardmäßig heißt die FIFO-Pipe weechat_fifo_xxx (wobei xxx die WeeChat-Prozess-ID ist) und befindet sich im WeeChat-Laufzeitverzeichnis (siehe /debug dirs).

Folgendes Format wird erwartet:
  plugin.buffer *Text oder Befehl an dieser Stelle
  *Text oder Befehl an dieser Stelle

Beispiel um den eigenen Nick auf dem Server libera zu ändern:
  echo 'irc.server.libera */nick newnick' >/run/user/1000/weechat/weechat_fifo_12345

Bitte lese die Benutzeranleitung für weitere Informationen und Beispiele.

Beispiele:
  /fifo toggle
----
// end::fifo_commands[]

// tag::fset_commands[]
[[command_fset_fset]]
* `+fset+`: Optionen von WeeChat und Erweiterungen schnell anpassen

----
/fset  -bar
       -refresh
       -up|-down [<number>]
       -left|-right [<percent>]
       -go <line>|end
       -toggle
       -add [<value>]
       -reset
       -unset
       -set
       -setnew
       -append
       -mark
       -format
       -export [-help|-nohelp] <filename>
       <filter>

       -bar: fügt eine Hilfe in einer Bar hinzu
   -refresh: der Bildschirm wird neu gezeichnet (Befehl: /window refresh)
        -up: bewegt die ausgewählte Zeile um die Anzahl an Zeilen nach oben
      -down: bewegt die ausgewählte Zeile um die Anzahl an Zeilen nach unten
      -left: der fset Buffer wird wird prozentual entsprechend der Fensterbreite nach links verschoben
     -right: der fset Buffer wird wird prozentual entsprechend der Fensterbreite nach rechts verschoben
        -go: wählt eine Zeile mit der entsprechenden Nummer aus, die erste Zeile beginnt mit 0 (mit "end" wird die letzte Zeile ausgewählt)
    -toggle: der Wert einer Variable vom Typ boolean wird umgeschaltet
       -add: addiert den "Wert" (kann auch eine negative Zahl sein) bei Integer und Farbe, für andere Typen wird die Variable in die Eingabezeile kopiert und der Cursor positioniert (bei negativem Wert wird der Cursor an Beginn der Variable positioniert, bei positivem Wert wird der Cursor an das Ende gesetzt)
     -reset: löscht den Wert von der Option
     -unset: Option wird zurückgesetzt
       -set: der /set Befehl wird in die Eingabezeile kopiert um den Wert der Option zu editieren (der Cursor wird auf den Anfang des Wertes gesetzt)
    -setnew: der /set Befehl wird in die Eingabezeile kopiert um den Wert add the /set command in input to edit a new value for the option
    -append: der /set Befehl wird in die Eingabezeile kopiert um einen zusätzlichen Wert einzugeben (der Cursor wird an das Ende der Variable positioniert)
      -mark: Markierung umschalten
    -format: es wird zum nächsten verfügbaren Format gewechselt
    -export: exportiert die Optionen und Werte, welche angezeigt werden, in eine Datei (jede Zeile hat das Format: "/set Name Wert" oder "/unset Name")
      -help: der Hilfstext für eine Option wird in die exportierte Datei geschrieben (siehe /help fset.look.export_help_default)
    -nohelp: der Hilfetext für eine Option wird nicht in die exportierte Datei geschrieben (siehe /help fset.look.export_help_default)
     filter: setzt einen neuen Filter um nur ausgewählte Optionen anzuzeigen (die Filterfunktion kann direkt in der Eingabezeile eingegeben werden); mögliche Formate sind:
               *       alle Optionen werden angezeigt  (keine Filterung)
               xxx     zeigt nur Optionen mit "xxx" im Namen
               f:xxx   zeigt nur Konfigurationsdatei "xxx" an
               t:xxx   zeigt nur Optionen des entsprechenden Typs, "xxx" (bool/int/str/col)
               d       zeigt nur Optionen die verändert wurden
               d:xxx   zeigt nur Optionen die verändert wurden und "xxx" im Namen haben
               d=xxx   zeigt nur veränderte Optionen, die "xxx" als Wert haben
               d==xxx  zeigt nur veränderte Optionen die exakt "xxx" als Wert haben
               h=xxx   zeigt alle Optionen, die den Text "xxx" in der Beschreibung enthalten (in der Übersetzung)
               he=xxx  zeigt alle Optionen, die den Text "xxx" in der Beschreibung enthalten (in der englischen Beschreibung)
               =xxx    zeigt nur Optionen mit "xxx" als Wert
               ==xxx   zeigt nur Optionen die exakt "xxx" als Wert haben
               c:xxx   zeigt nur Optionen auf die die evaluierte Bedingung "xxx" zutrifft, folgende Variable können verwendet werden: file, section, option, name, parent_name, type, type_en, type_short (bool/int/str/col), type_tiny (b/i/s/c), default_value, default_value_undef, value, quoted_value, value_undef, value_changed, parent_value, min, max, description, description2, description_en, description_en2, string_values

Zeilen werden mittels evaluierten Ausdrücken dargestellt (siehe /help eval für das Format), dazu werden diese Optionen verwendet:
  - fset.format.option1: erstes Format für eine Option
  - fset.format.option2: zweites Format für eine Option

Die nachfolgenden Variablen können in den Optionen genutzt werden:
  - Optionsdaten, mit Farbe und durch Leerzeichen auf der rechten Seite aufgefüllt:
    - ${file}: Konfigurationsdatei (zum Beispiel "weechat" oder "irc")
    - ${section}: Sektion
    - ${option}: Name der Option
    - ${name}: vollständiger Name der Option (file.section.option)
    - ${parent_name}: übergeordneter Name der Option
    - ${type}: Optionstyp (übersetzt)
    - ${type_en}: Optionstyp (auf englisch)
    - ${type_short}: Optionstyp Kurzform (bool/int/str/col)
    - ${type_tiny}: Optionstyp klein (b/i/s/c)
    - ${default_value}: Standardwert einer Option
    - ${default_value_undef}: "1" falls Standardwert null ist, andernfalls "0"
    - ${value}: Optionswert
    - ${value_undef}: "1" wenn Wert null ist, andernfalls "0"
    - ${value_changed}: "1" wenn Wert abweichend vom Standardwert ist, andernfalls "0"
    - ${value2}: Optionswert, mit geerbtem Wert falls null
    - ${parent_value}: übergeordneter Optionswert
    - ${min}: minimaler Wert
    - ${max}: maximaler Wert
    - ${description}: Beschreibung der Option (übersetzt)
    - ${description2}: Beschreibung der Option (übersetzt), "(keine Beschreibung)" (übersetzt) falls keine Beschreibung vorhanden
    - ${description_en}: Beschreibung der Option (in englisch)
    - ${description_en2}: Beschreibung der Option (in englisch), "(keine Beschreibung)" falls keine Beschreibung vorhanden
    - ${string_values}: Zeichenketten sind für Integer Optionen erlaubt
    - ${marked}: "1" wenn Option markiert ist, andernfalls "0"
    - ${index}: Index der Option in der Liste
  - Optionsdaten, mit Farbe aber ohne Leerzeichen:
    - selbe Namen, vorangestellt mit Unterstrich, zum Beispiel: ${_name}, ${_type}, ...
  - Optionsdaten, Rohformat (keine Farben/Leerzeichen):
    - selbe Namen, mit zwei vorangestellten Unterstrichen, zum Beispiel: ${__name}, ${__type}, ...
  - Optionsdaten, nur Leerzeichen:
    - selbe Namen, mit vorangestelltem "empty_", zum Beispiel: ${empty_name}, ${empty_type}
  - andere Daten:
    - ${selected_line}: "1" wenn Zeile ausgewählt ist, andernfalls "0"
    - ${newline}: fügt einen Zeilenumbruch an diese Position, dadurch wird die Option über mehrere Zeilen angezeigt

Tasten und Eingaben um sich im fset Buffer zu bewegen:
  hoch                      eine Zeile nach oben
  runter                    eine Zeile nach unten
  pgup                      eine Seite nach oben
  pgdn                      eine Seite nach unten
  alt-home          <<      springe zur ersten Zeile
  alt-end           >>      springe zur letzten Zeile
  F11               <       horizontal nach links scrollen
  F12               >       horizontal nach rechts scrollen

Tasten und Eingaben um Optionen im fset Buffer zu editieren:
  alt+space         t       boolean Werte umschalten
  alt+'-'           -       subtrahiert 1 vom Wert, bei Integer/Farboptionen, bei anderen Typen kann der Wert editiert werden
  alt+'+'           +       addiert 1 zum Wert, bei Integer/Farboptionen, bei anderen Typen kann der Wert editiert werden
  alt+f, alt+r      r       Wert resetten
  alt+f, alt+u      u       Wert zurücksetzen
  alt+enter         s       Wert setzen
  alt+f, alt+n      n       ein neuer Wert wird gesetzt, der alte Wert wird gelöscht
  alt+f, alt+a      a       dem Wert was hinzufügen
  alt+','           ,       markieren/demarkieren einer Option
  shift+hoch                eine Zeile nach oben und markiert/demarkiert Option
  shift+runter              markiert/demarkiert Option und geht eine Zeile nach unten
                    m:xxx   markiert Optionen welche angezeigt werden und auf die der Filter "xxx" zutrifft (jeder Filter für Option oder Wert ist erlaubt, siehe Filterung weiter oben)
                    u:xxx   demarkiert Optionen welche angezeigt werden und auf die der Filter "xxx" zutrifft (jeder Filter für Option oder Wert ist erlaubt, siehe Filterung weiter oben)

weitere Tasten und Eingaben im fset Buffer:
  ctrl+L                    der Bildschirm wird neu gezeichnet (Befehl: /fset -refresh)
                    $       Optionen neu einlesen (markierte Optionen werden beibehalten)
                    $$      Optionen neu einlesen (Markierungen von Optionen werden dabei gelöscht)
  alt+p             p       Umschalten der Beschreibung von Erweiterungen (plugins.desc.*)
  alt+v             v       Hilfe-Bar Ein-/Ausschalten
                    s:x,y   sortiert Optionen nach Bereichen x,y (siehe /help fset.look.sort)
                    s:      setzt Sortierung wieder auf Standardwerte (siehe /help fset.look.sort)
                    w:xxx   exportiert Optionen in Datei "xxx"
                    w-:xxx  exportiert Optionen in Datei "xxx", ohne Hilfstext
                    w+:xxx  exportiert Optionen in Datei "xxx", mit Hilfstext
  ctrl+X            x       umschalten zwischen der Darstellung von Optionen
                    q       schließt fset Buffer

Mausaktionen im fset Buffer:
  Mausrad hoch/runter              Zeile hoch/runter
  linke Maustaste                  Zeile auswählen
  rechte Maustaste                 boolean umschalten (an/aus) oder editiere den Wert einer Option
  rechte Maustaste + links/rechts  Integer/Farbwerte werden erhöht/verringert, andere Variabletypen werden in die Eingabezeile kopiert
  rechte Maustaste + hoch/runter   markieren/demarkieren von mehreren Optionen

Hinweis: Leerzeichen am Anfang der Eingabezeile werden ignoriert und der folgende Text wird als Filter verwendet. Ein Beispiel: "q" schließt den fset Buffer wobei hingegen " q" alle Optionen anzeigt die ein "q" im Namen beinhalten.

Beispiele:
  zeigt alle IRC Optionen an, die verändert wurden:
    /fset d:irc.*
  zeigt alle Optionen die "nicklist" im Namen tragen:
    /fset nicklist
  zeigt alle Werte die "red" beinhalten:
    /fset =red
  zeigt alle Werte die exakt "red" lauten:
    /fset ==red
  zeigt alle Integer-Optionen der IRC-Erweiterung:
    /fset c:${file} == irc && ${type_en} == integer
----
// end::fset_commands[]

// tag::guile_commands[]
[[command_guile_guile]]
* `+guile+`: auflisten/installieren/beenden von Skripten

----
/guile  list|listfull [<name>]
        load [-q] <filename>
        autoload
        reload|unload [-q] [<name>]
        eval [-o|-oc] <code>
        version

    list: installierte Skripten werden aufgelistet
listfull: detaillierte Auflistung aller installierten Skripten
    load: installiert ein Skript
autoload: startet automatisch alle Skripten aus dem "autoload" Verzeichnis
  reload: ein Skript wird erneut gestartet (wird kein Name angegeben, dann werden alle Skripten beendet und erneut gestartet)
  unload: beendet ein Skript (wird kein Name angegeben, dann werden alle Skripten beendet)
filename: Skript (Datei) welches geladen werden soll
      -q: unterdrückter Modus: Es werden keine Nachrichten ausgegeben
    name: Name eines Skriptes (der Name der in der "register" Funktion der Skript-API genutzt wird)
    eval: evaluiert einen Quelltext und das Ergebnis wird im aktuellen Buffer ausgegeben
      -o: evaluierter Ergebnis wird im Buffer ausgegeben ohne das Befehle ausgeführt werden
     -oc: evaluierter Ergebnis wird im Buffer ausgegeben und Befehle werden ausgeführt
    code: Quelltext welcher evaluiert werden soll
 version: zeigt die Version des verwendeten Interpreters an

Ohne Angabe eines Argumentes listet dieser Befehl alle geladenen Skripten auf.
----
// end::guile_commands[]

// tag::javascript_commands[]
[[command_javascript_javascript]]
* `+javascript+`: auflisten/installieren/beenden von Skripten

----
/javascript  list|listfull [<name>]
             load [-q] <filename>
             autoload
             reload|unload [-q] [<name>]
             eval [-o|-oc] <code>
             version

    list: installierte Skripten werden aufgelistet
listfull: detaillierte Auflistung aller installierten Skripten
    load: installiert ein Skript
autoload: startet automatisch alle Skripten aus dem "autoload" Verzeichnis
  reload: ein Skript wird erneut gestartet (wird kein Name angegeben, dann werden alle Skripten beendet und erneut gestartet)
  unload: beendet ein Skript (wird kein Name angegeben, dann werden alle Skripten beendet)
filename: Skript (Datei) welches geladen werden soll
      -q: unterdrückter Modus: Es werden keine Nachrichten ausgegeben
    name: Name eines Skriptes (der Name der in der "register" Funktion der Skript-API genutzt wird)
    eval: evaluiert einen Quelltext und das Ergebnis wird im aktuellen Buffer ausgegeben
      -o: evaluierter Ergebnis wird im Buffer ausgegeben ohne das Befehle ausgeführt werden
     -oc: evaluierter Ergebnis wird im Buffer ausgegeben und Befehle werden ausgeführt
    code: Quelltext welcher evaluiert werden soll
 version: zeigt die Version des verwendeten Interpreters an

Ohne Angabe eines Argumentes listet dieser Befehl alle geladenen Skripten auf.
----
// end::javascript_commands[]

// tag::logger_commands[]
[[command_logger_logger]]
* `+logger+`: Konfiguration für "logger" Erweiterung (dient zum protokollieren der Buffer)

----
/logger  list
         set <level>
         flush
         disable

   list: zeigt von allen geöffneten Buffern den Status der Protokollierung an
    set: legt den Level fest, nach dem der aktuelle Buffer protokolliert werden soll
  level: legt fest, welche Nachrichten protokolliert werden sollen (0 = nichts protokollieren, 1 = nur die wichtigsten Nachrichten protokollieren .. 9 = alle Nachrichten werden protokolliert)
  flush: sichert alle Protokolle umgehend
disable: die Protokollierung wird für den aktuellen Buffer deaktiviert (der Level wird auf 0 gestellt)

Die Einstellungen "logger.level.*" und "logger.mask.*" können genutzt werden um den Level der Protokollierung festzulegen und um eine Maske für einen oder mehrere Buffer zu definieren.

Level der Protokollierung, die die IRC Erweiterung unterstützt:
  1: Nachrichten von Usern (private und öffentliche Nachrichten), notice (Server und Kanal)
  2: Wechsel von Nicks (/nick)
  3: Nachrichten vom Server
  4: join/part/quit Nachrichten
  9: alle Nachrichten

Beispiele:
  Stellt den Level für den aktuellen Buffer auf 5 ein:
    /logger set 5
  Die Protokollierung für den aktuellen Buffer wird ausgeschaltet:
    /logger disable
  Stellt den Level für alle IRC-Buffer auf 3 ein:
    /set logger.level.irc 3
  Die Protokollierung, für den WeeChat Haupt-Buffer, wird deaktiviert:
    /set logger.level.core.weechat 0
  Für jeden IRC-Server wird ein separates Verzeichnis erstellt und darin eine eigene Protokoll-Datei, für jeden Kanal:
    /set logger.mask.irc "$server/$channel.weechatlog"
----
// end::logger_commands[]

// tag::lua_commands[]
[[command_lua_lua]]
* `+lua+`: auflisten/installieren/beenden von Skripten

----
/lua  list|listfull [<name>]
      load [-q] <filename>
      autoload
      reload|unload [-q] [<name>]
      eval [-o|-oc] <code>
      version

    list: installierte Skripten werden aufgelistet
listfull: detaillierte Auflistung aller installierten Skripten
    load: installiert ein Skript
autoload: startet automatisch alle Skripten aus dem "autoload" Verzeichnis
  reload: ein Skript wird erneut gestartet (wird kein Name angegeben, dann werden alle Skripten beendet und erneut gestartet)
  unload: beendet ein Skript (wird kein Name angegeben, dann werden alle Skripten beendet)
filename: Skript (Datei) welches geladen werden soll
      -q: unterdrückter Modus: Es werden keine Nachrichten ausgegeben
    name: Name eines Skriptes (der Name der in der "register" Funktion der Skript-API genutzt wird)
    eval: evaluiert einen Quelltext und das Ergebnis wird im aktuellen Buffer ausgegeben
      -o: evaluierter Ergebnis wird im Buffer ausgegeben ohne das Befehle ausgeführt werden
     -oc: evaluierter Ergebnis wird im Buffer ausgegeben und Befehle werden ausgeführt
    code: Quelltext welcher evaluiert werden soll
 version: zeigt die Version des verwendeten Interpreters an

Ohne Angabe eines Argumentes listet dieser Befehl alle geladenen Skripten auf.
----
// end::lua_commands[]

// tag::xfer_commands[]
[[command_xfer_me]]
* `+me+`: sendet CTCP Aktion an entfernten Host

----
/me  <message>

message: zu sendende Nachricht
----

[[command_xfer_xfer]]
* `+xfer+`: Kontrolle der Übertragung(en)

----
/xfer  [list|listfull]

    list: zeigt Liste der Übertragungen
listfull: zeigt eine ausführliche Liste der Übertragungen

Ohne Angabe von Argumenten wird der Buffer mit der Übertragungsliste geöffnet.
----
// end::xfer_commands[]

// tag::perl_commands[]
[[command_perl_perl]]
* `+perl+`: auflisten/installieren/beenden von Skripten

----
/perl  list|listfull [<name>]
       load [-q] <filename>
       autoload
       reload|unload [-q] [<name>]
       eval [-o|-oc] <code>
       version

    list: installierte Skripten werden aufgelistet
listfull: detaillierte Auflistung aller installierten Skripten
    load: installiert ein Skript
autoload: startet automatisch alle Skripten aus dem "autoload" Verzeichnis
  reload: ein Skript wird erneut gestartet (wird kein Name angegeben, dann werden alle Skripten beendet und erneut gestartet)
  unload: beendet ein Skript (wird kein Name angegeben, dann werden alle Skripten beendet)
filename: Skript (Datei) welches geladen werden soll
      -q: unterdrückter Modus: Es werden keine Nachrichten ausgegeben
    name: Name eines Skriptes (der Name der in der "register" Funktion der Skript-API genutzt wird)
    eval: evaluiert einen Quelltext und das Ergebnis wird im aktuellen Buffer ausgegeben
      -o: evaluierter Ergebnis wird im Buffer ausgegeben ohne das Befehle ausgeführt werden
     -oc: evaluierter Ergebnis wird im Buffer ausgegeben und Befehle werden ausgeführt
    code: Quelltext welcher evaluiert werden soll
 version: zeigt die Version des verwendeten Interpreters an

Ohne Angabe eines Argumentes listet dieser Befehl alle geladenen Skripten auf.
----
// end::perl_commands[]

// tag::php_commands[]
[[command_php_php]]
* `+php+`: auflisten/installieren/beenden von Skripten

----
/php  list|listfull [<name>]
      load [-q] <filename>
      autoload
      reload|unload [-q] [<name>]
      eval [-o|-oc] <code>
      version

    list: installierte Skripten werden aufgelistet
listfull: detaillierte Auflistung aller installierten Skripten
    load: installiert ein Skript
autoload: startet automatisch alle Skripten aus dem "autoload" Verzeichnis
  reload: ein Skript wird erneut gestartet (wird kein Name angegeben, dann werden alle Skripten beendet und erneut gestartet)
  unload: beendet ein Skript (wird kein Name angegeben, dann werden alle Skripten beendet)
filename: Skript (Datei) welches geladen werden soll
      -q: unterdrückter Modus: Es werden keine Nachrichten ausgegeben
    name: Name eines Skriptes (der Name der in der "register" Funktion der Skript-API genutzt wird)
    eval: evaluiert einen Quelltext und das Ergebnis wird im aktuellen Buffer ausgegeben
      -o: evaluierter Ergebnis wird im Buffer ausgegeben ohne das Befehle ausgeführt werden
     -oc: evaluierter Ergebnis wird im Buffer ausgegeben und Befehle werden ausgeführt
    code: Quelltext welcher evaluiert werden soll
 version: zeigt die Version des verwendeten Interpreters an

Ohne Angabe eines Argumentes listet dieser Befehl alle geladenen Skripten auf.
----
// end::php_commands[]

// tag::python_commands[]
[[command_python_python]]
* `+python+`: auflisten/installieren/beenden von Skripten

----
/python  list|listfull [<name>]
         load [-q] <filename>
         autoload
         reload|unload [-q] [<name>]
         eval [-o|-oc] <code>
         version

    list: installierte Skripten werden aufgelistet
listfull: detaillierte Auflistung aller installierten Skripten
    load: installiert ein Skript
autoload: startet automatisch alle Skripten aus dem "autoload" Verzeichnis
  reload: ein Skript wird erneut gestartet (wird kein Name angegeben, dann werden alle Skripten beendet und erneut gestartet)
  unload: beendet ein Skript (wird kein Name angegeben, dann werden alle Skripten beendet)
filename: Skript (Datei) welches geladen werden soll
      -q: unterdrückter Modus: Es werden keine Nachrichten ausgegeben
    name: Name eines Skriptes (der Name der in der "register" Funktion der Skript-API genutzt wird)
    eval: evaluiert einen Quelltext und das Ergebnis wird im aktuellen Buffer ausgegeben
      -o: evaluierter Ergebnis wird im Buffer ausgegeben ohne das Befehle ausgeführt werden
     -oc: evaluierter Ergebnis wird im Buffer ausgegeben und Befehle werden ausgeführt
    code: Quelltext welcher evaluiert werden soll
 version: zeigt die Version des verwendeten Interpreters an

Ohne Angabe eines Argumentes listet dieser Befehl alle geladenen Skripten auf.
----
// end::python_commands[]

// tag::relay_commands[]
[[command_relay_relay]]
* `+relay+`: Relay-Kontrolle

----
/relay  list|listfull|listrelay
        add <name> <port>|<path>
        del|start|restart|stop <name>
        raw
        sslcertkey

         list: Auflistung der Relay-Clients (nur aktive Relays)
     listfull: detaillierte Auflistung der Relay-Clients (alle Relays)
    listrelay: Auflistung der Relays (Name und Port)
          add: fügt ein Relay, für ein Protokoll + Name, hinzu
          del: entfernt Relay für ein Protokoll + Name
        start: lausche am Port
      restart: beendet den Server Socket und lauscht erneut am Port (Clients bleiben verbunden)
         stop: schließt den Server Socket (Clients bleiben verbunden)
         name: Name des Relays (siehe Format weiter unten)
         port: Port der für Relay genutzt werden soll
         path: Pfad der für Relay genutzt werden soll (ausschließlich für UNIX Domain Socket); Pfad ist evaluiert (siehe Funktion string_eval_path_home in Erweiterung API Referenz)/n
          raw: öffnet einen Buffer mit Relay-Rohdaten
   sslcertkey: setzt SSL Zertifikat/Schlüssel mittels Pfad in Einstellung relay.network.ssl_cert_key

Aufbau des Relay-Namens: [ipv4.][ipv6.][ssl.]<Protokoll.Name> oder unix.[ssl.]<Protokoll.Name>
         ipv4: erzwingt die Nutzung von IPv4
         ipv6: erzwingt die Nutzung von IPv6
          ssl: aktiviert SSL
         unix: nutzt UNIX Domain Socket
protocol.name: Protokoll und Name des Relay:
                 - Protokoll "irc": Name des Servers welcher geteilt werden soll (optional. Falls kein Name angegeben wird, muss der Client einen Namen mit dem Befehl "PASS" übermitteln, das Format ist wie folgt: "PASS Server:Passwort")
                 - Protokoll "weechat" (es wird kein Name verwendet)

Das "irc" Protokoll dient dazu eine Verbindung zu einem anderen IRC Client (oder zu einem zweiten WeeChat) herzustellen.
Das "weechat" Protokoll wird von einem Remote-Interface genutzt um eine Verbindung auf dem Port herzustellen. Siehe https://weechat.org/about/interfaces/

Ohne Angabe von Argumenten werden alle Relay-Clients in einem neuen Buffer dargestellt.

Beispiele:
  IRC Proxy für Server "libera":
    /relay add irc.libera 8000
  IRC Proxy, für Server "libera", mit SSL:
    /relay add ssl.irc.libera 8001
  IRC Proxy für alle Server (Client wählt aus), mit SSL:
    /relay add ssl.irc 8002
  WeeChat Protokoll:
    /relay add weechat 9000
  WeeChat Protokoll, mit SSL:
    /relay add ssl.weechat 9001
  WeeChat Protokoll, mit SSL, nur IPv4 nutzen:
    /relay add ipv4.ssl.weechat 9001
  WeeChat Protokoll, mit SSL, nur IPv6 nutzen:
    /relay add ipv6.ssl.weechat 9001
  WeeChat Protokoll, mit SSL, mit IPv4 + IPv6:
    /relay add ipv4.ipv6.ssl.weechat 9001
  Weechat Protokoll über UNIX Domain Socket:
    /relay add unix.weechat ${weechat_runtime_dir}/relay_socket
----
// end::relay_commands[]

// tag::ruby_commands[]
[[command_ruby_ruby]]
* `+ruby+`: auflisten/installieren/beenden von Skripten

----
/ruby  list|listfull [<name>]
       load [-q] <filename>
       autoload
       reload|unload [-q] [<name>]
       eval [-o|-oc] <code>
       version

    list: installierte Skripten werden aufgelistet
listfull: detaillierte Auflistung aller installierten Skripten
    load: installiert ein Skript
autoload: startet automatisch alle Skripten aus dem "autoload" Verzeichnis
  reload: ein Skript wird erneut gestartet (wird kein Name angegeben, dann werden alle Skripten beendet und erneut gestartet)
  unload: beendet ein Skript (wird kein Name angegeben, dann werden alle Skripten beendet)
filename: Skript (Datei) welches geladen werden soll
      -q: unterdrückter Modus: Es werden keine Nachrichten ausgegeben
    name: Name eines Skriptes (der Name der in der "register" Funktion der Skript-API genutzt wird)
    eval: evaluiert einen Quelltext und das Ergebnis wird im aktuellen Buffer ausgegeben
      -o: evaluierter Ergebnis wird im Buffer ausgegeben ohne das Befehle ausgeführt werden
     -oc: evaluierter Ergebnis wird im Buffer ausgegeben und Befehle werden ausgeführt
    code: Quelltext welcher evaluiert werden soll
 version: zeigt die Version des verwendeten Interpreters an

Ohne Angabe eines Argumentes listet dieser Befehl alle geladenen Skripten auf.
----
// end::ruby_commands[]

// tag::script_commands[]
[[command_script_script]]
* `+script+`: WeeChat Skriptmanager

----
/script  list [-o|-ol|-i|-il]
         search <text>
         show <script>
         load|unload|reload <script> [<script>...]
         autoload|noautoload|toggleautoload <script> [<script>...]
         install|remove|installremove|hold [-q] <script> [<script>...]
         upgrade
         update

          list: gibt alle geladenen Skripten im Buffer aus (unabhängig der Programmiersprache)
            -o: gibt eine Liste der laufenden Skripten im Buffer aus (Ausgabe in englisch)
           -ol: gibt eine Liste der laufenden Skripten im Buffer aus (Ausgabe ist übersetzt)
            -i: eine Liste der laufenden Skripten wird in die Eingabezeile kopiert (um sie dann manuell in einen Buffer zu senden)(Ausgabe in englisch)
           -il: eine Liste der laufenden Skripten wird in die Eingabezeile kopiert (um sie dann manuell in einen Buffer zu senden)(Ausgabe ist übersetzt)
        search: sucht Skripten nach Schlagwörtern, Skriptsprache (python, perl, ...), Dateierweiterung (py, pl, ...) oder beliebigem Text. Das Ergebnis wird im Skripten-Buffer dargestellt
          show: zeigt detailliert Informationen zu einem Skript an
          load: startet Skript(en)
        unload: beendet Skript(en)
        reload: Skript(en) werden neu geladen
      autoload: das Skript wird in das autoload-Verzeichnis eingebunden
    noautoload: das Skript wird aus dem autoload-Verzeichnis entfernt
toggleautoload: autoload für das Skript umschalten
       install: installiert/aktualisiert Skript(en) (physikalisch, auf dem Datenträger)
        remove: deinstalliert Skript(en) (physikalisch, vom Datenträger)
 installremove: installiert oder deinstalliert Skript(en), abhängig davon welcher Status vorliegt
          hold: halten/freigeben von Skript(en) (ein Skript welches gehalten wird, kann weder aktualisiert noch entfernt werden)
            -q: unterdrückter Modus: Es werden keine Nachrichten ausgegeben
       upgrade: aktualisiert alle veralteten, installierten Skripten (sofern eine neue Version verfügbar ist)
        update: aktualisiert den lokalen Cache für die Skripten

Ohne Angaben von Argumenten öffnet dieser Befehl einen Buffer, in welchem eine Liste der Skripten dargestellt wird.

Im Skript-Buffer, werden folgende Statusangaben für ein Skript angezeigt:
  * i a H r N
  | | | | | |
  | | | | | obsolete (neue Version verfügbar)
  | | | | Skript wird ausgeführt (geladen)
  | | | gehalten
  | | Skript wird beim Start, von WeeChat, automatisch geladen
  | Skript ist installiert (wird aber nicht ausgeführt)
  beliebtes Skript

In der Ausgabe von /script list, wird der Status für ein Skript angegeben:
  * ? i a H N
  | | | | | |
  | | | | | obsolete (neue Version verfügbar)
  | | | | gehalten
  | | | Skript wird beim Start, von WeeChat, automatisch geladen
  | | Skript ist installiert (wird aber nicht ausgeführt)
  | unbekanntes Skript (dieses Skript kann nicht heruntergeladen/aktualisiert werden)
  beliebtes Skript

Tastenbefehle die im Skript-Buffer genutzt werden können:
  alt+i  installiert Skript (physikalisch)
  alt+r  deinstalliert Skript (physikalisch
  alt+l  startet ein Skript (Skript wird ausgeführt)
  alt+L  Skript wird neu gestartet
  alt+u  beendet ein Skript
  alt+A  das Skript wird in das autoload-Verzeichnis eingebunden
  alt+h  Skript wird gehalten bzw. freigegeben
  alt+v  Skript anzeigen

Befehle die in der Eingabezeile des Skript-Buffers eingegeben werden können:
  i/r/l/L/u/A/h/v  Aktionen die für ein Skript ausgeführt werden können (siehe Tastenbefehle, weiter oben)
  q                schließt den Buffer
  $                Buffer wird aktualisiert
  s:x,y            Buffer wird nach den Vorgaben x und y sortiert (siehe /help script.look.sort)
  s:               die Sortierung des Buffers wird zurückgesetzt (Standardwerte werden genutzt)
  word(s)          Skripten werden gefiltert: sucht nach einem oder mehreren Wörtern in den Skripten (der Beschreibung, in den Schlagwörtern, ...)
  *                Filter wird zurückgesetzt

Mausbefehle innerhalb des Skripten-Buffer:
  Mausrad            in der Liste scrollen
  linke Maustaste    Skript anwählen
  rechte Maustaste   Skript installieren/entfernen

Beispiele:
  /script search url
  /script install go.py urlserver.py
  /script remove go.py
  /script hold urlserver.py
  /script reload urlserver
  /script upgrade
----
// end::script_commands[]

// tag::spell_commands[]
[[command_spell_spell]]
* `+spell+`: Konfiguration für spell-Erweiterung

----
/spell  enable|disable|toggle
        listdict
        setdict -|<dict>[,<dict>...]
        deldict
        addword [<dict>] <word>

  enable: Rechtschreibprüfung wird aktiviert
 disable: Rechtschreibprüfung wird deaktiviert
  toggle: Funktionalität der Rechtschreibprüfung umschalten
listdict: die, auf dem System, installierten Wörterbücher werden aufgelistet
 setdict: Wörterbuch für den aktuellen Buffer einstellen (mehrere Wörterbücher müssen durch Kommata getrennt werden (spezieller Wert "-" deaktiviert die Rechtschreibprüfung für den aktuellen Buffer))
 deldict: Wörterbuch für den aktuellen Buffer entfernen
 addword: fügt ein Wort in das persönliche Wörterbuch hinzu

Eingaben die mit '/' beginnen werden nicht überprüft, davon ausgenommen sind einige Befehle (siehe /set spell.check.commands).

Um die Rechtschreibprüfung auf allen Buffer anzuwenden sollte die Einstellung "default_dict" genutzt und die Rechtschreibprüfung aktiviert werden:
  /set spell.check.default_dict "de_DE-neu"
  /spell enable

Um sich eine Liste von Vorschlägen in einer Bar anzeigen zu lassen nutzt man das Item "spell_suggest".

Die Standardtastaturbelegung zum Umschalten der Rechtschreibprüfung lautet alt-s.
----
// end::spell_commands[]

// tag::tcl_commands[]
[[command_tcl_tcl]]
* `+tcl+`: auflisten/installieren/beenden von Skripten

----
/tcl  list|listfull [<name>]
      load [-q] <filename>
      autoload
      reload|unload [-q] [<name>]
      eval [-o|-oc] <code>
      version

    list: installierte Skripten werden aufgelistet
listfull: detaillierte Auflistung aller installierten Skripten
    load: installiert ein Skript
autoload: startet automatisch alle Skripten aus dem "autoload" Verzeichnis
  reload: ein Skript wird erneut gestartet (wird kein Name angegeben, dann werden alle Skripten beendet und erneut gestartet)
  unload: beendet ein Skript (wird kein Name angegeben, dann werden alle Skripten beendet)
filename: Skript (Datei) welches geladen werden soll
      -q: unterdrückter Modus: Es werden keine Nachrichten ausgegeben
    name: Name eines Skriptes (der Name der in der "register" Funktion der Skript-API genutzt wird)
    eval: evaluiert einen Quelltext und das Ergebnis wird im aktuellen Buffer ausgegeben
      -o: evaluierter Ergebnis wird im Buffer ausgegeben ohne das Befehle ausgeführt werden
     -oc: evaluierter Ergebnis wird im Buffer ausgegeben und Befehle werden ausgeführt
    code: Quelltext welcher evaluiert werden soll
 version: zeigt die Version des verwendeten Interpreters an

Ohne Angabe eines Argumentes listet dieser Befehl alle geladenen Skripten auf.
----
// end::tcl_commands[]

// tag::trigger_commands[]
[[command_trigger_trigger]]
* `+trigger+`: verwaltet Trigger, das Schweizer Armeemesser für WeeChat

----
/trigger  list|listfull|listdefault
          add|addoff|addreplace <name> <hook> ["<arguments>" ["<conditions>" ["<regex>" ["<command>" ["<return_code>" ["<post_action>"]]]]]]
          addinput [<hook>]
          input|output|recreate <name>
          set <name> <option> <value>
          rename|copy <name> <new_name>
          enable|disable|toggle [<name>|-all [<name>...]]
          restart <name>|-all [<name>...]
          show <name>
          del <name>|-all [<name>...]
          restore <name> [<name>...]
          default -yes
          monitor [<filter>]

       list: zeigt eine Liste aller Trigger (ohne Angabe von Argumente wird diese Liste standardmäßig ausgegeben)
   listfull: zeigt eine detaillierte Liste, mit zusätzlichen Informationen, aller Trigger an
listdefault: zeigt die standardmäßig genutzten Trigger an
        add: fügt einen Trigger hinzu
     addoff: fügt einen Trigger hinzu (deaktiviert)
 addreplace: erzeugt neuen Trigger oder ersetzt einen schon existierenden Trigger
       name: Name des Trigger
       hook: signal, hsignal, modifier, line, print, command, command_run, timer, config, focus, info, info_hashtable
  arguments: Argumente für den Hook, abhängig vom genutzten Hook (getrennt durch Semikolon):
             signal: Name(en) des signals (erforderlich)
             hsignal: Name(en) des hsignal (erforderlich)
             modifier: Name(en) des modifier (erforderlich)
             line: Buffertyp ("formatted", "free" oder "*"), Liste von Buffermasken, Tags
             print: Buffer, Tags, Nachricht, Farben entfernen
             command: Befehl (erforderlich), Beschreibung, Argumente, Beschreibung der Argumente, Vervollständigung (alle Argumente, außer dem Befehl werden ausgewertet, "${tg_trigger_name}" wird durch den Triggernamen ersetzt, siehe /help eval)
             command_run: Befehl(e) (erforderlich)
             timer: Intervall (erforderlich), Anpassung an Sekunden (erforderlich), maximale Anzahl an Aufrufen
             config: Name der Einstellung (erforderlich)
             focus: Name(n) für sichtbaren Bereich (erforderlich) (z.B. "chat" für Chatbereich)
             info: Name(n) der Information (erforderlich)
             info_hashtable: Name(n) der Information (erforderlich)
 conditions: evaluierte Bedingungen für den Trigger
      regex: einer oder mehrere reguläre Ausdrücke um Zeichenketten in Variablen zu ersetzen
    command: Befehl welcher ausgeführt werden soll (mehrere Befehle müssen durch ";" voneinander getrennt werden)
return_code: Rückgabewert für Callback (ok (standard), ok_eat, error)
post_action: Aktion welche nach der Abarbeitung des Triggers ausgeführt werden soll (none (Standardwert), disable, delete)
   addinput: erstellt einen Trigger mit einer standardmäßigen Mustervorlage
      input: kopiert den kompletten Trigger-Befehl in die Eingabezeile
     output: schickt den Trigger-Befehl als Text in den Buffer
   recreate: wie "input", allerdings wird die Einstellung "addreplace" anstelle von "add" genutzt
        set: definiert, innerhalb eines Triggers, eine Einstellung neu
     option: Name einer Einstellung: name, hook, arguments, conditions, regex, command, return_code
             (um Hilfe über eine Einstellung zu erhalten: /help trigger.trigger.<name>.<option>)
      value: neuer Wert für Einstellung
     rename: benennt einen Trigger um
       copy: kopiert einen Trigger
     enable: aktiviert Trigger (ohne Angabe von Argumenten: aktiviert alle Trigger)
    disable: deaktiviert Trigger (ohne Angabe von Argumenten: deaktiviert alle Trigger)
     toggle: de-/aktiviert Trigger (ohne Angabe von Argumenten: de-/aktiviert alle Trigger)
    restart: startet Trigger neu (Hook(s) werden neu erstellt)
       show: zeigt detaillierte Informationen zu einem Trigger (inklusive einer kleinen Statistik)
        del: entfernt einen Trigger
       -all: führt eine Aktion aus, die alle Trigger betrifft
    restore: stellt Trigger mit Standardwerten wieder her (funktioniert nur bei vorgegebenen Triggern)
    default: stellt die standardmäßigen Trigger wieder her
    monitor: öffnet den Trigger Monitor-Buffer, mit optionaler Filterfunktion:
     filter: filtert Hooks/Trigger zum Anzeigen (ein Hook muss mit "@" beginnen, zum Beispiel "@signal"), mehrere Filter können durch Kommata voneinander getrennt werden; Platzhalter "*" kann im Namen des Trigger verwendet werden

Wenn ein Trigger-Callback aufgerufen wird, dann wird folgende Befehlskette ausgeführt:
  1. Überprüfung von Bedingungen; falls unwahr, beenden
  2. ersetze Text mittels einem oder mehreren erweiterten regulären POSIX Ausdrücken (sofern im Trigger definiert)
  3. ein oder mehrere Befehle werden ausgeführt (sofern im Trigger definiert)
  4. Beendigung mit einem Rückgabewert (ausgenommen sind modifiers, line, focus, info und info_hashtable)
  5. Aktion welche nach der Abarbeitung des Triggers ausgeführt werden soll

Beispiele (die standardmäßig verfügbaren Trigger kann man sich mit "/trigger listdefault" anzeigen lassen):
  fügt einer Nachricht die Textattribute *fett*, _unterstrichen_ und /kursiv/ hinzu (nur in User-Nachrichten):
    /trigger add effects modifier weechat_print "${tg_tag_nick}" "==\*([^ ]+)\*==*${color:bold}${re:1}${color:-bold}*== ==_([^ ]+)_==_${color:underline}${re:1}${color:-underline}_== ==/([^ ]+)/==/${color:italic}${re:1}${color:-italic}/"
  verbirgt die Nicklist auf kleineren Terminals:
    /trigger add resize_small signal signal_sigwinch "${info:term_width} < 100" "" "/bar hide nicklist"
    /trigger add resize_big signal signal_sigwinch "${info:term_width} >= 100" "" "/bar show nicklist"
  speichert die Konfiguration jede Stunde ab:
    /trigger add cfgsave timer 3600000;0;0 "" "" "/mute /save"
  speichert, ohne Ausgabe von Text, eine Weechat-Sitzung um Mitternach (siehe /help upgrade):
    /trigger add session_save signal day_changed "" "" "/mute /upgrade -save"
  öffnet den Trigger Monitor und zeigt ausschließlich modifier und Trigger an, die mit "resize" im Namen beginnen:
    /trigger monitor @modifier,resize*
----
// end::trigger_commands[]
