= WeeChat Benutzerhandbuch
:author: Sébastien Helleu
:email: flashcode@flashtux.org
:lang: de
:toc:
:toclevels: 4


Diese Anleitung beschreibt den WeeChat Chat Client und ist Teil von WeeChat.

Die aktuelle Version dieser Anleitung finden Sie auf:
http://weechat.org/doc


[[introduction]]
== Einleitung

WeeChat (Wee Enhanced Environment for Chat) ist ein freier, schneller und
schlanker Chat-Client der für unterschiedliche Betriebssysteme entwickelt wird.

[[features]]
=== Funktionen

wesentliche Merkmale:

* Unterstützung verschiedener Protokolle: IRC und Jabber (mittels Skript jabber.py
  oder bitlbee/minbif)
* mehrere Server Verbindungen sind möglich (mittels SSL, IPv6, proxy)
* klein, schnell und schlank
* den eigenen persönlichen Bedürfnissen anpassbar und durch Erweiterungen und Skripten in der Funktionalität erweiterbar
* IRC RFCs konform http://tools.ietf.org/html/rfc1459[1459],
  http://tools.ietf.org/html/rfc2810[2810],
  http://tools.ietf.org/html/rfc2811[2811],
  http://tools.ietf.org/html/rfc2812[2812] and
  http://tools.ietf.org/html/rfc2813[2813]
* Betriebssystemunabhängig (GNU/Linux, *BSD, MacOS X, Windows und weitere)
* 100% GPL, freie Software

Die WeeChat Homepage findet man unter: http://weechat.org/

[[prerequisites]]
=== Vorbereitung

Um WeeChat zu installieren wird folgendes benötigt:

* ein lauffähiges GNU/Linux System (mit Kompilierungswerkzeugen für Quellpakete),
  oder ein kompatibles OS
* 'root' Privilegien (um WeeChat in das Systemverzeichnis zu installieren)
* einige Bibliotheken (siehe <<dependencies,Abhängigkeiten>>).

[[install]]
== Installation

[[binary_packages]]
=== Binärpaket

Binärpakete sind für folgende Distributionen erhältlich:

* Debian (oder Debian kompatible Distribution):
  `apt-get install weechat-curses`
* Mandriva/RedHat (oder eine RPM kompatible Distribution):
  `rpm -i /path/to/weechat-x.y.z-1.i386.rpm`
* Gentoo: `emerge weechat`
* Arch Linux: `pacman -S weechat`
* Fedora Core: `yum install weechat`
* Sourcemage: `cast weechat`

zusätzliche Pakete können/sollten installiert werden. Zum Beispiel: weechat-plugins.

Für andere Distributionen schauen Sie bitte in die jeweilige Anleitung,
wie Pakete installiert werden können.

[[source_package]]
=== Quellpakete

WeeChat kann mittels cmake oder autotools kompiliert werden (cmake sollte dabei die bevorzugte Methode sein).

[NOTE]
Unter OS X kann http://brew.sh/[Homebrew] verwendet werden:
`brew install weechat --with-python --with-perl`
(für Hilfe: `brew info weechat`).

[[dependencies]]
==== Abhängigkeiten

folgende Tabelle beschreibt, welche Pakete zwingend notwendig sind um WeeChat zu kompilieren und
welche Pakete optional genutzt werden können.

[width="100%",cols="5,^3,^3,.^13",options="header"]
|===
| Paket ^(1)^                       | Version     | benötigt | Funktion
| cmake                             |             | *ja*     | Zum kompilieren (autotools ist möglich. cmake wird aber empfohlen)
| pkg-config                        |             | *ja*     | entdeckt installierte Bibliotheken
| libncursesw5-dev ^(2)^            |             | *ja*     | Ncurses Oberfläche
| libcurl4-gnutls-dev               |             | *ja*     | URL Transfer
| zlib1g-dev                        |             | *ja*     | Kompression für Pakete, die mittels Relay- (WeeChat Protokoll), Script-Erweiterung übertragen werden
| libgcrypt20-dev                   |             | *ja*     | Geschützte Daten, IRC SASL Authentifikation (DH-BLOWFISH/DH-AES), Skript-Erweiterung
| libgnutls28-dev                   | ≥ 2.2.0     |          | SSL Verbindung zu einem IRC Server, Unterstützung von SSL in der Relay-Erweiterung
| gettext                           |             |          | Internationalisierung (Übersetzung der Mitteilungen; Hauptsprache ist englisch)
| ca-certificates                   |             |          | Zertifikate für SSL Verbindungen
| libaspell-dev oder libenchant-dev |             |          | Aspell Erweiterung
| python-dev                        | ≥ 2.5 ^(3)^ |          | Python Erweiterung
| libperl-dev                       |             |          | Perl Erweiterung
| ruby2.1-dev                       | ≥ 1.8       |          | Ruby Erweiterung
| liblua5.2-dev                     |             |          | Lua Erweiterung
| tcl-dev                           | ≥ 8.5       |          | Tcl Erweiterung
| guile-2.0-dev                     | ≥ 2.0       |          | Guile (scheme) Erweiterung
| asciidoc                          | ≥ 8.5.0     |          | Zum Erstellen der man page und der Dokumentation
| source-highlight                  |             |          | Syntax Highlight für Quelltext in Dokumentation
| xsltproc,
  docbook-xml, docbook-xsl          |             |          | Erstellt man page
| libcpputest-dev                   | ≥ 3.4       |       .2+| Testlauf
| C++ compiler                      |             |
|===

[NOTE]
^(1)^ Paketnamen wurden von der Debian GNU/Linux Distribution übernommen. Versionen und Paketnamen
können für andere Distributionen abweichend sein. +
^(2)^ WeeChat kann auch mit libncurses5-dev kompiliert werden. Dies wird aber *NICHT* empfohlen (es
treten dabei Darstellungsfehler mit breiten Zeichen auf). +
^(3)^ Die empfohlene Version ist 2.7 (alle Skripten laufen mit der Version 2.7,
aber nicht mit Version ≤ 2.6 oder ≥ 3.0).

[[compile_with_cmake]]
==== Kompilieren mit cmake

* Installation in das Systemverzeichnis (benötigt 'root' Privilegien):

----
$ mkdir build
$ cd build
$ cmake ..
$ make
% make install    (als root)
----

* Installation in ein benutzerdefiniertes Verzeichnis:

----
$ mkdir build
$ cd build
$ cmake .. -DPREFIX=/Pfad/zum/Verzeichnis
$ make
$ make install
----

Optionen für cmake können mit dem Format, "-DOPTION=VALUE", genutzt werden.

Liste von häufig verwendeten Optionen:

[width="100%",cols="2m,2,5m,12",options="header"]
|===
| Option | Wert | Standardwert | Beschreibung

| CMAKE_BUILD_TYPE | `Debug`, `Release`, `RelWithDebInfo`, `MinSizeRel` | |
  Art des builds: `Debug` (oder `RelWithDebInfo`) sollte verwendet werden, wenn meine eine Entwicklerversion
  von WeeChat nutzt.

| PREFIX | Verzeichnis | /usr/local |
  Verzeichnis in welchem WeeChat installiert wird.

| WEECHAT_HOME | Verzeichnis | ~/.weechat |
  Standard-Verzeichnis in welchem die Daten liegen.

| CA_FILE | Datei | /etc/ssl/certs/ca-certificates.crt |
  Datei enthält die Zertifizierungen.
  This is the default value of option
  <<option_weechat.network.gnutls_ca_file,weechat.network.gnutls_ca_file>>.

| ENABLE_ALIAS | `ON`, `OFF` | ON |
  kompiliert <<alias_plugin,Alias Erweiterung>>.

| ENABLE_ASPELL | `ON`, `OFF` | ON |
  kompiliert <<aspell_plugin,Aspell Erweiterung>>.

| ENABLE_CHARSET | `ON`, `OFF` | ON |
  kompiliert <<charset_plugin,Charset Erweiterung>>.

| ENABLE_MAN | `ON`, `OFF` | OFF |
  kompiliert man page.

| ENABLE_DOC | `ON`, `OFF` | OFF |
  kompiliert Dokumentation (dies ist sehr zeitintensiv und wird nur empfohlen falls
  Binärpakete erstellt werden, die die Dokumentation beinhalten sollen, oder man die
  Dokumentation nicht auf der Homepage abrufen kann).

| ENABLE_ENCHANT | `ON`, `OFF` | OFF |
  kompiliert <<aspell_plugin,Aspell plugin>> mittels Enchant.

| ENABLE_EXEC | `ON`, `OFF` | ON |
  kompiliert <<exec_plugin,Exec Erweiterung>>.

| ENABLE_FIFO | `ON`, `OFF` | ON |
  kompiliert <<fifo_plugin,Fifo Erweiterung>>.

| ENABLE_GNUTLS | `ON`, `OFF` | ON |
  kompiliert Gnutls (für SSL).

| ENABLE_GUILE | `ON`, `OFF` | ON |
  kompiliert <<scripts_plugins,Guile Erweiterung>> (Scheme).

| ENABLE_IRC | `ON`, `OFF` | ON |
  kompiliert <<irc_plugin,IRC Erweiterung>>.

| ENABLE_LARGEFILE | `ON`, `OFF` | ON |
  Unterstützung großer Dateien.

| ENABLE_LOGGER | `ON`, `OFF` | ON |
  kompiliert <<logger_plugin,Logger Erweiterung>>.

| ENABLE_LUA | `ON`, `OFF` | ON |
  kompiliert <<scripts_plugins,Lua Erweiterung>>.

| ENABLE_NCURSES | `ON`, `OFF` | ON |
  kompiliert Ncurses Oberfläche.

| ENABLE_NLS | `ON`, `OFF` | ON |
  aktiviert NLS (Übersetzungen).

| ENABLE_PERL | `ON`, `OFF` | ON |
  kompiliert <<scripts_plugins,Perl Erweiterung>>.

| ENABLE_PYTHON | `ON`, `OFF` | ON |
  kompiliert <<scripts_plugins,Python Erweiterung>>.

| ENABLE_PYTHON3 | `ON`, `OFF` | OFF |
  kompiliert <<scripts_plugins,Python Erweiterung>> mittels Python 3 (dies wird *NICHT* empfohlen,
  da viele Skripten nicht kompatible mit Python 3 sind).

| ENABLE_RELAY | `ON`, `OFF` | ON |
  kompiliert <<relay_plugin,Relay Erweiterung>>.

| ENABLE_RUBY | `ON`, `OFF` | ON |
  kompiliert <<scripts_plugins,Ruby Erweiterung>>.

| ENABLE_SCRIPT | `ON`, `OFF` | ON |
  kompiliert <<scripts_plugins,Script Erweiterung>>.

| ENABLE_SCRIPTS | `ON`, `OFF` | ON |
  kompiliert <<scripts_plugins,Skripten-Erweiterungen>> (Python, Perl, Ruby, Lua, Tcl,
  Guile).

| ENABLE_TCL | `ON`, `OFF` | ON |
  kompiliert <<scripts_plugins,Tcl Erweiterung>>.

| ENABLE_TRIGGER | `ON`, `OFF` | ON |
  kompiliert <<trigger_plugin,Trigger Erweiterung>>.

| ENABLE_XFER | `ON`, `OFF` | ON |
  kompiliert <<xfer_plugin,Xfer Erweiterung>>.

| ENABLE_TESTS | `ON`, `OFF` | OFF |
  kompiliert Testumgebung.
|===

Weitere Optionen können mit folgendem Befehl angezeigt werden:

----
$ cmake -LA
----

oder mittels der Curses-Oberfläche:

----
$ ccmake ..
----

[[compile_with_autotools]]
==== Kompilieren mit autotools

[WARNING]
Ausschließlich das Kompilieren mittels cmake wird offiziell unterstützt. Autotools
sollte nur verwendet werden, falls man keine Möglichkeit hat, cmake zu nutzen. +
Das Erstellen mittels autotools benötigt zusätzliche Pakete und es ist langsamer
als cmake.

* Installation in das Systemverzeichnis (benötigt 'root' Privilegien):

----
$ ./autogen.sh
$ mkdir build
$ cd build
$ ../configure
$ make
% make install    (als root)
----

* Installation in ein benutzerdefiniertes Verzeichnis:

----
$ ./autogen.sh
$ mkdir build
$ cd build
$ ../configure --prefix=/Pfad/zum/Verzeichnis
$ make
$ make install
----

Die Optionen können auch für das 'configure' Skript verwendet und mittels
folgendem Befehl angezeigt werden:

----
$ ./configure --help
----

[[git_sources]]
=== Git Quellen

Warnung: Git Quellen sollten nur von erfahrenen Nutzern verwendet werden. Eventuell lassen
sich die Quellen nicht kompilieren oder der Code ist nicht stabil. Sie sind gewarnt!

Um die Git Quellen zu beziehen nutzen Sie folgende Befehle:

----
$ git clone https://github.com/weechat/weechat.git
----

Folgen Sie bitte der Anleitung zur Erstellung aus Quellpaketen (siehe <<source_package,Quellpakete>>).

[[report_crashes]]
=== Abstürze melden

Falls es zu einem Absturz von WeeChat gekommen ist und Sie diesen Fehler melden möchten:

* kompilieren Sie WeeChat mit Debug-Information (oder installieren Sie das Binärpaket mit Debug-Information)
* aktivieren Sie 'core' Dateien auf Ihrem System
* installieren Sie gdb

[[debug_info]]
==== Debug info

Bei der Kompilierung mit cmake muss folgende Option gesetzt werden:

----
$ cmake .. -DCMAKE_BUILD_TYPE=Debug
----

Bei der Kompilierung mit autotools, ist debug standardmäßig aktiviert (`--with-debug=1`).

Wird ein Binärpaket genutzt dann muss zusätzlich das Paket 'weechat-dbg' installiert werden.

[[core_files]]
==== Core Dateien

Um 'core' Dateien zu aktivieren kann folgende Option genutzt werden:
<<option_weechat.startup.sys_rlimit,weechat.startup.sys_rlimit>>:

----
/set weechat.startup.sys_rlimit "core:-1"
----

Wird eine WeeChat Version ≤ 0.3.8 verwendet oder man möchte die 'core' Dateien
aktivieren, bevor WeeChat gestaret wird, wird der Befehl `ulimit` benötigt.

Zum Beispiel muss unter Linux in einer 'bash' Shell folgender Befehl in die `~/.bashrc`
Datei eingetragen werden:

----
ulimit -c unlimited
----

optional kann noch die maximale Dateigröße bestimmt werden:

----
ulimit -c 200000
----

[[gdb_backtrace]]
==== Rückverfolgung mit gdb

Falls WeeChat abstürzen sollte wird auf Ihrem System eine 'core' bzw. 'core.12345' Datei
('12345' ist die Prozess-Id) erzeugt.
Diese Datei wird in dem Verzeichnis erzeugt aus welchem Sie WeeChat gestartet haben (dies
ist *nicht* das Verzeichnis in welchem sich WeeChat befindet!).

Beispiel: 'weechat' ist installiert in '/usr/bin/' und die 'core' Datei befindet sich
in '/home/xxx/'. Nun wird gdb mit folgendem Befehl aufgerufen:

----
gdb /usr/bin/weechat /home/xxx/core
----

[NOTE]
Ist das Binärpaket 'weechat-dbg' (z.B. Debian) installiert dann sollte dieser Pfad zum
starten von WeeChat genutzt werden: '/usr/lib/debug/usr/bin/weechat'

Nun startet man 'gdb' und führt den Befehl `bt full` innerhalb gdb aus um die Fehlermeldung
auszugeben. Eine Fehlermeldung von gdb sieht z.B. wie folgt aus:

----
(gdb) set logging file /tmp/crash.txt
(gdb) set logging on
Copying output to /tmp/crash.txt.
(gdb) bt full
#0  0x00007f9dfb04a465 in raise () from /lib/libc.so.6
#1  0x00007f9dfb04b8e6 in abort () from /lib/libc.so.6
#2  0x0000000000437f66 in weechat_shutdown (return_code=1, crash=1)
    at /some_path/src/core/weechat.c:351
#3  <signal handler called>
#4  0x000000000044cb24 in hook_process_timer_cb (arg_hook_process=0x254eb90,
    remaining_calls=<value optimized out>) at /some_path/src/core/wee-hook.c:1364
        hook_process = 0x254eb90
        status = <value optimized out>
#5  0x000000000044cc7d in hook_timer_exec ()
    at /some_path/src/core/wee-hook.c:1025
        tv_time = {tv_sec = 1272693881, tv_usec = 212665}
        ptr_hook = 0x2811f40
        next_hook = 0x0
#6  0x000000000041b5b0 in gui_main_loop ()
    at /some_path/src/gui/curses/gui-curses-main.c:319
        hook_fd_keyboard = 0x173b600
        tv_timeout = {tv_sec = 0, tv_usec = 0}
        read_fds = {fds_bits = {0 <repeats 16 times>}}
        write_fds = {fds_bits = {0 <repeats 16 times>}}
        except_fds = {fds_bits = {0 <repeats 16 times>}}
        max_fd = <value optimized out>
----

Diese Fehlermeldung senden Sie bitte an den Entwickler und beschreiben was den Fehler ausgelöst hat.

Danke für Ihre Mithilfe!

[[debug_running_weechat]]
==== Eine laufende Session von WeeChat debuggen

Um eine laufende Session von WeeChat zu debuggen (zum Beispiel wenn WeeChat nicht
mehr reagieren sollte) sollte man gdb mit der Prozess-ID starten ('12345' muss durch
die PID des laufenden weechat Prozesses ersetzt werden):

----
gdb /usr/bin/weechat 12345
----

Sollte WeeChat abgestürzt sein, muss der Befehl `bt full` genutzt werden:

----
(gdb) bt full
----

[[usage]]
== Nutzung

[[running_weechat]]
=== WeeChat starten

Befehlszeile:

include::cmdline_options.de.asciidoc[]

Um WeeChat zu starten muss folgender Befehl ausgeführt werden:

----
$ weechat
----

Wird WeeChat zum ersten mal gestartet wird eine Konfigurationsdatei
mit Standardparametern erstellt. Die Konfigurationsdatei heißt:
'~/.weechat/weechat.conf'.

Die Einstellungen für WeeChat können an die eigenen Bedürfnisse angepasst werden. Dazu sollten
Veränderungen an der Konfigurationsdatei mit dem internen Befehl `/set` durchführt werden. (siehe
<<weechat_commands,WeeChat Befehle>>).

[[screen_layout]]
=== Screen layout

Beispiel des WeeChat-Terminals:

....
 ▼ Bar "title"
┌───────────────────────────────────────────────────────────────────────────┐
│Welcome to #test, this is a test channel                                   │
│12:52:27   --> | Flashy (flashcode@weechat.org) has joined #test   │@Flashy│
│12:52:27    -- | Nicks #test: [@Flashy @joe +weebot peter]         │@joe   │
│12:52:27    -- | Channel #test: 4 nicks (2 ops, 1 voice, 1 normal) │+weebot│
│12:52:27    -- | Channel created on Tue Jan 27 06:30:17 2009       │peter  │
│12:54:15 peter | hey!                                              │       │
│12:55:01  @joe | hello                                             │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│[12:55] [6] [irc/freenode] 3:#test(+n){4}* [H: 4:#abc(2,5), 6]             │
│[@Flashy(i)] hi peter!█                                                    │
└───────────────────────────────────────────────────────────────────────────┘
 ▲ Bars "status" und "input"                               Bar "nicklist" ▲
....

Der Bildschirm setzt sich aus folgenden Bereichen zusammen:

* Chat-Bereich (in der Mitte des Bildschirms). Dieser enthält den Text und zusätzlich für jede Zeile:
** die Uhrzeit
** Prefix (links von dem "|")
** Nachricht (rechts von dem "|")
* Die Bars können um den Chat-Bereich angeordnet werden. Standard-Bars sind:
** 'title' Bar, über dem Chat-Bereich
** 'status' Bar, unter dem Chat-Bereich
** 'input' Bar, unter der Status-Bar
** 'nicklist' Bar, auf der rechten Seite

Die 'status'-Bar besitzt als Standardeinträge:

[width="100%",cols="^3,^4,10",options="header"]
|===
| Item                  | Beispiel              | Beschreibung
| time                  | `[12:55]`             | Uhrzeit
| buffer_last_number    | `[6]`                 | Nummer des letzten Buffers
| buffer_plugin         | `[irc/freenode]`      | Erweiterung des aktuellen Buffers (IRC Erweiterung setzt den IRC Servername für den Buffer)
| buffer_number         | `3`                   | Aktuelle Nummer des Buffers
| buffer_name           | `#test`               | Name des aktuellen Buffers
| buffer_modes          | `+n`                  | IRC Channel-Modi
| buffer_nicklist_count | `{4}`                 | Anzahl der Nicks in Benutzerliste
| buffer_zoom           | !                     | `!` bedeutet, dass ein zusammengefügter Buffer gezoomed (nur dieser Buffer wird angezeigt) wird.
| buffer_filter         | `*`                   | Filteranzeige: `*` bedeutet das Zeilen gefiltert (unterdrückt) wurden. Ein leerer Eintrag zeigt an dass alle Zeilen dargestellt werden
| scroll                | `-MORE(50)-`          | Scroll Indikator, zeigt an wie viele Zeilen unterhalb der zur Zeit dargestellten Zeile vorhanden sind
| lag                   | `[Lag: 2.5]`          | Verzögerungsanzeige, in Sekunden (keine Anzeige falls Verzögerung gering)
| hotlist               | `[H: 4:#abc(2,5), 6]` | Liste der Buffer mit Aktivität (ungelesene Nachrichten) (für das Beispiel: 2 Highlights und 5 ungelesene Nachrichten im Channel '#abc', eine ungelesene Nachricht in Buffer #6)
| completion            | `abc(2) def(5)`       | Liste von Wörtern für Vervollständigung, die Zahl zeigt an wie viele Varianten möglich sind
|===

In der 'input' Bar lautet die Standardeinstellung:

[width="100%",cols="^3,^4,10",options="header"]
|===
| Item         | Beispiel                                      | Beschreibung
| input_prompt | `[@Flashy(i)]`                                | Input prompt, für irc: Nick und Modi (Modus "+i" bedeutet auf freenode, unsichtbar)
| away         | `(away)`                                      | Abwesenheitsanzeige
| input_search | `[Search (~ str,msg)]`                        | Suchindikatoren ("`~`": Groß-und Kleinschreibung ignorieren, "`==`": Groß-und Kleinschreibung berücksichtigen, "`str`": einfache Textsuche, "`regex`": suche mit regulären Ausdrücken, "`msg`": Suche in Nachrichten, "`pre`": Suche in Präfix, "`pre\|msg`": Suche in Präfix und Nachrichten)
| input_paste  | `[Paste 7 lines ? [ctrl-Y] Ja [ctrl-N] Nein]` | Nachfrage ob sieben Zeilen eingefügt werden sollen
| input_text   | `hi peter!`                                   | Text der eingegeben wird
|===

andere Items die man nutzen kann (die aber nicht standardmäßig in einer Bar aktiviert sind):

[width="100%",cols="^3,^4,10",options="header"]
|===
| Item              | Beispiel            | Beschreibung
| aspell_dict       | `de,en`             | zeigt an welche Wörterbücher für die Rechtschreibung im aktuellen Buffer genutzt werden
| aspell_suggest    | `Glück,Glocke,Block`| Vorschläge für ein falsch geschriebenes Wort
| buffer_count      | `10`                | absolute Anzahl an geöffneten Buffern
| buffer_short_name | `#test`             | Kurzname des aktuellen Buffers
| irc_channel       | `#test`             | aktueller IRC Channelname
| irc_nick_modes    | `@`                 | IRC Modi für den eigenen Nick
| mouse_status      | `M`                 | Status der Maus (keine Anzeige, falls Maus deaktiviert)
| window_number     | `2`                 | Nummer des aktuellen Fensters
|===

[[buffers_and_windows]]
=== Buffer und Fenster

Ein 'Buffer' besteht aus einer Nummer, besitzt einem Namen, hat Zeilen die angezeigt
werden (und noch anderen Daten).

Beispiele von Buffern:

* Core Buffer (wird durch WeeChat beim Starten erstellt und kann nicht geschlossen werden!)
* IRC Server  (hier werden die Nachrichten ausgegeben, die der Server verschickt)
* IRC Channel
* IRC Privat  (wird auch Query-Buffer genannt)

Ein 'Fenster' ist ein Bildschirmbereich der Buffer darstellt. Es ist möglich
den Bildschirm in mehrere Fenster aufzuteilen.

Jedes Fenster stellt einen Buffer dar. Ein Buffer kann unsichtbar sein (er wird
in einem Fenster nicht angezeigt). Oder ein Buffer wird durch ein oder mehrere Fenster
angezeigt.

Beispiele für eine horizontal Fensteraufteilung (`/window splith`):

....
                          ▼ Fenster #2 (Buffer #4)
┌───────────────────────────────────────────────────────────────────────────┐
│Welcome to #abc                                                            │
│12:55:12     Max | hi                                              │@Flashy│
│12:55:20 @Flashy | hi Max!                                         │Max    │
│12:55:32     Max | how are you?                                    │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│[12:55] [6] [irc/freenode] 4:#abc(+n){2}                                   │
│[@Flashy]                                                                  │
│───────────────────────────────────────────────────────────────────────────│
│Welcome to #test                                                           │
│12:54:15 peter | hey!                                              │@Flashy│
│12:55:01  @joe | hello                                             │@joe   │
│                                                                   │+weebot│
│                                                                   │peter  │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│[12:55] [6] [irc/freenode] 3:#test(+n){4}                                  │
│[@Flashy] hi peter!█                                                       │
└───────────────────────────────────────────────────────────────────────────┘
                          ▲ Fenster #1 (Buffer #3)
....

Beispiele für eine vertikale Fensteraufteilung (`/window splitv`):

....
┌───────────────────────────────────────────────────────────────────────────┐
│Welcome to #test                     │Welcome to #abc                      │
│12:54:15 peter | hey!        │@Flashy│12:55:12     Max | hi        │@Flashy│
│12:55:01  @joe | hello       │@joe   │12:55:20 @Flashy | hi Max!   │Max    │
│                             │+weebot│                             │       │
│                             │peter  │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│[12:55] [irc/oftc] 3:#test(+n){4}    │[12:55] [irc/oftc] 4:#abc(+n){2}     │
│[@Flashy] hi peter!█                 │[@Flashy]                            │
└───────────────────────────────────────────────────────────────────────────┘
      ▲ Fenster #1 (Buffer #3)              ▲ Fenster #2 (Buffer #4)
....

Beispiele für eine vertikale und horizontale Fensteraufteilung:

....
                                            ▼ Fenster #3 (Buffer #5)
┌───────────────────────────────────────────────────────────────────────────┐
│Welcome to #test                     │Welcome to #def                      │
│12:54:15 peter | hey!        │@Flashy│12:55:42 @Flashy | hi        │@Flashy│
│12:55:01  @joe | hello       │@joe   │12:55:56    alex | hi Flashy │alex   │
│                             │+weebot│                             │       │
│                             │peter  │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │[12:55] [irc/oftc] 5:#def(+n){2}     │
│                             │       │[@Flashy]                            │
│                             │       │─────────────────────────────────────│
│                             │       │Welcome to #abc                      │
│                             │       │12:55:12     Max | hi        │@Flashy│
│                             │       │12:55:20 @Flashy | hi Max!   │Max    │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│                             │       │                             │       │
│[12:55] [irc/oftc] 3:#test(+n){4}    │[12:55] [irc/oftc] 4:#abc(+n){2}     │
│[@Flashy] hi peter!█                 │[@Flashy]                            │
└───────────────────────────────────────────────────────────────────────────┘
      ▲ Fenster #1 (Buffer #3)              ▲ Fenster #2 (Buffer #4)
....

[[bars]]
=== Bars

Eine 'Bar' ist ein Bereich, der neben dem Chatfenster, jedwede Art von Text enthalten kann.

Eine Bar kann mittels `weechat.bar.name.option` konfiguriert werden. Dabei steht `name`,
für den Namen der Bar und `option` für die Option für diese Bar.

Aufzählung von Bar-Optionen:

[width="100%",cols="2m,2,10",options="header"]
|===
| Option | Wert   | Beschreibung

| type | `root`, `window` |
  Eine Bar, vom Typ `root`, kann nur einmal, außerhalb von Fenstern, auf dem Bildschirm
  dargestellt werden. Standardmäßig existiert keine `root` Bar. Eine solche Bar, mit Namen
  'buffers', wird zum Beispiel durch das Skript 'buffers.pl' eingerichtet in welcher alle
  geöffneten Buffer aufgeführt werden. +
  Eine Bar, vom Typ `window`, wird in jedem einzelnen Fenster dargestellt, beispielsweise
  wenn man das Fenster teilt (mit `/window splith` oder `/window splitv`). Die vier
  standardmäßigen Bars ('title', 'status', 'input', 'nicklist'), sind vom Typ `window`.

| position | `top`, `bottom`, `left`, `right` |
  Position der Bar: ober- oder unterhalb des Chatfensters, oder links/rechts davon.

| priority | integer ≥ 0 |
  Priorität für die Bar: legt die Reihenfolge fest in der die Bars angeordnet werden sollen,
  wenn mehrere Bars den selben Typ und Position besitzen. +
  Die Bars werden vom Rand zur Mitte des Bildschirms gezeichnet. Eine höhere Priorität
  bewirkt, dass die Bar näher am Rand gezeichnet wird. +
  Beispiel: Die 'input' Bar hat eine Priorität von 1000 und wird somit vor der 'status' Bars
  gezeichnet, da diese lediglich eine Priorität von 500 besitzt.

| size | integer ≥ 0 |
  Die Größe der Bar: Anzahl der Spalten, falls die Bar links/rechts bzw. Anzahl an Zeilen falls
  die Bar oben/unten dargestellt wird. Wird eine Größe `0` gewählt, dann wird die Größe der Bar
  automatisch bestimmt.

| size_max | integer ≥ 0 |
  Die maximale Größe der Bar, `0` = keine Limitierung (diese Option wird nur genutzt, falls die
  Option `size` = `0` ist).

| color_bg | color |
  Hintergrundfarbe, für die Bar.

| color_fg | color |
  Textfarbe, für die Bar.

| color_delim | color |
  Farbe der Trennzeichen, in der Bar.

| hidden | `on`, `off` |
  Ist diese Option `on`, wird die Bar versteckt. +
  Hinweis: anstelle dieser Option sollte vorzugsweise der `/bar` Befehl genutzt werden.
  Beispiel: `/bar toggle nicklist` (siehe Befehl <<command_weechat_bar,/bar>>).

| separator | `on`, `off` |
  Ist diese Option `on`, wird ein Separator (Linie) gezeichnet die eine Bar von anderen
  Bars oder dem Chatbereich trennt.

| items | string |
  Eine Aufzählung von 'items' (siehe <<bar_items,items>> für weitere Informationen).

| filling_left_right | `horizontal`, `vertical`, `columns_horizontal`, `columns_vertical` |
  Art, wie der Inhalt der Bar die `links` oder `rechts` gezeichnet wird, dargestellt wird (siehe
  <<bar_filling,filling>> für weitere Informationen).

| filling_top_bottom | `horizontal`, `vertical`, `columns_horizontal`, `columns_vertical` |
  Art, wie der Inhalt der Bar die `oben` oder `unten` gezeichnet wird, dargestellt wird (siehe
  <<bar_filling,filling>> für weitere Informationen).

| conditions | string |
  Bedingungen, wann die Bar angezeigt wird (siehe <<bar_conditions,conditions>> für weitere
  Informationen).
|===

[[bar_items]]
==== Items

Die Option 'items' ist ein String, mit einer Anzahl von Bar-Items. Diese werden
durch Komma voneinander getrennt (auf dem Bildschirm wird das Komma durch ein
Leerzeichen ersetzt). Möchte man die Items ohne Leerzeichen darstellen, nutzt
man ein "+", zwischen den Items.

Eine Liste von Bar-Items kann man sich mit dem Befehl `/bar listitems` anzeigen lassen.

Vor oder nach dem Item können Zeichen eingefügt werden. Diese dürfen nicht alphanumerisch,
"-" oder "_" sein. Die Zeichen werden mit der entsprechenden Farbe, für Trennzeichen,
dargestellt (Option 'color_delim').

Beispiel einer Bar mit den Items, "[time],buffer_number+:+buffer_plugin+.+buffer_name":

....
┌───────────────────────────────────────────────────────────────────────────┐
│[12:55] 3:irc/freenode.#weechat                                            │
└───────────────────────────────────────────────────────────────────────────┘
....

Eine Besonderheit stellt die Möglichkeit dar, ein Item eines bestimmten Buffers
anzuzeigen. Syntax: "@buffer:item" ("buffer" ist der vollständige Name des Buffers
und "item" der Name der Bar-Item)

Dies ist für root-Bars sinnvoll, um gezielt ein Item eines bestimmten Buffers
anzuzeigen, welcher nicht im aktuellen Fenster oder überhaupt nicht sichtbar
ist.

Beispiel: Benutzerliste von bitlbee permanent in einer root-Bar darstellen (die Bar
heißt hierbei 'bitlist' und der Name des bitlbee Servers 'bitlbee'):

----
/set weechat.bar.bitlist.items "@irc.bitlbee.&bitlbee:buffer_nicklist"
----

[[bar_filling]]
==== Darstellung innerhalb einer Bar

Es gibt folgende vier Möglichkeiten um Text innerhalb einer Bar darzustellen:

* `horizontal`: die Items werden horizontal, von links nach rechts, dargestellt.
   Sollten neue Zeilen dargestellt werden, dann werden diese durch ein Leerzeichen
   von der vorherigen getrennt.
* `vertical`: die Items werden von oben nach unten dargestellt. Neue Zeilen werden
  neben der vorherigen dargestellt.
* `columns_horizontal`: Item werden in Spalten dargestellt, wobei der Text linksbündig
  ausgerichtet ist. Das erste Item wird in der linken oberen Ecke angezeigt und das
  zweite Item ist in der selben Zeile, auf der rechten Seite.
* `columns_vertical`: Item werden in Spalten dargestellt, wobei der Text linksbündig
  ausgerichtet ist. Das erste Item wird in der linken oben Ecke angezeigt und das
  zweite Item wird eine Zeile darunter angezeigt.

Die Standard-Bars 'title', 'status' und 'input' nutzen eine 'horizontal'
Darstellung und die Standard-Bar 'nicklist' nutzt eine 'vertical' Darstellung.

Einige Beispiele, wie die Bar 'nicklist' dargestellt werden kann:

....
┌──────────────────────────────────────────────────┐
│Welcome to #test, this is a test channel          │
│12:54:15 peter | hey!                    │@carl   │
│12:55:01  +Max | hello                   │@jessika│
│                                         │@maddy  │
│                                         │%Diego  │
│                                         │%Melody │
│                                         │+Max    │
│                                         │ celia  │
│                                         │ Eva    │
│                                         │ freddy │
│                                         │ Harold^│
│                                         │ henry4 │
│                                         │ jimmy17│
│                                         │ jodie ▼│
│[12:55] [6] [irc/freenode] 3:#test(+n){24}        │
│[@carl] █                                         │
└──────────────────────────────────────────────────┘
                filling_left_right = vertical ▲

┌──────────────────────────────────────────────────┐
│Welcome to #test, this is a test channel          │
│12:54:15 peter | hey!           │@carl     lee    │
│12:55:01  +Max | hello          │@jessika  louise │
│                                │@maddy    mario  │
│                                │%Diego    mark   │
│                                │%Melody   peter  │
│                                │+Max      Rachel │
│                                │ celia    richard│
│                                │ Eva      sheryl │
│                                │ freddy   Vince  │
│                                │ Harold^  warren │
│                                │ henry4   zack   │
│                                │ jimmy17         │
│                                │ jodie           │
│[12:55] [6] [irc/freenode] 3:#test(+n){24}        │
│[@carl] █                                         │
└──────────────────────────────────────────────────┘
        filling_left_right = columns_vertical ▲

┌───────────────────────────────────────────────────────────────────────┐
│@carl    %Diego    celia    Harold^  jodie    mario    Rachel   Vince  │
│@jessika %Melody   Eva      henry4   lee      mark     richard  warren │
│@maddy   +Max      freddy   jimmy17  louise   peter    sheryl   zack   │
│───────────────────────────────────────────────────────────────────────│
│                                                                       │
        filling_top_bottom = columns_vertical ▲

┌───────────────────────────────────────────────────────────────────────┐
│@carl    @jessika @maddy   %Diego   %Melody  +Max      celia    Eva    │
│ freddy   Harold^  henry4   jimmy17  jodie    lee      louise   mario  │
│ mark     peter    Rachel   richard  sheryl   Vince    warren   zack   │
│───────────────────────────────────────────────────────────────────────│
│                                                                       │
      filling_top_bottom = columns_horizontal ▲
....

[[bar_conditions]]
==== Bedingungen

Die Option 'conditions' ist eine Zeichenkette die direkten Einfluss darauf
nimmt, ob die Bar in einem Fenster dargestellt wird oder nicht (diese Option
kann nur für Bars vom Typ 'window' genutzt werden).

Folgende Zeichenketten sind möglich:

* 'active'  : das Fenster muss das aktive Fenster sein
* 'inactive': das Fenster muss das inaktive Fenster sein
* 'nicklist': der Buffer der in einem Fenster dargestellt wird, muss eine
              Benutzerliste anzeigen.
* ein Ausdruck: wird als boolescher Wert ausgewertet (siehe Befehl
  <<command_weechat_eval,/eval>>)

Für den Ausdruck sind folgende Variablen verfügbar:

* `${active}`  : wahr, wenn Fenster aktiv ist
* `${inactive}`: wahr, wenn Fenster inaktiv ist
* `${nicklist}`: wahr, wenn der Buffer im Fenster eine Nicklist anzeigt.

Folgende Zeiger sind verfügbar:

* `${window}`: das Fenster in dem der Zustand ausgewertet wird
* `${buffer}`: der Buffer eines Fensters in dem der Zustand ausgewertet wird

Beispiel wie man die Bar-Nicklist in allen Buffer, die eine Nicklist besitzen,
darstellt, aber nur wenn das Fenster eine Mindestbreite von > 100 Pixeln aufweist:

----
/set weechat.bar.nicklist.conditions "${nicklist} && ${window.win_width} > 100"
----

Gleiche Bedingungen, aber die Benutzerliste wird im Buffer '&bitlbee' immer angezeigt
(auch wenn das Fenster kleiner als 100 Pixel ist):

----
/set weechat.bar.nicklist.conditions "${nicklist} && (${window.win_width} > 100 || ${buffer.full_name} == irc.bitlbee.&bitlbee)"
----

[[bare_display]]
=== einfacher Anzeigemodus

Ein vereinfachter Anzeigemodus, mit Namen "bare", kann aktiviert werden um
überlange URLs ganz einfach mit der Maus anzuklicken oder um Text, mit der
Maus, zu markieren.

Der vereinfachte Anzeigemodus hat folgende Funktionen:

* es wird lediglich der Inhalt des aktuellen Buffers angezeigt, es findet keine
  Aufteilung des Fensters statt, es werden keine Bars angezeigt (Title, Nicklist,
  Status, Input, ...)
* die Mausunterstützung ist deaktiviert (sofern sie aktiviert war): die Maus kann
  wie in einem Terminal genutzt werden um URLs anzuklicken oder Text zu markieren
* ncurses wird nicht genutzt, deshalb werden URLs nicht am Ende der Zeile angeschnitten.

Der Standardtastenbefehl um den vereinfachten Textmodus zu aktivieren ist key[alt-l],
mit dem selben Tastenbefehl wird dieser Modus wieder beendet (es kann auch mit jeder
beliegen Tasteneingabe der Modus beendet werden, siehe Option
<<option_weechat.look.bare_display_exit_on_input,weechat.look.bare_display_exit_on_input>>).

Das Format für die Zeitanzeige kann mit folgender Option angepasst werden
<<option_weechat.look.bare_display_time_format,weechat.look.bare_display_time_format>>.

Der vereinfachte Anzeigemodus kann mit einer vorgegebenen Zeit gestartet werden
<<command_weechat_window,/window>>.

Im normalen Modus sieht WeeChat wie folgt aus:

....
┌───────────────────────────────────────────────────────────────────────────┐
│Welcome to #test, this is a test channel                                   │
│12:52:27   --> | Flashy (flashcode@weechat.org) has joined #test   │@Flashy│
│12:52:27    -- | Nicks #test: [@Flashy @joe +weebot peter]         │@joe   │
│12:52:27    -- | Channel #test: 4 nicks (2 ops, 1 voice, 1 normal) │+weebot│
│12:52:27    -- | Channel created on Tue Jan 27 06:30:17 2009       │peter  │
│12:54:15 peter | hey!                                              │       │
│12:55:01  @joe | peter: hook_process: http://weechat.org/files/doc │       │
│               | /devel/weechat_plugin_api.en.html#_weechat_hook_p │       │
│               | rocess                                            │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│                                                                   │       │
│[12:55] [6] [irc/freenode] 3:#test(+n){4}* [H: 4:#abc(2,5), 6]             │
│[@Flashy(i)] hi peter!█                                                    │
└───────────────────────────────────────────────────────────────────────────┘
....

Der selbe Bildschirm sieht im vereinfachten Anzeigemodus wie folgt aus:

....
┌───────────────────────────────────────────────────────────────────────────┐
│                                                                           │
│                                                                           │
│                                                                           │
│                                                                           │
│                                                                           │
│                                                                           │
│                                                                           │
│                                                                           │
│                                                                           │
│                                                                           │
│                                                                           │
│                                                                           │
│                                                                           │
│12:52 --> Flashy (flashcode@weechat.org) has joined #test                  │
│12:52 -- Nicks #test: [@Flashy @joe +weebot peter]                         │
│12:52 -- Channel #test: 4 nicks (2 ops, 1 voice, 1 normal)                 │
│12:52 -- Channel created on Tue Jan 27 06:30:17 2009                       │
│12:54 <peter> hey!                                                         │
│12:55 <@joe> peter: hook_process: http://weechat.org/files/doc/devel/weecha│
│t_plugin_api.en.html#_weechat_hook_process                                 │
└───────────────────────────────────────────────────────────────────────────┘
....

Es kann nun die URL von 'joe' ohne Probleme angeklickt werden (dies setzt
natürlich voraus, dass der Terminal das Anwählen von URLs unterstützt).

[[notify_levels]]
=== Benachrichtigungsstufen

Es gibt vier Benachrichtigungsstufen für Nachrichten, welche in Buffern dargestellt
werden. Nachfolgend eine Liste, sortiert von niedrig nach hoch:

*       'low': Nachricht mit einer geringen Wertigkeit (zum Beispiel: IRC join/part/quit)
*   'message': Nachricht von einem User
*   'private': Nachricht in einem privaten Buffer
* 'highlight': wenn es sich um eine 'highlight' Nachricht handelt

Jeder Buffer besitzt eine Benachrichtigungsstufe, um festzulegen, bei welchen Nachrichten
der entsprechende Buffer in der Hotlist angezeigt werden soll.

Der Wert für die Benachrichtigungsstufe kann mittels folgender Option festgelegt
werden:
<<option_weechat.look.buffer_notify_default,weechat.look.buffer_notify_default>>,
Der Standardwert ist 'all'.

[width="50%",cols="3m,10",options="header"]
|===
| Benachrichtigungsstufe | Welche Nachrichten Berücksichtigung in der Hotlist finden
| none                   | (keine)
| highlight              | 'highlight' + 'private Nachrichten'
| message                | 'highlight' + 'private Nachrichten' + 'normale Nachrichten'
| all                    | 'highlight' + 'private Nachrichten' + 'normal Nachrichten' + 'Nachrichten mit einer niedrigen Priorität'
|===

Benachrichtigungsstufen können für mehrere Buffer definiert werden. Zum Beispiel
für alle Buffer des IRC Servers "freenode":

----
/set weechat.notify.irc.freenode message
----

Setzt die Benachrichtigungsstufe ausschließlich für den Channel "#weechat",
auf die Stufe 'highlight':

----
/set weechat.notify.irc.freenode.#weechat highlight
----

Die Benachrichtigungsstufe für einen Buffer kann mittels dem `/buffer`
Befehl festgelegt werden:

----
/buffer notify highlight
----

[[key_bindings]]
=== Standard Tastenbelegung

[[key_bindings_command_line]]
==== Tastenbefehle für die Befehlszeile

[width="100%",cols="^.^3,.^10,.^5",options="header"]
|===
| Taste           | Beschreibung | Befehl
| key[←]       .2+| setzt den Cursor eine Position nach links .2+| `/input move_previous_char`
| key[ctrl-b]
| key[→]       .2+| setzt den Cursor eine Position nach rechts .2+| `/input move_next_char`
| key[ctrl-f]
| key[ctrl-←]  .2+| springt in der Befehlszeile zum Anfang des vorherigen Wortes .2+| `/input move_previous_word`
| key[alt-b]
| key[ctrl-→]  .2+| springt in der Befehlszeile zum Anfang des nächsten Wortes .2+| `/input move_next_word`
| key[alt-f]
| key[Home]    .2+| springt zum Anfang der Befehlszeile .2+| `/input move_beginning_of_line`
| key[ctrl-a]
| key[End]     .2+| springt ans Ende der Befehlszeile .2+| `/input move_end_of_line`
| key[ctrl-e]
| key[ctrl-c,b]   | fügt Steuerzeichen für fett geschrieben Text ein | `/input insert \x02`
| key[ctrl-c,c]   | fügt Steuerzeichen für Textfarbe ein | `/input insert \x03`
| key[ctrl-c,i]   | fügt Steuerzeichen für kursiven Text ein | `/input insert \x1D`
| key[ctrl-c,o]   | fügt Steuerzeichen für Standardfarbe ein | `/input insert \x0F`
| key[ctrl-c,v]   | fügt Steuerzeichen für Hintergrundfarbe ein | `/input insert \x16`
| key[ctrl-c,_]   | fügt Steuerzeichen für unterstrichenen Text ein | `/input insert \x1F`
| key[Del]     .2+| entfernt in der Befehlszeile das nächste Zeichen .2+| `/input delete_next_char`
| key[ctrl-d]
| key[Backsp.] .2+| entfernt in der Befehlszeile das vorherige Zeichen .2+| `/input delete_previous_char`
| key[ctrl-h]
| key[ctrl-k]     | entfernt alle Zeichen vom Cursor bis zum Ende der Zeile (Zeichenkette wird in Zwischenablage kopiert) | `/input delete_end_of_line`
| key[ctrl-r]     | Textsuche im Verlaufsspeicher des Buffers (siehe <<key_bindings_search_context,Tasten für Such-Kontext>>) | `/input search_text`
| key[ctrl-t]     | Zeichen austauschen | `/input transpose_chars`
| key[ctrl-u]     | entfernt alle Zeichen vom Cursor bis zum Anfang der Zeile (Zeichenkette wird in Zwischenablage kopiert) | `/input delete_beginning_of_line`
| key[ctrl-w]     | entfernt das Wort links vom Cursor (entferntes Wort wird in Zwischenablage kopiert) | `/input delete_previous_word`
| key[ctrl-y]     | fügt Zeichenkette aus Zwischenablage ein | `/input clipboard_paste`
| key[ctrl-_]     | Rückgängig machen der letzten Aktion, in der Befehlszeile | `/input undo`
| key[alt-_]      | Wiederherstellen der letzten Aktion, in der Befehlszeile | `/input redo`
| key[Tab]        | Vervollständigung von Befehlen oder Nicks (nochmaliges key[Tab]: findet nächste Vervollständigung) | `/input complete_next`
| key[shift-Tab]  | ohne Vervollständigung: führt eine teilweise Vervollständigung durch. Bei unerledigter Vervollständigung : wird die vorherige Vervollständigung genutzt | `/input complete_previous`
| key[Enter]   .3+| führt einen Befehl aus oder sendet den Text  (im Such-Modus: stoppt Suche) .3+| `/input return`
| key[ctrl-j]
| key[ctrl-m]
| key[↑]          | ruft vorherigen Befehl oder Nachricht aus dem Verlaufsspeicher auf (im Such-Modus: rückwärts suchen) | `/input history_previous`
| key[↓]          | ruft nächsten Befehl oder Nachricht aus dem Verlaufsspeicher auf (im Such-Modus: vorwärts suchen) | `/input history_next`
| key[ctrl-↑]     | ruft vorherigen Befehl/Nachricht aus dem globalen Verlaufsspeicher auf (für alle Buffer) | `/input history_global_previous`
| key[ctrl-↓]     | ruft nächsten Befehl/Nachricht aus dem globalen Verlaufsspeicher auf (für alle Buffer) | `/input history_global_next`
| key[alt-d]      | löscht das Wort rechts vom Cursor (Zeichenkette wird in Zwischenablage kopiert) | `/input delete_next_word`
| key[alt-k]      | zeigt den Tastencode, einschließlich des eingebundenen Befehls, einer Tastenkombination an und fügt diesen in die Befehlszeile ein | `/input grab_key_command`
| key[alt-r]      | komplette Eingabezeile löschen| `/input delete_line`
| key[alt-s]      | schaltet die Aspell Funktion an/aus | `/mute aspell toggle`
|===

[[key_bindings_buffers_windows]]
==== Tastenbefehle für Buffer / Fenster

[width="100%",cols="^.^3,.^10,.^5",options="header"]
|===
| Taste              | Beschreibung | Befehl
| key[ctrl-l]        | Fenster wird neu gezeichnet | `/window refresh`
| key[ctrl-s,ctrl-u] | setzt für alle Buffer die Markierung für ungelesene Nachrichten | `/input set_unread`
| key[ctrl-x]        | sind mehrere Buffer zu einem Buffer zusammen gefügt wechselt man diese durch | `/input switch_active_buffer`
| key[alt-x]         | Zoom eines zusammengefügten Buffers (key[alt-x] ein zweites mal: alle zusammengefügten Buffer werden angezeigt) | `/input zoom_merged_buffer`
| key[PgUp]          | eine Seite im Verlaufsspeicher des Buffers nach oben blättern | `/window page_up`
| key[PgDn]          | eine Seite im Verlaufsspeicher des Buffer nach unten blättern | `/window page_down`
| key[alt-PgUp]      | einige Zeilen im Verlaufsspeicher des Buffer nach oben blättern | `/window scroll_up`
| key[alt-PgDn]      | einige Zeilen im Verlaufsspeicher des Buffer nach unten blättern | `/window scroll_down`
| key[alt-Home]      | springt zur ersten Zeile des Verlaufsspeichers des aktuellen Buffers| `/window scroll_top`
| key[alt-End]       | springt zur letzten Zeile des Verlaufsspeichers des aktuellen Buffers | `/window scroll_bottom`
| key[alt-←]      .4+| zum vorherigen Buffer springen .4+| `/buffer -1`
| key[alt-↑]
| key[ctrl-p]
| key[F5]
| key[alt-→]      .4+| zum nächsten Buffer springen .4+| `/buffer +1`
| key[alt-↓]
| key[ctrl-n]
| key[F6]
| key[F7]            | zum vorherigen Fenster wechseln | `/window -1`
| key[F8]            | zum nächsten Fenster wechseln | `/window +1`
| key[F9]            | Titel des Buffers nach links verschieben | `/bar scroll title * -30%`
| key[F10]           | Titel des Buffers nach rechts verschieben | `/bar scroll title * +30%`
| key[F11]           | Benutzerliste um eine Seite nach oben blättern | `/bar scroll nicklist * -100%`
| key[F12]           | Benutzerliste um eine Seite nach unten blättern | `/bar scroll nicklist * +100%`
| key[alt-F11]       | springt zum Anfang der Benutzerliste | `/bar scroll nicklist * b`
| key[alt-F12]       | springt zum Ende der Benutzerliste | `/bar scroll nicklist * e`
| key[alt-a]         | wechselt zum nächsten Buffer mit Aktivität (nach Priorität: highlight, Nachricht, ...) | `/input jump_smart`
| key[alt-h]         | löscht Hotliste (Aktivitätsanzeige für die Buffer) | `/input hotlist_clear`
| key[alt-j,alt-f]   | wechselt zum ersten Buffer | `/buffer -`
| key[alt-j,alt-l]   | wechselt zum letzten Buffer | `/buffer +`
| key[alt-j,alt-r]   | wechselt zum IRC RAW Buffer | `/server raw`
| key[alt-j,alt-s]   | wechselt zum IRC Server Buffer | `/server jump`
| key[alt-0...9]     | wechselt zum Buffer mit der Nummer (0 = 10) | `/buffer *N`
| key[alt-j,01...99] | wechselt zum Buffer mit der angegeben Nummer | `/buffer NN`
| key[alt-l]         | schaltet einfachen Anzeigemodus an/aus | `/window bare`
| key[alt-m]         | schaltet Mausfunktion ein/aus | `/mouse toggle`
| key[alt-n]         | springt zur nächsten Highlight Nachricht | `/window scroll_next_highlight`
| key[alt-p]         | springt zur vorherigen Highlight Nachricht | `/window scroll_previous_highlight`
| key[alt-u]         | springt zur ersten ungelesenen Zeile im Buffer | `/window scroll_unread`
| key[alt-w,alt-↑]   | wechselt zum oberen Fenster | `/window up`
| key[alt-w,alt-↓]   | wechselt zum unteren Fenster | `/window down`
| key[alt-w,alt-←]   | wechselt zum linken Fenster | `/window left`
| key[alt-w,alt-→]   | wechselt zum rechten Fenster | `/window right`
| key[alt-w,alt-b]   | passt die Größe aller Fenster an | `/window balance`
| key[alt-w,alt-s]   | Wechselt Buffer von zwei Fenstern | `/window swap`
| key[alt-z]         | Zoom für aktuelles Fenster (nochmals key[alt-z]: stellt die vorherigen Einstellungen wieder her) | `/window zoom`
| key[alt-]key[<]    | springt zum letzten besuchten Buffer | `/input jump_previously_visited_buffer`
| key[alt-]key[>]    | springt zum nächsten besuchten Buffer | `/input jump_next_visited_buffer`
| key[alt-/]         | wechselt zum jeweils zuletzt angezeigten Buffern | `/input jump_last_buffer_displayed`
| key[alt-=]         | schaltet Filterfunktion an/aus | `/filter toggle`
| key[alt--]         | schaltet, für den aktuellen Buffer, Filterfunktion an/aus | `/filter toggle @`
|===

[[key_bindings_search_context]]
==== Tasten für "Suchen"-Kontext

Diese Tasten werden im Kontext "search" verwendet (wenn key[ctrl-r] genutzt wird um
in einem Buffer nach einem Text zu suchen).

[width="100%",cols="^.^3,.^10,.^5",options="header"]
|===
| Taste         | Beschreibung | Befehl
| key[ctrl-r]   | Wechsel des Suchmodus: einfache Textsuche (Standard), reguläre Ausdrücke | `/input search_switch_regex`
| key[alt-c]    | auf Groß-/Kleinschreibung umschalten | `/input search_switch_case`
| key[Tab]      | wechselt Suche in: Nachricht (Standard), im Präfix, Präfix + Nachricht | `/input search_switch_where`
| key[↑]        | sucht vorheriger Zeile | `/input search_previous`
| key[↓]        | sucht nächste Zeile  | `/input search_next`
| key[Enter] .3+| Suche abbrechen .3+| `/input search_stop`
| key[ctrl-j]
| key[ctrl-m]
|===

[[key_bindings_cursor_context]]
==== Tasten für "Cursor"-Kontext

Diese Tasten werden im Kontext "cursor" verwendet (Cursor kann frei auf dem Bildschirm bewegt werden)

[width="100%",cols="^.^3,^.^3,.^10,.^8",options="header"]
|===
| Taste         | Bereich   | Beschreibung | Befehl
| key[↑]        | -         | bewegt Cursor eine Zeile nach oben | `/cursor move up`
| key[↓]        | -         | bewegt Cursor eine Zeile nach unten | `/cursor move down`
| key[←]        | -         | bewegt Cursor eine Spalte nach links | `/cursor move left`
| key[→]        | -         | bewegt Cursor eine Spalte nach rechts | `/cursor move right`
| key[alt-↑]    | -         | bewegt Cursor einen Bereich nach oben | `/cursor move area_up`
| key[alt-↓]    | -         | bewegt Cursor einen Bereich nach unten | `/cursor move area_down`
| key[alt-←]    | -         | bewegt Cursor einen Bereich nach links | `/cursor move area_left`
| key[alt-→]    | -         | bewegt Cursor einen Bereich nach rechts | `/cursor move area_right`
| key[m]        | Chat      | quotet Nachricht | `hsignal:chat_quote_message;/cursor stop`
| key[q]        | Chat      | quotet prefix + Nachricht | `hsignal:chat_quote_prefix_message;/cursor stop`
| key[Q]        | Chat      | quotet Uhrzeit + prefix + Nachricht | `hsignal:chat_quote_time_prefix_message;/cursor stop`
| key[b]        | Benutzerliste | verbannt nick (Ban) | `/window ${_window_number};/ban ${nick}`
| key[k]        | Benutzerliste | kickt nick | `/window ${_window_number};/kick ${nick}`
| key[K]        | Benutzerliste | kickt und verbannt nick | `/window ${_window_number};/kickban ${nick}`
| key[q]        | Benutzerliste | öffnet privaten Chat mit Nick | `/window ${_window_number};/query ${nick};/cursor stop`
| key[w]        | Benutzerliste | führt einen whois für Nick aus | `/window ${_window_number};/whois ${nick}`
| key[Enter] .3+| -      .3+| beendet den Cursor-Modus .3+| `/cursor stop`
| key[ctrl-j]
| key[ctrl-m]
|===

[[key_bindings_mouse_context]]
==== Tasten für "mouse"-Kontext

Diese Tasten werden im Kontext "mouse" verwendet, wenn eine Mausfunktion genutzt worden ist.

[width="100%",cols="^.^3,^.^3,^.^3,.^10,.^8",options="header"]
|===
| Maustaste ^(1)^ | Mausgeste | Bereich | Beschreibung | Befehl
| ◾◽◽         | -            | Chat                 | wechselt zum Fenster | `/window ${_window_number}`
| ◾◽◽         | links        | Chat                 | zum vorherigen Buffer springen | `/window ${_window_number};/buffer +1`
| ◾◽◽         | rechts       | Chat                 | zum nächsten Buffer springen | `/window ${_window_number};/buffer +1`
| ◾◽◽         | links(lang)  | Chat                 | wechselt zum ersten Buffer | `/window ${_window_number};/buffer 1`
| ◾◽◽         | rechts(lang) | Chat                 | wechselt zum letzten Buffer | `/window ${_window_number};/input jump_last_buffer`
| ◾◽◽         | -            | chat (script buffer) | wählt einen Eintrag im Script-Buffer aus | `/script go ${_chat_line_y}`
| ◽◽◾         | -            | chat (script buffer) | installiert/entfernt ein Skript | `/script go ${_chat_line_y};/script installremove -q ${script_name_with_extension}`
| ⇑           | -            | Chat                 | mehrere Zeilen im Verlaufsspeicher des Buffer nach oben blättern | `/window scroll_up -window ${_window_number}`
| ⇓           | -            | Chat                 | mehrere Zeilen im Verlaufsspeicher des Buffer nach unten blättern | `/window scroll_down -window ${_window_number}`
| ⇑           | -            | chat (script buffer) | fünf Zeilen nach oben blättern, im Script-Buffer | `/script up 5`
| ⇓           | -            | chat (script buffer) | fünf Zeilen nach unten blättern, im Script-Buffer | `/script down 5`
| key[ctrl-]⇑ | -            | chat                 | horizontal, nach links scrollen | `/window scroll_horiz -window ${_window_number} -10%`
| key[ctrl-]⇓ | -            | chat                 | horizontal, nach rechts scrollen | `/window scroll_horiz -window ${_window_number} +10%`
| ◾◽◽         | hoch         | Benutzerliste        | Benutzerliste um eine Seite nach oben blättern | `/bar scroll nicklist ${_window_number} -100%`
| ◾◽◽         | runter       | Benutzerliste        | Benutzerliste um eine Seite nach unten blättern | `/bar scroll nicklist ${_window_number} +100%`
| ◾◽◽         | hoch(lang)   | Benutzerliste        | springt zum Anfang der Benutzerliste | `/bar scroll nicklist ${_window_number} b`
| ◾◽◽         | runter(lang) | Benutzerliste        | springt zum Ende der Benutzerliste | `/bar scroll nicklist ${_window_number} e`
| ◾◽◽         | -            | Benutzerliste        | öffnet privaten Chat mit Nick | `/window ${_window_number};/query ${nick}`
| ◽◽◾         | -            | Benutzerliste        | führt einen whois für Nick aus | `/window ${_window_number};/whois ${nick}`
| ◾◽◽         | links        | Benutzerliste        | kickt Nick | `/window ${_window_number};/kick ${nick}`
| ◾◽◽         | links(lang)  | Benutzerliste        | kickt und verbannt Nick | `/window ${_window_number};/kickban ${nick}`
| ◽◽◾         | links        | Benutzerliste        | verbannt Nick | `/window ${_window_number};/ban ${nick}`
| ◽◽◾         | -            | Input                | fängt ein Mausereignis und fügt dieses in die Befehlszeile ein | `/input grab_mouse_area`
| ⇑           | -            | jede Bar             | blättert Bar um 20% nach oben | `/bar scroll ${_bar_name} ${_window_number} -20%`
| ⇓           | -            | jede Bar             | blättert Bar um 20% nach unten | `/bar scroll ${_bar_name} ${_window_number} +20%`
| ◽◾◽         | -            | überall              | aktiviert den Cursor-Modus an dieser Position | `/cursor go ${_x},${_y}`
|===

[NOTE]
^(1)^ "⇑" und "⇓" sind Symbole für Mausrad hoch/runter.

[[mouse]]
=== Mausunterstützung

WeeChat unterstützt Maustasten als auch Mausgesten. Dies funktioniert sowohl im
lokalen Terminal wie auch über eine Remote Verbindung via SSH.

[[mouse_enable]]
==== Mausunterstützung aktivieren

Um die Mausunterstützung beim Programmstart zu aktivieren:

----
/set weechat.look.mouse on
----

Um die Mausunterstützung direkt zu aktivieren, kann man den Tastenkurzbefehl
key[alt-m] nutzen oder folgenden Befehl ausführen:

----
/mouse enable
----

Es ist möglich die Mausunterstützung kurzzeitig zu deaktivieren und dies auf
einen Tastenkurzbefehl zu legen. Zum Beispiel soll über den Tastenkurzbefehl
key[alt-x] die Mausunterstützung für 10 Sekunden deaktiviert werden:

----
/key bind meta-x /mouse toggle 10
----

Ist die Mausunterstützung aktiviert kann man mittels gedrückter key[shift]-Taste (Umschalttaste)
Text im Terminal markieren oder einfügen, als ob die Mausunterstützung deaktiviert sei (bei
einigen Terminals muss die key[alt]-Taste anstelle der key[shift]-Taste gedrückt werden).

[NOTE]
Sollten Probleme bei der Mausunterstützung auftreten, dann sollte Bitte die 'WeeChat FAQ' gelesen werden.

[[mouse_bind_events]]
==== Befehle einem Maus-Ereignis zuweisen

Es gibt eine Anzahl von Maus-Ereignissen, die standardmäßig durch WeeChat definiert
sind (siehe <<key_bindings_mouse_context,Tasten für "mouse"-Kontext>>).

Man kann mit dem Befehl `/key` im Kontext "mouse" aber auch eigene Befehle zuweisen
und löschen (für die Syntax, siehe Befehl <<command_weechat_key,/key>>).

Der Name eines Ereignisses besteht aus einem Modifier (optional), einer Maustaste/Mausrad
und der Mausgeste (optional). Die unterschiedlichen Elemente werden durch ein "-" getrennt.

Liste der Modifiers:

[width="50%",cols="3m,4",options="header"]
|===
| Modifier | Beschreibung
| ctrl     | Taste key[ctrl]
| alt      | Taste key[alt]
| ctrl-alt | Taste key[ctrl-]key[alt]
|===

Liste der Maustasten/Mausrad:

[width="50%",cols="3m,4",options="header"]
|===
| Maustaste/-rad      | Beschreibung
| button1             | Linker Mausknopf wird gedrückt
| button2             | Rechter Mausknopf wird gedrückt
| button3             | Mittlerer Mausknopf wird gedrückt (häufig der Druck auf das Mausrad)
| button4 ... button9 | Ein zusätzlicher Mausknopf wird gedrückt
| wheelup             | Mausrad wird nach oben gescrollt
| wheeldown           | Mausrad wird nach unten gescrollt
|===

Liste der Mausgesten (nur für Maustasten, nicht für das Mausrad, anwendbar):

[width="50%",cols="3m,4",options="header"]
|===
| Mausgeste          | Distanz
| gesture-up         | 3 ... 19
| gesture-up-long    | ≥ 20
| gesture-down       | 3 ... 19
| gesture-down-long  | ≥ 20
| gesture-left       | 3 ... 39
| gesture-left-long  | ≥ 40
| gesture-right      | 3 ... 39
| gesture-right-long | ≥ 40
|===

Liste von unvollständigen Ereignissen (nur für Mausknopf, nützlich für Erweiterungen/Skripten):

[width="50%",cols="3m,4",options="header"]
|===
| Ereignis   | Beschreibung
| event-down | Mausknopf ist gedrückt
| event-drag | Maus wurde mit gedrücktem Mausknopf bewegt
|===

Bespiele von Ereignissen:

* `button1`
* `ctrl-button1`
* `button1-gesture-right`
* `button1-event-down`
* `button1-event-drag`
* `alt-button2-gesture-down-long`
* `wheelup`
* `ctrl-alt-wheeldown`

[TIP]
Wird eine Funktion im "mouse"-Kontext hinzufügt ist es möglich, mehrere Mausereignisse
mittels `*` abzufangen. Zum Beispiel fängt `button1-gesture-*` alle Mausgesten ab, die
mit der linken Maustaste eingeleitet werden.

[TIP]
Den Namen eines Mausereignisses kann man mittels des Befehls `/input grab_mouse` erfragen.
Man führt den Befehl in der Eingabezeile aus und startet das Ereignis. Als Ergebnis erhält
man in der Eingabezeile den Namen des ausgeführten Mausereignisses.

[[command_line]]
=== Befehlszeile

In der WeeChat Befehlszeile (am unteren Rand des Fensters) können Befehle ausgeführt oder
ein Text in den Buffer geschrieben werden.

[[command_line_syntax]]
==== Syntax

Ein Befehl wird durch das Zeichen "/" eingeleitet, gefolgt von dem Namen des Befehls. In folgendem
Beispiel werden alle Konfigurationsoptionen angezeigt:

----
/set
----

Jeder Text der nicht mit dem Zeichen "/" beginnt wird in den Buffer geschrieben.
In folgendem Beispiel wird der Text 'Hallo' in den aktuellen Buffer geschrieben:

----
Hallo
----

Dennoch ist es möglich einen Text in den Buffer zu schreiben der mit dem Zeichen "/" beginnt.
Dazu muss dem ersten "/" ein zweites "/" vorangestellt werden. Um den Befehl'/set' als Text zu senden:

----
//set
----

[[command_line_colors]]
==== Farbkodierung

Für einige Erweiterungen wie z.B. der IRC Erweiterung können Farbkodierungen und Attribute für den
Text gesetzt werden. Dazu muss die Tastenkombination key[ctrl-c], gefolgt von einem der folgenden
Zeichen, genutzt werden:

key[ctrl-c,b]::
    Text wird fett dargestellt

key[ctrl-c,c], key[xx]::
    Textfarbe `xx` (siehe Farbtabelle)

key[ctrl-c,c], key[xx]key[,]key[yy]::
    Textfarbe `xx` und Hintergrundfarbe `yy` (siehe Farbtabelle)

key[ctrl-c,i]::
    Text wird kursiv dargestellt

key[ctrl-c,o]::
    deaktiviert Farben und Attribute

key[ctrl-c,v]::
    Farben umkehren (kehrt Textfarbe und Hintergrundfarbe um)

key[ctrl-c,_]::
    Text wird mit Unterstrich dargestellt

[NOTE]
Der selbe Befehl (ohne den Wert für key[ctrl-c,c]) sollte genutzt werden
um die Farbkodierungen bzw. Attribute zu deaktivieren.

Farbtabelle für key[ctrl-c,c]:

[width="50%",cols="^1m,3,3",options="header"]
|===
| Code | IRC          | WeeChat (curses)
| 00   | weiß         | white
| 01   | schwarz      | black
| 02   | dunkelblau   | blue
| 03   | dunkelgrün   | green
| 04   | hellrot      | lightred
| 05   | dunkelrot    | red
| 06   | magenta      | magenta
| 07   | orange       | brown
| 08   | gelb         | yellow
| 09   | hellgrün     | lightgreen
| 10   | türkis       | cyan
| 11   | hell türkis  | lightcyan
| 12   | hellblau     | lightblue
| 13   | hell magenta | lightmagenta
| 14   | grau         | darkgray
| 15   | hellgrau     | gray
|===

Beispiel: Im Buffer wird "Hallo an alle!" ausgegeben. Dabei wird "Hallo" in fett und hellblau
und "an alle" rot und unterstrichen dargestellt.

----
^Cc12^CbHallo ^Cb^Cc04^C_an alle^C_^Cc!
----

[NOTE]
Die Farben können in der IRC Erweiterung neu belegt werden,
mittels der Option <<option_irc.color.mirc_remap,irc.color.mirc_remap>>.

[[colors]]
=== Farben

WeeChat kann bis zu 256 Farbpaarungen nutzen um einen Text in Bars oder im
Chatbereich darzustellen (der Terminal muss natürlich 256 Farben unterstützten).

Gemäß der Einstellung in der 'TERM'-Umgebungsvariable bestehen folgende Einschränkungen
was die Farbdarstellung in WeeChat betrifft:

[width="50%",cols="8,>2,>2",options="header"]
|===
| $TERM                                  | Farben | Paare ^(1)^
| "rxvt-unicode", "xterm", ...           |     88 |         256
| "rxvt-256color", "xterm-256color", ... |    256 |       32767
| "screen"                               |      8 |          64
| "screen-256color"                      |    256 |       32767
|===

[NOTE]
^(1)^ Auch falls die Terminal-Emulation mehr als 256 Farbpaare unterstützten sollte
können lediglich 256 Farbpaare durch WeeChat genutzt werden, dies ist eine Einschränkung
von ncurses.

Mittels `weechat --colors` oder dem internen WeeChat-Befehl `/color` kann man sich
die Einschränkungen für die jeweilige Umgebungsvariable anzeigen lassen.

Folgende Werte sind für die 'TERM'-Umgebungsvariable zu empfehlen, sofern man 256 Farben
nutzen möchte:

* falls screen genutzt wird: 'screen-256color'
* screen wird nicht genutzt: 'xterm-256color', 'rxvt-256color', 'putty-256color', ...

[NOTE]
Es sollte das Paket "ncurses-term" installiert werden um die Werte der 'TERM'
Variable nutzen zu können.

Sollte screen genutzt werden, fügt man folgende Zeile an das Ende der Datei
'~/.screenrc':

----
term screen-256color
----

Sollte die Umgebungsvariable 'TERM' falsch gesetzt worden sein und WeeChat
wird derweil schon ausgeführt, kann die Variable mit folgenden zwei Befehlen
geändert werden:

----
/set env TERM screen-256color
/upgrade
----

[[colors_basic]]
==== Basisfarben

Basisfarben in WeeChat sind:

[width="50%",cols="^3m,8",options="header"]
|===
| Name         | Farbe
| default      | Standard Terminalfarbe (transparent für Hintergrund)
| black        | Schwarz
| darkgray     | Dunkelgrau
| red          | Dunkelrot
| lightred     | Hellrot
| green        | Dunkelgrün
| lightgreen   | Hellgrün
| brown        | Braun
| yellow       | Gelb
| blue         | Dunkelblau
| lightblue    | Hellblau
| magenta      | Dunkel magenta
| lightmagenta | Hell magenta
| cyan         | Dunkel türkis
| lightcyan    | Hell türkis
| gray         | Grau
| white        | Weiß
|===

[[colors_extended]]
==== erweiterte Farbpalette

WeeChat belegt die Farbpaare dynamisch, sobald die Farbe genutzt werden sollte. Zum Beispiel
um mit einer Farbe Buffer oder Bars zu nutzen.

Zu den Basisfarben können zusätzlich Farben zwischen eins und der maximalen Anzahl an Farben
genutzt werden die vom jeweiligen Terminal zur Verfügung gestellt werden.

Mit dem `/color` Befehl kann man sich sowohl die aktuelle Farbpalette anzeigen lassen als
auch die Anzahl der zu nutzenden Farben. Mit key[alt-c] kann man vorübergehend zu den
Terminalfarben wechseln um eine Farbe auszuwählen.

Um zum Beispiel die Uhrzeit in einem Buffer in einem schönen Orange darzustellen:

----
/set weechat.color.chat_time 214
----

oder falls man den Hintergrund der Statusbar in einm sehr dunklen Grün haben möchte:

----
/set weechat.bar.status.color_bg 22
----

[[colors_aliases]]
==== Alias

Man kann einer Farbe einen Alias zuordnen um diesen Alias anstelle einer Zahl in
die Optionen einzutragen. Um einen Alias zu definieren nutzt man den Befehl
`/color alias`.

Beispiel:

----
/color alias 214 orange
/set weechat.color.chat_delimiters orange
----

[[colors_attributes]]
==== Attribute

Er ist möglich einer Farbe ein Attribut hinzuzufügen. Dazu wird dem
Farbnamen oder der Farbnummer ein- oder mehrere Attribute vorangestellt.

* `*` : fett
* `!` : invertierte Darstellung
* `/` : kursiven
* `_` : unterstrichen
* `|` : behält Attribut bei: fett, invertierte Darstellung, Unterstrichen wird beim Farbwechsel nicht zurückgesetzt

Um zum Beispiel dem eigenen Nick die Farbe weiß und unterstrichen
zuzuordnen:

----
/set weechat.color.chat_nick_self _white
----

oder um die Zeitanzeige in der Statusbar orange, fett und unterstrichen
darzustellen:

----
/set weechat.color.status_time *_214
----

Um einer Standard-Terminalfarbe (-1) ein Attribut hinzuzufügen muss eine Zahl
gewählt werden die größer ist als die letzte genutzte Farbe des Terminals.
Zum Beispiel; maximale Farbwahl in WeeChat: 99999.

Um der Vordergrundfarbe des Terminals das Attribut "fett" zuzuordnen:

----
/set weechat.color.status_time *99999
----

[[secured_data]]
=== sensible Daten

[[secured_data_storage]]
==== Archivierung

WeeChat kann Passwörter oder sensible Daten verschlüsseln und in der
Datei 'sec.conf' speichern.

Diese Konfigurationsdatei wird vor allen anderen Dateien geladen und die
gespeicherten Daten können in verschiedenen WeeChat Optionen bzw.
Erweiterungen und Skripten genutzt werden.

Es kann eine Passphrase genutzt werden um die Daten in 'sec.conf' zu
verschlüsseln. Dies ist nicht obligatorisch wird aber dringend empfohlen,
da ansonsten die Daten in Klartext gesichert werden.

----
/secure passphrase Dies ist meine Passphrase
----

Wenn eine Passphrase genutzt wird fragt WeeChat diese beim Programmstart
ab (bei einem `/upgrade` ist dies nicht der Fall).

Die Passphrase kann auch in einer Datei gesichert werden (siehe Option
<<option_sec.crypt.passphrase_file,sec.crypt.passphrase_file>>).

[[secured_data_encryption]]
===== Verschlüsselung

Die Daten werden in drei Schritten verschlüsselt:

. erstellt einen Schlüssel anhand der Passphrase (optional mit Salt).
. errechnet einen Hash über die Daten die verschlüsselt werden soll.
. verschlüsselt den Hash + Daten (Ausgabe ist: Salt + Hash/Daten verschlüsselt)

[NOTE]
Der Cipher Block Modus ist 'CFB'.

Das Ergebnis wird als hexadezimale Zeichenkette in 'sec.conf' gesichert.
Zum Beispiel:

----
[data]
__passphrase__ = on
freenode = "53B1C86FCDA28FC122A95B0456ABD79B5AB74654F21C3D099A6CCA8173239EEA59533A1D83011251F96778AC3F5166A394"
----

[[secured_data_decryption]]
===== Entschlüsselung

Die Entschlüsselung findet in drei Schritten statt:

. erstellt einen Schlüssel mittels Salt und Passphrase.
. entschlüsselt Hash + Daten.
. überprüft ob der entschlüsselte Hash mit dem Hash der entschlüsselten Daten übereinstimmt.

[[secured_data_manage]]
==== Umgang mit sensiblen Daten

Um sensible Daten zu schützen wird der Befehl `/secure set` verwendet. Es folgt
ein Beispiel wie man das Passwort für den IRC Server 'freenode' schützt:

----
/secure set freenode meinPasswort
----

Um einen Überblick über seine schutzwürdigen Daten zu erhalten kann ein
gesonderter Buffer geöffnet werden. In diesem Buffer kann man sich mittels
key[alt-v] seine Passwörter anzeigen lassen. Um den Buffer zu öffnen nutzt
man:

----
/secure
----

Verschlüsselte Daten können in einigen Optionen verwendet werden, die z.B.
Passwörter beinhalten. Dies dient dazu Passwörter nicht im Klartext als
Wert einer Option zu sichern. Dazu wird folgendes Format, anstelle des
Passwortes, verwendet: "${sec.data.xxx}". "xxx" ist hierbei der Name den man
dem Passwort zugeordnet hat (siehe oben, mittels `/secure set xxx ...`). +
Für eine vollständige Liste aller unterstützten Optionen, siehe  `/help secure`.

Um z.B. das oben eingestellte 'freenode' Passwort für eine
<<irc_sasl_authentication,SASL Authentifizierung>> zu nutzen:

----
/set irc.server.freenode.sasl_password "${sec.data.freenode}"
----

[[options_and_commands]]
=== Optionen und Befehle

[[sec_options]]
==== Optionen für schutzwürdige Daten (sec.conf)

Sektionen:

[width="100%",cols="3m,6m,16",options="header"]
|===
| Sektion | Steuerbefehl                       | Beschreibung
| crypt   | /set sec.crypt.*                   | Optionen für Verschlüsselung
| data    | <<command_weechat_secure,/secure>> | geschützte Daten
|===

Optionen:

include::autogen/user/sec_options.asciidoc[]

[[weechat_options]]
==== WeeChat Optionen (weechat.conf)

Sektionen:

[width="100%",cols="3m,6m,16",options="header"]
|===
| Sektion    | Steuerbefehl                              | Beschreibung
| debug      | <<command_weechat_debug,/debug set>>      +
               /set weechat.debug.*                      | Debug level, for core and plugins (Optionen können in Sektion hinzugefügt/entfernt werden)
| startup    | /set weechat.startup.*                    | Startup options
| look       | /set weechat.look.*                       | Look and feel
| palette    | <<command_weechat_color,/color alias>>    +
               /set weechat.palette.*                    | Alternativnamen für Farben (Optionen können in Sektion hinzugefügt/entfernt werden)
| color      | /set weechat.color.*                      | Farben
| completion | /set weechat.completion.*                 | Optionen für Vervollständigung
| history    | /set weechat.history.*                    | Optionen für Befehlsverlauf (Befehle und Buffer)
| proxy      | <<command_weechat_proxy,/proxy>>          +
               /set weechat.proxy.*                      | Proxy Optionen
| network    | /set weechat.network.*                    | Netzwerk/SSL Optionen
| bar        | <<command_weechat_bar,/bar>>              +
               /set weechat.bar.*                        | Optionen für die Bars
| layout     | <<command_weechat_layout,/layout>>        | Layouts
| notify     | <<command_weechat_buffer,/buffer notify>> | Benachrichtigungsstufe für Buffer (Optionen können in Sektion hinzugefügt/entfernt werden)
| filter     | <<command_weechat_filter,/filter>>        | Filter
| key        | <<command_weechat_key,/key>>              | Tastenbefehle in default context
| key_search | <<command_weechat_key,/key>>              | Tastenbefehle in search context
| key_cursor | <<command_weechat_key,/key>>              | Tastenbefehle in cursor context
| key_mouse  | <<command_weechat_key,/key>>              | Tastenbefehle in mouse context
|===

Optionen:

include::autogen/user/weechat_options.asciidoc[]

[[weechat_commands]]
==== WeeChat Befehle

include::autogen/user/weechat_commands.asciidoc[]

[[plugins]]
== Erweiterungen

Eine WeeChat Erweiterung ist eine dynamische Bibliothek (library), die in C geschrieben
und kompiliert ist. Unter GNU/Linux besitzt eine Erweiterung als Dateiendung ".so", unter
Windows ".dll".

Erweiterungen die gefunden werden, werden beim Start von WeeChat automatisch geladen.
Natürlich ist es möglich während einer laufenden Session von WeeChat Erweiterungen
nachträglich zu laden oder zu entfernen.

Es ist wichtig zwischen 'Erweiterung' und 'Skript' zu unterscheiden. Eine Erweiterung
ist eine Binärdatei die kompiliert wurde und mit dem Befehl `/plugin` geladen wird.
Dem gegenüber ist ein 'Skript' eine Textdatei die durch eine Erweiterung z.B. 'python'
mittels dem Befehl `/python` geladen wird.

Mit dem Befehl `/plugin` kann eine Erweiterung geladen bzw. entfernt werden. Auch können
mit dem Befehl alle installierten Erweiterungen aufgelistet werden. Wird eine Erweiterung
entfernt hat dies Einfluss auf die von dieser Erweiterung geöffneten Buffer.
Diese Buffer werden dann geschlossen.

Beispiele wie man Erweiterungen lädt, entfernt und auflistet:

----
/plugin load irc
/plugin unload irc
/plugin list
----

Standarderweiterungen:

[width="50%",cols="^1,5",options="header"]
|===
| Erweiterung | Beschreibung
| alias       | definiert Alias für Befehle
| aspell      | Rechtschreibprüfung für Befehlszeile
| charset     | Zeichensatz (de)-kodierung in Buffern
| exec        | ausführen von externen Befehlen aus WeeChat heraus
| fifo        | FIFO Pipe die zur Fernsteuerung von WeeChat genutzt werden kann
| irc         | IRC Chat-Protokoll
| logger      | erstellt Protokolldateien von Buffern
| relay       | Daten via Netzwerk übermitteln
| script      | Skripten-Manager
| python      | Python-Skript API
| perl        | Perl-Skript API
| ruby        | Ruby-Skript API
| lua         | Lua-Skript API
| tcl         | Tcl-Skript API
| guile       | Guile(scheme)-Skript API
| trigger     | Veränderung von Text und Ausführen von Befehlen bei einem Ereignis, welche durch WeeChat oder eine Erweiterung ausgelöst werden
| xfer        | Datentransfer und Direktchat
|===

Um mehr über Erweiterungen- und Skriptenprogrammierung (mittels API) zu erfahren,
sollten Sie die 'WeeChat Plugin API Reference' oder 'WeeChat Scripting Guide' lesen.

[[alias_plugin]]
=== Alias Erweiterung

Die Alias-Erweiterung erlaubt es, für Befehle, sogenannte Kurzbefehle (einen Alias) zu erstellen.

[[alias_commands]]
==== Befehle

include::autogen/user/alias_commands.asciidoc[]

[[aspell_plugin]]
=== Aspell Erweiterung

Mit der ASpell Erweiterung findet eine Rechtschreibprüfung Einzug in WeeChat.
Dabei ist es möglich mehrere Wörterbücher für einen Buffer zu nutzen.

[[aspell_options]]
==== Optionen (aspell.conf)

Sektionen:

[width="100%",cols="3m,6m,16",options="header"]
|===
| Sektion    | Steuerbefehl                              | Beschreibung
| color      | /set aspell.color.*                       | Farben
| check      | /set aspell.check.*                       | Optionen um Einstellungen an der Rechtschreibprüfung vorzunehmen
| dict       | <<command_aspell_aspell,/aspell setdict>> +
               /set aspell.dict.*                        | Wörterbücher für Buffer (Optionen können in Sektion hinzugefügt/entfernt werden)
| option     | /set aspell.option.*                      | <<aspell_speller_options,Optionen für Rechtschreibprüfung>> (Optionen können in Sektion hinzugefügt/entfernt werden)
|===

Optionen:

include::autogen/user/aspell_options.asciidoc[]

[[aspell_commands]]
==== Befehle

include::autogen/user/aspell_commands.asciidoc[]

[[aspell_speller_options]]
==== Optionen für Rechtschreibprüfung

Optionen für die Rechtschreibprüfung können definiert werden indem man die entsprechende
Option in die Sektion "option" der Aspell-Konfiguration hinzufügt.

Den Name der Option findet man in der ASpell-Konfigurationsdatei. Eine Auflistung aller
möglichen Optionen erhält man durch:

----
$ aspell config
----

Um zum Beispiel die Option "ignore-case" einzuschalten:

----
/set aspell.option.ignore-case "true"
----

[[aspell_suggestions]]
==== Rechtschreibkorrektur

Eine Rechtschreibkorrektur wird in der Bar-Item "aspell_suggest" angezeigt.
Die Anzahl an Vorschlägen, für die Rechtschreibkorrektur, kann mit der Option
'aspell.check.suggestions' bestimmt werden.

Um die Rechtschreibkorrektur zu aktivieren, muss für die Option 'aspell.check.suggestions'
ein Wert ≥ 0 eingestellt werden und das Bar-Item "aspell_suggest" zu einer Bar, zum
Beispiel 'status', hinzufügt werden.

Beispiel der Rechtschreibkorrektur, mit einem deutschen Wörterbuch (`de`):

....
│[12:55] [6] [irc/freenode] 3:#test(+n){4} [dies,Diebs,Viehs]                     │
│[@Flashy] diehs █                                                                │
└─────────────────────────────────────────────────────────────────────────────────┘
....

Beispiel der Rechtschreibkorrektur, mit zwei Wörterbüchern (`en,de`):

....
│[12:55] [6] [irc/freenode] 3:#test(+n){4} [print,prone,prune/Prinz]              │
│[@Flashy] prinr █                                                                │
└─────────────────────────────────────────────────────────────────────────────────┘
....

[[charset_plugin]]
=== Charset Erweiterung

Die Charset Erweiterung übernimmt das de-/kodieren der Zeichensätze.

Es existiert ein Standardzeichensatz zum de-/kodieren und spezielle Zeichensätze
für Buffer (oder Gruppen von Buffern).

Diese Erweiterung ist optional, sie wird aber empfohlen. Wenn diese Erweiterung
nicht genutzt wird steht WeeChat lediglich UTF-8 zur Verfügung.

Die Charset Erweiterung wird automatisch von WeeChat geladen. Um sicher zu gehen
dass diese Erweiterung geladen wurde führen Sie folgenden Befehl aus:

----
/charset
----

Wird der Befehl nicht gefunden dann kann die Erweiterung mit dem nachfolgenden
Befehl nachgeladen werden:

----
/plugin load charset
----

Wird die Erweiterung nicht geladen dann sollten Sie WeeChat nochmals mit allen
Erweiterungen und der Charset Unterstützung kompilieren.

Wird die Charset Erweiterung gestartet dann wird der Terminal und der interne
Zeichensatz genutzt. Welcher Terminal Zeichensatz genutzt wird hängt davon ab
welchen Zeichensatz Sie lokal nutzen. Intern wird UTF-8 genutzt.

Beispiel:

....
charset: terminal: ISO-8859-15, internal: UTF-8
....

[[charset_options]]
==== Optionen (charset.conf)

Sektionen:

[width="100%",cols="3m,6m,16",options="header"]
|===
| Sektion | Steuerbefehl                                | Beschreibung
| default | /set charset.default.*                      | Vorgegebener Zeichensatz zum De-/kodieren.
| decode  | <<command_charset_charset,/charset decode>> +
            /set charset.decode.*                       | Zeichensatz zum dekodieren (Optionen können in Sektion hinzugefügt/entfernt werden)
| encode  | <<command_charset_charset,/charset encode>> +
            /set charset.encode.*                       | Zeichensatz zum kodieren (Optionen können in Sektion hinzugefügt/entfernt werden)
|===

Optionen:

include::autogen/user/charset_options.asciidoc[]

[[charset_commands]]
==== Befehle

include::autogen/user/charset_commands.asciidoc[]

[[charset_set]]
==== Zeichensatz auswählen

Um einen Zeichensatz zum de-/kodieren zu bestimmen wird der Befehl `/set` genutzt.

Beispiel:

----
/set charset.default.decode ISO-8859-15
/set charset.default.encode ISO-8859-15
----

Wenn der globale Zeichensatz zum dekodieren nicht gesetzt ist (dies tritt beim
ersten Aufruf des Charset Erweiterung auf) dann wird automatisch der Zeichensatz
genutzt der vom Terminal verwendet wird (sofern dieser nicht UTF-8 ist) oder
der Standardzeichensatz 'ISO-8859-1'.

Der Standardwert zum kodieren ist nicht gesetzt. Deshalb wird der interne Zeichensatz
(UTF-8) genutzt.

Um einen Zeichensatz für IRC Server einzustellen wird der Befehl `/charset` im Server
Buffer ausgeführt. Wird nur der Zeichensatz als Argument übergeben wird dieser sowohl
zum kodieren als auch dekodieren genutzt.

Beispiel:

----
/charset ISO-8859-15
----

ist identisch mit den Befehlen:

----
/charset decode ISO-8859-15
/charset encode ISO-8859-15
----

Um den Zeichensatz in einem IRC-Channel (oder in einem privaten Buffer) zu ändern
wird der selbe Befehl im entsprechenden Buffer genutzt.

Um die Zeichenkodierung für alle Channels und privaten Buffer eines IRC Server zu ändern:

----
/set charset.encode.irc.freenode ISO-8859-15
----

Um sich alle genutzten Zeichensätze anzeigen zu lassen wird folgender Befehl genutzt:

----
/set charset.*
----

[[charset_troubleshooting]]
==== Fehlersuche

sollten Probleme bei der Zeichensatzdarstellung auftreten dann werfen Sie bitte
einen Blick in die 'WeeChat FAQ'.

[[exec_plugin]]
=== Exec Erweiterung

Der `/exec` Befehl erlaubt es aus WeeChat heraus einen oder mehrere externe
Befehle auszuführen und eine Ausgabe im lokalen Buffer darzustellen oder in
einem Buffer auszugeben.

[[exec_options]]
==== Optionen (exec.conf)

Sections:

[width="100%",cols="3m,6m,16",options="header"]
|===
| Sektion | Steuerbefehl        | Beschreibung
| command | /set exec.command.* | Optionen für Befehle
| color   | /set exec.color.*   | Farben
|===

Options:

include::autogen/user/exec_options.asciidoc[]

[[exec_commands]]
==== Commands

include::autogen/user/exec_commands.asciidoc[]

[[fifo_plugin]]
=== Fifo Erweiterung

Sie können WeeChat fern steuern indem Sie Befehle oder einen Text an die FIFO Pipe
schicken (dazu muss die Option "plugins.var.fifo.fifo" aktiviert sein (standardmäßig
ist diese Option aktiviert).

Die FIFO pipe findet man in '~/.weechat/' und heisst 'weechat_fifo_xxxx'
('xxxx' ist dabei die ID (PID) der laufenden WeeChat Session).

Die Syntax der FIFO Pipe Befehle/Text sieht wie folgt aus:

....
  plugin.buffer *hier Text oder Befehl
  *hier Text oder Befehl
....

einige Beispiele:

* Den eigenen Nick auf dem IRC Server freenode in "newnick" ändern:

----
$ echo 'irc.server.freenode */nick newnick' >~/.weechat/weechat_fifo_12345
----

* Den Text 'Hallo!' in den Channel #weechat schreiben:

----
$ echo 'irc.freenode.#weechat *Hallo!' >~/.weechat/weechat_fifo_12345
----

* Einen Text im aktuellen Buffer ausgeben:

----
$ echo '*hello!' >~/.weechat/weechat_fifo_12345
----

* sendet zwei Befehle um alle Python-Skripten zu entfernen und dann neu zu laden (die beiden Befehle müssen
  mit "\n" getrennt werden):

----
$ printf '%b' '*/python unload\n*/python autoload\n' >~/.weechat/weechat_fifo_12345
----

Das nachfolgende Skript sendet einen Befehl an alle laufenden WeeChat Instanzen:

[source,shell]
----
#!/bin/sh
if [ $# -eq 1 ]; then
    for fifo in ~/.weechat/weechat_fifo_*
    do
        echo -e "$1" >$fifo
    done
fi
----

Falls man das Skript "auto_weechat_command" benennt ruft man es wie folgt auf:

----
$ ./auto_weechat_command 'irc.freenode.#weechat *Hallo'
----

[[irc_plugin]]
=== IRC Erweiterung

Die IRC Erweiterung ist konzipiert um mittels dem IRC Protokoll mit anderen Menschen zu chatten.

Die Erweiterung ist Multi-Server fähig und verfügt über alle IRC Befehle, einschließlich DCC Chat
und Datenübertragung (via xfer Erweiterung, siehe <<xfer_plugin,Xfer Erweiterung>>).

[[irc_command_line_options]]
==== Kommandozeilen Befehle

Es ist möglich eine oder mehrere URL von IRC Servern zu übergeben:

----
irc[6][s]://[nick[:password]@]irc.example.org[:port][/channel][,channel[...]]
----

Beispiel: Anmelden beim Server 'irc.freenode.net' mit dem Nick 'nono' und betreten
der Channels '#weechat' und '#toto' (Standardport (6667) wird genutzt):

----
$ weechat irc://nono@irc.freenode.net/#weechat,#toto
----

[[irc_options]]
==== Optionen (irc.conf)

Sektionen:

[width="100%",cols="3m,6m,16",options="header"]
|===
| Sektion        | Steuerbefehl                   | Beschreibung
| look           | /set irc.look.*                | Erscheinungsbild
| color          | /set irc.color.*               | Farben
| network        | /set irc.network.*             | Netzwerkoptionen
| msgbuffer      | /set irc.msgbuffer.*           | <<irc_target_buffer,Zielbuffer für IRC Nachrichten>> (Optionen können in Sektion hinzugefügt/entfernt werden)
| ctcp           | /set irc.ctcp.*                | <<irc_ctcp_replies,CTCP Antworten>> (Optionen können in Sektion hinzugefügt/entfernt werden)
| ignore         | <<command_irc_ignore,/ignore>> | Ignoriert Menschen
| server_default | /set irc.server_default.*      | Standardwerte für Server (werden genutzt, falls keine Optionen für einen Server gesetzt sind)
| server         | <<command_irc_server,/server>> +
                   /set irc.server.*              | Server
|===

Optionen:

include::autogen/user/irc_options.asciidoc[]

[[irc_commands]]
==== Befehle

include::autogen/user/irc_commands.asciidoc[]

[[irc_ssl_certificates]]
==== SSL Zertifikate

Wenn eine Verbindung mittels SSL zu einem IRC Server hergestellt wird dann überprüft
WeeChat immer ob dieser Verbindung sicher ist.

Einige Optionen dienen dazu eine SSL Verbindung zu nutzen:

weechat.network.gnutls_ca_file::
    Pfad zu einer Datei mit SSL Zertifikaten (Standardpfad: "%h/ssl/CAs.pem")

irc.server.xxx.ssl_cert::
    Datei mit den SSL Zertifikaten die genutzt werden um automatisch Ihren Nick
    zu identifizieren (zum Beispiel CertFP auf oftc, siehe unten)

irc.server.xxx.ssl_dhkey_size::
    Größe des Schlüssels der genutzt werden soll beim Schlüsseltausch mittels
    der Diffie-Hellman Methode (Standardwert: 2048)

irc.server.xxx.ssl_verify::
    überprüft ob der SSL Verbindung uneingeschränkt vertraut werden kann (Standardwert: AN)

[NOTE]
Die Option "ssl_verify" ist Vorgabe mäßig immer eingeschaltet. Das gewährleistet dass
die Verifizierung sehr streng genommen wird und dadurch vielleicht versagt. Auch wenn
die Verbindung mit einer vorherigen Version (<0.3.1) funktioniert hat.

[[irc_connect_oftc_with_certificate]]
===== erstes Beispiel: Verbindung zu oftc und Überprüfung der Zertifikate

* Importieren Sie die Zertifikate in einer Shell:

----
$ mkdir -p ~/.weechat/ssl
$ wget -O ~/.weechat/ssl/CAs.pem http://www.spi-inc.org/ca/spi-cacert.crt
----

Hinweis: es ist möglich mehrere Zertifikate in der Datei CAs.pem zu halten.

* In WeeChat startet man nun eine Verbindung zum "oftc" Server (der vorher angelegt
  werden musste):

----
/connect oftc
----

[[irc_connect_oftc_with_certfp]]
===== zweites Beispiel: Verbindung zu oftc mittels CertFP

* Erstellen Sie ein Zertifikat in der Shell:

----
$ mkdir -p ~/.weechat/ssl
$ cd ~/.weechat/ssl
$ openssl req -nodes -newkey rsa:2048 -keyout nick.pem -x509 -days 365 -out nick.pem
----

* In WeeChat startet man nun eine Verbindung zum "oftc" Server (der vorher angelegt
  werden musste):

----
/set irc.server.oftc.ssl_cert "%h/ssl/nick.pem"
/connect oftc
/msg nickserv cert add
----

Für weiterreichende Informationen lesen Sie bitte: http://www.oftc.net/oftc/NickServ/CertFP

[[irc_sasl_authentication]]
==== SASL Authentifizierung

WeeChat unterstützt eine SASL Authentifikation, mittels verschiedener Mechanismen:

* 'plain': Passwort liegt in Klarschrift vor
* 'dh-blowfish': Passwort wird mittels blowfish verschlüsselt
* 'dh-aes': Passwort wird mittels AES verschlüsselt
* 'external': SSL Zertifikat welches auf Client Seite vorliegt

Optionen für Server sind:

* 'sasl_mechanism': Mechanismus welcher genutzt werden soll (siehe oben)
* 'sasl_timeout': Zeitüberschreitung für Authentifizierung (in Sekunden)
* 'sasl_username': Username (Nickname)
* 'sasl_password': Passwort

Soll "dh-blowfish" standardmäßig auf allen Servern angewandt werden:

----
/set irc.server_default.sasl_mechanism dh-blowfish
----

[NOTE]
Die "gcrypt" Bibliothek wird beim kompilieren von WeeChat benötigt um
"dh-blowfish"nutzen zu können (siehe <<dependencies,Abhängigkeiten>>).

[[irc_tor_freenode]]
==== Verbindung zu Freenode mittels TOR/SASL herstellen

Neben der Möglichkeit eine Verbindung zum Freenode Server mittels SSL aufzubauen,
kann man außerdem eine Verbindung via TOR (https://www.torproject.org/) herstellen.
Dies dient dazu die eigene Privatsphäre und Sicherheit im Internet zu erhöhen.

Zuerst sollte man sicher gehen, dass WeeChat mit <<dependencies,libgcrypt11-dev>> kompiliert
wurde (sofern WeeChat aus den Quellen erstellt wurde); es ist nicht verpflichtend, allerdings
bietet "dh-blowfish" eine größere Sicherheit als eine "plain" Authentifikation mittels SASL.

Im ersten Schritt muss TOR installiert werden. Für Debian (und Derivate):

----
$ sudo apt-get install tor
----

In WeeChat muss nun ein socks5 Proxy für den TOR Service erstellt werden (Hostname/IP
und Port müssen dabei an die eigene TOR Konfiguration angepasst werden):

----
/proxy add tor socks5 127.0.0.1 9050
----

Nun erstellt man einen neuen Server, zum Beispiel:

----
/server add freenode-tor p4fsi4ockecnea7l.onion
----

Der Proxy muss für TOR angelegt werden:

----
/set irc.server.freenode-tor.proxy "tor"
----

Die SASL Authentifikation einstellen:

----
/set irc.server.freenode-tor.sasl_mechanism dh-blowfish
/set irc.server.freenode-tor.sasl_username "your_nickname"
/set irc.server.freenode-tor.sasl_password "your_password"
----

Zum Abschluss stellt man eine Verbindung zum Server her:

----
/connect freenode-tor
----

Um mehr über Freenode und TOR zu erfahren: http://freenode.net/irc_servers.shtml#tor

[[irc_smart_filter_join_part_quit]]
==== einfacher Filter für join/part/quit Nachrichten

Es existiert ein einfacher Filter für join/part/quit Nachrichten falls ein Nick für
eine vorgegebene Zeit in einem Channel inaktiv gewesen ist.

Diese Funktion ist standardmäßig aktiviert, aber Sie müssen einen Filter erstellen damit
solche Nachrichten im Buffer unterdrückt werden. Ein Beispiel:

----
/filter add irc_smart * irc_smart_filter *
----

Dabei ist es natürlich möglich den Filter in der Form einzurichten dass er nur
für einen Channel Gültigkeit besitzt oder aber für mehrere Channels die mit dem
selben Namen beginnen (siehe `/help filter`):

----
/filter add irc_smart_weechat irc.freenode.#weechat irc_smart_filter *
/filter add irc_smart_weechats irc.freenode.#weechat* irc_smart_filter *
----

Sie können auch nur join oder part/quit Nachrichten unterdrücken:

----
/set irc.look.smart_filter_join on
/set irc.look.smart_filter_quit on
----

Zusätzlich kann auch eine Verzögerung (in Minuten) eingestellt werden:

----
/set irc.look.smart_filter_delay 5
----

Falls ein Nick in den letzten fünf Minuten nicht aktiv gewesen ist werden seine
join und/oder part/quit Nachrichten im Channel unterdrückt.

[[irc_ctcp_replies]]
==== CTCP Antworten

Sie haben die Möglichkeit CTCP Antworten anzupassen oder aber bestimmte CTCP
Anfragen zu sperren (es wird nicht darauf geantwortet).

Beispiel: Um eine Antwort auf die CTCP Anfrage "VERSION" anzupassen nutzen Sie
folgenden Befehl:

----
/set irc.ctcp.version "I'm running WeeChat $version, it rocks!"
----

Wenn Sie die Anfrage CTCP "VERSION" blockieren möchten (es wird nicht darauf
geantwortet) dann löschen Sie einfach den Rückgabe-String:

----
/set irc.ctcp.version ""
----

Selbst bisher unbekannte CTCP Anfragen können beantwortet werden. Nehmen wir
zum Beispiel die Anfrage CTCP "BLABLA":

----
/set irc.ctcp.blabla "Dies ist meine Antwort auf CTCP BLABLA"
----

Auch kann man CTCP Antworten für jeden einzelnen Server anpassen. Dazu muss
man lediglich den internen Servernamen vor die CTCP Anfrage setzen:

----
/set irc.ctcp.freenode.version "WeeChat $version (for freenode)"
----

Sollen die CTCP Antworten wieder auf die Standardeinstellungen zurück gesetzt werden
dann müssen Sie lediglich die Option löschen:

----
/unset irc.ctcp.version
----

Folgende Platzhalter können in den CTCP-Antworten genutzt werden. Diese werden dann
mit dem entsprechenden Wert ersetzt:

[width="100%",cols="^2l,4,8",options="header"]
|===
| Platzhalter  | Beschreibung                        | Wert/Beispiel
| $clientinfo  | Liste der CTCP Antworten            | `ACTION DCC CLIENTINFO FINGER PING SOURCE TIME USERINFO VERSION`
| $version     | WeeChat Version                     | `0.4.0-dev`
| $versiongit  | WeeChat Version + Git version ^(1)^ | `0.4.0-dev (git: v0.3.9-104-g7eb5cc4)`
| $git         | Git Version ^(1)^                   | `v0.3.9-104-g7eb5cc4`
| $compilation | Datum der Kompilierung              | `Dec 16 2012`
| $osinfo      | Info über das genutzte OS           | `Linux 2.6.32-5-amd64 / x86_64`
| $site        | WeeChat Seite                       | `http://weechat.org/`
| $download    | WeeChat, Download Seite             | `http://weechat.org/download`
| $time        | Aktuelle Uhrzeit/Datum              | `Sun, 16 Dec 2012 10:40:48 +0100`
| $username    | Username beim IRC Server            | `Name`
| $realname    | Realname beim IRC Server            | `John Doe`
|===

[NOTE]
^(1)^ Die Git Version wird durch die Ausgabe des Befehls `git describe` ermittelt.
Dies erfordert, dass WeeChat aus dem Git Repository heraus kompiliert wurde
und das Git überhaupt installiert ist.

Falls CTCP Optionen nicht festgelegt sind, lauten die CTCP Antworten:

[width="100%",cols="^2,4,8",options="header"]
|===
| CTCP       | Antwortformat                        | Beispiel
| CLIENTINFO | `$clientinfo`                        | `ACTION DCC CLIENTINFO FINGER PING SOURCE TIME USERINFO VERSION`
| FINGER     | `WeeChat $versiongit`                | `WeeChat 0.4.0-dev (git: v0.3.9-104-g7eb5cc4)`
| SOURCE     | `$download`                          | `http://weechat.org/download`
| TIME       | `$time`                              | `Sun, 16 Dec 2012 10:40:48 +0100`
| USERINFO   | `$username ($realname)`              | `Name (John Doe)`
| VERSION    | `WeeChat $versiongit ($compilation)` | `WeeChat 0.4.0-dev (git: v0.3.9-104-g7eb5cc4) (Dec 16 2012)`
|===

[[irc_target_buffer]]
==== Zielbuffer für IRC Nachrichten

Sie können einen Zielbuffer einstellen in welchem IRC Nachrichten dargestellt werden sollen.
Dazu dienen die Optionen `irc.msgbuffer.*`.

Für einige IRC Nachrichten (siehe unten) können zusätzliche Werte angepasst werden:

current::
    aktueller Buffer (falls es ein IRC Buffer ist, ansonsten im entsprechenden Server Buffer)

private::
    privaten Buffer, oder im aktuellen/Server Buffer falls nicht vorhanden (gemäß der Einstellung
    in der Option 'irc.look.msgbuffer_fallback')

server::
    Server Buffer

weechat::
    WeeChat "core" Buffer

Falls die Option nicht gesetzt ist (Standard) wählt WeeChat einen geeigneten Buffer aus,
üblicherweise handelt es sich dabei um einen Server oder Channel-Buffer.

Unvollständige Liste der IRC Nachrichten bzw. Alias die angepasst werden können:

[width="60%",cols="^1m,^3m,8",options="header"]
|===
| Nachricht | Alias         | Beschreibung
| error     |               | Fehler
| invite    |               | Einladung in einen Channel
| join      |               | join
| kick      |               | kick
| kill      |               | kill
| mode      |               | Modus
| notice    |               | Mitteilung
| part      |               | part
| quit      |               | quit
| topic     |               | topic
| wallops   |               | wallops
|           | ctcp          | ctcp (gesendet oder empfangen, in einer privmsg oder notice Nachricht)
| 221       |               | User mode string
| 275       | whois         | whois (sichere Verbindung)
| 301       | whois         | whois (abwesend)
| 303       |               | ison
| 305       | unaway        | nicht abwesend
| 306       | away          | abwesend
| 307       | whois         | whois (registrierter Nick)
| 310       | whois         | whois (Hilfe Modus)
| 311       | whois         | whois (User)
| 312       | whois         | whois (Server)
| 313       | whois         | whois (Operator)
| 314       | whowas        | whowas
| 315       | who           | who (Ende)
| 317       | whois         | whois (inaktiv)
| 318       | whois         | whois (ende)
| 319       | whois         | whois (Channels)
| 320       | whois         | whois (User identifizieren)
| 321       | list          | list (Start)
| 322       | list          | list (Channel)
| 323       | list          | list (Ende)
| 326       | whois         | whois (hat oper privs)
| 327       | whois         | whois (Host)
| 328       |               | Channel URL
| 329       |               | Erstellungsdatum des Channel
| 330       | whois         | whois (eingelogged als)
| 331       |               | kein Topic für Channel
| 332       |               | Channel-Topic
| 333       |               | Infos über Topic
| 335       | whois         | whois (ist ein Bot auf)
| 338       | whois         | whois (Host)
| 341       |               | inviting
| 343       | whois         | whois (ist opered als)
| 344       | reop          | channel reop
| 345       | reop          | channel reop (Ende)
| 346       | invitelist    | Einladung Liste
| 347       | invitelist    | Einladung Liste (Ende)
| 348       | exceptionlist | exception Liste
| 349       | exceptionlist | exception Liste (Ende)
| 351       |               | Server Version
| 352       | who           | who
| 353       | names         | Liste von Usern im Channel
| 366       | names         | Ende der /names Liste
| 367       | banlist       | ban Liste
| 368       | banlist       | Ende der ban Liste
| 369       | whowas        | whowas (Ende)
| 378       | whois         | whois (Verbindung von)
| 379       | whois         | whois (genutzte Modi)
| 401       | whois         | kein solcher Nick/Channel
| 402       | whois         | kein solcher Server
| 432       |               | fehlerhafter Nickname
| 433       |               | Nickname wird schon verwendet
| 438       |               | nicht autorisiert um Nicknamen zu ändern
| 671       | whois         | whois (sichere Verbindung)
| 728       | quietlist     | quiet Liste
| 729       | quietlist     | Ende der quiet Liste
| 732       | monitor       | Liste der Nicks welche überwacht werden
| 733       | monitor       | Liste der Nicks welche überwacht werden (Ende)
| 901       |               | Sie sind nun eingelogged
|===

andere nummerische Befehle können angepasst werden.

Den IRC Nachrichten kann der Servername vorangestellt werden um zu spezifizieren
von welchem IRC Server die Nachricht gekommen ist. Zum Beispiel: `freenode.whois`.

einige Beispiele:

* gibt die Antwort von `/whois` im privaten Buffer aus:

----
/set irc.msgbuffer.whois private
----

* stellt die Ausgabe von whois wieder auf Standardbuffer zurück (Server Buffer):

----
/unset irc.msgbuffer.whois
----

* zeigt Einladungen im aktuellen Buffer an, nur für den "freenode" Server:

----
/set irc.msgbuffer.freenode.invite current
----

* die Nachricht "303" (ison) wird im WeeChat "core" Buffer angezeigt:

----
/set irc.msgbuffer.303 weechat
----

[[logger_plugin]]
=== Logger Erweiterung

Die Logger Erweiterung erlaubt es den Inhalt von Buffern in Dateien zu sichern.
Dabei kann man über Optionen Einfluss darauf nehmen was gesichert und wie etwas
gesichert werden soll.

[[logger_options]]
==== Optionen (logger.conf)

Sektionen:

[width="100%",cols="3m,6m,16",options="header"]
|===
| Sektion | Steuerbefehl        | Beschreibung
| look    | /set logger.look.*  | Erscheinungsbild
| color   | /set logger.color.* | Farben
| file    | /set logger.file.*  | Optionen für Protokolldateien
| level   | /set logger.level.* | Protokollierungslevel pro Buffer (Optionen können in Sektion hinzugefügt/entfernt werden)
| mask    | /set logger.mask.*  | Dateinamenmaske pro buffer (Optionen können in Sektion hinzugefügt/entfernt werden)
|===

Optionen:

include::autogen/user/logger_options.asciidoc[]

[[logger_commands]]
==== Befehle

include::autogen/user/logger_commands.asciidoc[]

[[logger_log_levels]]
==== Log Levels

Die Protokollierung wird durch einen sogenannten Level für jeden Buffer sichergestellt.
Der Standardlevel ist dabei 9 (damit werden alle Nachrichten die im Buffer angezeigt
werden protokolliert). Der Grad einer Protokollierung kann separat für jeden einzelnen
Buffer oder aber für eine Anzahl von Buffern festgelegt werden.

Mögliche Level sind hierbei 0 bis 9. Null bedeutet, es findet keine Protokollierung
statt und neun, dass alle Nachrichten protokolliert werden.

Erweiterungen nutzen unterschiedliche Level um Nachrichten anzuzeigen.
Die IRC Erweiterung nutzt folgende Level:

* Level 1: Nachrichten eines Users (im Channel oder privat)
* Level 2: Nick wurde geändert (der eigene oder von einer anderen Person)
* Level 3: jedwede Server Nachricht (ausgenommen join/part/quit)
* Level 4: Server Nachrichten join/part/quit

Setzen Sie also den Grad der Protokollierung für einen IRC Channel auf "3"
wird Weechat alle Nachrichten protokollieren, ausgenommen join/part/quit
Nachrichten.

weitere Beispiele:

* Level 3 für IRC Channel #weechat nutzen:

----
/set logger.level.irc.freenode.#weechat 3
----

* Level 3 für freenode Server Buffer nutzen:

----
/set logger.level.irc.server.freenode 3
----

* Level 3 für alle Channels auf dem Server freenode nutzen:

----
/set logger.level.irc.freenode 3
----

* Level 2 für alle IRC Buffers nutzen:

----
/set logger.level.irc 2
----

[[logger_filenames_masks]]
==== Dateinamenmaske

Es ist möglich eine Dateinamenmaske für jeden Buffer zu erstellen und diese Maske
mit lokalen Buffervariablen zu füllen. Um zu sehen welche lokalen Variabel es gibt:

----
/buffer localvar
----

Zum Beispiel für den Buffer "irc.freenode.#weechat". WeeChat sucht in dieser
Reihenfolge nach einer Maske:

----
logger.mask.irc.freenode.#weechat
logger.mask.irc.freenode
logger.mask.irc
logger.file.mask
----

Dies bedeutet dass man eine Maske speziell für einen IRC Server
("logger.mask.irc.freenode") anlegen kann oder aber global für
die Erweiterung ("logger.mask.irc").

[[logger_files_by_date]]
===== Protokolldatei nach Datum

Um Protokolldateien mit einer Datumsrelevanz zu erstellen müssen
Datumsspezifikationen in der Maske genutzt werden (siehe
`man strftime` für das Format). Zum Beispiel:

----
/set logger.file.mask "%Y/%m/$plugin.$name.weechatlog"
----

Erstellt eine Struktur in folgender Form:

....
~/.weechat/
    |--- logs/
        |--- 2010/
            |--- 11/
            |       irc.server.freenode.weechatlog
            |       irc.freenode.#weechat.weechatlog
        |--- 2010/
            |--- 12/
            |       irc.server.freenode.weechatlog
            |       irc.freenode.#weechat.weechatlog
....

[[logger_irc_files_by_server_channel]]
===== Protokolldateien nach Server und Channel

Soll für jeden IRC Server ein Verzeichnis erstellt werden mit jeweils
einer Protokolldatei für jeden Channel:

----
/set logger.mask.irc "irc/$server/$channel.weechatlog"
----

Erstellt eine Struktur in folgender Form:

....
~/.weechat/
    |--- logs/
        |--- irc/
            |--- freenode/
            |       freenode.weechatlog
            |       #weechat.weechatlog
            |       #mychan.weechatlog
            |--- oftc/
            |       oftc.weechatlog
            |       #chan1.weechatlog
            |       #chan2.weechatlog
....

[[relay_plugin]]
=== Relay Erweiterung

Die Relay-Erweiterung wird genutzt um Daten, mittels unterschiedlicher Protokolle,
über ein Netzwerk zu übermitteln:

* 'irc': IRC Proxy: um mittels einem oder mehreren IRC-Clients eine Verbindung zu
  IRC Servern zu unterhalten.
* 'weechat': Protokoll welches es erlaubt die Daten mit einer externen Oberfläche
  zu teilen (zum Beispiel QWeeChat)

[[relay_options]]
==== Optionen (relay.conf)

Sektionen:

[width="100%",cols="3m,6m,16",options="header"]
|===
| Sektion | Steuerbefehl                       | Beschreibung
| look    | /set relay.look.*                  | Erscheinungsbild
| color   | /set relay.color.*                 | Farben
| network | /set relay.network.*               | Netzwerkoptionen
| irc     | /set relay.irc.*                   | für das IRC Protokoll spezifische Optionen (IRC Proxy)
| port    | <<command_relay_relay,/relay add>> +
            /set relay.port.*                  | Ports zur Nutzung der Relay-Erweiterung (IRC und weechat Protokolle) (Optionen können in Sektion hinzugefügt/entfernt werden)
|===

Optionen:

include::autogen/user/relay_options.asciidoc[]

[[relay_commands]]
==== Befehle

include::autogen/user/relay_commands.asciidoc[]

[[relay_password]]
==== Passwort

Es wird nachdrücklich Empfohlen ein Passwort für die Relay-Verbindung zu nutzen:

----
/set relay.network.password "meinPasswort"
----

Dieses Passwort wird sowohl für das 'irc' als auch für das 'weechat' Protokoll
verwendet.

[[relay_ssl]]
==== SSL

Man kann SSL mittels eines selbst erstellten Zertifikates und eines privaten
Schlüssels nutzen. Um SSL für die Verbindung zu aktivieren stellt man dem
Protokollnamen ein "ssl" voran.

Die Standarddatei für Zertifikate/Schlüssel ist '~/.weechat/ssl/relay.pem'
(option <<option_relay.network.ssl_cert_key,relay.network.ssl_cert_key>>).

Ein Zertifikat und einen privaten Schlüssel kann man mit folgenden Befehlen
erstellen:

----
$ mkdir -p ~/.weechat/ssl
$ cd ~/.weechat/ssl
$ openssl req -nodes -newkey rsa:2048 -keyout relay.pem -x509 -days 365 -out relay.pem
----

Sollte WeeChat schon gestartet worden sein, kann man das Zertifikat und der private
Schlüssel mittels folgendem Befehl nachträglich geladen werden:

----
/relay sslcertkey
----

[[relay_irc_proxy]]
==== IRC Proxy

Die Relay Erweiterung kann wie ein IRC Proxy genutzt werden. Dabei simuliert
die Erweiterung einen IRC Server und man kann sich mit jedem IRC Client zu WeeChat
verbinden.

Es kann für jeden IRC Server ein Port definiert werden, oder aber ein Port für
alle Server.

Wird ein Port für alle Server genutzt, dann muss der Client den internen Namen
des zu nutzenden Servers mit dem IRC Befehl "PASS" anfordern:

----
PASS server:meinPasswort
----

Beispiel: IRC Proxy mit SSL für einen beliebigen Server (Client wählt aus):

----
/relay add ssl.irc 8000
----

Beispiel: IRC Proxy ohne SSL und nur für "freenode":

----
/relay add irc.freenode 8000
----

Nun kann man eine Verbindung zum Port 8000 mit jedem beliebigen IRC Client
herstellen, indem man das Server Passwort "meinPasswort" nutzt (oder
"freenode:meinPasswort" sofern kein Server angegeben wurde).

[[relay_weechat_protocol]]
==== WeeChat Protokoll

Die Relay-Erweiterung kann Daten, mittels dem WeeChat Protokoll, an eine
externe Oberfläche senden.

Nun kann man mittels einer remote Oberfläche Kontakt zu WeeChat herstellen.
Eine Liste der remote Oberflächen findet man auf der Homepage:
http://weechat.org/download

[IMPORTANT]
WeeChat selber kann sich NICHT mit einer anderen WeeChat Instanz über
dieses Protokoll verbinden.

Zum Beispiel:

----
/relay add weechat 9000
----

Nun kann man über den Port 9000 mittels einer Oberfläche und dem Passwort
"meinPasswort" eine Verbindung zu WeeChat herstellen.

[[relay_websocket]]
==== WebSocket

Das WebSocket Protokoll (http://tools.ietf.org/html/rfc6455[RFC 6455]) wird nun
in der Relay Erweiterung unterstützt.

Der WebSocket Handshake wird automatisch erkannt und der Socket ist sofort
funktionsfähig, sofern die benötigten Header gefunden werden und die Herkunft
bestätigt wurde (siehe Option <<option_relay.network.websocket_allowed_origins,relay.network.websocket_allowed_origins>>).

Ein WebSocket kann in HTML5, mit einer JavaScript Zeile, geöffnet werden:

[source,js]
----
websocket = new WebSocket("ws://server.com:9000/weechat");
----

Der Port (im Beispiel: 9000) ist der Port der in der Relay Erweiterung angegeben wurde.
Die URI muss immer auf "/weechat" enden ('irc' und 'weechat' Protokoll).

[[scripts_plugins]]
=== Erweiterungen für Skripten

WeeChat unterstützt sechs Skript-Erweiterungen: Python, Perl, Ruby, Lua, Tcl und Guile
(scheme).
Mit diesen Erweiterungen kann für die jeweilige Skript-Sprache, Skripten geladen, ausgeführt
und entfernt werden.

Eine weitere Erweiterung ist "script". Dies ist ein Skripten-Manager mit dem es möglich ist,
unabhängig von der Skript-Sprache, Skripten zu laden und zu entfernen. Des weiteren können
Skripten, aus dem Skript-Repository, installiert und deinstalliert werden. Das Skript-Repository
kann unter folgender URL eingesehen werden: http://weechat.org/scripts

Sollten wir Ihr Interesse geweckt haben, selber Skripten für WeeChat zu programmieren, dann lesen Sie
bitte die 'WeeChat Scripting Guide'.

[[script_options]]
==== Script Optionen (script.conf)

Sektionen:

[width="100%",cols="3m,6m,16",options="header"]
|===
| Sektion | Steuerbefehl          | Beschreibung
| look    | /set script.look.*    | Erscheinungsbild
| color   | /set script.color.*   | Farben
| scripts | /set script.scripts.* | Optionen für den Download von Skripten
|===

Optionen:

include::autogen/user/script_options.asciidoc[]

[[script_commands]]
==== Skript Befehle

include::autogen/user/script_commands.asciidoc[]

[[python_commands]]
==== Python Befehle

include::autogen/user/python_commands.asciidoc[]

[[perl_commands]]
==== Perl Befehle

include::autogen/user/perl_commands.asciidoc[]

[[ruby_commands]]
==== Ruby Befehle

include::autogen/user/ruby_commands.asciidoc[]

[[lua_commands]]
==== Lua Befehle

include::autogen/user/lua_commands.asciidoc[]

[[tcl_commands]]
==== Tcl Befehle

include::autogen/user/tcl_commands.asciidoc[]

[[guile_commands]]
==== Guile Befehle

include::autogen/user/guile_commands.asciidoc[]

[[trigger_plugin]]
=== Trigger Erweiterung

Trigger ist das Schweizer Armeemesser für WeeChat. Es können verschiedene
Hooks überwacht werden (signal. modifier, print, ...), der Inhalt von
Daten kann verändert werden, es können ein- oder mehrere Befehle ausgeführt
werden. Eine Bedingung kann genutzt werden um damit zu verhindern, dass der
Trigger unter bestimmten Umständen ausgeführt wird.

Um Trigger nutzen zu können ist es erforderlich zu wissen wie signals,
modifiers, ... in WeeChat funktionieren. Dazu sollte man das Kapitel
'Hooks' in der 'Anleitung für API Erweiterung' lesen.

[[trigger_options]]
==== Optionen (trigger.conf)

Sektionen:

[width="100%",cols="3m,6m,16",options="header"]
|===
| Sektion | Steuerbefehl                             | Beschreibung
| look    | /set trigger.look.*                      | Erscheinungsbild
| color   | /set trigger.color.*                     | Farben
| trigger | <<command_trigger_trigger,/trigger add>> +
            <<command_trigger_trigger,/trigger set>> +
            /set trigger.trigger.*                   | Trigger Optionen
|===

Optionen:

include::autogen/user/trigger_options.asciidoc[]

[[trigger_commands]]
==== Befehle

include::autogen/user/trigger_commands.asciidoc[]

[[trigger_anatomy]]
==== Aufbau eines Triggers

Ein Trigger hat folgende Optionen (Benennung ist
`trigger.trigger.<name>.<option>`):

[width="100%",cols="2m,2,10",options="header"]
|===
| Option | Wert   | Beschreibung

| enabled | `on`, `off` |
  Wenn die Option auf `off` gesetzt ist, dann ist der Trigger deaktiviert und die Ausführung ist gestoppt.

| hook | `signal`, `hsignal`, `modifier`, `print`, `command`, `command_run`,
  `timer`, `config`, `focus` |
  Der hook welcher durch Trigger genutzt werden soll. Für weitere Informationen siehe
  'Anleitung für API Erweiterung', Kapitel 'Hooks'.

| arguments | string |
  Argumente welche der Hook nutzen soll. Dies ist davon abhängig welcher Hook-Typ genutzt wird.

| conditions | string |
  Bedingung wann der Trigger ausgeführt werden soll; Inhalt ist evaluiert
  (siehe Befehl <<command_weechat_eval,/eval>>).

| regex | string |
  Einer oder mehrere erweiterte reguläre POSIX Ausdrücke, um die empfangenen Daten
  im Hook-Callback zu ändern (oder Daten die durch die Trigger-Erweiterung hinzugefügt
  worden sind), siehe <<trigger_regex,reguläre Ausdrücke>>.

| command | string |
  Befehl der ausgeführt werden soll (mehrere Befehle können durch Kommata
  voneinander getrennt werden); Inhalt ist evaluiert (siehe Befehl <<command_weechat_eval,/eval>>).

| return_code | `ok`, `ok_eat`, `error` |
  Rückgabewert des Callback (Standardwert: `ok`, sollte für fast jeden Trigger
  genutzt werden. Die anderen Werte werden höchst selten verwendet).
|===

Ein Beispiel ist der standardmäßig genutzte Trigger 'beep', der
folgende Optionen besitzt:

----
trigger.trigger.beep.enabled = on
trigger.trigger.beep.hook = print
trigger.trigger.beep.arguments = ""
trigger.trigger.beep.conditions = "${tg_highlight} || ${tg_msg_pv}"
trigger.trigger.beep.regex = ""
trigger.trigger.beep.command = "/print -beep"
trigger.trigger.beep.return_code = ok
----

[[trigger_execution]]
==== Ausführung

Wenn ein Trigger-Callback aufgerufen wird, dann wird folgende Befehlskette
abgearbeitet:

. Überprüfung von Bedingungen; falls unwahr, beenden
. ersetze Text mittels erweitertem regulärer POSIX Ausdruck (sofern im Trigger definiert)
. ein oder mehrere Befehle werden ausgeführt (sofern im Trigger definiert)
. Beendigung mit einem Rückgabewert (ausgenommen sind die Hooks 'modifier' und 'focus')

[[trigger_hook_arguments]]
==== Hook Argumente

Die Argumente sind abhängig von dem genutzten Hook und werden durch
ein Semikolon getrennt.

[width="100%",cols="2,6,7",options="header"]
|===
| Hook | Argumente | Beispiele

| signal |
  1. Signalname (Priorität erlaubt) (erforderlich) +
  2. Signalname (Priorität erlaubt) +
  3. ... |
  `*,irc_in_privmsg` +
  `*,irc_in_privmsg;*,irc_in_notice` +
  `signal_sigwinch`

| hsignal |
  1. Signalname (Priorität erlaubt) (erforderlich) +
  2. Signalname (Priorität erlaubt) +
  3. ... |
  `nicklist_nick_added`

| modifier |
  1. modifier-Name (Priorität erlaubt) (erforderlich) +
  2. modifier-Name (Priorität erlaubt) +
  3. ... |
  `weechat_print` +
  `5000\|input_text_display;5000\|history_add`

| print |
  1. Buffername +
  2. Tags +
  3. Nachricht +
  4. entferne Farben (0/1) |
  `irc.freenode.*` +
  `irc.freenode.#weechat` +
  `irc.freenode.#weechat;irc_notice` +
  `*;;;1`

| command |
  1. Befehlsname (Priorität erlaubt) (erforderlich) +
  2. Beschreibung +
  3. Argumente +
  4. Beschreibung der Argumente +
  5. Vervollständigung |
  `test` +
  `5000\|test`

| command_run |
  1. Befehl (Priorität erlaubt) (erforderlich) +
  2. Befehl (Priorität erlaubt) +
  3. ... |
  `/cmd arguments`

| timer |
  1. Intervall in Millisekunden (erforderlich) +
  2. Abgleich der Sekunden (Standardwert: 0) +
  3. max. Anzahl an Aufrufen (Standardwert: 0, was "unendlich" bedeutet) |
  `3600000` +
  `60000;0;5`

| config |
  1. Name der Option (Priorität erlaubt) (erforderlich) +
  2. Name der Option (Priorität erlaubt) +
  3. ... |
  `weechat.look.*`

| focus |
  1. area Name (Priorität erlaubt) (erforderlich) +
  2. area Name (Priorität erlaubt) +
  3. ... |
  `buffer_nicklist`
|===

[[trigger_conditions]]
==== Bedingungen

Bedingungen werden benötigt um einen Vorgang am Laufen zu halten oder um
diesen zu stoppen.

Diese sind evaluiert und die Daten im Callback können verwendet werden
(siehe <<trigger_callback_data,Daten in Callbacks>> und Befehl
<<command_weechat_eval,/eval>>).

Beispiel: der standardmäßig genutzte Trigger 'beep' nutzt folgende Bedingungen,
um ausschließlich bei einer privaten Nachricht oder einem Highlight ausgeführt
zu werden:

----
${tg_highlight} || ${tg_msg_pv}
----

[[trigger_regex]]
==== reguläre Ausdrücke

Reguläre Ausdrücke werden verwendet um Variablen in einem Callback Hashtable zu ändern.

Das Format ist: "/regex/replace" oder "/regex/replace/var" (wobei 'var' eine
Variable eines Hashtable darstellt). +
Sollte 'var' nicht näher spezifiziert sein, wird die Standard-Variable genutzt,
welche abhängig von dem genutzten Hook ist:

[width="50%",cols="4,5m",options="header"]
|===
| Hook        | Standard-Variable
| signal      | tg_signal_data
| hsignal     |
| modifier    | tg_string
| print       | tg_message
| command     | tg_argv_eol1
| command_run | tg_command
| timer       | tg_remaining_calls
| config      | tg_value
| focus       |
|===

Mehrere reguläre Ausdrücke können durch ein Leerzeichen voneinander
getrennt werden, zum Beispiel:
"/regex1/replace1/var1 /regex2/replace2/var2".

Das Zeichen "/" kann durch jedes andere Zeichen ersetzt werden (ein
oder mehrere identische Zeichen).

Matching groups können in "replace" genutzt werden:

* `${re:0}` bis `${re:99}`: `${re:0}` um alles zu matchen, `${re:1}` bis
  `${re:99}` um Gruppen zu fangen
* `${re:+}`: der letzte match (mit der höchsten Nummer)
* `${hide:c,${re:N}}`: match "N" mit allen Zeichen die durch "c" ersetzt wurden
  (Beispiel: `${hide:*,${re:2}}` ist die group #2 mit allen Zeichen die durch
  `*` ersetzt wurden).

Beispiel: nutzte Fettschrift zwischen dem Zeichen "*":

----
/\*(\S+)\*/*${color:bold}${re:1}${color:-bold}*/
----

Beispiel: der Standard-Trigger 'server_pass' nutzt folgenden regulären Ausdruck
um ein Passwort in den Befehlen `/server` und `/connect` zu verbergen (die
einzelnen Zeichen des Passwortes werden durch `*` ersetzt):

----
==^(/(server|connect) .*-(sasl_)?password=)(\S+)(.*)==${re:1}${hide:*,${re:4}}${re:5}
----

[NOTE]
In diesem Beispiel wird "==" als Trennzeichen verwendet, da ein "/" in
dem regulären Ausdruck genutzt wird.

[[trigger_command]]
==== Befehl

Der Befehl wird erst ausgeführt nach dem mittels eines regulären Ausdruckes
der Text verändert wurde. Mehrere Befehle können durch Semikolon voneinander
getrennt werden.

Der Inhalt ist evaluiert (siehe Befehl <<command_weechat_eval,/eval>>) und der
durch einen regulären Ausdruck veränderte Text kann in dem Befehl verwendet
werden.

Beispiel: der standardmäßig genutzte Trigger 'beep' nutzt folgenden
Befehl um einen Ton (BEL) zu erzeugen.

----
/print -beep
----

[[trigger_callback_data]]
==== Daten in Callbacks

Daten, die dem Callback übergeben werden, werden in einer Hashtable (Pointer
und Strings) gesichert und können durch folgende Optionen genutzt werden:

* 'conditions'
* 'regex'
* 'command'

Der Inhalt eines Hashtable ist abhängig von dem Hook-Typ.

Ein komfortabler Weg um die Daten eines Triggers zu sehen ist es den
Monitor-Buffer zu öffnen:

----
/trigger monitor
----

[[trigger_data_signal]]
===== Signale

Der Callback von "signal" legt folgende Variablen in der Hashtable an:

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable       | Typ    | Beschreibung
| tg_signal      | string | Name des Signals
| tg_signal_data | string | Daten die vom Signal gesendet wurde
|===

Sollte das Signal eine IRC Nachricht beinhalten, wird die Nachricht analysiert
und die Daten in einer Hashtable gesichert:

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable             | Typ    | Beschreibung
| server               | string | Name des Server (Beispiel: "freenode")
| tags                 | string | Tags in Nachricht (findet selten Verwendung)
| message_without_tags | string | Nachricht ohne Tags
| nick                 | string | Nick
| host                 | string | Hostname
| command              | string | IRC Befehl (Beispiel: "PRIVMSG", "NOTICE", ...)
| channel              | string | IRC Channel
| arguments            | string | Argumente des Befehls (Beinhaltet Wert von 'channel')
|===

[[trigger_data_hsignal]]
===== Hsignal

Der Callback von "hsignal" legt folgende Variablen in der Hashtable an:

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable  | Typ    | Beschreibung
| tg_signal | string | Name des Signals
|===

Das Hashtable enthält alle Schlüssel/Werte (Typ: string/string).

[[trigger_data_modifier]]
===== Modifier

Der Callback von "modifier" legt folgende Variablen in der Hashtable an:

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable          | Typ    | Beschreibung
| tg_modifier       | string | Name des modifier
| tg_modifier_data  | string | Daten die der modifier übermittelt
| tg_string         | string | Zeichenkette die verändert werden kann
| tg_string_nocolor | string | Zeichenkette ohne Farbcodes
|===

Für den modifier 'weechat_print' gilt, Tags werden hinzugefügt, sofern sie
vorhanden sind (siehe <<trigger_data_print,hook print>> weiter unten), und nachfolgende Variablen:

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable           | Typ     | Beschreibung
| buffer             | pointer | Buffer in welchem die Nachricht geschrieben werden soll
| tg_plugin          | string  | Erweiterung des entsprechenden Buffers
| tg_buffer          | string  | vollständiger Name des Buffers
| tg_prefix          | string  | Präfix der Nachricht
| tg_prefix_nocolor  | string  | Präfix ohne Farbcodes
| tg_message         | string  | Nachricht die ausgegeben werden soll
| tg_message_nocolor | string  | Nachricht die ausgegeben werden soll, ohne Farbcodes
|===

Sollte das Signal eine IRC Nachricht beinhalten, wird die Nachricht analysiert
und die Daten in einer Hashtable gesichert (siehe <<trigger_data_signal,hook signal>>).

[[trigger_data_print]]
===== Print

Der Callback von "print" legt folgende Variablen in der Hashtable an:

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable           | Typ     | Beschreibung
| buffer             | pointer | Buffer
| tg_date            | string  | Datum/Uhrzeit der Nachricht (Format: `YYYY-MM-DD hh:mm:ss`)
| tg_displayed       | string  | "1" wenn Nachricht dargestellt wird, "0" falls Nachricht gefiltert wird
| tg_highlight       | string  | "1" falls es sich um eine Highlight-Nachricht handelt, andernfalls "0"
| tg_prefix          | string  | Präfix
| tg_prefix_nocolor  | string  | Präfix ohne Farbcodes
| tg_message         | string  | Nachricht
| tg_message_nocolor | string  | Nachricht ohne Farbcodes
|===

Variablen welche gesetzt werden, aufgrund der Nutzung von Tags in einer Nachricht
('weechat_print' nutzt ebenso diese Tag-Variablen):

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable           | Typ    | Beschreibung
| tg_tags            | string | Tags einer Nachricht (Komma wird automatisch zu Beginn und Ende den Tags hinzugefügt)
| tg_tags_count      | string | Anzahl an Tags der Nachricht
| tg_tag_nick        | string | Nick (extrahiert aus Tag "nick_xxx")
| tg_tag_prefix_nick | string | Nickfarbe für Präfix (extrahier aus Tag "prefix_nick_ccc")
| tg_tag_host        | string | Username und Host, Format: username@host (extrahiert aus Tag "host_xxx")
| tg_tag_notify      | string | Benachrichtigungsstufe ('none', 'message', 'private', 'highlight')
| tg_notify          | string | Benachrichtigungsstufe, falls von 'none' abweichend
| tg_msg_pv          | string | "1" für eine private Nachricht, andernfalls "0"
|===

[[trigger_data_command]]
===== Command

Der Callback von "command" legt folgende Variablen in der Hashtable an:

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable     | Typ     | Beschreibung
| buffer       | pointer | Buffer
| tg_argvN     | string  | Argument #N
| tg_argv_eolN | string  | von Argument #N bis zum Ende der Argumente
|===

[[trigger_data_command_run]]
===== Command_run

Der Callback von "command_run" legt folgende Variablen in der Hashtable an:

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable   | Typ     | Beschreibung
| buffer     | pointer | Buffer
| tg_command | string  | auszuführender Befehl
|===

[[trigger_data_timer]]
===== Timer

Der Callback von "timer" legt folgende Variablen in der Hashtable an:

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable           | Typ    | Beschreibung
| tg_remaining_calls | string | Anzahl der noch ausstehenden Aufrufe
| tg_date            | string | aktuelles Datum und Uhrzeit (Format: `YYYY-MM-DD hh:mm:ss`)
|===

[[trigger_data_config]]
===== Config

Der Callback von "config" legt folgende Variablen in der Hashtable an:

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable  | Typ    | Beschreibung
| tg_option | string | Option
| tg_value  | string | Wert
|===

[[trigger_data_focus]]
===== Focus

Der Callback von "focus" legt folgende Variablen in der Hashtable an:

[width="100%",cols="3m,2,14",options="header"]
|===
| Variable | Typ     | Beschreibung
| window   | pointer | Fenster
| buffer   | pointer | Buffer
|===

Das Hashtable enthält alle Schlüssel/Werte (Typ: string/string).

[[trigger_examples]]
==== Beispiele

[[trigger_example_url_color]]
===== URLs werden eingefärbt

Zeigt URLs in grün an:

----
/trigger add url_color modifier weechat_print "${tg_notify}" "==\S+://\S+==${color:green}$0${color:reset}=="
----

[NOTE]
Dies ist ein einfacher regulärer Ausdruck der möglicherweise nicht alle URLs
erkennt, dafür ist er aber wesentlich schneller als ein komplexer regulärer Ausdruck.

[[trigger_example_auto_pong]]
===== automatisierte "pong" Antwort, bei einer "ping" Anfrage

Wenn jemand eine "ping" Nachricht in einen privaten Buffer sendet, verschickt dieser Trigger
automatisch eine `pong` Antwort:

----
/trigger add pong print "" "${type} == private && ${tg_message} == ping" "" "pong"
----

[[trigger_example_responsive_layout]]
===== reaktives layout

Der nachfolgende Trigger kann verwendet werden um Anpassungen vorzunehmen, falls
sich die Größe des Terminalfensters verändert:

----
/trigger add resize_small signal signal_sigwinch "${info:term_width} < 100" "" "/bar hide nicklist"
/trigger add resize_big signal signal_sigwinch "${info:term_width} >= 100" "" "/bar show nicklist"
----

Der Trigger nutzt das Signal "signal_sigwinch", welches durch WeeChat verschickt wird
sobald das Signal SIGWINCH vom Terminal empfangen wird.

Die Bedingung `${info:term_width}` überprüft die Breite des Terminal (zusätzlich kann
auch `${info:term_height}` genutzt werden).

In obigem Beispiel wird die Nicklist versteckt, sobald das Terminal verkleinert wird.
Die Benutzerliste wird wieder angezeigt, sobald die Breite des Terminals größer oder
gleich 100 Zeichen ist.

[[trigger_example_config_save]]
===== automatisches speichern der Konfiguration

Die Konfigurationsdateien (`*.conf`), können automatisch jede Stunde
gespeichert werden:

----
/trigger add cfgsave timer 3600000;0;0 "" "" "/mute /save"
----

Argumente für den Hook-Timer sind:

* '3600000': 3600 * 1000 Millisekunden, der Callback wird jede Stunde ausgeführt
* '0': Abgleich der Sekunden (es findet keine Justierung statt)
* '0': maximale Anzahl an aufrufen (0 = unbegrenzt)

Der Befehl `/mute /save` sorgt dafür, dass die Konfiguration ohne kommentarlos
gespeichert wird (es findet keine Ausgabe im Core-Buffer statt).

[[xfer_plugin]]
=== Xfer Erweiterung

Mit der xfer Erweiterung kann man:

* einen direkten Chat nutzen (zwischen zwei Hosts, ohne Server): zum Beispiel "DCC Chat"
  mittels IRC Erweiterung
* Datentransfer, zum Beispiel "DCC" mittels IRC Erweiterung

[[xfer_options]]
==== Optionen (xfer.conf)

Sektionen:

[width="100%",cols="3m,6m,16",options="header"]
|===
| Sektion | Steuerbefehl        | Beschreibung
| look    | /set xfer.look.*    | Erscheinungsbild
| color   | /set xfer.color.*   | Farben
| network | /set xfer.network.* | Netzwerkoptionen
| file    | /set xfer.file.*    | Optionen zum Versenden und Empfangen von Dateien
|===

Optionen:

include::autogen/user/xfer_options.asciidoc[]

[[xfer_commands]]
==== Befehle

include::autogen/user/xfer_commands.asciidoc[]

[[support]]
== Unterstützung

Bevor man nach Unterstützung fragt sollte man sicherstellen, dass man sowohl die
Dokumentation als auch die FAQ gelesen hat, welche mit WeeChat bereitgestellt wird.

Unterstützung im IRC findet man auf dem Server 'chat.freenode.net':

* offizielle Channel (Entwickler vertreten):
** '#weechat' (englisch)
** '#weechat-fr' (französisch)
* kein offizieller Channel:
** '#weechat-de' (deutsch)

Weitere Möglichkeiten, um mit den Entwicklern in Kontakt zu treten, siehe: http://weechat.org/dev/support
